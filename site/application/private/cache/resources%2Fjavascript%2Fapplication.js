/**
 * Applied (check for NABU-CUSTOMIZED comments):
 * +- 9074 (var regexEscapeRE): changed ^$ {} to $^{} not trigger variable replacement
 * +- 3896: changed $emit to still check for events {} (backwards compatibility with vuejs 1)
 * +- 2081: disable proxy if server side rendering (not implemented correctly in htmlunit)
 * +- 5416: add initComputed and initWatch to Vue.util so we can use them for asyncWatch and asyncComputed
 * +- 4780: don't overwrite the computed watchers as we now have two phases that can add computed watchers
 * +- 5726: added function decodeCustom to decode our encoded single quotes injected through translations (necessary for example for interpreted attributes with ternaries using translations) (plugged into 3 separate locations)
 * +- 1955: disable use of Proxy in server side rendering, it does not throw an exception but also does not seem to block the javascript thread until everything is rendered
 * 			the end result is that in some cases the last Vue.nextTick() (which uses the microtimer function) will never finish as the code stops before that time
 * +- 7909: added explicit setting of style attribute in server side rendering, otherwise style attributes don't make it into the html
 * +- 11940: allow vm on document.body
 * - changed all checks for "development" !== 'production' to take into account nabu development mode (a _lot_ fewer this time around)
 *    - 414: changed silent from hardcoded "false" to take into account production modus (might explain why we had a lot fewer checks...)
 * - commented out warning triggered a lot by page builder: 4758
 * 
 * Not applied:
 * expose observe method in public API: presumably doable with newly exposed API (2.6.0+): Vue.observable()
 * regex forAliasRE seems to be compatible again with the server side rendering in this version
 * changed main comment to remove the ! after /*. this was preventing closure compilation
 */

/*
 * Vue.js v2.6.10
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.Vue = factory());
}(this, function () { 'use strict';

  /*  */

  var emptyObject = Object.freeze({});

  // These helpers produce better VM code in JS engines due to their
  // explicitness and function inlining.
  function isUndef (v) {
    return v === undefined || v === null
  }

  function isDef (v) {
    return v !== undefined && v !== null
  }

  function isTrue (v) {
    return v === true
  }

  function isFalse (v) {
    return v === false
  }

  /**
   * Check if value is primitive.
   */
  function isPrimitive (value) {
    return (
      typeof value === 'string' ||
      typeof value === 'number' ||
      // $flow-disable-line
      typeof value === 'symbol' ||
      typeof value === 'boolean'
    )
  }

  /**
   * Quick object check - this is primarily used to tell
   * Objects from primitive values when we know the value
   * is a JSON-compliant type.
   */
  function isObject (obj) {
    return obj !== null && typeof obj === 'object'
  }

  /**
   * Get the raw type string of a value, e.g., [object Object].
   */
  var _toString = Object.prototype.toString;

  function toRawType (value) {
    return _toString.call(value).slice(8, -1)
  }

  /**
   * Strict object type check. Only returns true
   * for plain JavaScript objects.
   */
  function isPlainObject (obj) {
    return _toString.call(obj) === '[object Object]'
  }

  function isRegExp (v) {
    return _toString.call(v) === '[object RegExp]'
  }

  /**
   * Check if val is a valid array index.
   */
  function isValidArrayIndex (val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val)
  }

  function isPromise (val) {
    return (
      isDef(val) &&
      typeof val.then === 'function' &&
      typeof val.catch === 'function'
    )
  }

  /**
   * Convert a value to a string that is actually rendered.
   */
  function toString (val) {
    return val == null
      ? ''
      : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
        ? JSON.stringify(val, null, 2)
        : String(val)
  }

  /**
   * Convert an input value to a number for persistence.
   * If the conversion fails, return original string.
   */
  function toNumber (val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n
  }

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   */
  function makeMap (
    str,
    expectsLowerCase
  ) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase
      ? function (val) { return map[val.toLowerCase()]; }
      : function (val) { return map[val]; }
  }

  /**
   * Check if a tag is a built-in tag.
   */
  var isBuiltInTag = makeMap('slot,component', true);

  /**
   * Check if an attribute is a reserved attribute.
   */
  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

  /**
   * Remove an item from an array.
   */
  function remove (arr, item) {
    if (arr.length) {
      var index = arr.indexOf(item);
      if (index > -1) {
        return arr.splice(index, 1)
      }
    }
  }

  /**
   * Check whether an object has the property.
   */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn (obj, key) {
    return hasOwnProperty.call(obj, key)
  }

  /**
   * Create a cached version of a pure function.
   */
  function cached (fn) {
    var cache = Object.create(null);
    return (function cachedFn (str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str))
    })
  }

  /**
   * Camelize a hyphen-delimited string.
   */
  var camelizeRE = /-(\w)/g;
  var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
  });

  /**
   * Capitalize a string.
   */
  var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
  });

  /**
   * Hyphenate a camelCase string.
   */
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase()
  });

  /**
   * Simple bind polyfill for environments that do not support it,
   * e.g., PhantomJS 1.x. Technically, we don't need this anymore
   * since native bind is now performant enough in most browsers.
   * But removing it would mean breaking code that was able to run in
   * PhantomJS 1.x, so this must be kept for backward compatibility.
   */

  /* istanbul ignore next */
  function polyfillBind (fn, ctx) {
    function boundFn (a) {
      var l = arguments.length;
      return l
        ? l > 1
          ? fn.apply(ctx, arguments)
          : fn.call(ctx, a)
        : fn.call(ctx)
    }

    boundFn._length = fn.length;
    return boundFn
  }

  function nativeBind (fn, ctx) {
    return fn.bind(ctx)
  }

  var bind = Function.prototype.bind
    ? nativeBind
    : polyfillBind;

  /**
   * Convert an Array-like object to a real Array.
   */
  function toArray (list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
      ret[i] = list[i + start];
    }
    return ret
  }

  /**
   * Mix properties into target object.
   */
  function extend (to, _from) {
    for (var key in _from) {
      to[key] = _from[key];
    }
    return to
  }

  /**
   * Merge an Array of Objects into a single Object.
   */
  function toObject (arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
      if (arr[i]) {
        extend(res, arr[i]);
      }
    }
    return res
  }

  /* eslint-disable no-unused-vars */

  /**
   * Perform no operation.
   * Stubbing args to make Flow happy without leaving useless transpiled code
   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
   */
  function noop (a, b, c) {}

  /**
   * Always return false.
   */
  var no = function (a, b, c) { return false; };

  /* eslint-enable no-unused-vars */

  /**
   * Return the same value.
   */
  var identity = function (_) { return _; };

  /**
   * Generate a string containing static keys from compiler modules.
   */
  function genStaticKeys (modules) {
    return modules.reduce(function (keys, m) {
      return keys.concat(m.staticKeys || [])
    }, []).join(',')
  }

  /**
   * Check if two values are loosely equal - that is,
   * if they are plain objects, do they have the same shape?
   */
  function looseEqual (a, b) {
    if (a === b) { return true }
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
      try {
        var isArrayA = Array.isArray(a);
        var isArrayB = Array.isArray(b);
        if (isArrayA && isArrayB) {
          return a.length === b.length && a.every(function (e, i) {
            return looseEqual(e, b[i])
          })
        } else if (a instanceof Date && b instanceof Date) {
          return a.getTime() === b.getTime()
        } else if (!isArrayA && !isArrayB) {
          var keysA = Object.keys(a);
          var keysB = Object.keys(b);
          return keysA.length === keysB.length && keysA.every(function (key) {
            return looseEqual(a[key], b[key])
          })
        } else {
          /* istanbul ignore next */
          return false
        }
      } catch (e) {
        /* istanbul ignore next */
        return false
      }
    } else if (!isObjectA && !isObjectB) {
      return String(a) === String(b)
    } else {
      return false
    }
  }

  /**
   * Return the first index at which a loosely equal value can be
   * found in the array (if value is a plain object, the array must
   * contain an object of the same shape), or -1 if it is not present.
   */
  function looseIndexOf (arr, val) {
    for (var i = 0; i < arr.length; i++) {
      if (looseEqual(arr[i], val)) { return i }
    }
    return -1
  }

  /**
   * Ensure a function is called only once.
   */
  function once (fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        fn.apply(this, arguments);
      }
    }
  }

  var SSR_ATTR = 'data-server-rendered';

  var ASSET_TYPES = [
    'component',
    'directive',
    'filter'
  ];

  var LIFECYCLE_HOOKS = [
    'beforeCreate',
    'created',
    'beforeMount',
    'mounted',
    'beforeUpdate',
    'updated',
    'beforeDestroy',
    'destroyed',
    'activated',
    'deactivated',
    'errorCaptured',
    'serverPrefetch'
  ];

  /*  */



  var config = ({
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),

    /**
     * Whether to suppress warnings.
     */
    silent: application && application.configuration && application.configuration.development,

    /**
     * Show production mode tip message on boot?
     */
    productionTip: application && application.configuration && application.configuration.development,

    /**
     * Whether to enable devtools
     */
    devtools: application && application.configuration && application.configuration.development,

    /**
     * Whether to record perf
     */
    performance: false,

    /**
     * Error handler for watcher errors
     */
    errorHandler: null,

    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,

    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],

    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),

    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,

    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,

    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,

    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,

    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,

    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,

    /**
     * Perform updates asynchronously. Intended to be used by Vue Test Utils
     * This will significantly reduce performance if set to false.
     */
    async: true,

    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
  });

  /*  */

  /**
   * unicode letters used for parsing html tags, component names and property paths.
   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
   * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
   */
  var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

  /**
   * Check if a string starts with $ or _
   */
  function isReserved (str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5F
  }

  /**
   * Define a property.
   */
  function def (obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }

  /**
   * Parse simple path.
   */
  var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
  function parsePath (path) {
    if (bailRE.test(path)) {
      return
    }
    var segments = path.split('.');
    return function (obj) {
      for (var i = 0; i < segments.length; i++) {
        if (!obj) { return }
        obj = obj[segments[i]];
      }
      return obj
    }
  }

  /*  */

  // can we use __proto__?
  var hasProto = '__proto__' in {};

  // Browser environment sniffing
  var inBrowser = typeof window !== 'undefined';
  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
  var isIE = UA && /msie|trident/.test(UA);
  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
  var isEdge = UA && UA.indexOf('edge/') > 0;
  var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
  var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
  var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
  var isPhantomJS = UA && /phantomjs/.test(UA);
  var isFF = UA && UA.match(/firefox\/(\d+)/);

  // Firefox has a "watch" function on Object.prototype...
  var nativeWatch = ({}).watch;

  var supportsPassive = false;
  if (inBrowser) {
    try {
      var opts = {};
      Object.defineProperty(opts, 'passive', ({
        get: function get () {
          /* istanbul ignore next */
          supportsPassive = true;
        }
      })); // https://github.com/facebook/flow/issues/285
      window.addEventListener('test-passive', null, opts);
    } catch (e) {}
  }

  // this needs to be lazy-evaled because vue may be required before
  // vue-server-renderer can set VUE_ENV
  var _isServer;
  var isServerRendering = function () {
    if (_isServer === undefined) {
      /* istanbul ignore if */
      if (!inBrowser && !inWeex && typeof global !== 'undefined') {
        // detect presence of vue-server-renderer and avoid
        // Webpack shimming the process
        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
      } else {
        _isServer = false;
      }
    }
    return _isServer
  };

  // detect devtools
  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

  /* istanbul ignore next */
  function isNative (Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
  }

  var hasSymbol =
    typeof Symbol !== 'undefined' && isNative(Symbol) &&
    typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

  var _Set;
  /* istanbul ignore if */ // $flow-disable-line
  if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
  } else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = /*@__PURE__*/(function () {
      function Set () {
        this.set = Object.create(null);
      }
      Set.prototype.has = function has (key) {
        return this.set[key] === true
      };
      Set.prototype.add = function add (key) {
        this.set[key] = true;
      };
      Set.prototype.clear = function clear () {
        this.set = Object.create(null);
      };

      return Set;
    }());
  }

  /*  */

  var warn = noop;
  var tip = noop;
  var generateComponentTrace = (noop); // work around flow check
  var formatComponentName = (noop);

  {
    var hasConsole = typeof console !== 'undefined';
    var classifyRE = /(?:^|[-_])(\w)/g;
    var classify = function (str) { return str
      .replace(classifyRE, function (c) { return c.toUpperCase(); })
      .replace(/[-_]/g, ''); };

    warn = function (msg, vm) {
      var trace = vm ? generateComponentTrace(vm) : '';

      if (config.warnHandler) {
        config.warnHandler.call(null, msg, vm, trace);
      } else if (hasConsole && (!config.silent)) {
        console.error(("[Vue warn]: " + msg + trace));
      }
    };

    tip = function (msg, vm) {
      if (hasConsole && (!config.silent)) {
        console.warn("[Vue tip]: " + msg + (
          vm ? generateComponentTrace(vm) : ''
        ));
      }
    };

    formatComponentName = function (vm, includeFile) {
      if (vm.$root === vm) {
        return '<Root>'
      }
      var options = typeof vm === 'function' && vm.cid != null
        ? vm.options
        : vm._isVue
          ? vm.$options || vm.constructor.options
          : vm;
      var name = options.name || options._componentTag;
      var file = options.__file;
      if (!name && file) {
        var match = file.match(/([^/\\]+)\.vue$/);
        name = match && match[1];
      }

      return (
        (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
        (file && includeFile !== false ? (" at " + file) : '')
      )
    };

    var repeat = function (str, n) {
      var res = '';
      while (n) {
        if (n % 2 === 1) { res += str; }
        if (n > 1) { str += str; }
        n >>= 1;
      }
      return res
    };

    generateComponentTrace = function (vm) {
      if (vm._isVue && vm.$parent) {
        var tree = [];
        var currentRecursiveSequence = 0;
        while (vm) {
          if (tree.length > 0) {
            var last = tree[tree.length - 1];
            if (last.constructor === vm.constructor) {
              currentRecursiveSequence++;
              vm = vm.$parent;
              continue
            } else if (currentRecursiveSequence > 0) {
              tree[tree.length - 1] = [last, currentRecursiveSequence];
              currentRecursiveSequence = 0;
            }
          }
          tree.push(vm);
          vm = vm.$parent;
        }
        return '\n\nfound in\n\n' + tree
          .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
              ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
              : formatComponentName(vm))); })
          .join('\n')
      } else {
        return ("\n\n(found in " + (formatComponentName(vm)) + ")")
      }
    };
  }

  /*  */

  var uid = 0;

  /**
   * A dep is an observable that can have multiple
   * directives subscribing to it.
   */
  var Dep = function Dep () {
    this.id = uid++;
    this.subs = [];
  };

  Dep.prototype.addSub = function addSub (sub) {
    this.subs.push(sub);
  };

  Dep.prototype.removeSub = function removeSub (sub) {
    remove(this.subs, sub);
  };

  Dep.prototype.depend = function depend () {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };

  Dep.prototype.notify = function notify () {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    if (!config.async) {
      // subs aren't sorted in scheduler if not running async
      // we need to sort them now to make sure they fire in correct
      // order
      subs.sort(function (a, b) { return a.id - b.id; });
    }
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };

  // The current target watcher being evaluated.
  // This is globally unique because only one watcher
  // can be evaluated at a time.
  Dep.target = null;
  var targetStack = [];

  function pushTarget (target) {
    targetStack.push(target);
    Dep.target = target;
  }

  function popTarget () {
    targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
  }

  /*  */

  var VNode = function VNode (
    tag,
    data,
    children,
    text,
    elm,
    context,
    componentOptions,
    asyncFactory
  ) {
    this.tag = tag;
    this.data = data;
    this.children = children;
    this.text = text;
    this.elm = elm;
    this.ns = undefined;
    this.context = context;
    this.fnContext = undefined;
    this.fnOptions = undefined;
    this.fnScopeId = undefined;
    this.key = data && data.key;
    this.componentOptions = componentOptions;
    this.componentInstance = undefined;
    this.parent = undefined;
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = undefined;
    this.isAsyncPlaceholder = false;
  };

  var prototypeAccessors = { child: { configurable: true } };

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  prototypeAccessors.child.get = function () {
    return this.componentInstance
  };

  Object.defineProperties( VNode.prototype, prototypeAccessors );

  var createEmptyVNode = function (text) {
    if ( text === void 0 ) text = '';

    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node
  };

  function createTextVNode (val) {
    return new VNode(undefined, undefined, undefined, String(val))
  }

  // optimized shallow clone
  // used for static nodes and slot nodes because they may be reused across
  // multiple renders, cloning them avoids errors when DOM manipulations rely
  // on their elm reference.
  function cloneVNode (vnode) {
    var cloned = new VNode(
      vnode.tag,
      vnode.data,
      // #7975
      // clone children array to avoid mutating original in case of cloning
      // a child.
      vnode.children && vnode.children.slice(),
      vnode.text,
      vnode.elm,
      vnode.context,
      vnode.componentOptions,
      vnode.asyncFactory
    );
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.asyncMeta = vnode.asyncMeta;
    cloned.isCloned = true;
    return cloned
  }

  /*
   * not type checking this file because flow doesn't play well with
   * dynamically accessing methods on Array prototype
   */

  var arrayProto = Array.prototype;
  var arrayMethods = Object.create(arrayProto);

  var methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
  ];

  /**
   * Intercept mutating methods and emit events
   */
  methodsToPatch.forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break
        case 'splice':
          inserted = args.slice(2);
          break
      }
      if (inserted) { ob.observeArray(inserted); }
      // notify change
      ob.dep.notify();
      return result
    });
  });

  /*  */

  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

  /**
   * In some cases we may want to disable observation inside a component's
   * update computation.
   */
  var shouldObserve = true;

  function toggleObserving (value) {
    shouldObserve = value;
  }

  /**
   * Observer class that is attached to each observed
   * object. Once attached, the observer converts the target
   * object's property keys into getter/setters that
   * collect dependencies and dispatch updates.
   */
  var Observer = function Observer (value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this);
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods);
      } else {
        copyAugment(value, arrayMethods, arrayKeys);
      }
      this.observeArray(value);
    } else {
      this.walk(value);
    }
  };

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  Observer.prototype.walk = function walk (obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
      defineReactive$$1(obj, keys[i]);
    }
  };

  /**
   * Observe a list of Array items.
   */
  Observer.prototype.observeArray = function observeArray (items) {
    for (var i = 0, l = items.length; i < l; i++) {
      observe(items[i]);
    }
  };

  // helpers

  /**
   * Augment a target Object or Array by intercepting
   * the prototype chain using __proto__
   */
  function protoAugment (target, src) {
    /* eslint-disable no-proto */
    target.__proto__ = src;
    /* eslint-enable no-proto */
  }

  /**
   * Augment a target Object or Array by defining
   * hidden properties.
   */
  /* istanbul ignore next */
  function copyAugment (target, src, keys) {
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      def(target, key, src[key]);
    }
  }

  /**
   * Attempt to create an observer instance for a value,
   * returns the new observer if successfully observed,
   * or the existing observer if the value already has one.
   */
  function observe (value, asRootData) {
    if (!isObject(value) || value instanceof VNode) {
      return
    }
    var ob;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
      ob = value.__ob__;
    } else if (
      shouldObserve &&
      !isServerRendering() &&
      (Array.isArray(value) || isPlainObject(value)) &&
      Object.isExtensible(value) &&
      !value._isVue
    ) {
      ob = new Observer(value);
    }
    if (asRootData && ob) {
      ob.vmCount++;
    }
    return ob
  }

  /**
   * Define a reactive property on an Object.
   */
  function defineReactive$$1 (
    obj,
    key,
    val,
    customSetter,
    shallow
  ) {
    var dep = new Dep();

    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
      return
    }

    // cater for pre-defined getter/setters
    var getter = property && property.get;
    var setter = property && property.set;
    if ((!getter || setter) && arguments.length === 2) {
      val = obj[key];
    }

    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: function reactiveGetter () {
        var value = getter ? getter.call(obj) : val;
        if (Dep.target) {
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        return value
      },
      set: function reactiveSetter (newVal) {
        var value = getter ? getter.call(obj) : val;
        /* eslint-disable no-self-compare */
        if (newVal === value || (newVal !== newVal && value !== value)) {
          return
        }
        /* eslint-enable no-self-compare */
        if (customSetter) {
          customSetter();
        }
        // #7981: for accessor properties without setter
        if (getter && !setter) { return }
        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }
        childOb = !shallow && observe(newVal);
        dep.notify();
      }
    });
  }

  /**
   * Set a property on an object. Adds the new property and
   * triggers change notification if the property doesn't
   * already exist.
   */
  function set (target, key, val) {
    if (isUndef(target) || isPrimitive(target)
    ) {
      warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val
    }
    if (key in target && !(key in Object.prototype)) {
      target[key] = val;
      return val
    }
    var ob = (target).__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
      warn(
        'Avoid adding reactive properties to a Vue instance or its root $data ' +
        'at runtime - declare it upfront in the data option.'
      );
      return val
    }
    if (!ob) {
      target[key] = val;
      return val
    }
    defineReactive$$1(ob.value, key, val);
    ob.dep.notify();
    return val
  }

  /**
   * Delete a property and trigger change if necessary.
   */
  function del (target, key) {
    if (isUndef(target) || isPrimitive(target)
    ) {
      warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.splice(key, 1);
      return
    }
    var ob = (target).__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
      warn(
        'Avoid deleting properties on a Vue instance or its root $data ' +
        '- just set it to null.'
      );
      return
    }
    if (!hasOwn(target, key)) {
      return
    }
    delete target[key];
    if (!ob) {
      return
    }
    ob.dep.notify();
  }

  /**
   * Collect dependencies on array elements when the array is touched, since
   * we cannot intercept array element access like property getters.
   */
  function dependArray (value) {
    for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
      e = value[i];
      e && e.__ob__ && e.__ob__.dep.depend();
      if (Array.isArray(e)) {
        dependArray(e);
      }
    }
  }

  /*  */

  /**
   * Option overwriting strategies are functions that handle
   * how to merge a parent option value and a child option
   * value into the final value.
   */
  var strats = config.optionMergeStrategies;

  /**
   * Options with restrictions
   */
  {
    strats.el = strats.propsData = function (parent, child, vm, key) {
      if (!vm) {
        warn(
          "option \"" + key + "\" can only be used during instance " +
          'creation with the `new` keyword.'
        );
      }
      return defaultStrat(parent, child)
    };
  }

  /**
   * Helper that recursively merges two data objects together.
   */
  function mergeData (to, from) {
    if (!from) { return to }
    var key, toVal, fromVal;

    var keys = hasSymbol
      ? Reflect.ownKeys(from)
      : Object.keys(from);

    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      // in case the object is already observed...
      if (key === '__ob__') { continue }
      toVal = to[key];
      fromVal = from[key];
      if (!hasOwn(to, key)) {
        set(to, key, fromVal);
      } else if (
        toVal !== fromVal &&
        isPlainObject(toVal) &&
        isPlainObject(fromVal)
      ) {
        mergeData(toVal, fromVal);
      }
    }
    return to
  }

  /**
   * Data
   */
  function mergeDataOrFn (
    parentVal,
    childVal,
    vm
  ) {
    if (!vm) {
      // in a Vue.extend merge, both should be functions
      if (!childVal) {
        return parentVal
      }
      if (!parentVal) {
        return childVal
      }
      // when parentVal & childVal are both present,
      // we need to return a function that returns the
      // merged result of both functions... no need to
      // check if parentVal is a function here because
      // it has to be a function to pass previous merges.
      return function mergedDataFn () {
        return mergeData(
          typeof childVal === 'function' ? childVal.call(this, this) : childVal,
          typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
        )
      }
    } else {
      return function mergedInstanceDataFn () {
        // instance merge
        var instanceData = typeof childVal === 'function'
          ? childVal.call(vm, vm)
          : childVal;
        var defaultData = typeof parentVal === 'function'
          ? parentVal.call(vm, vm)
          : parentVal;
        if (instanceData) {
          return mergeData(instanceData, defaultData)
        } else {
          return defaultData
        }
      }
    }
  }

  strats.data = function (
    parentVal,
    childVal,
    vm
  ) {
    if (!vm) {
      if (childVal && typeof childVal !== 'function') {
        warn(
          'The "data" option should be a function ' +
          'that returns a per-instance value in component ' +
          'definitions.',
          vm
        );

        return parentVal
      }
      return mergeDataOrFn(parentVal, childVal)
    }

    return mergeDataOrFn(parentVal, childVal, vm)
  };

  /**
   * Hooks and props are merged as arrays.
   */
  function mergeHook (
    parentVal,
    childVal
  ) {
    var res = childVal
      ? parentVal
        ? parentVal.concat(childVal)
        : Array.isArray(childVal)
          ? childVal
          : [childVal]
      : parentVal;
    return res
      ? dedupeHooks(res)
      : res
  }

  function dedupeHooks (hooks) {
    var res = [];
    for (var i = 0; i < hooks.length; i++) {
      if (res.indexOf(hooks[i]) === -1) {
        res.push(hooks[i]);
      }
    }
    return res
  }

  LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeHook;
  });

  /**
   * Assets
   *
   * When a vm is present (instance creation), we need to do
   * a three-way merge between constructor options, instance
   * options and parent options.
   */
  function mergeAssets (
    parentVal,
    childVal,
    vm,
    key
  ) {
    var res = Object.create(parentVal || null);
    if (childVal) {
      assertObjectType(key, childVal, vm);
      return extend(res, childVal)
    } else {
      return res
    }
  }

  ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
  });

  /**
   * Watchers.
   *
   * Watchers hashes should not overwrite one
   * another, so we merge them as arrays.
   */
  strats.watch = function (
    parentVal,
    childVal,
    vm,
    key
  ) {
    // work around Firefox's Object.prototype.watch...
    if (parentVal === nativeWatch) { parentVal = undefined; }
    if (childVal === nativeWatch) { childVal = undefined; }
    /* istanbul ignore if */
    if (!childVal) { return Object.create(parentVal || null) }
    {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) { return childVal }
    var ret = {};
    extend(ret, parentVal);
    for (var key$1 in childVal) {
      var parent = ret[key$1];
      var child = childVal[key$1];
      if (parent && !Array.isArray(parent)) {
        parent = [parent];
      }
      ret[key$1] = parent
        ? parent.concat(child)
        : Array.isArray(child) ? child : [child];
    }
    return ret
  };

  /**
   * Other object hashes.
   */
  strats.props =
  strats.methods =
  strats.inject =
  strats.computed = function (
    parentVal,
    childVal,
    vm,
    key
  ) {
    if (childVal && application && application.configuration && application.configuration.development) {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) { return childVal }
    var ret = Object.create(null);
    extend(ret, parentVal);
    if (childVal) { extend(ret, childVal); }
    return ret
  };
  strats.provide = mergeDataOrFn;

  /**
   * Default strategy.
   */
  var defaultStrat = function (parentVal, childVal) {
    return childVal === undefined
      ? parentVal
      : childVal
  };

  /**
   * Validate component names
   */
  function checkComponents (options) {
    for (var key in options.components) {
      validateComponentName(key);
    }
  }

  function validateComponentName (name) {
    if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
      warn(
        'Invalid component name: "' + name + '". Component names ' +
        'should conform to valid custom element name in html5 specification.'
      );
    }
    if (isBuiltInTag(name) || config.isReservedTag(name)) {
      warn(
        'Do not use built-in or reserved HTML elements as component ' +
        'id: ' + name
      );
    }
  }

  /**
   * Ensure all props option syntax are normalized into the
   * Object-based format.
   */
  function normalizeProps (options, vm) {
    var props = options.props;
    if (!props) { return }
    var res = {};
    var i, val, name;
    if (Array.isArray(props)) {
      i = props.length;
      while (i--) {
        val = props[i];
        if (typeof val === 'string') {
          name = camelize(val);
          res[name] = { type: null };
        } else {
          warn('props must be strings when using array syntax.');
        }
      }
    } else if (isPlainObject(props)) {
      for (var key in props) {
        val = props[key];
        name = camelize(key);
        res[name] = isPlainObject(val)
          ? val
          : { type: val };
      }
    } else {
      warn(
        "Invalid value for option \"props\": expected an Array or an Object, " +
        "but got " + (toRawType(props)) + ".",
        vm
      );
    }
    options.props = res;
  }

  /**
   * Normalize all injections into Object-based format
   */
  function normalizeInject (options, vm) {
    var inject = options.inject;
    if (!inject) { return }
    var normalized = options.inject = {};
    if (Array.isArray(inject)) {
      for (var i = 0; i < inject.length; i++) {
        normalized[inject[i]] = { from: inject[i] };
      }
    } else if (isPlainObject(inject)) {
      for (var key in inject) {
        var val = inject[key];
        normalized[key] = isPlainObject(val)
          ? extend({ from: key }, val)
          : { from: val };
      }
    } else {
      warn(
        "Invalid value for option \"inject\": expected an Array or an Object, " +
        "but got " + (toRawType(inject)) + ".",
        vm
      );
    }
  }

  /**
   * Normalize raw function directives into object format.
   */
  function normalizeDirectives (options) {
    var dirs = options.directives;
    if (dirs) {
      for (var key in dirs) {
        var def$$1 = dirs[key];
        if (typeof def$$1 === 'function') {
          dirs[key] = { bind: def$$1, update: def$$1 };
        }
      }
    }
  }

  function assertObjectType (name, value, vm) {
    if (!isPlainObject(value)) {
      warn(
        "Invalid value for option \"" + name + "\": expected an Object, " +
        "but got " + (toRawType(value)) + ".",
        vm
      );
    }
  }

  /**
   * Merge two option objects into a new one.
   * Core utility used in both instantiation and inheritance.
   */
  function mergeOptions (
    parent,
    child,
    vm
  ) {
    {
      checkComponents(child);
    }

    if (typeof child === 'function') {
      child = child.options;
    }

    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives(child);

    // Apply extends and mixins on the child options,
    // but only if it is a raw options object that isn't
    // the result of another mergeOptions call.
    // Only merged options has the _base property.
    if (!child._base) {
      if (child.extends) {
        parent = mergeOptions(parent, child.extends, vm);
      }
      if (child.mixins) {
        for (var i = 0, l = child.mixins.length; i < l; i++) {
          parent = mergeOptions(parent, child.mixins[i], vm);
        }
      }
    }

    var options = {};
    var key;
    for (key in parent) {
      mergeField(key);
    }
    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }
    function mergeField (key) {
      var strat = strats[key] || defaultStrat;
      options[key] = strat(parent[key], child[key], vm, key);
    }
    return options
  }

  /**
   * Resolve an asset.
   * This function is used because child instances need access
   * to assets defined in its ancestor chain.
   */
  function resolveAsset (
    options,
    type,
    id,
    warnMissing
  ) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
      return
    }
    var assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id)) { return assets[id] }
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if (warnMissing && !res) {
      warn(
        'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
        options
      );
    }
    return res
  }

  /*  */



  function validateProp (
    key,
    propOptions,
    propsData,
    vm
  ) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // boolean casting
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
      if (absent && !hasOwn(prop, 'default')) {
        value = false;
      } else if (value === '' || value === hyphenate(key)) {
        // only cast empty string / same name to boolean if
        // boolean has higher priority
        var stringIndex = getTypeIndex(String, prop.type);
        if (stringIndex < 0 || booleanIndex < stringIndex) {
          value = true;
        }
      }
    }
    // check default value
    if (value === undefined) {
      value = getPropDefaultValue(vm, prop, key);
      // since the default value is a fresh copy,
      // make sure to observe it.
      var prevShouldObserve = shouldObserve;
      toggleObserving(true);
      observe(value);
      toggleObserving(prevShouldObserve);
    }
    {
      assertProp(prop, key, value, vm, absent);
    }
    return value
  }

  /**
   * Get the default value of a prop.
   */
  function getPropDefaultValue (vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
      return undefined
    }
    var def = prop.default;
    // warn against non-factory defaults for Object & Array
    if (isObject(def)) {
      warn(
        'Invalid default value for prop "' + key + '": ' +
        'Props with type Object/Array must use a factory function ' +
        'to return the default value.',
        vm
      );
    }
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm && vm.$options.propsData &&
      vm.$options.propsData[key] === undefined &&
      vm._props[key] !== undefined
    ) {
      return vm._props[key]
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return typeof def === 'function' && getType(prop.type) !== 'Function'
      ? def.call(vm)
      : def
  }

  /**
   * Assert whether a prop is valid.
   */
  function assertProp (
    prop,
    name,
    value,
    vm,
    absent
  ) {
    if (prop.required && absent) {
      warn(
        'Missing required prop: "' + name + '"',
        vm
      );
      return
    }
    if (value == null && !prop.required) {
      return
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    if (type) {
      if (!Array.isArray(type)) {
        type = [type];
      }
      for (var i = 0; i < type.length && !valid; i++) {
        var assertedType = assertType(value, type[i]);
        expectedTypes.push(assertedType.expectedType || '');
        valid = assertedType.valid;
      }
    }

    if (!valid) {
      warn(
        getInvalidTypeMessage(name, value, expectedTypes),
        vm
      );
      return
    }
    var validator = prop.validator;
    if (validator) {
      if (!validator(value)) {
        warn(
          'Invalid prop: custom validator check failed for prop "' + name + '".',
          vm
        );
      }
    }
  }

  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

  function assertType (value, type) {
    var valid;
    var expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
      var t = typeof value;
      valid = t === expectedType.toLowerCase();
      // for primitive wrapper objects
      if (!valid && t === 'object') {
        valid = value instanceof type;
      }
    } else if (expectedType === 'Object') {
      valid = isPlainObject(value);
    } else if (expectedType === 'Array') {
      valid = Array.isArray(value);
    } else {
      valid = value instanceof type;
    }
    return {
      valid: valid,
      expectedType: expectedType
    }
  }

  /**
   * Use function string name to check built-in types,
   * because a simple equality check will fail when running
   * across different vms / iframes.
   */
  function getType (fn) {
    var match = fn && fn.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ''
  }

  function isSameType (a, b) {
    return getType(a) === getType(b)
  }

  function getTypeIndex (type, expectedTypes) {
    if (!Array.isArray(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
      if (isSameType(expectedTypes[i], type)) {
        return i
      }
    }
    return -1
  }

  function getInvalidTypeMessage (name, value, expectedTypes) {
    var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
      " Expected " + (expectedTypes.map(capitalize).join(', '));
    var expectedType = expectedTypes[0];
    var receivedType = toRawType(value);
    var expectedValue = styleValue(value, expectedType);
    var receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        !isBoolean(expectedType, receivedType)) {
      message += " with value " + expectedValue;
    }
    message += ", got " + receivedType + " ";
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
      message += "with value " + receivedValue + ".";
    }
    return message
  }

  function styleValue (value, type) {
    if (type === 'String') {
      return ("\"" + value + "\"")
    } else if (type === 'Number') {
      return ("" + (Number(value)))
    } else {
      return ("" + value)
    }
  }

  function isExplicable (value) {
    var explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })
  }

  function isBoolean () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
  }

  /*  */

  function handleError (err, vm, info) {
    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
    // See: https://github.com/vuejs/vuex/issues/1505
    pushTarget();
    try {
      if (vm) {
        var cur = vm;
        while ((cur = cur.$parent)) {
          var hooks = cur.$options.errorCaptured;
          if (hooks) {
            for (var i = 0; i < hooks.length; i++) {
              try {
                var capture = hooks[i].call(cur, err, vm, info) === false;
                if (capture) { return }
              } catch (e) {
                globalHandleError(e, cur, 'errorCaptured hook');
              }
            }
          }
        }
      }
      globalHandleError(err, vm, info);
    } finally {
      popTarget();
    }
  }

  function invokeWithErrorHandling (
    handler,
    context,
    args,
    vm,
    info
  ) {
    var res;
    try {
      res = args ? handler.apply(context, args) : handler.call(context);
      if (res && !res._isVue && isPromise(res) && !res._handled) {
        res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
        // issue #9511
        // avoid catch triggering multiple times when nested calls
        res._handled = true;
      }
    } catch (e) {
      handleError(e, vm, info);
    }
    return res
  }

  function globalHandleError (err, vm, info) {
    if (config.errorHandler) {
      try {
        return config.errorHandler.call(null, err, vm, info)
      } catch (e) {
        // if the user intentionally throws the original error in the handler,
        // do not log it twice
        if (e !== err) {
          logError(e, null, 'config.errorHandler');
        }
      }
    }
    logError(err, vm, info);
  }

  function logError (err, vm, info) {
    {
      warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
    }
    /* istanbul ignore else */
    if ((inBrowser || inWeex) && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err
    }
  }

  /*  */

  var isUsingMicroTask = false;

  var callbacks = [];
  var pending = false;

  function flushCallbacks () {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // Here we have async deferring wrappers using microtasks.
  // In 2.5 we used (macro) tasks (in combination with microtasks).
  // However, it has subtle problems when state is changed right before repaint
  // (e.g. #6813, out-in transitions).
  // Also, using (macro) tasks in event handler would cause some weird behaviors
  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
  // So we now use microtasks everywhere, again.
  // A major drawback of this tradeoff is that there are some scenarios
  // where microtasks have too high a priority and fire in between supposedly
  // sequential events (e.g. #4521, #6690, which have workarounds)
  // or even between bubbling of the same event (#6566).
  var timerFunc;

  // The nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore next, $flow-disable-line */
  // NABU-CUSTOMIZED
  if (typeof Promise !== 'undefined' && isNative(Promise) && !navigator.userAgent.match(/Nabu-Renderer/)) {
  	// NABU-END
    var p = Promise.resolve();
    timerFunc = function () {
      p.then(flushCallbacks);
      // In problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) { setTimeout(noop); }
    };
    isUsingMicroTask = true;
  } else if (!isIE && typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
  )) {
    // Use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    // (#6466 MutationObserver is unreliable in IE11)
    var counter = 1;
    var observer = new MutationObserver(flushCallbacks);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
    isUsingMicroTask = true;
  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Techinically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = function () {
      setImmediate(flushCallbacks);
    };
  } else {
    // Fallback to setTimeout.
    timerFunc = function () {
      setTimeout(flushCallbacks, 0);
    };
  }

  function nextTick (cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      })
    }
  }

  /*  */

  var mark;
  var measure;

  {
    var perf = inBrowser && window.performance;
    /* istanbul ignore if */
    if (
      perf &&
      perf.mark &&
      perf.measure &&
      perf.clearMarks &&
      perf.clearMeasures
    ) {
      mark = function (tag) { return perf.mark(tag); };
      measure = function (name, startTag, endTag) {
        perf.measure(name, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
        // perf.clearMeasures(name)
      };
    }
  }

  /* not type checking this file because flow doesn't play well with Proxy */

  var initProxy;

  {
    var allowedGlobals = makeMap(
      'Infinity,undefined,NaN,isFinite,isNaN,' +
      'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
      'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
      'require' // for Webpack/Browserify
    );

    var warnNonPresent = function (target, key) {
      warn(
        "Property or method \"" + key + "\" is not defined on the instance but " +
        'referenced during render. Make sure that this property is reactive, ' +
        'either in the data option, or for class-based components, by ' +
        'initializing the property. ' +
        'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
        target
      );
    };

    var warnReservedPrefix = function (target, key) {
      warn(
        "Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " +
        'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
        'prevent conflicts with Vue internals' +
        'See: https://vuejs.org/v2/api/#data',
        target
      );
    };

    var hasProxy =
      typeof Proxy !== 'undefined' && isNative(Proxy);

	// NABU-CUSTOMIZED
	if (navigator.userAgent.match(/Nabu-Renderer/)) {
	  	hasProxy = false;
	  }
	// NABU-END
		
    if (hasProxy) {
      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
      config.keyCodes = new Proxy(config.keyCodes, {
        set: function set (target, key, value) {
          if (isBuiltInModifier(key)) {
            warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
            return false
          } else {
            target[key] = value;
            return true
          }
        }
      });
    }

    var hasHandler = {
      has: function has (target, key) {
        var has = key in target;
        var isAllowed = allowedGlobals(key) ||
          (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
        if (!has && !isAllowed) {
          if (key in target.$data) { warnReservedPrefix(target, key); }
          else { warnNonPresent(target, key); }
        }
        return has || !isAllowed
      }
    };

    var getHandler = {
      get: function get (target, key) {
        if (typeof key === 'string' && !(key in target)) {
          if (key in target.$data) { warnReservedPrefix(target, key); }
          else { warnNonPresent(target, key); }
        }
        return target[key]
      }
    };

    initProxy = function initProxy (vm) {
      if (hasProxy) {
        // determine which proxy handler to use
        var options = vm.$options;
        var handlers = options.render && options.render._withStripped
          ? getHandler
          : hasHandler;
        vm._renderProxy = new Proxy(vm, handlers);
      } else {
        vm._renderProxy = vm;
      }
    };
  }

  /*  */

  var seenObjects = new _Set();

  /**
   * Recursively traverse an object to evoke all converted
   * getters, so that every nested property inside the object
   * is collected as a "deep" dependency.
   */
  function traverse (val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
  }

  function _traverse (val, seen) {
    var i, keys;
    var isA = Array.isArray(val);
    if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
      return
    }
    if (val.__ob__) {
      var depId = val.__ob__.dep.id;
      if (seen.has(depId)) {
        return
      }
      seen.add(depId);
    }
    if (isA) {
      i = val.length;
      while (i--) { _traverse(val[i], seen); }
    } else {
      keys = Object.keys(val);
      i = keys.length;
      while (i--) { _traverse(val[keys[i]], seen); }
    }
  }

  /*  */

  var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once$$1 ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
      name: name,
      once: once$$1,
      capture: capture,
      passive: passive
    }
  });

  function createFnInvoker (fns, vm) {
    function invoker () {
      var arguments$1 = arguments;

      var fns = invoker.fns;
      if (Array.isArray(fns)) {
        var cloned = fns.slice();
        for (var i = 0; i < cloned.length; i++) {
          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
        }
      } else {
        // return handler return value for single handlers
        return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
      }
    }
    invoker.fns = fns;
    return invoker
  }

  function updateListeners (
    on,
    oldOn,
    add,
    remove$$1,
    createOnceHandler,
    vm
  ) {
    var name, def$$1, cur, old, event;
    for (name in on) {
      def$$1 = cur = on[name];
      old = oldOn[name];
      event = normalizeEvent(name);
      if (isUndef(cur)) {
        warn(
          "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
          vm
        );
      } else if (isUndef(old)) {
        if (isUndef(cur.fns)) {
          cur = on[name] = createFnInvoker(cur, vm);
        }
        if (isTrue(event.once)) {
          cur = on[name] = createOnceHandler(event.name, cur, event.capture);
        }
        add(event.name, cur, event.capture, event.passive, event.params);
      } else if (cur !== old) {
        old.fns = cur;
        on[name] = old;
      }
    }
    for (name in oldOn) {
      if (isUndef(on[name])) {
        event = normalizeEvent(name);
        remove$$1(event.name, oldOn[name], event.capture);
      }
    }
  }

  /*  */

  function mergeVNodeHook (def, hookKey, hook) {
    if (def instanceof VNode) {
      def = def.data.hook || (def.data.hook = {});
    }
    var invoker;
    var oldHook = def[hookKey];

    function wrappedHook () {
      hook.apply(this, arguments);
      // important: remove merged hook to ensure it's called only once
      // and prevent memory leak
      remove(invoker.fns, wrappedHook);
    }

    if (isUndef(oldHook)) {
      // no existing hook
      invoker = createFnInvoker([wrappedHook]);
    } else {
      /* istanbul ignore if */
      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
        // already a merged invoker
        invoker = oldHook;
        invoker.fns.push(wrappedHook);
      } else {
        // existing plain hook
        invoker = createFnInvoker([oldHook, wrappedHook]);
      }
    }

    invoker.merged = true;
    def[hookKey] = invoker;
  }

  /*  */

  function extractPropsFromVNodeData (
    data,
    Ctor,
    tag
  ) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
      return
    }
    var res = {};
    var attrs = data.attrs;
    var props = data.props;
    if (isDef(attrs) || isDef(props)) {
      for (var key in propOptions) {
        var altKey = hyphenate(key);
        {
          var keyInLowerCase = key.toLowerCase();
          if (
            key !== keyInLowerCase &&
            attrs && hasOwn(attrs, keyInLowerCase)
          ) {
            tip(
              "Prop \"" + keyInLowerCase + "\" is passed to component " +
              (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
              " \"" + key + "\". " +
              "Note that HTML attributes are case-insensitive and camelCased " +
              "props need to use their kebab-case equivalents when using in-DOM " +
              "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
            );
          }
        }
        checkProp(res, props, key, altKey, true) ||
        checkProp(res, attrs, key, altKey, false);
      }
    }
    return res
  }

  function checkProp (
    res,
    hash,
    key,
    altKey,
    preserve
  ) {
    if (isDef(hash)) {
      if (hasOwn(hash, key)) {
        res[key] = hash[key];
        if (!preserve) {
          delete hash[key];
        }
        return true
      } else if (hasOwn(hash, altKey)) {
        res[key] = hash[altKey];
        if (!preserve) {
          delete hash[altKey];
        }
        return true
      }
    }
    return false
  }

  /*  */

  // The template compiler attempts to minimize the need for normalization by
  // statically analyzing the template at compile time.
  //
  // For plain HTML markup, normalization can be completely skipped because the
  // generated render function is guaranteed to return Array<VNode>. There are
  // two cases where extra normalization is needed:

  // 1. When the children contains components - because a functional component
  // may return an Array instead of a single root. In this case, just a simple
  // normalization is needed - if any child is an Array, we flatten the whole
  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
  // because functional components already normalize their own children.
  function simpleNormalizeChildren (children) {
    for (var i = 0; i < children.length; i++) {
      if (Array.isArray(children[i])) {
        return Array.prototype.concat.apply([], children)
      }
    }
    return children
  }

  // 2. When the children contains constructs that always generated nested Arrays,
  // e.g. <template>, <slot>, v-for, or when the children is provided by user
  // with hand-written render functions / JSX. In such cases a full normalization
  // is needed to cater to all possible types of children values.
  function normalizeChildren (children) {
    return isPrimitive(children)
      ? [createTextVNode(children)]
      : Array.isArray(children)
        ? normalizeArrayChildren(children)
        : undefined
  }

  function isTextNode (node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment)
  }

  function normalizeArrayChildren (children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
      c = children[i];
      if (isUndef(c) || typeof c === 'boolean') { continue }
      lastIndex = res.length - 1;
      last = res[lastIndex];
      //  nested
      if (Array.isArray(c)) {
        if (c.length > 0) {
          c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
          // merge adjacent text nodes
          if (isTextNode(c[0]) && isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + (c[0]).text);
            c.shift();
          }
          res.push.apply(res, c);
        }
      } else if (isPrimitive(c)) {
        if (isTextNode(last)) {
          // merge adjacent text nodes
          // this is necessary for SSR hydration because text nodes are
          // essentially merged when rendered to HTML strings
          res[lastIndex] = createTextVNode(last.text + c);
        } else if (c !== '') {
          // convert primitive to vnode
          res.push(createTextVNode(c));
        }
      } else {
        if (isTextNode(c) && isTextNode(last)) {
          // merge adjacent text nodes
          res[lastIndex] = createTextVNode(last.text + c.text);
        } else {
          // default key for nested array children (likely generated by v-for)
          if (isTrue(children._isVList) &&
            isDef(c.tag) &&
            isUndef(c.key) &&
            isDef(nestedIndex)) {
            c.key = "__vlist" + nestedIndex + "_" + i + "__";
          }
          res.push(c);
        }
      }
    }
    return res
  }

  /*  */

  function initProvide (vm) {
    var provide = vm.$options.provide;
    if (provide) {
      vm._provided = typeof provide === 'function'
        ? provide.call(vm)
        : provide;
    }
  }

  function initInjections (vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
      toggleObserving(false);
      Object.keys(result).forEach(function (key) {
        /* istanbul ignore else */
        {
          defineReactive$$1(vm, key, result[key], function () {
            warn(
              "Avoid mutating an injected value directly since the changes will be " +
              "overwritten whenever the provided component re-renders. " +
              "injection being mutated: \"" + key + "\"",
              vm
            );
          });
        }
      });
      toggleObserving(true);
    }
  }

  function resolveInject (inject, vm) {
    if (inject) {
      // inject is :any because flow is not smart enough to figure out cached
      var result = Object.create(null);
      var keys = hasSymbol
        ? Reflect.ownKeys(inject)
        : Object.keys(inject);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        // #6574 in case the inject object is observed...
        if (key === '__ob__') { continue }
        var provideKey = inject[key].from;
        var source = vm;
        while (source) {
          if (source._provided && hasOwn(source._provided, provideKey)) {
            result[key] = source._provided[provideKey];
            break
          }
          source = source.$parent;
        }
        if (!source) {
          if ('default' in inject[key]) {
            var provideDefault = inject[key].default;
            result[key] = typeof provideDefault === 'function'
              ? provideDefault.call(vm)
              : provideDefault;
          } else {
            warn(("Injection \"" + key + "\" not found"), vm);
          }
        }
      }
      return result
    }
  }

  /*  */



  /**
   * Runtime helper for resolving raw children VNodes into a slot object.
   */
  function resolveSlots (
    children,
    context
  ) {
    if (!children || !children.length) {
      return {}
    }
    var slots = {};
    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
      var data = child.data;
      // remove slot attribute if the node is resolved as a Vue slot node
      if (data && data.attrs && data.attrs.slot) {
        delete data.attrs.slot;
      }
      // named slots should only be respected if the vnode was rendered in the
      // same context.
      if ((child.context === context || child.fnContext === context) &&
        data && data.slot != null
      ) {
        var name = data.slot;
        var slot = (slots[name] || (slots[name] = []));
        if (child.tag === 'template') {
          slot.push.apply(slot, child.children || []);
        } else {
          slot.push(child);
        }
      } else {
        (slots.default || (slots.default = [])).push(child);
      }
    }
    // ignore slots that contains only whitespace
    for (var name$1 in slots) {
      if (slots[name$1].every(isWhitespace)) {
        delete slots[name$1];
      }
    }
    return slots
  }

  function isWhitespace (node) {
    return (node.isComment && !node.asyncFactory) || node.text === ' '
  }

  /*  */

  function normalizeScopedSlots (
    slots,
    normalSlots,
    prevSlots
  ) {
    var res;
    var hasNormalSlots = Object.keys(normalSlots).length > 0;
    var isStable = slots ? !!slots.$stable : !hasNormalSlots;
    var key = slots && slots.$key;
    if (!slots) {
      res = {};
    } else if (slots._normalized) {
      // fast path 1: child component re-render only, parent did not change
      return slots._normalized
    } else if (
      isStable &&
      prevSlots &&
      prevSlots !== emptyObject &&
      key === prevSlots.$key &&
      !hasNormalSlots &&
      !prevSlots.$hasNormal
    ) {
      // fast path 2: stable scoped slots w/ no normal slots to proxy,
      // only need to normalize once
      return prevSlots
    } else {
      res = {};
      for (var key$1 in slots) {
        if (slots[key$1] && key$1[0] !== '$') {
          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
        }
      }
    }
    // expose normal slots on scopedSlots
    for (var key$2 in normalSlots) {
      if (!(key$2 in res)) {
        res[key$2] = proxyNormalSlot(normalSlots, key$2);
      }
    }
    // avoriaz seems to mock a non-extensible $scopedSlots object
    // and when that is passed down this would cause an error
    if (slots && Object.isExtensible(slots)) {
      (slots)._normalized = res;
    }
    def(res, '$stable', isStable);
    def(res, '$key', key);
    def(res, '$hasNormal', hasNormalSlots);
    return res
  }

  function normalizeScopedSlot(normalSlots, key, fn) {
    var normalized = function () {
      var res = arguments.length ? fn.apply(null, arguments) : fn({});
      res = res && typeof res === 'object' && !Array.isArray(res)
        ? [res] // single vnode
        : normalizeChildren(res);
      return res && (
        res.length === 0 ||
        (res.length === 1 && res[0].isComment) // #9658
      ) ? undefined
        : res
    };
    // this is a slot using the new v-slot syntax without scope. although it is
    // compiled as a scoped slot, render fn users would expect it to be present
    // on this.$slots because the usage is semantically a normal slot.
    if (fn.proxy) {
      Object.defineProperty(normalSlots, key, {
        get: normalized,
        enumerable: true,
        configurable: true
      });
    }
    return normalized
  }

  function proxyNormalSlot(slots, key) {
    return function () { return slots[key]; }
  }

  /*  */

  /**
   * Runtime helper for rendering v-for lists.
   */
  function renderList (
    val,
    render
  ) {
    var ret, i, l, keys, key;
    if (Array.isArray(val) || typeof val === 'string') {
      ret = new Array(val.length);
      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = render(val[i], i);
      }
    } else if (typeof val === 'number') {
      ret = new Array(val);
      for (i = 0; i < val; i++) {
        ret[i] = render(i + 1, i);
      }
    } else if (isObject(val)) {
      if (hasSymbol && val[Symbol.iterator]) {
        ret = [];
        var iterator = val[Symbol.iterator]();
        var result = iterator.next();
        while (!result.done) {
          ret.push(render(result.value, ret.length));
          result = iterator.next();
        }
      } else {
        keys = Object.keys(val);
        ret = new Array(keys.length);
        for (i = 0, l = keys.length; i < l; i++) {
          key = keys[i];
          ret[i] = render(val[key], key, i);
        }
      }
    }
    if (!isDef(ret)) {
      ret = [];
    }
    (ret)._isVList = true;
    return ret
  }

  /*  */

  /**
   * Runtime helper for rendering <slot>
   */
  function renderSlot (
    name,
    fallback,
    props,
    bindObject
  ) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;
    if (scopedSlotFn) { // scoped slot
      props = props || {};
      if (bindObject) {
        if (!isObject(bindObject)) {
          warn(
            'slot v-bind without argument expects an Object',
            this
          );
        }
        props = extend(extend({}, bindObject), props);
      }
      nodes = scopedSlotFn(props) || fallback;
    } else {
      nodes = this.$slots[name] || fallback;
    }

    var target = props && props.slot;
    if (target) {
      return this.$createElement('template', { slot: target }, nodes)
    } else {
      return nodes
    }
  }

  /*  */

  /**
   * Runtime helper for resolving filters
   */
  function resolveFilter (id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity
  }

  /*  */

  function isKeyNotMatch (expect, actual) {
    if (Array.isArray(expect)) {
      return expect.indexOf(actual) === -1
    } else {
      return expect !== actual
    }
  }

  /**
   * Runtime helper for checking keyCodes from config.
   * exposed as Vue.prototype._k
   * passing in eventKeyName as last argument separately for backwards compat
   */
  function checkKeyCodes (
    eventKeyCode,
    key,
    builtInKeyCode,
    eventKeyName,
    builtInKeyName
  ) {
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
      return isKeyNotMatch(builtInKeyName, eventKeyName)
    } else if (mappedKeyCode) {
      return isKeyNotMatch(mappedKeyCode, eventKeyCode)
    } else if (eventKeyName) {
      return hyphenate(eventKeyName) !== key
    }
  }

  /*  */

  /**
   * Runtime helper for merging v-bind="object" into a VNode's data.
   */
  function bindObjectProps (
    data,
    tag,
    value,
    asProp,
    isSync
  ) {
    if (value) {
      if (!isObject(value)) {
        warn(
          'v-bind without argument expects an Object or Array value',
          this
        );
      } else {
        if (Array.isArray(value)) {
          value = toObject(value);
        }
        var hash;
        var loop = function ( key ) {
          if (
            key === 'class' ||
            key === 'style' ||
            isReservedAttribute(key)
          ) {
            hash = data;
          } else {
            var type = data.attrs && data.attrs.type;
            hash = asProp || config.mustUseProp(tag, type, key)
              ? data.domProps || (data.domProps = {})
              : data.attrs || (data.attrs = {});
          }
          var camelizedKey = camelize(key);
          var hyphenatedKey = hyphenate(key);
          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
            hash[key] = value[key];

            if (isSync) {
              var on = data.on || (data.on = {});
              on[("update:" + key)] = function ($event) {
                value[key] = $event;
              };
            }
          }
        };

        for (var key in value) loop( key );
      }
    }
    return data
  }

  /*  */

  /**
   * Runtime helper for rendering static trees.
   */
  function renderStatic (
    index,
    isInFor
  ) {
    var cached = this._staticTrees || (this._staticTrees = []);
    var tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
      return tree
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(
      this._renderProxy,
      null,
      this // for render fns generated for functional component templates
    );
    markStatic(tree, ("__static__" + index), false);
    return tree
  }

  /**
   * Runtime helper for v-once.
   * Effectively it means marking the node as static with a unique key.
   */
  function markOnce (
    tree,
    index,
    key
  ) {
    markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
    return tree
  }

  function markStatic (
    tree,
    key,
    isOnce
  ) {
    if (Array.isArray(tree)) {
      for (var i = 0; i < tree.length; i++) {
        if (tree[i] && typeof tree[i] !== 'string') {
          markStaticNode(tree[i], (key + "_" + i), isOnce);
        }
      }
    } else {
      markStaticNode(tree, key, isOnce);
    }
  }

  function markStaticNode (node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
  }

  /*  */

  function bindObjectListeners (data, value) {
    if (value) {
      if (!isPlainObject(value)) {
        warn(
          'v-on without argument expects an Object value',
          this
        );
      } else {
        var on = data.on = data.on ? extend({}, data.on) : {};
        for (var key in value) {
          var existing = on[key];
          var ours = value[key];
          on[key] = existing ? [].concat(existing, ours) : ours;
        }
      }
    }
    return data
  }

  /*  */

  function resolveScopedSlots (
    fns, // see flow/vnode
    res,
    // the following are added in 2.6
    hasDynamicKeys,
    contentHashKey
  ) {
    res = res || { $stable: !hasDynamicKeys };
    for (var i = 0; i < fns.length; i++) {
      var slot = fns[i];
      if (Array.isArray(slot)) {
        resolveScopedSlots(slot, res, hasDynamicKeys);
      } else if (slot) {
        // marker for reverse proxying v-slot without scope on this.$slots
        if (slot.proxy) {
          slot.fn.proxy = true;
        }
        res[slot.key] = slot.fn;
      }
    }
    if (contentHashKey) {
      (res).$key = contentHashKey;
    }
    return res
  }

  /*  */

  function bindDynamicKeys (baseObj, values) {
    for (var i = 0; i < values.length; i += 2) {
      var key = values[i];
      if (typeof key === 'string' && key) {
        baseObj[values[i]] = values[i + 1];
      } else if (key !== '' && key !== null) {
        // null is a speical value for explicitly removing a binding
        warn(
          ("Invalid value for dynamic directive argument (expected string or null): " + key),
          this
        );
      }
    }
    return baseObj
  }

  // helper to dynamically append modifier runtime markers to event names.
  // ensure only append when value is already string, otherwise it will be cast
  // to string and cause the type check to miss.
  function prependModifier (value, symbol) {
    return typeof value === 'string' ? symbol + value : value
  }

  /*  */

  function installRenderHelpers (target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
    target._d = bindDynamicKeys;
    target._p = prependModifier;
  }

  /*  */

  function FunctionalRenderContext (
    data,
    props,
    children,
    parent,
    Ctor
  ) {
    var this$1 = this;

    var options = Ctor.options;
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    var contextVm;
    if (hasOwn(parent, '_uid')) {
      contextVm = Object.create(parent);
      // $flow-disable-line
      contextVm._original = parent;
    } else {
      // the context vm passed in is a functional context as well.
      // in this case we want to make sure we are able to get a hold to the
      // real context instance.
      contextVm = parent;
      // $flow-disable-line
      parent = parent._original;
    }
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;

    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function () {
      if (!this$1.$slots) {
        normalizeScopedSlots(
          data.scopedSlots,
          this$1.$slots = resolveSlots(children, parent)
        );
      }
      return this$1.$slots
    };

    Object.defineProperty(this, 'scopedSlots', ({
      enumerable: true,
      get: function get () {
        return normalizeScopedSlots(data.scopedSlots, this.slots())
      }
    }));

    // support for compiled functional template
    if (isCompiled) {
      // exposing $options for renderStatic()
      this.$options = options;
      // pre-resolve slots for renderSlot()
      this.$slots = this.slots();
      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
    }

    if (options._scopeId) {
      this._c = function (a, b, c, d) {
        var vnode = createElement(contextVm, a, b, c, d, needNormalization);
        if (vnode && !Array.isArray(vnode)) {
          vnode.fnScopeId = options._scopeId;
          vnode.fnContext = parent;
        }
        return vnode
      };
    } else {
      this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
    }
  }

  installRenderHelpers(FunctionalRenderContext.prototype);

  function createFunctionalComponent (
    Ctor,
    propsData,
    data,
    contextVm,
    children
  ) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;
    if (isDef(propOptions)) {
      for (var key in propOptions) {
        props[key] = validateProp(key, propOptions, propsData || emptyObject);
      }
    } else {
      if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
      if (isDef(data.props)) { mergeProps(props, data.props); }
    }

    var renderContext = new FunctionalRenderContext(
      data,
      props,
      children,
      contextVm,
      Ctor
    );

    var vnode = options.render.call(null, renderContext._c, renderContext);

    if (vnode instanceof VNode) {
      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
    } else if (Array.isArray(vnode)) {
      var vnodes = normalizeChildren(vnode) || [];
      var res = new Array(vnodes.length);
      for (var i = 0; i < vnodes.length; i++) {
        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
      }
      return res
    }
  }

  function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    {
      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
    }
    if (data.slot) {
      (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone
  }

  function mergeProps (to, from) {
    for (var key in from) {
      to[camelize(key)] = from[key];
    }
  }

  /*  */

  /*  */

  /*  */

  /*  */

  // inline hooks to be invoked on component VNodes during patch
  var componentVNodeHooks = {
    init: function init (vnode, hydrating) {
      if (
        vnode.componentInstance &&
        !vnode.componentInstance._isDestroyed &&
        vnode.data.keepAlive
      ) {
        // kept-alive components, treat as a patch
        var mountedNode = vnode; // work around flow
        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      } else {
        var child = vnode.componentInstance = createComponentInstanceForVnode(
          vnode,
          activeInstance
        );
        child.$mount(hydrating ? vnode.elm : undefined, hydrating);
      }
    },

    prepatch: function prepatch (oldVnode, vnode) {
      var options = vnode.componentOptions;
      var child = vnode.componentInstance = oldVnode.componentInstance;
      updateChildComponent(
        child,
        options.propsData, // updated props
        options.listeners, // updated listeners
        vnode, // new parent vnode
        options.children // new children
      );
    },

    insert: function insert (vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isMounted) {
        componentInstance._isMounted = true;
        callHook(componentInstance, 'mounted');
      }
      if (vnode.data.keepAlive) {
        if (context._isMounted) {
          // vue-router#1212
          // During updates, a kept-alive component's child components may
          // change, so directly walking the tree here may call activated hooks
          // on incorrect children. Instead we push them into a queue which will
          // be processed after the whole patch process ended.
          queueActivatedComponent(componentInstance);
        } else {
          activateChildComponent(componentInstance, true /* direct */);
        }
      }
    },

    destroy: function destroy (vnode) {
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isDestroyed) {
        if (!vnode.data.keepAlive) {
          componentInstance.$destroy();
        } else {
          deactivateChildComponent(componentInstance, true /* direct */);
        }
      }
    }
  };

  var hooksToMerge = Object.keys(componentVNodeHooks);

  function createComponent (
    Ctor,
    data,
    context,
    children,
    tag
  ) {
    if (isUndef(Ctor)) {
      return
    }

    var baseCtor = context.$options._base;

    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }

    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
      {
        warn(("Invalid Component definition: " + (String(Ctor))), context);
      }
      return
    }

    // async component
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
      asyncFactory = Ctor;
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
      if (Ctor === undefined) {
        // return a placeholder node for async component, which is rendered
        // as a comment node but preserves all the raw information for the node.
        // the information will be used for async server-rendering and hydration.
        return createAsyncPlaceholder(
          asyncFactory,
          data,
          context,
          children,
          tag
        )
      }
    }

    data = data || {};

    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);

    // transform component v-model data into props & events
    if (isDef(data.model)) {
      transformModel(Ctor.options, data);
    }

    // extract props
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);

    // functional component
    if (isTrue(Ctor.options.functional)) {
      return createFunctionalComponent(Ctor, propsData, data, context, children)
    }

    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;

    if (isTrue(Ctor.options.abstract)) {
      // abstract components do not keep anything
      // other than props & listeners & slot

      // work around flow
      var slot = data.slot;
      data = {};
      if (slot) {
        data.slot = slot;
      }
    }

    // install component management hooks onto the placeholder node
    installComponentHooks(data);

    // return a placeholder vnode
    var name = Ctor.options.name || tag;
    var vnode = new VNode(
      ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
      data, undefined, undefined, undefined, context,
      { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
      asyncFactory
    );

    return vnode
  }

  function createComponentInstanceForVnode (
    vnode, // we know it's MountedComponentVNode but flow doesn't
    parent // activeInstance in lifecycle state
  ) {
    var options = {
      _isComponent: true,
      _parentVnode: vnode,
      parent: parent
    };
    // check inline-template render functions
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
      options.render = inlineTemplate.render;
      options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options)
  }

  function installComponentHooks (data) {
    var hooks = data.hook || (data.hook = {});
    for (var i = 0; i < hooksToMerge.length; i++) {
      var key = hooksToMerge[i];
      var existing = hooks[key];
      var toMerge = componentVNodeHooks[key];
      if (existing !== toMerge && !(existing && existing._merged)) {
        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
      }
    }
  }

  function mergeHook$1 (f1, f2) {
    var merged = function (a, b) {
      // flow complains about extra args which is why we use any
      f1(a, b);
      f2(a, b);
    };
    merged._merged = true;
    return merged
  }

  // transform component v-model info (value and callback) into
  // prop and event handler respectively.
  function transformModel (options, data) {
    var prop = (options.model && options.model.prop) || 'value';
    var event = (options.model && options.model.event) || 'input'
    ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    var existing = on[event];
    var callback = data.model.callback;
    if (isDef(existing)) {
      if (
        Array.isArray(existing)
          ? existing.indexOf(callback) === -1
          : existing !== callback
      ) {
        on[event] = [callback].concat(existing);
      }
    } else {
      on[event] = callback;
    }
  }

  /*  */

  var SIMPLE_NORMALIZE = 1;
  var ALWAYS_NORMALIZE = 2;

  // wrapper function for providing a more flexible interface
  // without getting yelled at by flow
  function createElement (
    context,
    tag,
    data,
    children,
    normalizationType,
    alwaysNormalize
  ) {
    if (Array.isArray(data) || isPrimitive(data)) {
      normalizationType = children;
      children = data;
      data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
      normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType)
  }

  function _createElement (
    context,
    tag,
    data,
    children,
    normalizationType
  ) {
    if (isDef(data) && isDef((data).__ob__)) {
      warn(
        "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
        'Always create fresh vnode data objects in each render!',
        context
      );
      return createEmptyVNode()
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
      tag = data.is;
    }
    if (!tag) {
      // in case of component :is set to falsy value
      return createEmptyVNode()
    }
    // warn against non-primitive key
    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)
    ) {
      {
        warn(
          'Avoid using non-primitive value as key, ' +
          'use string/number value instead.',
          context
        );
      }
    }
    // support single function children as default scoped slot
    if (Array.isArray(children) &&
      typeof children[0] === 'function'
    ) {
      data = data || {};
      data.scopedSlots = { default: children[0] };
      children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
      children = normalizeChildren(children);
    } else if (normalizationType === SIMPLE_NORMALIZE) {
      children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === 'string') {
      var Ctor;
      ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
      if (config.isReservedTag(tag)) {
        // platform built-in elements
        vnode = new VNode(
          config.parsePlatformTagName(tag), data, children,
          undefined, undefined, context
        );
      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
        // component
        vnode = createComponent(Ctor, data, context, children, tag);
      } else {
        // unknown or unlisted namespaced elements
        // check at runtime because it may get assigned a namespace when its
        // parent normalizes children
        vnode = new VNode(
          tag, data, children,
          undefined, undefined, context
        );
      }
    } else {
      // direct component options / constructor
      vnode = createComponent(tag, data, context, children);
    }
    if (Array.isArray(vnode)) {
      return vnode
    } else if (isDef(vnode)) {
      if (isDef(ns)) { applyNS(vnode, ns); }
      if (isDef(data)) { registerDeepBindings(data); }
      return vnode
    } else {
      return createEmptyVNode()
    }
  }

  function applyNS (vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
      // use default namespace inside foreignObject
      ns = undefined;
      force = true;
    }
    if (isDef(vnode.children)) {
      for (var i = 0, l = vnode.children.length; i < l; i++) {
        var child = vnode.children[i];
        if (isDef(child.tag) && (
          isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
          applyNS(child, ns, force);
        }
      }
    }
  }

  // ref #5318
  // necessary to ensure parent re-render when deep bindings like :style and
  // :class are used on slot nodes
  function registerDeepBindings (data) {
    if (isObject(data.style)) {
      traverse(data.style);
    }
    if (isObject(data.class)) {
      traverse(data.class);
    }
  }

  /*  */

  function initRender (vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    var options = vm.$options;
    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
    // normalization is always applied for the public version, used in
    // user-written render functions.
    vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    var parentData = parentVnode && parentVnode.data;

    /* istanbul ignore else */
    {
      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
        !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
      }, true);
      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
        !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
      }, true);
    }
  }

  var currentRenderingInstance = null;

  function renderMixin (Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);

    Vue.prototype.$nextTick = function (fn) {
      return nextTick(fn, this)
    };

    Vue.prototype._render = function () {
      var vm = this;
      var ref = vm.$options;
      var render = ref.render;
      var _parentVnode = ref._parentVnode;

      if (_parentVnode) {
        vm.$scopedSlots = normalizeScopedSlots(
          _parentVnode.data.scopedSlots,
          vm.$slots,
          vm.$scopedSlots
        );
      }

      // set parent vnode. this allows render functions to have access
      // to the data on the placeholder node.
      vm.$vnode = _parentVnode;
      // render self
      var vnode;
      try {
        // There's no need to maintain a stack becaues all render fns are called
        // separately from one another. Nested component's render fns are called
        // when parent component is patched.
        currentRenderingInstance = vm;
        vnode = render.call(vm._renderProxy, vm.$createElement);
      } catch (e) {
        handleError(e, vm, "render");
        // return error render result,
        // or previous vnode to prevent render error causing blank component
        /* istanbul ignore else */
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } finally {
        currentRenderingInstance = null;
      }
      // if the returned array contains only a single node, allow it
      if (Array.isArray(vnode) && vnode.length === 1) {
        vnode = vnode[0];
      }
      // return empty vnode in case the render function errored out
      if (!(vnode instanceof VNode)) {
        if (Array.isArray(vnode)) {
          warn(
            'Multiple root nodes returned from render function. Render function ' +
            'should return a single root node.',
            vm
          );
        }
        vnode = createEmptyVNode();
      }
      // set parent
      vnode.parent = _parentVnode;
      return vnode
    };
  }

  /*  */

  function ensureCtor (comp, base) {
    if (
      comp.__esModule ||
      (hasSymbol && comp[Symbol.toStringTag] === 'Module')
    ) {
      comp = comp.default;
    }
    return isObject(comp)
      ? base.extend(comp)
      : comp
  }

  function createAsyncPlaceholder (
    factory,
    data,
    context,
    children,
    tag
  ) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node
  }

  function resolveAsyncComponent (
    factory,
    baseCtor
  ) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
      return factory.errorComp
    }

    if (isDef(factory.resolved)) {
      return factory.resolved
    }

    var owner = currentRenderingInstance;
    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
      // already pending
      factory.owners.push(owner);
    }

    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
      return factory.loadingComp
    }

    if (owner && !isDef(factory.owners)) {
      var owners = factory.owners = [owner];
      var sync = true;
      var timerLoading = null;
      var timerTimeout = null

      ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

      var forceRender = function (renderCompleted) {
        for (var i = 0, l = owners.length; i < l; i++) {
          (owners[i]).$forceUpdate();
        }

        if (renderCompleted) {
          owners.length = 0;
          if (timerLoading !== null) {
            clearTimeout(timerLoading);
            timerLoading = null;
          }
          if (timerTimeout !== null) {
            clearTimeout(timerTimeout);
            timerTimeout = null;
          }
        }
      };

      var resolve = once(function (res) {
        // cache resolved
        factory.resolved = ensureCtor(res, baseCtor);
        // invoke callbacks only if this is not a synchronous resolve
        // (async resolves are shimmed as synchronous during SSR)
        if (!sync) {
          forceRender(true);
        } else {
          owners.length = 0;
        }
      });

      var reject = once(function (reason) {
        warn(
          "Failed to resolve async component: " + (String(factory)) +
          (reason ? ("\nReason: " + reason) : '')
        );
        if (isDef(factory.errorComp)) {
          factory.error = true;
          forceRender(true);
        }
      });

      var res = factory(resolve, reject);

      if (isObject(res)) {
        if (isPromise(res)) {
          // () => Promise
          if (isUndef(factory.resolved)) {
            res.then(resolve, reject);
          }
        } else if (isPromise(res.component)) {
          res.component.then(resolve, reject);

          if (isDef(res.error)) {
            factory.errorComp = ensureCtor(res.error, baseCtor);
          }

          if (isDef(res.loading)) {
            factory.loadingComp = ensureCtor(res.loading, baseCtor);
            if (res.delay === 0) {
              factory.loading = true;
            } else {
              timerLoading = setTimeout(function () {
                timerLoading = null;
                if (isUndef(factory.resolved) && isUndef(factory.error)) {
                  factory.loading = true;
                  forceRender(false);
                }
              }, res.delay || 200);
            }
          }

          if (isDef(res.timeout)) {
            timerTimeout = setTimeout(function () {
              timerTimeout = null;
              if (isUndef(factory.resolved)) {
                reject(
                  "timeout (" + (res.timeout) + "ms)"
                );
              }
            }, res.timeout);
          }
        }
      }

      sync = false;
      // return in case resolved synchronously
      return factory.loading
        ? factory.loadingComp
        : factory.resolved
    }
  }

  /*  */

  function isAsyncPlaceholder (node) {
    return node.isComment && node.asyncFactory
  }

  /*  */

  function getFirstComponentChild (children) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var c = children[i];
        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
          return c
        }
      }
    }
  }

  /*  */

  /*  */

  function initEvents (vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    var listeners = vm.$options._parentListeners;
    if (listeners) {
      updateComponentListeners(vm, listeners);
    }
  }

  var target;

  function add (event, fn) {
    target.$on(event, fn);
  }

  function remove$1 (event, fn) {
    target.$off(event, fn);
  }

  function createOnceHandler (event, fn) {
    var _target = target;
    return function onceHandler () {
      var res = fn.apply(null, arguments);
      if (res !== null) {
        _target.$off(event, onceHandler);
      }
    }
  }

  function updateComponentListeners (
    vm,
    listeners,
    oldListeners
  ) {
    target = vm;
    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
    target = undefined;
  }

  function eventsMixin (Vue) {
    var hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
      var vm = this;
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          vm.$on(event[i], fn);
        }
      } else {
        (vm._events[event] || (vm._events[event] = [])).push(fn);
        // optimize hook:event cost by using a boolean flag marked at registration
        // instead of a hash lookup
        if (hookRE.test(event)) {
          vm._hasHookEvent = true;
        }
      }
      return vm
    };

    Vue.prototype.$once = function (event, fn) {
      var vm = this;
      function on () {
        vm.$off(event, on);
        fn.apply(vm, arguments);
      }
      on.fn = fn;
      vm.$on(event, on);
      return vm
    };

    Vue.prototype.$off = function (event, fn) {
      var vm = this;
      // all
      if (!arguments.length) {
        vm._events = Object.create(null);
        return vm
      }
      // array of events
      if (Array.isArray(event)) {
        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
          vm.$off(event[i$1], fn);
        }
        return vm
      }
      // specific event
      var cbs = vm._events[event];
      if (!cbs) {
        return vm
      }
      if (!fn) {
        vm._events[event] = null;
        return vm
      }
      // specific handler
      var cb;
      var i = cbs.length;
      while (i--) {
        cb = cbs[i];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i, 1);
          break
        }
      }
      return vm
    };

    Vue.prototype.$emit = function (event) {
      var vm = this;
      {
        var lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
          tip(
            "Event \"" + lowerCaseEvent + "\" is emitted in component " +
            (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
            "Note that HTML attributes are case-insensitive and you cannot use " +
            "v-on to listen to camelCase events when using in-DOM templates. " +
            "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
          );
        }
      }
      var cbs = vm._events[event];
      if (cbs) {
        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
        var args = toArray(arguments, 1);
        var info = "event handler for \"" + event + "\"";
        for (var i = 0, l = cbs.length; i < l; i++) {
          invokeWithErrorHandling(cbs[i], vm, args, vm, info);
        }
      }
      // NABU-CUSTOMIZED
      else if (vm.$options && vm.$options.events && vm.$options.events[event]) {
		var args = [];
		for (var i = 1; i < arguments.length; i++) {
			args.push(arguments[i]);
		}
	    	vm.$options.events[event].apply(vm, args);
   	   }
       // NABU-END
      return vm
    };
  }

  /*  */

  var activeInstance = null;
  var isUpdatingChildComponent = false;

  function setActiveInstance(vm) {
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    return function () {
      activeInstance = prevActiveInstance;
    }
  }

  function initLifecycle (vm) {
    var options = vm.$options;

    // locate first non-abstract parent
    var parent = options.parent;
    if (parent && !options.abstract) {
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
      }
      parent.$children.push(vm);
    }

    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;

    vm.$children = [];
    vm.$refs = {};

    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
  }

  function lifecycleMixin (Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
      var vm = this;
      var prevEl = vm.$el;
      var prevVnode = vm._vnode;
      var restoreActiveInstance = setActiveInstance(vm);
      vm._vnode = vnode;
      // Vue.prototype.__patch__ is injected in entry points
      // based on the rendering backend used.
      if (!prevVnode) {
        // initial render
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
      } else {
        // updates
        vm.$el = vm.__patch__(prevVnode, vnode);
      }
      restoreActiveInstance();
      // update __vue__ reference
      if (prevEl) {
        prevEl.__vue__ = null;
      }
      if (vm.$el) {
        vm.$el.__vue__ = vm;
      }
      // if parent is an HOC, update its $el as well
      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el;
      }
      // updated hook is called by the scheduler to ensure that children are
      // updated in a parent's updated hook.
    };

    Vue.prototype.$forceUpdate = function () {
      var vm = this;
      if (vm._watcher) {
        vm._watcher.update();
      }
    };

    Vue.prototype.$destroy = function () {
      var vm = this;
      if (vm._isBeingDestroyed) {
        return
      }
      callHook(vm, 'beforeDestroy');
      vm._isBeingDestroyed = true;
      // remove self from parent
      var parent = vm.$parent;
      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm);
      }
      // teardown watchers
      if (vm._watcher) {
        vm._watcher.teardown();
      }
      var i = vm._watchers.length;
      while (i--) {
        vm._watchers[i].teardown();
      }
      // remove reference from data ob
      // frozen object may not have observer.
      if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--;
      }
      // call the last hook...
      vm._isDestroyed = true;
      // invoke destroy hooks on current rendered tree
      vm.__patch__(vm._vnode, null);
      // fire destroyed hook
      callHook(vm, 'destroyed');
      // turn off all instance listeners.
      vm.$off();
      // remove __vue__ reference
      if (vm.$el) {
        vm.$el.__vue__ = null;
      }
      // release circular reference (#6759)
      if (vm.$vnode) {
        vm.$vnode.parent = null;
      }
    };
  }

  function mountComponent (
    vm,
    el,
    hydrating
  ) {
    vm.$el = el;
    if (!vm.$options.render) {
      vm.$options.render = createEmptyVNode;
      {
        /* istanbul ignore if */
        if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
          vm.$options.el || el) {
          warn(
            'You are using the runtime-only build of Vue where the template ' +
            'compiler is not available. Either pre-compile the templates into ' +
            'render functions, or use the compiler-included build.',
            vm
          );
        } else {
          warn(
            'Failed to mount component: template or render function not defined.',
            vm
          );
        }
      }
    }
    callHook(vm, 'beforeMount');

    var updateComponent;
    /* istanbul ignore if */
    if (config.performance && mark) {
      updateComponent = function () {
        var name = vm._name;
        var id = vm._uid;
        var startTag = "vue-perf-start:" + id;
        var endTag = "vue-perf-end:" + id;

        mark(startTag);
        var vnode = vm._render();
        mark(endTag);
        measure(("vue " + name + " render"), startTag, endTag);

        mark(startTag);
        vm._update(vnode, hydrating);
        mark(endTag);
        measure(("vue " + name + " patch"), startTag, endTag);
      };
    } else {
      updateComponent = function () {
        vm._update(vm._render(), hydrating);
      };
    }

    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    new Watcher(vm, updateComponent, noop, {
      before: function before () {
        if (vm._isMounted && !vm._isDestroyed) {
          callHook(vm, 'beforeUpdate');
        }
      }
    }, true /* isRenderWatcher */);
    hydrating = false;

    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
      vm._isMounted = true;
      callHook(vm, 'mounted');
    }
    return vm
  }

  function updateChildComponent (
    vm,
    propsData,
    listeners,
    parentVnode,
    renderChildren
  ) {
    {
      isUpdatingChildComponent = true;
    }

    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren.

    // check if there are dynamic scopedSlots (hand-written or compiled but with
    // dynamic slot names). Static scoped slots compiled from template has the
    // "$stable" marker.
    var newScopedSlots = parentVnode.data.scopedSlots;
    var oldScopedSlots = vm.$scopedSlots;
    var hasDynamicScopedSlot = !!(
      (newScopedSlots && !newScopedSlots.$stable) ||
      (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
      (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)
    );

    // Any static slot children from the parent may have changed during parent's
    // update. Dynamic scoped slots may also have changed. In such cases, a forced
    // update is necessary to ensure correctness.
    var needsForceUpdate = !!(
      renderChildren ||               // has new static slots
      vm.$options._renderChildren ||  // has old static slots
      hasDynamicScopedSlot
    );

    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render

    if (vm._vnode) { // update child tree's parent
      vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;

    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    vm.$attrs = parentVnode.data.attrs || emptyObject;
    vm.$listeners = listeners || emptyObject;

    // update props
    if (propsData && vm.$options.props) {
      toggleObserving(false);
      var props = vm._props;
      var propKeys = vm.$options._propKeys || [];
      for (var i = 0; i < propKeys.length; i++) {
        var key = propKeys[i];
        var propOptions = vm.$options.props; // wtf flow?
        props[key] = validateProp(key, propOptions, propsData, vm);
      }
      toggleObserving(true);
      // keep a copy of raw propsData
      vm.$options.propsData = propsData;
    }

    // update listeners
    listeners = listeners || emptyObject;
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);

    // resolve slots + force update if has children
    if (needsForceUpdate) {
      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
      vm.$forceUpdate();
    }

    {
      isUpdatingChildComponent = false;
    }
  }

  function isInInactiveTree (vm) {
    while (vm && (vm = vm.$parent)) {
      if (vm._inactive) { return true }
    }
    return false
  }

  function activateChildComponent (vm, direct) {
    if (direct) {
      vm._directInactive = false;
      if (isInInactiveTree(vm)) {
        return
      }
    } else if (vm._directInactive) {
      return
    }
    if (vm._inactive || vm._inactive === null) {
      vm._inactive = false;
      for (var i = 0; i < vm.$children.length; i++) {
        activateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'activated');
    }
  }

  function deactivateChildComponent (vm, direct) {
    if (direct) {
      vm._directInactive = true;
      if (isInInactiveTree(vm)) {
        return
      }
    }
    if (!vm._inactive) {
      vm._inactive = true;
      for (var i = 0; i < vm.$children.length; i++) {
        deactivateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'deactivated');
    }
  }

  function callHook (vm, hook) {
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var handlers = vm.$options[hook];
    var info = hook + " hook";
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        invokeWithErrorHandling(handlers[i], vm, null, vm, info);
      }
    }
    if (vm._hasHookEvent) {
      vm.$emit('hook:' + hook);
    }
    popTarget();
  }

  /*  */

  var MAX_UPDATE_COUNT = 100;

  var queue = [];
  var activatedChildren = [];
  var has = {};
  var circular = {};
  var waiting = false;
  var flushing = false;
  var index = 0;

  /**
   * Reset the scheduler's state.
   */
  function resetSchedulerState () {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    {
      circular = {};
    }
    waiting = flushing = false;
  }

  // Async edge case #6566 requires saving the timestamp when event listeners are
  // attached. However, calling performance.now() has a perf overhead especially
  // if the page has thousands of event listeners. Instead, we take a timestamp
  // every time the scheduler flushes and use that for all event listeners
  // attached during that flush.
  var currentFlushTimestamp = 0;

  // Async edge case fix requires storing an event listener's attach timestamp.
  var getNow = Date.now;

  // Determine what event timestamp the browser is using. Annoyingly, the
  // timestamp can either be hi-res (relative to page load) or low-res
  // (relative to UNIX epoch), so in order to compare time we have to use the
  // same timestamp type when saving the flush timestamp.
  // All IE versions use low-res event timestamps, and have problematic clock
  // implementations (#9632)
  if (inBrowser && !isIE) {
    var performance = window.performance;
    if (
      performance &&
      typeof performance.now === 'function' &&
      getNow() > document.createEvent('Event').timeStamp
    ) {
      // if the event timestamp, although evaluated AFTER the Date.now(), is
      // smaller than it, it means the event is using a hi-res timestamp,
      // and we need to use the hi-res version for event listener timestamps as
      // well.
      getNow = function () { return performance.now(); };
    }
  }

  /**
   * Flush both queues and run the watchers.
   */
  function flushSchedulerQueue () {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id;

    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(function (a, b) { return a.id - b.id; });

    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];
      if (watcher.before) {
        watcher.before();
      }
      id = watcher.id;
      has[id] = null;
      watcher.run();
      // in dev build, check and stop circular updates.
      if (has[id] != null) {
        circular[id] = (circular[id] || 0) + 1;
        if (circular[id] > MAX_UPDATE_COUNT) {
          warn(
            'You may have an infinite update loop ' + (
              watcher.user
                ? ("in watcher with expression \"" + (watcher.expression) + "\"")
                : "in a component render function."
            ),
            watcher.vm
          );
          break
        }
      }
    }

    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();

    resetSchedulerState();

    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
      devtools.emit('flush');
    }
  }

  function callUpdatedHooks (queue) {
    var i = queue.length;
    while (i--) {
      var watcher = queue[i];
      var vm = watcher.vm;
      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'updated');
      }
    }
  }

  /**
   * Queue a kept-alive component that was activated during patch.
   * The queue will be processed after the entire tree has been patched.
   */
  function queueActivatedComponent (vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
  }

  function callActivatedHooks (queue) {
    for (var i = 0; i < queue.length; i++) {
      queue[i]._inactive = true;
      activateChildComponent(queue[i], true /* true */);
    }
  }

  /**
   * Push a watcher into the watcher queue.
   * Jobs with duplicate IDs will be skipped unless it's
   * pushed when the queue is being flushed.
   */
  function queueWatcher (watcher) {
    var id = watcher.id;
    if (has[id] == null) {
      has[id] = true;
      if (!flushing) {
        queue.push(watcher);
      } else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
          i--;
        }
        queue.splice(i + 1, 0, watcher);
      }
      // queue the flush
      if (!waiting) {
        waiting = true;

        if (!config.async) {
          flushSchedulerQueue();
          return
        }
        nextTick(flushSchedulerQueue);
      }
    }
  }

  /*  */



  var uid$2 = 0;

  /**
   * A watcher parses an expression, collects dependencies,
   * and fires callback when the expression value changes.
   * This is used for both the $watch() api and directives.
   */
  var Watcher = function Watcher (
    vm,
    expOrFn,
    cb,
    options,
    isRenderWatcher
  ) {
    this.vm = vm;
    if (isRenderWatcher) {
      vm._watcher = this;
    }
    vm._watchers.push(this);
    // options
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
      this.before = options.before;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$2; // uid for batching
    this.active = true;
    this.dirty = this.lazy; // for lazy watchers
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = expOrFn.toString();
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = noop;
        warn(
          "Failed watching path: \"" + expOrFn + "\" " +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        );
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get();
  };

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  Watcher.prototype.get = function get () {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
      } else {
        throw e
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value);
      }
      popTarget();
      this.cleanupDeps();
    }
    return value
  };

  /**
   * Add a dependency to this directive.
   */
  Watcher.prototype.addDep = function addDep (dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };

  /**
   * Clean up for dependency collection.
   */
  Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var i = this.deps.length;
    while (i--) {
      var dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  Watcher.prototype.update = function update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  Watcher.prototype.run = function run () {
    if (this.active) {
      var value = this.get();
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) {
        // set new value
        var oldValue = this.value;
        this.value = value;
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  Watcher.prototype.evaluate = function evaluate () {
    this.value = this.get();
    this.dirty = false;
  };

  /**
   * Depend on all deps collected by this watcher.
   */
  Watcher.prototype.depend = function depend () {
    var i = this.deps.length;
    while (i--) {
      this.deps[i].depend();
    }
  };

  /**
   * Remove self from all dependencies' subscriber list.
   */
  Watcher.prototype.teardown = function teardown () {
    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this);
      }
      var i = this.deps.length;
      while (i--) {
        this.deps[i].removeSub(this);
      }
      this.active = false;
    }
  };

  /*  */

  var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
  };

  function proxy (target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter () {
      return this[sourceKey][key]
    };
    sharedPropertyDefinition.set = function proxySetter (val) {
      this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function initState (vm) {
    vm._watchers = [];
    var opts = vm.$options;
    if (opts.props) { initProps(vm, opts.props); }
    if (opts.methods) { initMethods(vm, opts.methods); }
    if (opts.data) {
      initData(vm);
    } else {
      observe(vm._data = {}, true /* asRootData */);
    }
    if (opts.computed) { initComputed(vm, opts.computed); }
    if (opts.watch && opts.watch !== nativeWatch) {
      initWatch(vm, opts.watch);
    }
  }

  function initProps (vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = vm._props = {};
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    var keys = vm.$options._propKeys = [];
    var isRoot = !vm.$parent;
    // root instance props should be converted
    if (!isRoot) {
      toggleObserving(false);
    }
    var loop = function ( key ) {
      keys.push(key);
      var value = validateProp(key, propsOptions, propsData, vm);
      /* istanbul ignore else */
      {
        var hyphenatedKey = hyphenate(key);
        if (isReservedAttribute(hyphenatedKey) ||
            config.isReservedAttr(hyphenatedKey)) {
          warn(
            ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
            vm
          );
        }
        defineReactive$$1(props, key, value, function () {
          if (!isRoot && !isUpdatingChildComponent) {
            warn(
              "Avoid mutating a prop directly since the value will be " +
              "overwritten whenever the parent component re-renders. " +
              "Instead, use a data or computed property based on the prop's " +
              "value. Prop being mutated: \"" + key + "\"",
              vm
            );
          }
        });
      }
      // static props are already proxied on the component's prototype
      // during Vue.extend(). We only need to proxy props defined at
      // instantiation here.
      if (!(key in vm)) {
        proxy(vm, "_props", key);
      }
    };

    for (var key in propsOptions) loop( key );
    toggleObserving(true);
  }

  function initData (vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function'
      ? getData(data, vm)
      : data || {};
    if (!isPlainObject(data)) {
      data = {};
      warn(
        'data functions should return an object:\n' +
        'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
        vm
      );
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
      var key = keys[i];
      {
        if (methods && hasOwn(methods, key)) {
          warn(
            ("Method \"" + key + "\" has already been defined as a data property."),
            vm
          );
        }
      }
      if (props && hasOwn(props, key)) {
        /*warn(
          "The data property \"" + key + "\" is already declared as a prop. " +
          "Use prop default value instead.",
          vm
        );*/
      } else if (!isReserved(key)) {
        proxy(vm, "_data", key);
      }
    }
    // observe data
    observe(data, true /* asRootData */);
  }

  function getData (data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();
    try {
      return data.call(vm, vm)
    } catch (e) {
      handleError(e, vm, "data()");
      return {}
    } finally {
      popTarget();
    }
  }

  var computedWatcherOptions = { lazy: true };

  function initComputed (vm, computed) {
  	// NABU-CUSTOMIZED
  	if (!vm._computedWatchers) {
		vm._computedWatchers = Object.create(null);
	}
	var watchers = vm._computedWatchers;
	
    // $flow-disable-line
    //var watchers = vm._computedWatchers = Object.create(null);
	// NABU-END
    // computed properties are just getters during SSR
    var isSSR = isServerRendering();

    for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;
      if (getter == null) {
        warn(
          ("Getter is missing for computed property \"" + key + "\"."),
          vm
        );
      }

      if (!isSSR) {
        // create internal watcher for the computed property.
        watchers[key] = new Watcher(
          vm,
          getter || noop,
          noop,
          computedWatcherOptions
        );
      }

      // component-defined computed properties are already defined on the
      // component prototype. We only need to define computed properties defined
      // at instantiation here.
      if (!(key in vm)) {
        defineComputed(vm, key, userDef);
      } else {
        if (key in vm.$data) {
          warn(("The computed property \"" + key + "\" is already defined in data."), vm);
        } else if (vm.$options.props && key in vm.$options.props) {
          warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
        }
      }
    }
  }

  function defineComputed (
    target,
    key,
    userDef
  ) {
    var shouldCache = !isServerRendering();
    if (typeof userDef === 'function') {
      sharedPropertyDefinition.get = shouldCache
        ? createComputedGetter(key)
        : createGetterInvoker(userDef);
      sharedPropertyDefinition.set = noop;
    } else {
      sharedPropertyDefinition.get = userDef.get
        ? shouldCache && userDef.cache !== false
          ? createComputedGetter(key)
          : createGetterInvoker(userDef.get)
        : noop;
      sharedPropertyDefinition.set = userDef.set || noop;
    }
    if (sharedPropertyDefinition.set === noop) {
      sharedPropertyDefinition.set = function () {
        warn(
          ("Computed property \"" + key + "\" was assigned to but it has no setter."),
          this
        );
      };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function createComputedGetter (key) {
    return function computedGetter () {
      var watcher = this._computedWatchers && this._computedWatchers[key];
      if (watcher) {
        if (watcher.dirty) {
          watcher.evaluate();
        }
        if (Dep.target) {
          watcher.depend();
        }
        return watcher.value
      }
    }
  }

  function createGetterInvoker(fn) {
    return function computedGetter () {
      return fn.call(this, this)
    }
  }

  function initMethods (vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
      {
        if (typeof methods[key] !== 'function') {
          warn(
            "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
            "Did you reference the function correctly?",
            vm
          );
        }
        if (props && hasOwn(props, key)) {
          warn(
            ("Method \"" + key + "\" has already been defined as a prop."),
            vm
          );
        }
        if ((key in vm) && isReserved(key)) {
          warn(
            "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
            "Avoid defining component methods that start with _ or $."
          );
        }
      }
      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
    }
  }

  function initWatch (vm, watch) {
    for (var key in watch) {
      var handler = watch[key];
      if (Array.isArray(handler)) {
        for (var i = 0; i < handler.length; i++) {
          createWatcher(vm, key, handler[i]);
        }
      } else {
        createWatcher(vm, key, handler);
      }
    }
  }

  function createWatcher (
    vm,
    expOrFn,
    handler,
    options
  ) {
    if (isPlainObject(handler)) {
      options = handler;
      handler = handler.handler;
    }
    if (typeof handler === 'string') {
      handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options)
  }

  function stateMixin (Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};
    dataDef.get = function () { return this._data };
    var propsDef = {};
    propsDef.get = function () { return this._props };
    {
      dataDef.set = function () {
        warn(
          'Avoid replacing instance root $data. ' +
          'Use nested data properties instead.',
          this
        );
      };
      propsDef.set = function () {
        warn("$props is readonly.", this);
      };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);

    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;

    Vue.prototype.$watch = function (
      expOrFn,
      cb,
      options
    ) {
      var vm = this;
      if (isPlainObject(cb)) {
        return createWatcher(vm, expOrFn, cb, options)
      }
      options = options || {};
      options.user = true;
      var watcher = new Watcher(vm, expOrFn, cb, options);
      if (options.immediate) {
        try {
          cb.call(vm, watcher.value);
        } catch (error) {
          handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\""));
        }
      }
      return function unwatchFn () {
        watcher.teardown();
      }
    };
  }

  /*  */

  var uid$3 = 0;

  function initMixin (Vue) {
    Vue.prototype._init = function (options) {
      var vm = this;
      // a uid
      vm._uid = uid$3++;

      var startTag, endTag;
      /* istanbul ignore if */
      if (config.performance && mark) {
        startTag = "vue-perf-start:" + (vm._uid);
        endTag = "vue-perf-end:" + (vm._uid);
        mark(startTag);
      }

      // a flag to avoid this being observed
      vm._isVue = true;
      // merge options
      if (options && options._isComponent) {
        // optimize internal component instantiation
        // since dynamic options merging is pretty slow, and none of the
        // internal component options needs special treatment.
        initInternalComponent(vm, options);
      } else {
        vm.$options = mergeOptions(
          resolveConstructorOptions(vm.constructor),
          options || {},
          vm
        );
      }
      /* istanbul ignore else */
      {
        initProxy(vm);
      }
      // expose real self
      vm._self = vm;
      initLifecycle(vm);
      initEvents(vm);
      initRender(vm);
      callHook(vm, 'beforeCreate');
      initInjections(vm); // resolve injections before data/props
      initState(vm);
      initProvide(vm); // resolve provide after data/props
      callHook(vm, 'created');

      /* istanbul ignore if */
      if (config.performance && mark) {
        vm._name = formatComponentName(vm, false);
        mark(endTag);
        measure(("vue " + (vm._name) + " init"), startTag, endTag);
      }

      if (vm.$options.el) {
        vm.$mount(vm.$options.el);
      }
    };
  }

  function initInternalComponent (vm, options) {
    var opts = vm.$options = Object.create(vm.constructor.options);
    // doing this because it's faster than dynamic enumeration.
    var parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;

    var vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;

    if (options.render) {
      opts.render = options.render;
      opts.staticRenderFns = options.staticRenderFns;
    }
  }

  function resolveConstructorOptions (Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
      var superOptions = resolveConstructorOptions(Ctor.super);
      var cachedSuperOptions = Ctor.superOptions;
      if (superOptions !== cachedSuperOptions) {
        // super option changed,
        // need to resolve new options.
        Ctor.superOptions = superOptions;
        // check if there are any late-modified/attached options (#4976)
        var modifiedOptions = resolveModifiedOptions(Ctor);
        // update base extend options
        if (modifiedOptions) {
          extend(Ctor.extendOptions, modifiedOptions);
        }
        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
        if (options.name) {
          options.components[options.name] = Ctor;
        }
      }
    }
    return options
  }

  function resolveModifiedOptions (Ctor) {
    var modified;
    var latest = Ctor.options;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
      if (latest[key] !== sealed[key]) {
        if (!modified) { modified = {}; }
        modified[key] = latest[key];
      }
    }
    return modified
  }

  function Vue (options) {
    if (!(this instanceof Vue)
    ) {
      warn('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
  }

  initMixin(Vue);
  stateMixin(Vue);
  eventsMixin(Vue);
  lifecycleMixin(Vue);
  renderMixin(Vue);

  /*  */

  function initUse (Vue) {
    Vue.use = function (plugin) {
      var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
      if (installedPlugins.indexOf(plugin) > -1) {
        return this
      }

      // additional parameters
      var args = toArray(arguments, 1);
      args.unshift(this);
      if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args);
      } else if (typeof plugin === 'function') {
        plugin.apply(null, args);
      }
      installedPlugins.push(plugin);
      return this
    };
  }

  /*  */

  function initMixin$1 (Vue) {
    Vue.mixin = function (mixin) {
      this.options = mergeOptions(this.options, mixin);
      return this
    };
  }

  /*  */

  function initExtend (Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;

    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
      extendOptions = extendOptions || {};
      var Super = this;
      var SuperId = Super.cid;
      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
      if (cachedCtors[SuperId]) {
        return cachedCtors[SuperId]
      }

      var name = extendOptions.name || Super.options.name;
      if (name) {
        validateComponentName(name);
      }

      var Sub = function VueComponent (options) {
        this._init(options);
      };
      Sub.prototype = Object.create(Super.prototype);
      Sub.prototype.constructor = Sub;
      Sub.cid = cid++;
      Sub.options = mergeOptions(
        Super.options,
        extendOptions
      );
      Sub['super'] = Super;

      // For props and computed properties, we define the proxy getters on
      // the Vue instances at extension time, on the extended prototype. This
      // avoids Object.defineProperty calls for each instance created.
      if (Sub.options.props) {
        initProps$1(Sub);
      }
      if (Sub.options.computed) {
        initComputed$1(Sub);
      }

      // allow further extension/mixin/plugin usage
      Sub.extend = Super.extend;
      Sub.mixin = Super.mixin;
      Sub.use = Super.use;

      // create asset registers, so extended classes
      // can have their private assets too.
      ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type];
      });
      // enable recursive self-lookup
      if (name) {
        Sub.options.components[name] = Sub;
      }

      // keep a reference to the super options at extension time.
      // later at instantiation we can check if Super's options have
      // been updated.
      Sub.superOptions = Super.options;
      Sub.extendOptions = extendOptions;
      Sub.sealedOptions = extend({}, Sub.options);

      // cache constructor
      cachedCtors[SuperId] = Sub;
      return Sub
    };
  }

  function initProps$1 (Comp) {
    var props = Comp.options.props;
    for (var key in props) {
      proxy(Comp.prototype, "_props", key);
    }
  }

  function initComputed$1 (Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
      defineComputed(Comp.prototype, key, computed[key]);
    }
  }

  /*  */

  function initAssetRegisters (Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
      Vue[type] = function (
        id,
        definition
      ) {
        if (!definition) {
          return this.options[type + 's'][id]
        } else {
          /* istanbul ignore if */
          if (type === 'component') {
            validateComponentName(id);
          }
          if (type === 'component' && isPlainObject(definition)) {
            definition.name = definition.name || id;
            definition = this.options._base.extend(definition);
          }
          if (type === 'directive' && typeof definition === 'function') {
            definition = { bind: definition, update: definition };
          }
          this.options[type + 's'][id] = definition;
          return definition
        }
      };
    });
  }

  /*  */



  function getComponentName (opts) {
    return opts && (opts.Ctor.options.name || opts.tag)
  }

  function matches (pattern, name) {
    if (Array.isArray(pattern)) {
      return pattern.indexOf(name) > -1
    } else if (typeof pattern === 'string') {
      return pattern.split(',').indexOf(name) > -1
    } else if (isRegExp(pattern)) {
      return pattern.test(name)
    }
    /* istanbul ignore next */
    return false
  }

  function pruneCache (keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache;
    var keys = keepAliveInstance.keys;
    var _vnode = keepAliveInstance._vnode;
    for (var key in cache) {
      var cachedNode = cache[key];
      if (cachedNode) {
        var name = getComponentName(cachedNode.componentOptions);
        if (name && !filter(name)) {
          pruneCacheEntry(cache, key, keys, _vnode);
        }
      }
    }
  }

  function pruneCacheEntry (
    cache,
    key,
    keys,
    current
  ) {
    var cached$$1 = cache[key];
    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
      cached$$1.componentInstance.$destroy();
    }
    cache[key] = null;
    remove(keys, key);
  }

  var patternTypes = [String, RegExp, Array];

  var KeepAlive = {
    name: 'keep-alive',
    abstract: true,

    props: {
      include: patternTypes,
      exclude: patternTypes,
      max: [String, Number]
    },

    created: function created () {
      this.cache = Object.create(null);
      this.keys = [];
    },

    destroyed: function destroyed () {
      for (var key in this.cache) {
        pruneCacheEntry(this.cache, key, this.keys);
      }
    },

    mounted: function mounted () {
      var this$1 = this;

      this.$watch('include', function (val) {
        pruneCache(this$1, function (name) { return matches(val, name); });
      });
      this.$watch('exclude', function (val) {
        pruneCache(this$1, function (name) { return !matches(val, name); });
      });
    },

    render: function render () {
      var slot = this.$slots.default;
      var vnode = getFirstComponentChild(slot);
      var componentOptions = vnode && vnode.componentOptions;
      if (componentOptions) {
        // check pattern
        var name = getComponentName(componentOptions);
        var ref = this;
        var include = ref.include;
        var exclude = ref.exclude;
        if (
          // not included
          (include && (!name || !matches(include, name))) ||
          // excluded
          (exclude && name && matches(exclude, name))
        ) {
          return vnode
        }

        var ref$1 = this;
        var cache = ref$1.cache;
        var keys = ref$1.keys;
        var key = vnode.key == null
          // same constructor may get registered as different local components
          // so cid alone is not enough (#3269)
          ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
          : vnode.key;
        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance;
          // make current key freshest
          remove(keys, key);
          keys.push(key);
        } else {
          cache[key] = vnode;
          keys.push(key);
          // prune oldest entry
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode);
          }
        }

        vnode.data.keepAlive = true;
      }
      return vnode || (slot && slot[0])
    }
  };

  var builtInComponents = {
    KeepAlive: KeepAlive
  };

  /*  */

  function initGlobalAPI (Vue) {
    // config
    var configDef = {};
    configDef.get = function () { return config; };
    {
      configDef.set = function () {
        warn(
          'Do not replace the Vue.config object, set individual fields instead.'
        );
      };
    }
    Object.defineProperty(Vue, 'config', configDef);

    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
    	// NABU-CUSTOMIZED
    	initComputed: initComputed,
  		initWatch: initWatch,
  		// NABU-END
      warn: warn,
      extend: extend,
      mergeOptions: mergeOptions,
      defineReactive: defineReactive$$1
    };

    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;

    // 2.6 explicit observable API
    Vue.observable = function (obj) {
      observe(obj);
      return obj
    };

    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
      Vue.options[type + 's'] = Object.create(null);
    });

    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;

    extend(Vue.options.components, builtInComponents);

    initUse(Vue);
    initMixin$1(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
  }

  initGlobalAPI(Vue);

  Object.defineProperty(Vue.prototype, '$isServer', {
    get: isServerRendering
  });

  Object.defineProperty(Vue.prototype, '$ssrContext', {
    get: function get () {
      /* istanbul ignore next */
      return this.$vnode && this.$vnode.ssrContext
    }
  });

  // expose FunctionalRenderContext for ssr runtime helper installation
  Object.defineProperty(Vue, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
  });

  Vue.version = '2.6.10';

  /*  */

  // these are reserved for web because they are directly compiled away
  // during template compilation
  var isReservedAttr = makeMap('style,class');

  // attributes that should be using props for binding
  var acceptValue = makeMap('input,textarea,option,select,progress');
  var mustUseProp = function (tag, type, attr) {
    return (
      (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
      (attr === 'selected' && tag === 'option') ||
      (attr === 'checked' && tag === 'input') ||
      (attr === 'muted' && tag === 'video')
    )
  };

  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

  var convertEnumeratedValue = function (key, value) {
    return isFalsyAttrValue(value) || value === 'false'
      ? 'false'
      // allow arbitrary string value for contenteditable
      : key === 'contenteditable' && isValidContentEditableValue(value)
        ? value
        : 'true'
  };

  var isBooleanAttr = makeMap(
    'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
    'required,reversed,scoped,seamless,selected,sortable,translate,' +
    'truespeed,typemustmatch,visible'
  );

  var xlinkNS = 'http://www.w3.org/1999/xlink';

  var isXlink = function (name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
  };

  var getXlinkProp = function (name) {
    return isXlink(name) ? name.slice(6, name.length) : ''
  };

  var isFalsyAttrValue = function (val) {
    return val == null || val === false
  };

  /*  */

  function genClassForVnode (vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data) {
        data = mergeClassData(childNode.data, data);
      }
    }
    while (isDef(parentNode = parentNode.parent)) {
      if (parentNode && parentNode.data) {
        data = mergeClassData(data, parentNode.data);
      }
    }
    return renderClass(data.staticClass, data.class)
  }

  function mergeClassData (child, parent) {
    return {
      staticClass: concat(child.staticClass, parent.staticClass),
      class: isDef(child.class)
        ? [child.class, parent.class]
        : parent.class
    }
  }

  function renderClass (
    staticClass,
    dynamicClass
  ) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
      return concat(staticClass, stringifyClass(dynamicClass))
    }
    /* istanbul ignore next */
    return ''
  }

  function concat (a, b) {
    return a ? b ? (a + ' ' + b) : a : (b || '')
  }

  function stringifyClass (value) {
    if (Array.isArray(value)) {
      return stringifyArray(value)
    }
    if (isObject(value)) {
      return stringifyObject(value)
    }
    if (typeof value === 'string') {
      return value
    }
    /* istanbul ignore next */
    return ''
  }

  function stringifyArray (value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
        if (res) { res += ' '; }
        res += stringified;
      }
    }
    return res
  }

  function stringifyObject (value) {
    var res = '';
    for (var key in value) {
      if (value[key]) {
        if (res) { res += ' '; }
        res += key;
      }
    }
    return res
  }

  /*  */

  var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
  };

  var isHTMLTag = makeMap(
    'html,body,base,head,link,meta,style,title,' +
    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
    'embed,object,param,source,canvas,script,noscript,del,ins,' +
    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
    'output,progress,select,textarea,' +
    'details,dialog,menu,menuitem,summary,' +
    'content,element,shadow,template,blockquote,iframe,tfoot'
  );

  // this map is intentionally selective, only covering SVG elements that may
  // contain child elements.
  var isSVG = makeMap(
    'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
    'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
    true
  );

  var isPreTag = function (tag) { return tag === 'pre'; };

  var isReservedTag = function (tag) {
    return isHTMLTag(tag) || isSVG(tag)
  };

  function getTagNamespace (tag) {
    if (isSVG(tag)) {
      return 'svg'
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
      return 'math'
    }
  }

  var unknownElementCache = Object.create(null);
  function isUnknownElement (tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
      return true
    }
    if (isReservedTag(tag)) {
      return false
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
      return unknownElementCache[tag]
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
      // http://stackoverflow.com/a/28210364/1070244
      return (unknownElementCache[tag] = (
        el.constructor === window.HTMLUnknownElement ||
        el.constructor === window.HTMLElement
      ))
    } else {
      return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
    }
  }

  var isTextInputType = makeMap('text,number,password,search,email,tel,url');

  /*  */

  /**
   * Query an element selector if it's not an element already.
   */
  function query (el) {
    if (typeof el === 'string') {
      var selected = document.querySelector(el);
      if (!selected) {
        warn(
          'Cannot find element: ' + el
        );
        return document.createElement('div')
      }
      return selected
    } else {
      return el
    }
  }

  /*  */

  function createElement$1 (tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
      return elm
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
      elm.setAttribute('multiple', 'multiple');
    }
    return elm
  }
  
  // NABU-CUSTOMIZED
  function decodeCustom(text) {
		return text && text.replace ? text.replace("&#39;", "'") : text;
	}
	// NABU-END

  function createElementNS (namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName)
  }

  function createTextNode (text) {
  	// NABU-CUSTOMIZED
    return document.createTextNode(decodeCustom(text))
    // NABU-END
  }

  function createComment (text) {
    return document.createComment(text)
  }

  function insertBefore (parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
  }

  function removeChild (node, child) {
    node.removeChild(child);
  }

  function appendChild (node, child) {
    node.appendChild(child);
  }

  function parentNode (node) {
    return node.parentNode
  }

  function nextSibling (node) {
    return node.nextSibling
  }

  function tagName (node) {
    return node.tagName
  }

  function setTextContent (node, text) {
  	// NABU-CUSTOMIZED
    node.textContent = decodeCustom(text);
    // NABU-END
  }

  function setStyleScope (node, scopeId) {
    node.setAttribute(scopeId, '');
  }

  var nodeOps = /*#__PURE__*/Object.freeze({
    createElement: createElement$1,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    setStyleScope: setStyleScope
  });

  /*  */

  var ref = {
    create: function create (_, vnode) {
      registerRef(vnode);
    },
    update: function update (oldVnode, vnode) {
      if (oldVnode.data.ref !== vnode.data.ref) {
        registerRef(oldVnode, true);
        registerRef(vnode);
      }
    },
    destroy: function destroy (vnode) {
      registerRef(vnode, true);
    }
  };

  function registerRef (vnode, isRemoval) {
    var key = vnode.data.ref;
    if (!isDef(key)) { return }

    var vm = vnode.context;
    var ref = vnode.componentInstance || vnode.elm;
    var refs = vm.$refs;
    if (isRemoval) {
      if (Array.isArray(refs[key])) {
        remove(refs[key], ref);
      } else if (refs[key] === ref) {
        refs[key] = undefined;
      }
    } else {
      if (vnode.data.refInFor) {
        if (!Array.isArray(refs[key])) {
          refs[key] = [ref];
        } else if (refs[key].indexOf(ref) < 0) {
          // $flow-disable-line
          refs[key].push(ref);
        }
      } else {
        refs[key] = ref;
      }
    }
  }

  /**
   * Virtual DOM patching algorithm based on Snabbdom by
   * Simon Friis Vindum (@paldepind)
   * Licensed under the MIT License
   * https://github.com/paldepind/snabbdom/blob/master/LICENSE
   *
   * modified by Evan You (@yyx990803)
   *
   * Not type-checking this because this file is perf-critical and the cost
   * of making flow understand it is not worth it.
   */

  var emptyNode = new VNode('', {}, []);

  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

  function sameVnode (a, b) {
    return (
      a.key === b.key && (
        (
          a.tag === b.tag &&
          a.isComment === b.isComment &&
          isDef(a.data) === isDef(b.data) &&
          sameInputType(a, b)
        ) || (
          isTrue(a.isAsyncPlaceholder) &&
          a.asyncFactory === b.asyncFactory &&
          isUndef(b.asyncFactory.error)
        )
      )
    )
  }

  function sameInputType (a, b) {
    if (a.tag !== 'input') { return true }
    var i;
    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
  }

  function createKeyToOldIdx (children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
      key = children[i].key;
      if (isDef(key)) { map[key] = i; }
    }
    return map
  }

  function createPatchFunction (backend) {
    var i, j;
    var cbs = {};

    var modules = backend.modules;
    var nodeOps = backend.nodeOps;

    for (i = 0; i < hooks.length; ++i) {
      cbs[hooks[i]] = [];
      for (j = 0; j < modules.length; ++j) {
        if (isDef(modules[j][hooks[i]])) {
          cbs[hooks[i]].push(modules[j][hooks[i]]);
        }
      }
    }

    function emptyNodeAt (elm) {
      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
    }

    function createRmCb (childElm, listeners) {
      function remove$$1 () {
        if (--remove$$1.listeners === 0) {
          removeNode(childElm);
        }
      }
      remove$$1.listeners = listeners;
      return remove$$1
    }

    function removeNode (el) {
      var parent = nodeOps.parentNode(el);
      // element may have already been removed due to v-html / v-text
      if (isDef(parent)) {
        nodeOps.removeChild(parent, el);
      }
    }

    function isUnknownElement$$1 (vnode, inVPre) {
      return (
        !inVPre &&
        !vnode.ns &&
        !(
          config.ignoredElements.length &&
          config.ignoredElements.some(function (ignore) {
            return isRegExp(ignore)
              ? ignore.test(vnode.tag)
              : ignore === vnode.tag
          })
        ) &&
        config.isUnknownElement(vnode.tag)
      )
    }

    var creatingElmInVPre = 0;

    function createElm (
      vnode,
      insertedVnodeQueue,
      parentElm,
      refElm,
      nested,
      ownerArray,
      index
    ) {
      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // This vnode was used in a previous render!
        // now it's used as a new node, overwriting its elm would cause
        // potential patch errors down the road when it's used as an insertion
        // reference node. Instead, we clone the node on-demand before creating
        // associated DOM element for it.
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      vnode.isRootInsert = !nested; // for transition enter check
      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return
      }

      var data = vnode.data;
      var children = vnode.children;
      var tag = vnode.tag;
      if (isDef(tag)) {
        {
          if (data && data.pre) {
            creatingElmInVPre++;
          }
          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
            warn(
              'Unknown custom element: <' + tag + '> - did you ' +
              'register the component correctly? For recursive components, ' +
              'make sure to provide the "name" option.',
              vnode.context
            );
          }
        }

        vnode.elm = vnode.ns
          ? nodeOps.createElementNS(vnode.ns, tag)
          : nodeOps.createElement(tag, vnode);
        setScope(vnode);

        /* istanbul ignore if */
        {
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }

        if (data && data.pre) {
          creatingElmInVPre--;
        }
      } else if (isTrue(vnode.isComment)) {
        vnode.elm = nodeOps.createComment(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      } else {
        vnode.elm = nodeOps.createTextNode(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      }
    }

    function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
      var i = vnode.data;
      if (isDef(i)) {
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
        if (isDef(i = i.hook) && isDef(i = i.init)) {
          i(vnode, false /* hydrating */);
        }
        // after calling the init hook, if the vnode is a child component
        // it should've created a child instance and mounted it. the child
        // component also has set the placeholder vnode's elm.
        // in that case we can just return the element and be done.
        if (isDef(vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          insert(parentElm, vnode.elm, refElm);
          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          return true
        }
      }
    }

    function initComponent (vnode, insertedVnodeQueue) {
      if (isDef(vnode.data.pendingInsert)) {
        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
        vnode.data.pendingInsert = null;
      }
      vnode.elm = vnode.componentInstance.$el;
      if (isPatchable(vnode)) {
        invokeCreateHooks(vnode, insertedVnodeQueue);
        setScope(vnode);
      } else {
        // empty component root.
        // skip all element-related modules except for ref (#3455)
        registerRef(vnode);
        // make sure to invoke the insert hook
        insertedVnodeQueue.push(vnode);
      }
    }

    function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
      var i;
      // hack for #4339: a reactivated component with inner transition
      // does not trigger because the inner node's created hooks are not called
      // again. It's not ideal to involve module-specific logic in here but
      // there doesn't seem to be a better way to do it.
      var innerNode = vnode;
      while (innerNode.componentInstance) {
        innerNode = innerNode.componentInstance._vnode;
        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
          for (i = 0; i < cbs.activate.length; ++i) {
            cbs.activate[i](emptyNode, innerNode);
          }
          insertedVnodeQueue.push(innerNode);
          break
        }
      }
      // unlike a newly created component,
      // a reactivated keep-alive component doesn't insert itself
      insert(parentElm, vnode.elm, refElm);
    }

    function insert (parent, elm, ref$$1) {
      if (isDef(parent)) {
        if (isDef(ref$$1)) {
          if (nodeOps.parentNode(ref$$1) === parent) {
            nodeOps.insertBefore(parent, elm, ref$$1);
          }
        } else {
          nodeOps.appendChild(parent, elm);
        }
      }
    }

    function createChildren (vnode, children, insertedVnodeQueue) {
      if (Array.isArray(children)) {
        {
          checkDuplicateKeys(children);
        }
        for (var i = 0; i < children.length; ++i) {
          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
        }
      } else if (isPrimitive(vnode.text)) {
        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
      }
    }

    function isPatchable (vnode) {
      while (vnode.componentInstance) {
        vnode = vnode.componentInstance._vnode;
      }
      return isDef(vnode.tag)
    }

    function invokeCreateHooks (vnode, insertedVnodeQueue) {
      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
        cbs.create[i$1](emptyNode, vnode);
      }
      i = vnode.data.hook; // Reuse variable
      if (isDef(i)) {
        if (isDef(i.create)) { i.create(emptyNode, vnode); }
        if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
      }
    }

    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope (vnode) {
      var i;
      if (isDef(i = vnode.fnScopeId)) {
        nodeOps.setStyleScope(vnode.elm, i);
      } else {
        var ancestor = vnode;
        while (ancestor) {
          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
            nodeOps.setStyleScope(vnode.elm, i);
          }
          ancestor = ancestor.parent;
        }
      }
      // for slot content they should also get the scopeId from the host instance.
      if (isDef(i = activeInstance) &&
        i !== vnode.context &&
        i !== vnode.fnContext &&
        isDef(i = i.$options._scopeId)
      ) {
        nodeOps.setStyleScope(vnode.elm, i);
      }
    }

    function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
      for (; startIdx <= endIdx; ++startIdx) {
        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
      }
    }

    function invokeDestroyHook (vnode) {
      var i, j;
      var data = vnode.data;
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
        for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
      }
      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }

    function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vnodes[startIdx];
        if (isDef(ch)) {
          if (isDef(ch.tag)) {
            removeAndInvokeRemoveHook(ch);
            invokeDestroyHook(ch);
          } else { // Text node
            removeNode(ch.elm);
          }
        }
      }
    }

    function removeAndInvokeRemoveHook (vnode, rm) {
      if (isDef(rm) || isDef(vnode.data)) {
        var i;
        var listeners = cbs.remove.length + 1;
        if (isDef(rm)) {
          // we have a recursively passed down rm callback
          // increase the listeners count
          rm.listeners += listeners;
        } else {
          // directly removing
          rm = createRmCb(vnode.elm, listeners);
        }
        // recursively invoke hooks on child component root node
        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
          removeAndInvokeRemoveHook(i, rm);
        }
        for (i = 0; i < cbs.remove.length; ++i) {
          cbs.remove[i](vnode, rm);
        }
        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
          i(vnode, rm);
        } else {
          rm();
        }
      } else {
        removeNode(vnode.elm);
      }
    }

    function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

      // removeOnly is a special flag used only by <transition-group>
      // to ensure removed elements stay in correct relative positions
      // during leaving transitions
      var canMove = !removeOnly;

      {
        checkDuplicateKeys(newCh);
      }

      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (isUndef(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
        } else if (isUndef(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
          idxInOld = isDef(newStartVnode.key)
            ? oldKeyToIdx[newStartVnode.key]
            : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
          if (isUndef(idxInOld)) { // New element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          } else {
            vnodeToMove = oldCh[idxInOld];
            if (sameVnode(vnodeToMove, newStartVnode)) {
              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
              oldCh[idxInOld] = undefined;
              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
            } else {
              // same key but different element. treat as new element
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
            }
          }
          newStartVnode = newCh[++newStartIdx];
        }
      }
      if (oldStartIdx > oldEndIdx) {
        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }

    function checkDuplicateKeys (children) {
      var seenKeys = {};
      for (var i = 0; i < children.length; i++) {
        var vnode = children[i];
        var key = vnode.key;
        if (isDef(key)) {
          if (seenKeys[key]) {
            warn(
              ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
              vnode.context
            );
          } else {
            seenKeys[key] = true;
          }
        }
      }
    }

    function findIdxInOld (node, oldCh, start, end) {
      for (var i = start; i < end; i++) {
        var c = oldCh[i];
        if (isDef(c) && sameVnode(node, c)) { return i }
      }
    }

    function patchVnode (
      oldVnode,
      vnode,
      insertedVnodeQueue,
      ownerArray,
      index,
      removeOnly
    ) {
      if (oldVnode === vnode) {
        return
      }

      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // clone reused vnode
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      var elm = vnode.elm = oldVnode.elm;

      if (isTrue(oldVnode.isAsyncPlaceholder)) {
        if (isDef(vnode.asyncFactory.resolved)) {
          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
        } else {
          vnode.isAsyncPlaceholder = true;
        }
        return
      }

      // reuse element for static trees.
      // note we only do this if the vnode is cloned -
      // if the new node is not cloned it means the render functions have been
      // reset by the hot-reload-api and we need to do a proper re-render.
      if (isTrue(vnode.isStatic) &&
        isTrue(oldVnode.isStatic) &&
        vnode.key === oldVnode.key &&
        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
      ) {
        vnode.componentInstance = oldVnode.componentInstance;
        return
      }

      var i;
      var data = vnode.data;
      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
        i(oldVnode, vnode);
      }

      var oldCh = oldVnode.children;
      var ch = vnode.children;
      if (isDef(data) && isPatchable(vnode)) {
        for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
        if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
      }
      if (isUndef(vnode.text)) {
        if (isDef(oldCh) && isDef(ch)) {
          if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
        } else if (isDef(ch)) {
          {
            checkDuplicateKeys(ch);
          }
          if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
        } else if (isDef(oldCh)) {
          removeVnodes(elm, oldCh, 0, oldCh.length - 1);
        } else if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
      } else if (oldVnode.text !== vnode.text) {
        nodeOps.setTextContent(elm, vnode.text);
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
      }
    }

    function invokeInsertHook (vnode, queue, initial) {
      // delay insert hooks for component root nodes, invoke them after the
      // element is really inserted
      if (isTrue(initial) && isDef(vnode.parent)) {
        vnode.parent.data.pendingInsert = queue;
      } else {
        for (var i = 0; i < queue.length; ++i) {
          queue[i].data.hook.insert(queue[i]);
        }
      }
    }

    var hydrationBailed = false;
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
      var i;
      var tag = vnode.tag;
      var data = vnode.data;
      var children = vnode.children;
      inVPre = inVPre || (data && data.pre);
      vnode.elm = elm;

      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
        vnode.isAsyncPlaceholder = true;
        return true
      }
      // assert node match
      {
        if (!assertNodeMatch(elm, vnode, inVPre)) {
          return false
        }
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
        if (isDef(i = vnode.componentInstance)) {
          // child component. it should have hydrated its own tree.
          initComponent(vnode, insertedVnodeQueue);
          return true
        }
      }
      if (isDef(tag)) {
        if (isDef(children)) {
          // empty element, allow client to pick up and populate children
          if (!elm.hasChildNodes()) {
            createChildren(vnode, children, insertedVnodeQueue);
          } else {
            // v-html and domProps: innerHTML
            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
              if (i !== elm.innerHTML) {
                /* istanbul ignore if */
                if (typeof console !== 'undefined' &&
                  !hydrationBailed
                ) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('server innerHTML: ', i);
                  console.warn('client innerHTML: ', elm.innerHTML);
                }
                return false
              }
            } else {
              // iterate and compare children lists
              var childrenMatch = true;
              var childNode = elm.firstChild;
              for (var i$1 = 0; i$1 < children.length; i$1++) {
                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                  childrenMatch = false;
                  break
                }
                childNode = childNode.nextSibling;
              }
              // if childNode is not null, it means the actual childNodes list is
              // longer than the virtual children list.
              if (!childrenMatch || childNode) {
                /* istanbul ignore if */
                if (typeof console !== 'undefined' &&
                  !hydrationBailed
                ) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                }
                return false
              }
            }
          }
        }
        if (isDef(data)) {
          var fullInvoke = false;
          for (var key in data) {
            if (!isRenderedModule(key)) {
              fullInvoke = true;
              invokeCreateHooks(vnode, insertedVnodeQueue);
              break
            }
          }
          if (!fullInvoke && data['class']) {
            // ensure collecting deps for deep class bindings for future updates
            traverse(data['class']);
          }
        }
      } else if (elm.data !== vnode.text) {
        elm.data = vnode.text;
      }
      return true
    }

    function assertNodeMatch (node, vnode, inVPre) {
      if (isDef(vnode.tag)) {
        return vnode.tag.indexOf('vue-component') === 0 || (
          !isUnknownElement$$1(vnode, inVPre) &&
          vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
        )
      } else {
        return node.nodeType === (vnode.isComment ? 8 : 3)
      }
    }

    return function patch (oldVnode, vnode, hydrating, removeOnly) {
      if (isUndef(vnode)) {
        if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
        return
      }

      var isInitialPatch = false;
      var insertedVnodeQueue = [];

      if (isUndef(oldVnode)) {
        // empty mount (likely as component), create new root element
        isInitialPatch = true;
        createElm(vnode, insertedVnodeQueue);
      } else {
        var isRealElement = isDef(oldVnode.nodeType);
        if (!isRealElement && sameVnode(oldVnode, vnode)) {
          // patch existing root node
          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
        } else {
          if (isRealElement) {
            // mounting to a real element
            // check if this is server-rendered content and if we can perform
            // a successful hydration.
            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
              oldVnode.removeAttribute(SSR_ATTR);
              hydrating = true;
            }
            if (isTrue(hydrating)) {
              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                invokeInsertHook(vnode, insertedVnodeQueue, true);
                return oldVnode
              } else {
                warn(
                  'The client-side rendered virtual DOM tree is not matching ' +
                  'server-rendered content. This is likely caused by incorrect ' +
                  'HTML markup, for example nesting block-level elements inside ' +
                  '<p>, or missing <tbody>. Bailing hydration and performing ' +
                  'full client-side render.'
                );
              }
            }
            // either not server-rendered, or hydration failed.
            // create an empty node and replace it
            oldVnode = emptyNodeAt(oldVnode);
          }

          // replacing existing element
          var oldElm = oldVnode.elm;
          var parentElm = nodeOps.parentNode(oldElm);

          // create new node
          createElm(
            vnode,
            insertedVnodeQueue,
            // extremely rare edge case: do not insert if old element is in a
            // leaving transition. Only happens when combining transition +
            // keep-alive + HOCs. (#4590)
            oldElm._leaveCb ? null : parentElm,
            nodeOps.nextSibling(oldElm)
          );

          // update parent placeholder node element, recursively
          if (isDef(vnode.parent)) {
            var ancestor = vnode.parent;
            var patchable = isPatchable(vnode);
            while (ancestor) {
              for (var i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](ancestor);
              }
              ancestor.elm = vnode.elm;
              if (patchable) {
                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                  cbs.create[i$1](emptyNode, ancestor);
                }
                // #6513
                // invoke insert hooks that may have been merged by create hooks.
                // e.g. for directives that uses the "inserted" hook.
                var insert = ancestor.data.hook.insert;
                if (insert.merged) {
                  // start at index 1 to avoid re-invoking component mounted hook
                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                    insert.fns[i$2]();
                  }
                }
              } else {
                registerRef(ancestor);
              }
              ancestor = ancestor.parent;
            }
          }

          // destroy old node
          if (isDef(parentElm)) {
            removeVnodes(parentElm, [oldVnode], 0, 0);
          } else if (isDef(oldVnode.tag)) {
            invokeDestroyHook(oldVnode);
          }
        }
      }

      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
      return vnode.elm
    }
  }

  /*  */

  var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives (vnode) {
      updateDirectives(vnode, emptyNode);
    }
  };

  function updateDirectives (oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
      _update(oldVnode, vnode);
    }
  }

  function _update (oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

    var dirsWithInsert = [];
    var dirsWithPostpatch = [];

    var key, oldDir, dir;
    for (key in newDirs) {
      oldDir = oldDirs[key];
      dir = newDirs[key];
      if (!oldDir) {
        // new directive, bind
        callHook$1(dir, 'bind', vnode, oldVnode);
        if (dir.def && dir.def.inserted) {
          dirsWithInsert.push(dir);
        }
      } else {
        // existing directive, update
        dir.oldValue = oldDir.value;
        dir.oldArg = oldDir.arg;
        callHook$1(dir, 'update', vnode, oldVnode);
        if (dir.def && dir.def.componentUpdated) {
          dirsWithPostpatch.push(dir);
        }
      }
    }

    if (dirsWithInsert.length) {
      var callInsert = function () {
        for (var i = 0; i < dirsWithInsert.length; i++) {
          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
        }
      };
      if (isCreate) {
        mergeVNodeHook(vnode, 'insert', callInsert);
      } else {
        callInsert();
      }
    }

    if (dirsWithPostpatch.length) {
      mergeVNodeHook(vnode, 'postpatch', function () {
        for (var i = 0; i < dirsWithPostpatch.length; i++) {
          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
        }
      });
    }

    if (!isCreate) {
      for (key in oldDirs) {
        if (!newDirs[key]) {
          // no longer present, unbind
          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
        }
      }
    }
  }

  var emptyModifiers = Object.create(null);

  function normalizeDirectives$1 (
    dirs,
    vm
  ) {
    var res = Object.create(null);
    if (!dirs) {
      // $flow-disable-line
      return res
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
      dir = dirs[i];
      if (!dir.modifiers) {
        // $flow-disable-line
        dir.modifiers = emptyModifiers;
      }
      res[getRawDirName(dir)] = dir;
      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    // $flow-disable-line
    return res
  }

  function getRawDirName (dir) {
    return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
  }

  function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
      try {
        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
      } catch (e) {
        handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
      }
    }
  }

  var baseModules = [
    ref,
    directives
  ];

  /*  */

  function updateAttrs (oldVnode, vnode) {
    var opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
      return
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
      return
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__)) {
      attrs = vnode.data.attrs = extend({}, attrs);
    }

    for (key in attrs) {
      cur = attrs[key];
      old = oldAttrs[key];
      if (old !== cur) {
        setAttr(elm, key, cur);
      }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
      setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
      if (isUndef(attrs[key])) {
        if (isXlink(key)) {
          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else if (!isEnumeratedAttr(key)) {
          elm.removeAttribute(key);
        }
      }
    }
  }

  function setAttr (el, key, value) {
    if (el.tagName.indexOf('-') > -1) {
      baseSetAttr(el, key, value);
    } else if (isBooleanAttr(key)) {
      // set attribute for blank value
      // e.g. <option disabled>Select one</option>
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        // technically allowfullscreen is a boolean attribute for <iframe>,
        // but Flash expects a value of "true" when used on <embed> tag
        value = key === 'allowfullscreen' && el.tagName === 'EMBED'
          ? 'true'
          : key;
        el.setAttribute(key, value);
      }
    } else if (isEnumeratedAttr(key)) {
      el.setAttribute(key, convertEnumeratedValue(key, value));
    } else if (isXlink(key)) {
      if (isFalsyAttrValue(value)) {
        el.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      baseSetAttr(el, key, value);
    }
  }

  function baseSetAttr (el, key, value) {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // #7138: IE10 & 11 fires input event when setting placeholder on
      // <textarea>... block the first input event and remove the blocker
      // immediately.
      /* istanbul ignore if */
      if (
        isIE && !isIE9 &&
        el.tagName === 'TEXTAREA' &&
        key === 'placeholder' && value !== '' && !el.__ieph
      ) {
        var blocker = function (e) {
          e.stopImmediatePropagation();
          el.removeEventListener('input', blocker);
        };
        el.addEventListener('input', blocker);
        // $flow-disable-line
        el.__ieph = true; /* IE placeholder patched */
      }
      // NABU-CUSTOMIZED
      el.setAttribute(key, decodeCustom(value));
      // NABU-END
    }
  }

  var attrs = {
    create: updateAttrs,
    update: updateAttrs
  };

  /*  */

  function updateClass (oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (
      isUndef(data.staticClass) &&
      isUndef(data.class) && (
        isUndef(oldData) || (
          isUndef(oldData.staticClass) &&
          isUndef(oldData.class)
        )
      )
    ) {
      return
    }

    var cls = genClassForVnode(vnode);

    // handle transition classes
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
      cls = concat(cls, stringifyClass(transitionClass));
    }

    // set the class
    if (cls !== el._prevClass) {
      el.setAttribute('class', cls);
      el._prevClass = cls;
    }
  }

  var klass = {
    create: updateClass,
    update: updateClass
  };

  /*  */

  var validDivisionCharRE = /[\w).+\-_$\]]/;

  function parseFilters (exp) {
    var inSingle = false;
    var inDouble = false;
    var inTemplateString = false;
    var inRegex = false;
    var curly = 0;
    var square = 0;
    var paren = 0;
    var lastFilterIndex = 0;
    var c, prev, i, expression, filters;

    for (i = 0; i < exp.length; i++) {
      prev = c;
      c = exp.charCodeAt(i);
      if (inSingle) {
        if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
      } else if (inDouble) {
        if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
      } else if (inTemplateString) {
        if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
      } else if (inRegex) {
        if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
      } else if (
        c === 0x7C && // pipe
        exp.charCodeAt(i + 1) !== 0x7C &&
        exp.charCodeAt(i - 1) !== 0x7C &&
        !curly && !square && !paren
      ) {
        if (expression === undefined) {
          // first filter, end of expression
          lastFilterIndex = i + 1;
          expression = exp.slice(0, i).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c) {
          case 0x22: inDouble = true; break         // "
          case 0x27: inSingle = true; break         // '
          case 0x60: inTemplateString = true; break // `
          case 0x28: paren++; break                 // (
          case 0x29: paren--; break                 // )
          case 0x5B: square++; break                // [
          case 0x5D: square--; break                // ]
          case 0x7B: curly++; break                 // {
          case 0x7D: curly--; break                 // }
        }
        if (c === 0x2f) { // /
          var j = i - 1;
          var p = (void 0);
          // find first non-whitespace prev char
          for (; j >= 0; j--) {
            p = exp.charAt(j);
            if (p !== ' ') { break }
          }
          if (!p || !validDivisionCharRE.test(p)) {
            inRegex = true;
          }
        }
      }
    }

    if (expression === undefined) {
      expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }

    function pushFilter () {
      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
      lastFilterIndex = i + 1;
    }

    if (filters) {
      for (i = 0; i < filters.length; i++) {
        expression = wrapFilter(expression, filters[i]);
      }
    }

    return expression
  }

  function wrapFilter (exp, filter) {
    var i = filter.indexOf('(');
    if (i < 0) {
      // _f: resolveFilter
      return ("_f(\"" + filter + "\")(" + exp + ")")
    } else {
      var name = filter.slice(0, i);
      var args = filter.slice(i + 1);
      return ("_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args))
    }
  }

  /*  */



  /* eslint-disable no-unused-vars */
  function baseWarn (msg, range) {
    console.error(("[Vue compiler]: " + msg));
  }
  /* eslint-enable no-unused-vars */

  function pluckModuleFunction (
    modules,
    key
  ) {
    return modules
      ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
      : []
  }

  function addProp (el, name, value, range, dynamic) {
    (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
    el.plain = false;
  }

  function addAttr (el, name, value, range, dynamic) {
    var attrs = dynamic
      ? (el.dynamicAttrs || (el.dynamicAttrs = []))
      : (el.attrs || (el.attrs = []));
    attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
    el.plain = false;
  }

  // add a raw attr (use this in preTransforms)
  function addRawAttr (el, name, value, range) {
    el.attrsMap[name] = value;
    el.attrsList.push(rangeSetItem({ name: name, value: value }, range));
  }

  function addDirective (
    el,
    name,
    rawName,
    value,
    arg,
    isDynamicArg,
    modifiers,
    range
  ) {
    (el.directives || (el.directives = [])).push(rangeSetItem({
      name: name,
      rawName: rawName,
      value: value,
      arg: arg,
      isDynamicArg: isDynamicArg,
      modifiers: modifiers
    }, range));
    el.plain = false;
  }

  function prependModifierMarker (symbol, name, dynamic) {
    return dynamic
      ? ("_p(" + name + ",\"" + symbol + "\")")
      : symbol + name // mark the event as captured
  }

  function addHandler (
    el,
    name,
    value,
    modifiers,
    important,
    warn,
    range,
    dynamic
  ) {
    modifiers = modifiers || emptyObject;
    // warn prevent and passive modifier
    /* istanbul ignore if */
    if (
      warn &&
      modifiers.prevent && modifiers.passive
    ) {
      warn(
        'passive and prevent can\'t be used together. ' +
        'Passive handler can\'t prevent default event.',
        range
      );
    }

    // normalize click.right and click.middle since they don't actually fire
    // this is technically browser-specific, but at least for now browsers are
    // the only target envs that have right/middle clicks.
    if (modifiers.right) {
      if (dynamic) {
        name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
      } else if (name === 'click') {
        name = 'contextmenu';
        delete modifiers.right;
      }
    } else if (modifiers.middle) {
      if (dynamic) {
        name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
      } else if (name === 'click') {
        name = 'mouseup';
      }
    }

    // check capture modifier
    if (modifiers.capture) {
      delete modifiers.capture;
      name = prependModifierMarker('!', name, dynamic);
    }
    if (modifiers.once) {
      delete modifiers.once;
      name = prependModifierMarker('~', name, dynamic);
    }
    /* istanbul ignore if */
    if (modifiers.passive) {
      delete modifiers.passive;
      name = prependModifierMarker('&', name, dynamic);
    }

    var events;
    if (modifiers.native) {
      delete modifiers.native;
      events = el.nativeEvents || (el.nativeEvents = {});
    } else {
      events = el.events || (el.events = {});
    }

    var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);
    if (modifiers !== emptyObject) {
      newHandler.modifiers = modifiers;
    }

    var handlers = events[name];
    /* istanbul ignore if */
    if (Array.isArray(handlers)) {
      important ? handlers.unshift(newHandler) : handlers.push(newHandler);
    } else if (handlers) {
      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
    } else {
      events[name] = newHandler;
    }

    el.plain = false;
  }

  function getRawBindingAttr (
    el,
    name
  ) {
    return el.rawAttrsMap[':' + name] ||
      el.rawAttrsMap['v-bind:' + name] ||
      el.rawAttrsMap[name]
  }

  function getBindingAttr (
    el,
    name,
    getStatic
  ) {
    var dynamicValue =
      getAndRemoveAttr(el, ':' + name) ||
      getAndRemoveAttr(el, 'v-bind:' + name);
    if (dynamicValue != null) {
      return parseFilters(dynamicValue)
    } else if (getStatic !== false) {
      var staticValue = getAndRemoveAttr(el, name);
      if (staticValue != null) {
        return JSON.stringify(staticValue)
      }
    }
  }

  // note: this only removes the attr from the Array (attrsList) so that it
  // doesn't get processed by processAttrs.
  // By default it does NOT remove it from the map (attrsMap) because the map is
  // needed during codegen.
  function getAndRemoveAttr (
    el,
    name,
    removeFromMap
  ) {
    var val;
    if ((val = el.attrsMap[name]) != null) {
      var list = el.attrsList;
      for (var i = 0, l = list.length; i < l; i++) {
        if (list[i].name === name) {
          list.splice(i, 1);
          break
        }
      }
    }
    if (removeFromMap) {
      delete el.attrsMap[name];
    }
    return val
  }

  function getAndRemoveAttrByRegex (
    el,
    name
  ) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      var attr = list[i];
      if (name.test(attr.name)) {
        list.splice(i, 1);
        return attr
      }
    }
  }

  function rangeSetItem (
    item,
    range
  ) {
    if (range) {
      if (range.start != null) {
        item.start = range.start;
      }
      if (range.end != null) {
        item.end = range.end;
      }
    }
    return item
  }

  /*  */

  /**
   * Cross-platform code generation for component v-model
   */
  function genComponentModel (
    el,
    value,
    modifiers
  ) {
    var ref = modifiers || {};
    var number = ref.number;
    var trim = ref.trim;

    var baseValueExpression = '$$v';
    var valueExpression = baseValueExpression;
    if (trim) {
      valueExpression =
        "(typeof " + baseValueExpression + " === 'string'" +
        "? " + baseValueExpression + ".trim()" +
        ": " + baseValueExpression + ")";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }
    var assignment = genAssignmentCode(value, valueExpression);

    el.model = {
      value: ("(" + value + ")"),
      expression: JSON.stringify(value),
      callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
    };
  }

  /**
   * Cross-platform codegen helper for generating v-model value assignment code.
   */
  function genAssignmentCode (
    value,
    assignment
  ) {
    var res = parseModel(value);
    if (res.key === null) {
      return (value + "=" + assignment)
    } else {
      return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
    }
  }

  /**
   * Parse a v-model expression into a base path and a final key segment.
   * Handles both dot-path and possible square brackets.
   *
   * Possible cases:
   *
   * - test
   * - test[key]
   * - test[test1[key]]
   * - test["a"][key]
   * - xxx.test[a[a].test1[key]]
   * - test.xxx.a["asa"][test1[key]]
   *
   */

  var len, str, chr, index$1, expressionPos, expressionEndPos;



  function parseModel (val) {
    // Fix https://github.com/vuejs/vue/pull/7730
    // allow v-model="obj.val " (trailing whitespace)
    val = val.trim();
    len = val.length;

    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
      index$1 = val.lastIndexOf('.');
      if (index$1 > -1) {
        return {
          exp: val.slice(0, index$1),
          key: '"' + val.slice(index$1 + 1) + '"'
        }
      } else {
        return {
          exp: val,
          key: null
        }
      }
    }

    str = val;
    index$1 = expressionPos = expressionEndPos = 0;

    while (!eof()) {
      chr = next();
      /* istanbul ignore if */
      if (isStringStart(chr)) {
        parseString(chr);
      } else if (chr === 0x5B) {
        parseBracket(chr);
      }
    }

    return {
      exp: val.slice(0, expressionPos),
      key: val.slice(expressionPos + 1, expressionEndPos)
    }
  }

  function next () {
    return str.charCodeAt(++index$1)
  }

  function eof () {
    return index$1 >= len
  }

  function isStringStart (chr) {
    return chr === 0x22 || chr === 0x27
  }

  function parseBracket (chr) {
    var inBracket = 1;
    expressionPos = index$1;
    while (!eof()) {
      chr = next();
      if (isStringStart(chr)) {
        parseString(chr);
        continue
      }
      if (chr === 0x5B) { inBracket++; }
      if (chr === 0x5D) { inBracket--; }
      if (inBracket === 0) {
        expressionEndPos = index$1;
        break
      }
    }
  }

  function parseString (chr) {
    var stringQuote = chr;
    while (!eof()) {
      chr = next();
      if (chr === stringQuote) {
        break
      }
    }
  }

  /*  */

  var warn$1;

  // in some cases, the event used has to be determined at runtime
  // so we used some reserved tokens during compile.
  var RANGE_TOKEN = '__r';
  var CHECKBOX_RADIO_TOKEN = '__c';

  function model (
    el,
    dir,
    _warn
  ) {
    warn$1 = _warn;
    var value = dir.value;
    var modifiers = dir.modifiers;
    var tag = el.tag;
    var type = el.attrsMap.type;

    {
      // inputs with type="file" are read only and setting the input's
      // value will throw an error.
      if (tag === 'input' && type === 'file') {
        warn$1(
          "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
          "File inputs are read only. Use a v-on:change listener instead.",
          el.rawAttrsMap['v-model']
        );
      }
    }

    if (el.component) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false
    } else if (tag === 'select') {
      genSelect(el, value, modifiers);
    } else if (tag === 'input' && type === 'checkbox') {
      genCheckboxModel(el, value, modifiers);
    } else if (tag === 'input' && type === 'radio') {
      genRadioModel(el, value, modifiers);
    } else if (tag === 'input' || tag === 'textarea') {
      genDefaultModel(el, value, modifiers);
    } else if (!config.isReservedTag(tag)) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false
    } else {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "v-model is not supported on this element type. " +
        'If you are working with contenteditable, it\'s recommended to ' +
        'wrap a library dedicated for that purpose inside a custom component.',
        el.rawAttrsMap['v-model']
      );
    }

    // ensure runtime directive metadata
    return true
  }

  function genCheckboxModel (
    el,
    value,
    modifiers
  ) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
    addProp(el, 'checked',
      "Array.isArray(" + value + ")" +
      "?_i(" + value + "," + valueBinding + ")>-1" + (
        trueValueBinding === 'true'
          ? (":(" + value + ")")
          : (":_q(" + value + "," + trueValueBinding + ")")
      )
    );
    addHandler(el, 'change',
      "var $$a=" + value + "," +
          '$$el=$event.target,' +
          "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
      'if(Array.isArray($$a)){' +
        "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
            '$$i=_i($$a,$$v);' +
        "if($$el.checked){$$i<0&&(" + (genAssignmentCode(value, '$$a.concat([$$v])')) + ")}" +
        "else{$$i>-1&&(" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + ")}" +
      "}else{" + (genAssignmentCode(value, '$$c')) + "}",
      null, true
    );
  }

  function genRadioModel (
    el,
    value,
    modifiers
  ) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
    addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
  }

  function genSelect (
    el,
    value,
    modifiers
  ) {
    var number = modifiers && modifiers.number;
    var selectedVal = "Array.prototype.filter" +
      ".call($event.target.options,function(o){return o.selected})" +
      ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
      "return " + (number ? '_n(val)' : 'val') + "})";

    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
    var code = "var $$selectedVal = " + selectedVal + ";";
    code = code + " " + (genAssignmentCode(value, assignment));
    addHandler(el, 'change', code, null, true);
  }

  function genDefaultModel (
    el,
    value,
    modifiers
  ) {
    var type = el.attrsMap.type;

    // warn if v-bind:value conflicts with v-model
    // except for inputs with v-bind:type
    {
      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
      if (value$1 && !typeBinding) {
        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
        warn$1(
          binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " +
          'because the latter already expands to a value binding internally',
          el.rawAttrsMap[binding]
        );
      }
    }

    var ref = modifiers || {};
    var lazy = ref.lazy;
    var number = ref.number;
    var trim = ref.trim;
    var needCompositionGuard = !lazy && type !== 'range';
    var event = lazy
      ? 'change'
      : type === 'range'
        ? RANGE_TOKEN
        : 'input';

    var valueExpression = '$event.target.value';
    if (trim) {
      valueExpression = "$event.target.value.trim()";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }

    var code = genAssignmentCode(value, valueExpression);
    if (needCompositionGuard) {
      code = "if($event.target.composing)return;" + code;
    }

    addProp(el, 'value', ("(" + value + ")"));
    addHandler(el, event, code, null, true);
    if (trim || number) {
      addHandler(el, 'blur', '$forceUpdate()');
    }
  }

  /*  */

  // normalize v-model event tokens that can only be determined at runtime.
  // it's important to place the event as the first in the array because
  // the whole point is ensuring the v-model callback gets called before
  // user-attached handlers.
  function normalizeEvents (on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
      // IE input[type=range] only supports `change` event
      var event = isIE ? 'change' : 'input';
      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
      delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
      delete on[CHECKBOX_RADIO_TOKEN];
    }
  }

  var target$1;

  function createOnceHandler$1 (event, handler, capture) {
    var _target = target$1; // save current target element in closure
    return function onceHandler () {
      var res = handler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, onceHandler, capture, _target);
      }
    }
  }

  // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
  // implementation and does not fire microtasks in between event propagation, so
  // safe to exclude.
  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

  function add$1 (
    name,
    handler,
    capture,
    passive
  ) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    if (useMicrotaskFix) {
      var attachedTimestamp = currentFlushTimestamp;
      var original = handler;
      handler = original._wrapper = function (e) {
        if (
          // no bubbling, should always fire.
          // this is just a safety net in case event.timeStamp is unreliable in
          // certain weird environments...
          e.target === e.currentTarget ||
          // event is fired after handler attachment
          e.timeStamp >= attachedTimestamp ||
          // bail for environments that have buggy event.timeStamp implementations
          // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
          // #9681 QtWebEngine event.timeStamp is negative value
          e.timeStamp <= 0 ||
          // #9448 bail if event is fired in another document in a multi-page
          // electron/nw.js app, since event.timeStamp will be using a different
          // starting reference
          e.target.ownerDocument !== document
        ) {
          return original.apply(this, arguments)
        }
      };
    }
    target$1.addEventListener(
      name,
      handler,
      supportsPassive
        ? { capture: capture, passive: passive }
        : capture
    );
  }

  function remove$2 (
    name,
    handler,
    capture,
    _target
  ) {
    (_target || target$1).removeEventListener(
      name,
      handler._wrapper || handler,
      capture
    );
  }

  function updateDOMListeners (oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
      return
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    target$1 = vnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
    target$1 = undefined;
  }

  var events = {
    create: updateDOMListeners,
    update: updateDOMListeners
  };

  /*  */

  var svgContainer;

  function updateDOMProps (oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
      return
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__)) {
      props = vnode.data.domProps = extend({}, props);
    }

    for (key in oldProps) {
      if (!(key in props)) {
        elm[key] = '';
      }
    }

    for (key in props) {
      cur = props[key];
      // ignore children if the node has textContent or innerHTML,
      // as these will throw away existing DOM nodes and cause removal errors
      // on subsequent patches (#3360)
      if (key === 'textContent' || key === 'innerHTML') {
        if (vnode.children) { vnode.children.length = 0; }
        if (cur === oldProps[key]) { continue }
        // #6601 work around Chrome version <= 55 bug where single textNode
        // replaced by innerHTML/textContent retains its parentNode property
        if (elm.childNodes.length === 1) {
          elm.removeChild(elm.childNodes[0]);
        }
      }

      if (key === 'value' && elm.tagName !== 'PROGRESS') {
        // store value as _value as well since
        // non-string values will be stringified
        elm._value = cur;
        // avoid resetting cursor position when value is the same
        var strCur = isUndef(cur) ? '' : String(cur);
        if (shouldUpdateValue(elm, strCur)) {
          elm.value = strCur;
        }
      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
        // IE doesn't support innerHTML for SVG elements
        svgContainer = svgContainer || document.createElement('div');
        svgContainer.innerHTML = "<svg>" + cur + "</svg>";
        var svg = svgContainer.firstChild;
        while (elm.firstChild) {
          elm.removeChild(elm.firstChild);
        }
        while (svg.firstChild) {
          elm.appendChild(svg.firstChild);
        }
      } else if (
        // skip the update if old and new VDOM state is the same.
        // `value` is handled separately because the DOM value may be temporarily
        // out of sync with VDOM state due to focus, composition and modifiers.
        // This  #4521 by skipping the unnecesarry `checked` update.
        cur !== oldProps[key]
      ) {
        // some property updates can throw
        // e.g. `value` on <progress> w/ non-finite value
        try {
          elm[key] = cur;
        } catch (e) {}
      }
    }
  }

  // check platforms/web/util/attrs.js acceptValue


  function shouldUpdateValue (elm, checkVal) {
    return (!elm.composing && (
      elm.tagName === 'OPTION' ||
      isNotInFocusAndDirty(elm, checkVal) ||
      isDirtyWithModifiers(elm, checkVal)
    ))
  }

  function isNotInFocusAndDirty (elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try { notInFocus = document.activeElement !== elm; } catch (e) {}
    return notInFocus && elm.value !== checkVal
  }

  function isDirtyWithModifiers (elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers)) {
      if (modifiers.number) {
        return toNumber(value) !== toNumber(newVal)
      }
      if (modifiers.trim) {
        return value.trim() !== newVal.trim()
      }
    }
    return value !== newVal
  }

  var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
  };

  /*  */

  var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
      if (item) {
        var tmp = item.split(propertyDelimiter);
        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return res
  });

  // merge static and dynamic style data on the same vnode
  function normalizeStyleData (data) {
    var style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle
      ? extend(data.staticStyle, style)
      : style
  }

  // normalize possible array / string values into Object
  function normalizeStyleBinding (bindingStyle) {
    if (Array.isArray(bindingStyle)) {
      return toObject(bindingStyle)
    }
    if (typeof bindingStyle === 'string') {
      return parseStyleText(bindingStyle)
    }
    return bindingStyle
  }

  /**
   * parent component style should be after child's
   * so that parent component's style could override it
   */
  function getStyle (vnode, checkChild) {
    var res = {};
    var styleData;

    if (checkChild) {
      var childNode = vnode;
      while (childNode.componentInstance) {
        childNode = childNode.componentInstance._vnode;
        if (
          childNode && childNode.data &&
          (styleData = normalizeStyleData(childNode.data))
        ) {
          extend(res, styleData);
        }
      }
    }

    if ((styleData = normalizeStyleData(vnode.data))) {
      extend(res, styleData);
    }

    var parentNode = vnode;
    while ((parentNode = parentNode.parent)) {
      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
        extend(res, styleData);
      }
    }
    return res
  }

  /*  */

  var cssVarRE = /^--/;
  var importantRE = /\s*!important$/;
  var setProp = function (el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
      el.style.setProperty(name, val);
    } else if (importantRE.test(val)) {
      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
    } else {
      var normalizedName = normalize(name);
      if (Array.isArray(val)) {
        // Support values array created by autoprefixer, e.g.
        // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
        // Set them one by one, and the browser will only set those it can recognize
        for (var i = 0, len = val.length; i < len; i++) {
          el.style[normalizedName] = val[i];
        }
      } else {
        el.style[normalizedName] = val;
      }
    }
  };

  var vendorNames = ['Webkit', 'Moz', 'ms'];

  var emptyStyle;
  var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && (prop in emptyStyle)) {
      return prop
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
      var name = vendorNames[i] + capName;
      if (name in emptyStyle) {
        return name
      }
    }
  });

  function updateStyle (oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;

    if (isUndef(data.staticStyle) && isUndef(data.style) &&
      isUndef(oldData.staticStyle) && isUndef(oldData.style)
    ) {
      return
    }

    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    var oldStyle = oldStaticStyle || oldStyleBinding;

    var style = normalizeStyleBinding(vnode.data.style) || {};

    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__)
      ? extend({}, style)
      : style;

    var newStyle = getStyle(vnode, true);

    for (name in oldStyle) {
      if (isUndef(newStyle[name])) {
        setProp(el, name, '');
      }
    }
    for (name in newStyle) {
      cur = newStyle[name];
      if (cur !== oldStyle[name]) {
        // ie9 setting to null has no effect, must use empty string
        setProp(el, name, cur == null ? '' : cur);
      }
    }
    // NABU-CUSTOMIZED
    // vue only sets the style through element.style[attr] = value
  // it does not actually set the property
  // for server-side rendering however, this is bad as it does not end up in the html
  if (navigator.userAgent.match(/Nabu-Renderer/)) {
  	var result = "";
  	for (name in newStyle) {
  		if (result != "") {
  			result += ";"
  		}
  		result += name + ":" + newStyle[name];
  	}
  	el.setAttribute("style", result);
  }
  // NABU-END
  }

  var style = {
    create: updateStyle,
    update: updateStyle
  };

  /*  */

  var whitespaceRE = /\s+/;

  /**
   * Add class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function addClass (el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
      } else {
        el.classList.add(cls);
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      if (cur.indexOf(' ' + cls + ' ') < 0) {
        el.setAttribute('class', (cur + cls).trim());
      }
    }
  }

  /**
   * Remove class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function removeClass (el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
      } else {
        el.classList.remove(cls);
      }
      if (!el.classList.length) {
        el.removeAttribute('class');
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      var tar = ' ' + cls + ' ';
      while (cur.indexOf(tar) >= 0) {
        cur = cur.replace(tar, ' ');
      }
      cur = cur.trim();
      if (cur) {
        el.setAttribute('class', cur);
      } else {
        el.removeAttribute('class');
      }
    }
  }

  /*  */

  function resolveTransition (def$$1) {
    if (!def$$1) {
      return
    }
    /* istanbul ignore else */
    if (typeof def$$1 === 'object') {
      var res = {};
      if (def$$1.css !== false) {
        extend(res, autoCssTransition(def$$1.name || 'v'));
      }
      extend(res, def$$1);
      return res
    } else if (typeof def$$1 === 'string') {
      return autoCssTransition(def$$1)
    }
  }

  var autoCssTransition = cached(function (name) {
    return {
      enterClass: (name + "-enter"),
      enterToClass: (name + "-enter-to"),
      enterActiveClass: (name + "-enter-active"),
      leaveClass: (name + "-leave"),
      leaveToClass: (name + "-leave-to"),
      leaveActiveClass: (name + "-leave-active")
    }
  });

  var hasTransition = inBrowser && !isIE9;
  var TRANSITION = 'transition';
  var ANIMATION = 'animation';

  // Transition property/event sniffing
  var transitionProp = 'transition';
  var transitionEndEvent = 'transitionend';
  var animationProp = 'animation';
  var animationEndEvent = 'animationend';
  if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined &&
      window.onwebkittransitionend !== undefined
    ) {
      transitionProp = 'WebkitTransition';
      transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined &&
      window.onwebkitanimationend !== undefined
    ) {
      animationProp = 'WebkitAnimation';
      animationEndEvent = 'webkitAnimationEnd';
    }
  }

  // binding to window is necessary to make hot reload work in IE in strict mode
  var raf = inBrowser
    ? window.requestAnimationFrame
      ? window.requestAnimationFrame.bind(window)
      : setTimeout
    : /* istanbul ignore next */ function (fn) { return fn(); };

  function nextFrame (fn) {
    raf(function () {
      raf(fn);
    });
  }

  function addTransitionClass (el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
      transitionClasses.push(cls);
      addClass(el, cls);
    }
  }

  function removeTransitionClass (el, cls) {
    if (el._transitionClasses) {
      remove(el._transitionClasses, cls);
    }
    removeClass(el, cls);
  }

  function whenTransitionEnds (
    el,
    expectedType,
    cb
  ) {
    var ref = getTransitionInfo(el, expectedType);
    var type = ref.type;
    var timeout = ref.timeout;
    var propCount = ref.propCount;
    if (!type) { return cb() }
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function () {
      el.removeEventListener(event, onEnd);
      cb();
    };
    var onEnd = function (e) {
      if (e.target === el) {
        if (++ended >= propCount) {
          end();
        }
      }
    };
    setTimeout(function () {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
  }

  var transformRE = /\b(transform|all)(,|$)/;

  function getTransitionInfo (el, expectedType) {
    var styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);

    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0
        ? transitionTimeout > animationTimeout
          ? TRANSITION
          : ANIMATION
        : null;
      propCount = type
        ? type === TRANSITION
          ? transitionDurations.length
          : animationDurations.length
        : 0;
    }
    var hasTransform =
      type === TRANSITION &&
      transformRE.test(styles[transitionProp + 'Property']);
    return {
      type: type,
      timeout: timeout,
      propCount: propCount,
      hasTransform: hasTransform
    }
  }

  function getTimeout (delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }

    return Math.max.apply(null, durations.map(function (d, i) {
      return toMs(d) + toMs(delays[i])
    }))
  }

  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
  // in a locale-dependent way, using a comma instead of a dot.
  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting
  // as a floor function) causing unexpected behaviors
  function toMs (s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000
  }

  /*  */

  function enter (vnode, toggleDisplay) {
    var el = vnode.elm;

    // call leave callback now
    if (isDef(el._leaveCb)) {
      el._leaveCb.cancelled = true;
      el._leaveCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
      return
    }

    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
      return
    }

    var css = data.css;
    var type = data.type;
    var enterClass = data.enterClass;
    var enterToClass = data.enterToClass;
    var enterActiveClass = data.enterActiveClass;
    var appearClass = data.appearClass;
    var appearToClass = data.appearToClass;
    var appearActiveClass = data.appearActiveClass;
    var beforeEnter = data.beforeEnter;
    var enter = data.enter;
    var afterEnter = data.afterEnter;
    var enterCancelled = data.enterCancelled;
    var beforeAppear = data.beforeAppear;
    var appear = data.appear;
    var afterAppear = data.afterAppear;
    var appearCancelled = data.appearCancelled;
    var duration = data.duration;

    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
      context = transitionNode.context;
      transitionNode = transitionNode.parent;
    }

    var isAppear = !context._isMounted || !vnode.isRootInsert;

    if (isAppear && !appear && appear !== '') {
      return
    }

    var startClass = isAppear && appearClass
      ? appearClass
      : enterClass;
    var activeClass = isAppear && appearActiveClass
      ? appearActiveClass
      : enterActiveClass;
    var toClass = isAppear && appearToClass
      ? appearToClass
      : enterToClass;

    var beforeEnterHook = isAppear
      ? (beforeAppear || beforeEnter)
      : beforeEnter;
    var enterHook = isAppear
      ? (typeof appear === 'function' ? appear : enter)
      : enter;
    var afterEnterHook = isAppear
      ? (afterAppear || afterEnter)
      : afterEnter;
    var enterCancelledHook = isAppear
      ? (appearCancelled || enterCancelled)
      : enterCancelled;

    var explicitEnterDuration = toNumber(
      isObject(duration)
        ? duration.enter
        : duration
    );

    if (explicitEnterDuration != null) {
      checkDuration(explicitEnterDuration, 'enter', vnode);
    }

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);

    var cb = el._enterCb = once(function () {
      if (expectsCSS) {
        removeTransitionClass(el, toClass);
        removeTransitionClass(el, activeClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, startClass);
        }
        enterCancelledHook && enterCancelledHook(el);
      } else {
        afterEnterHook && afterEnterHook(el);
      }
      el._enterCb = null;
    });

    if (!vnode.data.show) {
      // remove pending leave element on enter by injecting an insert hook
      mergeVNodeHook(vnode, 'insert', function () {
        var parent = el.parentNode;
        var pendingNode = parent && parent._pending && parent._pending[vnode.key];
        if (pendingNode &&
          pendingNode.tag === vnode.tag &&
          pendingNode.elm._leaveCb
        ) {
          pendingNode.elm._leaveCb();
        }
        enterHook && enterHook(el, cb);
      });
    }

    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
      addTransitionClass(el, startClass);
      addTransitionClass(el, activeClass);
      nextFrame(function () {
        removeTransitionClass(el, startClass);
        if (!cb.cancelled) {
          addTransitionClass(el, toClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitEnterDuration)) {
              setTimeout(cb, explicitEnterDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    if (vnode.data.show) {
      toggleDisplay && toggleDisplay();
      enterHook && enterHook(el, cb);
    }

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }

  function leave (vnode, rm) {
    var el = vnode.elm;

    // call enter callback now
    if (isDef(el._enterCb)) {
      el._enterCb.cancelled = true;
      el._enterCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
      return rm()
    }

    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
      return
    }

    var css = data.css;
    var type = data.type;
    var leaveClass = data.leaveClass;
    var leaveToClass = data.leaveToClass;
    var leaveActiveClass = data.leaveActiveClass;
    var beforeLeave = data.beforeLeave;
    var leave = data.leave;
    var afterLeave = data.afterLeave;
    var leaveCancelled = data.leaveCancelled;
    var delayLeave = data.delayLeave;
    var duration = data.duration;

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);

    var explicitLeaveDuration = toNumber(
      isObject(duration)
        ? duration.leave
        : duration
    );

    if (isDef(explicitLeaveDuration)) {
      checkDuration(explicitLeaveDuration, 'leave', vnode);
    }

    var cb = el._leaveCb = once(function () {
      if (el.parentNode && el.parentNode._pending) {
        el.parentNode._pending[vnode.key] = null;
      }
      if (expectsCSS) {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, leaveClass);
        }
        leaveCancelled && leaveCancelled(el);
      } else {
        rm();
        afterLeave && afterLeave(el);
      }
      el._leaveCb = null;
    });

    if (delayLeave) {
      delayLeave(performLeave);
    } else {
      performLeave();
    }

    function performLeave () {
      // the delayed leave may have already been cancelled
      if (cb.cancelled) {
        return
      }
      // record leaving element
      if (!vnode.data.show && el.parentNode) {
        (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
      }
      beforeLeave && beforeLeave(el);
      if (expectsCSS) {
        addTransitionClass(el, leaveClass);
        addTransitionClass(el, leaveActiveClass);
        nextFrame(function () {
          removeTransitionClass(el, leaveClass);
          if (!cb.cancelled) {
            addTransitionClass(el, leaveToClass);
            if (!userWantsControl) {
              if (isValidDuration(explicitLeaveDuration)) {
                setTimeout(cb, explicitLeaveDuration);
              } else {
                whenTransitionEnds(el, type, cb);
              }
            }
          }
        });
      }
      leave && leave(el, cb);
      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }
  }

  // only used in dev mode
  function checkDuration (val, name, vnode) {
    if (typeof val !== 'number') {
      warn(
        "<transition> explicit " + name + " duration is not a valid number - " +
        "got " + (JSON.stringify(val)) + ".",
        vnode.context
      );
    } else if (isNaN(val)) {
      warn(
        "<transition> explicit " + name + " duration is NaN - " +
        'the duration expression might be incorrect.',
        vnode.context
      );
    }
  }

  function isValidDuration (val) {
    return typeof val === 'number' && !isNaN(val)
  }

  /**
   * Normalize a transition hook's argument length. The hook may be:
   * - a merged hook (invoker) with the original in .fns
   * - a wrapped component method (check ._length)
   * - a plain function (.length)
   */
  function getHookArgumentsLength (fn) {
    if (isUndef(fn)) {
      return false
    }
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
      // invoker
      return getHookArgumentsLength(
        Array.isArray(invokerFns)
          ? invokerFns[0]
          : invokerFns
      )
    } else {
      return (fn._length || fn.length) > 1
    }
  }

  function _enter (_, vnode) {
    if (vnode.data.show !== true) {
      enter(vnode);
    }
  }

  var transition = inBrowser ? {
    create: _enter,
    activate: _enter,
    remove: function remove$$1 (vnode, rm) {
      /* istanbul ignore else */
      if (vnode.data.show !== true) {
        leave(vnode, rm);
      } else {
        rm();
      }
    }
  } : {};

  var platformModules = [
    attrs,
    klass,
    events,
    domProps,
    style,
    transition
  ];

  /*  */

  // the directive module should be applied last, after all
  // built-in modules have been applied.
  var modules = platformModules.concat(baseModules);

  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

  /**
   * Not type checking this file because flow doesn't like attaching
   * properties to Elements.
   */

  /* istanbul ignore if */
  if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
      var el = document.activeElement;
      if (el && el.vmodel) {
        trigger(el, 'input');
      }
    });
  }

  var directive = {
    inserted: function inserted (el, binding, vnode, oldVnode) {
      if (vnode.tag === 'select') {
        // #6903
        if (oldVnode.elm && !oldVnode.elm._vOptions) {
          mergeVNodeHook(vnode, 'postpatch', function () {
            directive.componentUpdated(el, binding, vnode);
          });
        } else {
          setSelected(el, binding, vnode.context);
        }
        el._vOptions = [].map.call(el.options, getValue);
      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
        el._vModifiers = binding.modifiers;
        if (!binding.modifiers.lazy) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
          // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.
          el.addEventListener('change', onCompositionEnd);
          /* istanbul ignore if */
          if (isIE9) {
            el.vmodel = true;
          }
        }
      }
    },

    componentUpdated: function componentUpdated (el, binding, vnode) {
      if (vnode.tag === 'select') {
        setSelected(el, binding, vnode.context);
        // in case the options rendered by v-for have changed,
        // it's possible that the value is out-of-sync with the rendered options.
        // detect such cases and filter out values that no longer has a matching
        // option in the DOM.
        var prevOptions = el._vOptions;
        var curOptions = el._vOptions = [].map.call(el.options, getValue);
        if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
          // trigger change event if
          // no matching option found for at least one value
          var needReset = el.multiple
            ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
            : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
          if (needReset) {
            trigger(el, 'change');
          }
        }
      }
    }
  };

  function setSelected (el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */
    if (isIE || isEdge) {
      setTimeout(function () {
        actuallySetSelected(el, binding, vm);
      }, 0);
    }
  }

  function actuallySetSelected (el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
      warn(
        "<select multiple v-model=\"" + (binding.expression) + "\"> " +
        "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
        vm
      );
      return
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
      option = el.options[i];
      if (isMultiple) {
        selected = looseIndexOf(value, getValue(option)) > -1;
        if (option.selected !== selected) {
          option.selected = selected;
        }
      } else {
        if (looseEqual(getValue(option), value)) {
          if (el.selectedIndex !== i) {
            el.selectedIndex = i;
          }
          return
        }
      }
    }
    if (!isMultiple) {
      el.selectedIndex = -1;
    }
  }

  function hasNoMatchingOption (value, options) {
    return options.every(function (o) { return !looseEqual(o, value); })
  }

  function getValue (option) {
    return '_value' in option
      ? option._value
      : option.value
  }

  function onCompositionStart (e) {
    e.target.composing = true;
  }

  function onCompositionEnd (e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing) { return }
    e.target.composing = false;
    trigger(e.target, 'input');
  }

  function trigger (el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
  }

  /*  */

  // recursively search for possible transition defined inside the component root
  function locateNode (vnode) {
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
      ? locateNode(vnode.componentInstance._vnode)
      : vnode
  }

  var show = {
    bind: function bind (el, ref, vnode) {
      var value = ref.value;

      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      var originalDisplay = el.__vOriginalDisplay =
        el.style.display === 'none' ? '' : el.style.display;
      if (value && transition$$1) {
        vnode.data.show = true;
        enter(vnode, function () {
          el.style.display = originalDisplay;
        });
      } else {
        el.style.display = value ? originalDisplay : 'none';
      }
    },

    update: function update (el, ref, vnode) {
      var value = ref.value;
      var oldValue = ref.oldValue;

      /* istanbul ignore if */
      if (!value === !oldValue) { return }
      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      if (transition$$1) {
        vnode.data.show = true;
        if (value) {
          enter(vnode, function () {
            el.style.display = el.__vOriginalDisplay;
          });
        } else {
          leave(vnode, function () {
            el.style.display = 'none';
          });
        }
      } else {
        el.style.display = value ? el.__vOriginalDisplay : 'none';
      }
    },

    unbind: function unbind (
      el,
      binding,
      vnode,
      oldVnode,
      isDestroy
    ) {
      if (!isDestroy) {
        el.style.display = el.__vOriginalDisplay;
      }
    }
  };

  var platformDirectives = {
    model: directive,
    show: show
  };

  /*  */

  var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
  };

  // in case the child is also an abstract component, e.g. <keep-alive>
  // we want to recursively retrieve the real component to be rendered
  function getRealChild (vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
      return getRealChild(getFirstComponentChild(compOptions.children))
    } else {
      return vnode
    }
  }

  function extractTransitionData (comp) {
    var data = {};
    var options = comp.$options;
    // props
    for (var key in options.propsData) {
      data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    var listeners = options._parentListeners;
    for (var key$1 in listeners) {
      data[camelize(key$1)] = listeners[key$1];
    }
    return data
  }

  function placeholder (h, rawChild) {
    if (/\d-keep-alive$/.test(rawChild.tag)) {
      return h('keep-alive', {
        props: rawChild.componentOptions.propsData
      })
    }
  }

  function hasParentTransition (vnode) {
    while ((vnode = vnode.parent)) {
      if (vnode.data.transition) {
        return true
      }
    }
  }

  function isSameChild (child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag
  }

  var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

  var isVShowDirective = function (d) { return d.name === 'show'; };

  var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,

    render: function render (h) {
      var this$1 = this;

      var children = this.$slots.default;
      if (!children) {
        return
      }

      // filter out text nodes (possible whitespaces)
      children = children.filter(isNotTextNode);
      /* istanbul ignore if */
      if (!children.length) {
        return
      }

      // warn multiple elements
      if (children.length > 1) {
        warn(
          '<transition> can only be used on a single element. Use ' +
          '<transition-group> for lists.',
          this.$parent
        );
      }

      var mode = this.mode;

      // warn invalid mode
      if (mode && mode !== 'in-out' && mode !== 'out-in'
      ) {
        warn(
          'invalid <transition> mode: ' + mode,
          this.$parent
        );
      }

      var rawChild = children[0];

      // if this is a component root node and the component's
      // parent container node also has transition, skip.
      if (hasParentTransition(this.$vnode)) {
        return rawChild
      }

      // apply transition data to child
      // use getRealChild() to ignore abstract components e.g. keep-alive
      var child = getRealChild(rawChild);
      /* istanbul ignore if */
      if (!child) {
        return rawChild
      }

      if (this._leaving) {
        return placeholder(h, rawChild)
      }

      // ensure a key that is unique to the vnode type and to this transition
      // component instance. This key will be used to remove pending leaving nodes
      // during entering.
      var id = "__transition-" + (this._uid) + "-";
      child.key = child.key == null
        ? child.isComment
          ? id + 'comment'
          : id + child.tag
        : isPrimitive(child.key)
          ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
          : child.key;

      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
      var oldRawChild = this._vnode;
      var oldChild = getRealChild(oldRawChild);

      // mark v-show
      // so that the transition module can hand over the control to the directive
      if (child.data.directives && child.data.directives.some(isVShowDirective)) {
        child.data.show = true;
      }

      if (
        oldChild &&
        oldChild.data &&
        !isSameChild(child, oldChild) &&
        !isAsyncPlaceholder(oldChild) &&
        // #6687 component root is a comment node
        !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
      ) {
        // replace old child transition data with fresh one
        // important for dynamic transitions!
        var oldData = oldChild.data.transition = extend({}, data);
        // handle transition mode
        if (mode === 'out-in') {
          // return placeholder node and queue update when leave finishes
          this._leaving = true;
          mergeVNodeHook(oldData, 'afterLeave', function () {
            this$1._leaving = false;
            this$1.$forceUpdate();
          });
          return placeholder(h, rawChild)
        } else if (mode === 'in-out') {
          if (isAsyncPlaceholder(child)) {
            return oldRawChild
          }
          var delayedLeave;
          var performLeave = function () { delayedLeave(); };
          mergeVNodeHook(data, 'afterEnter', performLeave);
          mergeVNodeHook(data, 'enterCancelled', performLeave);
          mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
        }
      }

      return rawChild
    }
  };

  /*  */

  var props = extend({
    tag: String,
    moveClass: String
  }, transitionProps);

  delete props.mode;

  var TransitionGroup = {
    props: props,

    beforeMount: function beforeMount () {
      var this$1 = this;

      var update = this._update;
      this._update = function (vnode, hydrating) {
        var restoreActiveInstance = setActiveInstance(this$1);
        // force removing pass
        this$1.__patch__(
          this$1._vnode,
          this$1.kept,
          false, // hydrating
          true // removeOnly (!important, avoids unnecessary moves)
        );
        this$1._vnode = this$1.kept;
        restoreActiveInstance();
        update.call(this$1, vnode, hydrating);
      };
    },

    render: function render (h) {
      var tag = this.tag || this.$vnode.data.tag || 'span';
      var map = Object.create(null);
      var prevChildren = this.prevChildren = this.children;
      var rawChildren = this.$slots.default || [];
      var children = this.children = [];
      var transitionData = extractTransitionData(this);

      for (var i = 0; i < rawChildren.length; i++) {
        var c = rawChildren[i];
        if (c.tag) {
          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
            children.push(c);
            map[c.key] = c
            ;(c.data || (c.data = {})).transition = transitionData;
          } else {
            var opts = c.componentOptions;
            var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
            warn(("<transition-group> children must be keyed: <" + name + ">"));
          }
        }
      }

      if (prevChildren) {
        var kept = [];
        var removed = [];
        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
          var c$1 = prevChildren[i$1];
          c$1.data.transition = transitionData;
          c$1.data.pos = c$1.elm.getBoundingClientRect();
          if (map[c$1.key]) {
            kept.push(c$1);
          } else {
            removed.push(c$1);
          }
        }
        this.kept = h(tag, null, kept);
        this.removed = removed;
      }

      return h(tag, null, children)
    },

    updated: function updated () {
      var children = this.prevChildren;
      var moveClass = this.moveClass || ((this.name || 'v') + '-move');
      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
        return
      }

      // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.
      children.forEach(callPendingCbs);
      children.forEach(recordPosition);
      children.forEach(applyTranslation);

      // force reflow to put everything in position
      // assign to this to avoid being removed in tree-shaking
      // $flow-disable-line
      this._reflow = document.body.offsetHeight;

      children.forEach(function (c) {
        if (c.data.moved) {
          var el = c.elm;
          var s = el.style;
          addTransitionClass(el, moveClass);
          s.transform = s.WebkitTransform = s.transitionDuration = '';
          el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
            if (e && e.target !== el) {
              return
            }
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener(transitionEndEvent, cb);
              el._moveCb = null;
              removeTransitionClass(el, moveClass);
            }
          });
        }
      });
    },

    methods: {
      hasMove: function hasMove (el, moveClass) {
        /* istanbul ignore if */
        if (!hasTransition) {
          return false
        }
        /* istanbul ignore if */
        if (this._hasMove) {
          return this._hasMove
        }
        // Detect whether an element with the move class applied has
        // CSS transitions. Since the element may be inside an entering
        // transition at this very moment, we make a clone of it and remove
        // all other transition classes applied to ensure only the move class
        // is applied.
        var clone = el.cloneNode();
        if (el._transitionClasses) {
          el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
        }
        addClass(clone, moveClass);
        clone.style.display = 'none';
        this.$el.appendChild(clone);
        var info = getTransitionInfo(clone);
        this.$el.removeChild(clone);
        return (this._hasMove = info.hasTransform)
      }
    }
  };

  function callPendingCbs (c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
      c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
      c.elm._enterCb();
    }
  }

  function recordPosition (c) {
    c.data.newPos = c.elm.getBoundingClientRect();
  }

  function applyTranslation (c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
      c.data.moved = true;
      var s = c.elm.style;
      s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
      s.transitionDuration = '0s';
    }
  }

  var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup
  };

  /*  */

  // install platform specific utils
  Vue.config.mustUseProp = mustUseProp;
  Vue.config.isReservedTag = isReservedTag;
  Vue.config.isReservedAttr = isReservedAttr;
  Vue.config.getTagNamespace = getTagNamespace;
  Vue.config.isUnknownElement = isUnknownElement;

  // install platform runtime directives & components
  extend(Vue.options.directives, platformDirectives);
  extend(Vue.options.components, platformComponents);

  // install platform patch function
  Vue.prototype.__patch__ = inBrowser ? patch : noop;

  // public mount method
  Vue.prototype.$mount = function (
    el,
    hydrating
  ) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating)
  };

  // devtools global hook
  /* istanbul ignore next */
  if (inBrowser) {
    setTimeout(function () {
      if (config.devtools) {
        if (devtools) {
          devtools.emit('init', Vue);
        } else {
          console[console.info ? 'info' : 'log'](
            'Download the Vue Devtools extension for a better development experience:\n' +
            'https://github.com/vuejs/vue-devtools'
          );
        }
      }
      if (config.productionTip !== false &&
        typeof console !== 'undefined'
      ) {
        console[console.info ? 'info' : 'log'](
          "You are running Vue in development mode.\n" +
          "Make sure to turn on production mode when deploying for production.\n" +
          "See more tips at https://vuejs.org/guide/deployment.html"
        );
      }
    }, 0);
  }

  /*  */

  var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
  // NABU-CUSTOMIZED
  var regexEscapeRE = /[-.*+?$^{}()|[\]\/\\]/g;
  // NABU-END

  var buildRegex = cached(function (delimiters) {
    var open = delimiters[0].replace(regexEscapeRE, '\\$&');
    var close = delimiters[1].replace(regexEscapeRE, '\\$&');
    return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
  });



  function parseText (
    text,
    delimiters
  ) {
    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
    if (!tagRE.test(text)) {
      return
    }
    var tokens = [];
    var rawTokens = [];
    var lastIndex = tagRE.lastIndex = 0;
    var match, index, tokenValue;
    while ((match = tagRE.exec(text))) {
      index = match.index;
      // push text token
      if (index > lastIndex) {
        rawTokens.push(tokenValue = text.slice(lastIndex, index));
        tokens.push(JSON.stringify(tokenValue));
      }
      // tag token
      var exp = parseFilters(match[1].trim());
      tokens.push(("_s(" + exp + ")"));
      rawTokens.push({ '@binding': exp });
      lastIndex = index + match[0].length;
    }
    if (lastIndex < text.length) {
      rawTokens.push(tokenValue = text.slice(lastIndex));
      tokens.push(JSON.stringify(tokenValue));
    }
    return {
      expression: tokens.join('+'),
      tokens: rawTokens
    }
  }

  /*  */

  function transformNode (el, options) {
    var warn = options.warn || baseWarn;
    var staticClass = getAndRemoveAttr(el, 'class');
    if (staticClass) {
      var res = parseText(staticClass, options.delimiters);
      if (res) {
        warn(
          "class=\"" + staticClass + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div class="{{ val }}">, use <div :class="val">.',
          el.rawAttrsMap['class']
        );
      }
    }
    if (staticClass) {
      el.staticClass = JSON.stringify(staticClass);
    }
    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
    if (classBinding) {
      el.classBinding = classBinding;
    }
  }

  function genData (el) {
    var data = '';
    if (el.staticClass) {
      data += "staticClass:" + (el.staticClass) + ",";
    }
    if (el.classBinding) {
      data += "class:" + (el.classBinding) + ",";
    }
    return data
  }

  var klass$1 = {
    staticKeys: ['staticClass'],
    transformNode: transformNode,
    genData: genData
  };

  /*  */

  function transformNode$1 (el, options) {
    var warn = options.warn || baseWarn;
    var staticStyle = getAndRemoveAttr(el, 'style');
    if (staticStyle) {
      /* istanbul ignore if */
      {
        var res = parseText(staticStyle, options.delimiters);
        if (res) {
          warn(
            "style=\"" + staticStyle + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div style="{{ val }}">, use <div :style="val">.',
            el.rawAttrsMap['style']
          );
        }
      }
      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
    }

    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
    if (styleBinding) {
      el.styleBinding = styleBinding;
    }
  }

  function genData$1 (el) {
    var data = '';
    if (el.staticStyle) {
      data += "staticStyle:" + (el.staticStyle) + ",";
    }
    if (el.styleBinding) {
      data += "style:(" + (el.styleBinding) + "),";
    }
    return data
  }

  var style$1 = {
    staticKeys: ['staticStyle'],
    transformNode: transformNode$1,
    genData: genData$1
  };

  /*  */

  var decoder;

  var he = {
    decode: function decode (html) {
      decoder = decoder || document.createElement('div');
      decoder.innerHTML = html;
      return decoder.textContent
    }
  };

  /*  */

  var isUnaryTag = makeMap(
    'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
    'link,meta,param,source,track,wbr'
  );

  // Elements that you can, intentionally, leave open
  // (and which close themselves)
  var canBeLeftOpenTag = makeMap(
    'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
  );

  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
  var isNonPhrasingTag = makeMap(
    'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
    'title,tr,track'
  );

  /**
   * Not type-checking this file because it's mostly vendor code.
   */

  // Regular Expressions for parsing tags and attributes
  var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
  var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
  var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + (unicodeRegExp.source) + "]*";
  var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
  var startTagOpen = new RegExp(("^<" + qnameCapture));
  var startTagClose = /^\s*(\/?)>/;
  var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
  var doctype = /^<!DOCTYPE [^>]+>/i;
  // #7298: escape - to avoid being pased as HTML comment when inlined in page
  var comment = /^<!\--/;
  var conditionalComment = /^<!\[/;

  // Special Elements (can contain anything)
  var isPlainTextElement = makeMap('script,style,textarea', true);
  var reCache = {};

  var decodingMap = {
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&amp;': '&',
    '&#10;': '\n',
    '&#9;': '\t',
    '&#39;': "'"
  };
  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;

  // #5992
  var isIgnoreNewlineTag = makeMap('pre,textarea', true);
  var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

  function decodeAttr (value, shouldDecodeNewlines) {
    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
    return value.replace(re, function (match) { return decodingMap[match]; })
  }

  function parseHTML (html, options) {
    var stack = [];
    var expectHTML = options.expectHTML;
    var isUnaryTag$$1 = options.isUnaryTag || no;
    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
    var index = 0;
    var last, lastTag;
    while (html) {
      last = html;
      // Make sure we're not in a plaintext content element like script/style
      if (!lastTag || !isPlainTextElement(lastTag)) {
        var textEnd = html.indexOf('<');
        if (textEnd === 0) {
          // Comment:
          if (comment.test(html)) {
            var commentEnd = html.indexOf('-->');

            if (commentEnd >= 0) {
              if (options.shouldKeepComment) {
                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
              }
              advance(commentEnd + 3);
              continue
            }
          }

          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
          if (conditionalComment.test(html)) {
            var conditionalEnd = html.indexOf(']>');

            if (conditionalEnd >= 0) {
              advance(conditionalEnd + 2);
              continue
            }
          }

          // Doctype:
          var doctypeMatch = html.match(doctype);
          if (doctypeMatch) {
            advance(doctypeMatch[0].length);
            continue
          }

          // End tag:
          var endTagMatch = html.match(endTag);
          if (endTagMatch) {
            var curIndex = index;
            advance(endTagMatch[0].length);
            parseEndTag(endTagMatch[1], curIndex, index);
            continue
          }

          // Start tag:
          var startTagMatch = parseStartTag();
          if (startTagMatch) {
            handleStartTag(startTagMatch);
            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
              advance(1);
            }
            continue
          }
        }

        var text = (void 0), rest = (void 0), next = (void 0);
        if (textEnd >= 0) {
          rest = html.slice(textEnd);
          while (
            !endTag.test(rest) &&
            !startTagOpen.test(rest) &&
            !comment.test(rest) &&
            !conditionalComment.test(rest)
          ) {
            // < in plain text, be forgiving and treat it as text
            next = rest.indexOf('<', 1);
            if (next < 0) { break }
            textEnd += next;
            rest = html.slice(textEnd);
          }
          text = html.substring(0, textEnd);
        }

        if (textEnd < 0) {
          text = html;
        }

        if (text) {
          advance(text.length);
        }

        if (options.chars && text) {
          options.chars(text, index - text.length, index);
        }
      } else {
        var endTagLength = 0;
        var stackedTag = lastTag.toLowerCase();
        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
          endTagLength = endTag.length;
          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
            text = text
              .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
              .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
          }
          if (shouldIgnoreFirstNewline(stackedTag, text)) {
            text = text.slice(1);
          }
          if (options.chars) {
            options.chars(text);
          }
          return ''
        });
        index += html.length - rest$1.length;
        html = rest$1;
        parseEndTag(stackedTag, index - endTagLength, index);
      }

      if (html === last) {
        options.chars && options.chars(html);
        if (!stack.length && options.warn) {
          options.warn(("Mal-formatted tag at end of template: \"" + html + "\""), { start: index + html.length });
        }
        break
      }
    }

    // Clean up any remaining tags
    parseEndTag();

    function advance (n) {
      index += n;
      html = html.substring(n);
    }

    function parseStartTag () {
      var start = html.match(startTagOpen);
      if (start) {
        var match = {
          tagName: start[1],
          attrs: [],
          start: index
        };
        advance(start[0].length);
        var end, attr;
        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
          attr.start = index;
          advance(attr[0].length);
          attr.end = index;
          match.attrs.push(attr);
        }
        if (end) {
          match.unarySlash = end[1];
          advance(end[0].length);
          match.end = index;
          return match
        }
      }
    }

    function handleStartTag (match) {
      var tagName = match.tagName;
      var unarySlash = match.unarySlash;

      if (expectHTML) {
        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
          parseEndTag(lastTag);
        }
        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
          parseEndTag(tagName);
        }
      }

      var unary = isUnaryTag$$1(tagName) || !!unarySlash;

      var l = match.attrs.length;
      var attrs = new Array(l);
      for (var i = 0; i < l; i++) {
        var args = match.attrs[i];
        var value = args[3] || args[4] || args[5] || '';
        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
          ? options.shouldDecodeNewlinesForHref
          : options.shouldDecodeNewlines;
        attrs[i] = {
          name: args[1],
          value: decodeAttr(value, shouldDecodeNewlines)
        };
        if (options.outputSourceRange) {
          attrs[i].start = args.start + args[0].match(/^\s*/).length;
          attrs[i].end = args.end;
        }
      }

      if (!unary) {
        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });
        lastTag = tagName;
      }

      if (options.start) {
        options.start(tagName, attrs, unary, match.start, match.end);
      }
    }

    function parseEndTag (tagName, start, end) {
      var pos, lowerCasedTagName;
      if (start == null) { start = index; }
      if (end == null) { end = index; }

      // Find the closest opened tag of the same type
      if (tagName) {
        lowerCasedTagName = tagName.toLowerCase();
        for (pos = stack.length - 1; pos >= 0; pos--) {
          if (stack[pos].lowerCasedTag === lowerCasedTagName) {
            break
          }
        }
      } else {
        // If no tag name is provided, clean shop
        pos = 0;
      }

      if (pos >= 0) {
        // Close all the open elements, up the stack
        for (var i = stack.length - 1; i >= pos; i--) {
          if (i > pos || !tagName &&
            options.warn
          ) {
            options.warn(
              ("tag <" + (stack[i].tag) + "> has no matching end tag."),
              { start: stack[i].start, end: stack[i].end }
            );
          }
          if (options.end) {
            options.end(stack[i].tag, start, end);
          }
        }

        // Remove the open elements from the stack
        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
      } else if (lowerCasedTagName === 'br') {
        if (options.start) {
          options.start(tagName, [], true, start, end);
        }
      } else if (lowerCasedTagName === 'p') {
        if (options.start) {
          options.start(tagName, [], false, start, end);
        }
        if (options.end) {
          options.end(tagName, start, end);
        }
      }
    }
  }

  /*  */

  var onRE = /^@|^v-on:/;
  var dirRE = /^v-|^@|^:/;
  var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  var stripParensRE = /^\(|\)$/g;
  var dynamicArgRE = /^\[.*\]$/;

  var argRE = /:(.*)$/;
  var bindRE = /^:|^\.|^v-bind:/;
  var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;

  var slotRE = /^v-slot(:|$)|^#/;

  var lineBreakRE = /[\r\n]/;
  var whitespaceRE$1 = /\s+/g;

  var invalidAttributeRE = /[\s"'<>\/=]/;

  var decodeHTMLCached = cached(he.decode);

  var emptySlotScopeToken = "_empty_";

  // configurable state
  var warn$2;
  var delimiters;
  var transforms;
  var preTransforms;
  var postTransforms;
  var platformIsPreTag;
  var platformMustUseProp;
  var platformGetTagNamespace;
  var maybeComponent;

  function createASTElement (
    tag,
    attrs,
    parent
  ) {
    return {
      type: 1,
      tag: tag,
      attrsList: attrs,
      attrsMap: makeAttrsMap(attrs),
      rawAttrsMap: {},
      parent: parent,
      children: []
    }
  }

  /**
   * Convert HTML string to AST.
   */
  function parse (
    template,
    options
  ) {
    warn$2 = options.warn || baseWarn;

    platformIsPreTag = options.isPreTag || no;
    platformMustUseProp = options.mustUseProp || no;
    platformGetTagNamespace = options.getTagNamespace || no;
    var isReservedTag = options.isReservedTag || no;
    maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };

    transforms = pluckModuleFunction(options.modules, 'transformNode');
    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

    delimiters = options.delimiters;

    var stack = [];
    var preserveWhitespace = options.preserveWhitespace !== false;
    var whitespaceOption = options.whitespace;
    var root;
    var currentParent;
    var inVPre = false;
    var inPre = false;
    var warned = false;

    function warnOnce (msg, range) {
      if (!warned) {
        warned = true;
        warn$2(msg, range);
      }
    }

    function closeElement (element) {
      trimEndingWhitespace(element);
      if (!inVPre && !element.processed) {
        element = processElement(element, options);
      }
      // tree management
      if (!stack.length && element !== root) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          {
            checkRootConstraints(element);
          }
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else {
          warnOnce(
            "Component template should contain exactly one root element. " +
            "If you are using v-if on multiple elements, " +
            "use v-else-if to chain them instead.",
            { start: element.start }
          );
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else {
          if (element.slotScope) {
            // scoped slot
            // keep it in the children list so that v-else(-if) conditions can
            // find it as the prev node.
            var name = element.slotTarget || '"default"'
            ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
          }
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }

      // final children cleanup
      // filter out scoped slots
      element.children = element.children.filter(function (c) { return !(c).slotScope; });
      // remove trailing whitespace node again
      trimEndingWhitespace(element);

      // check pre state
      if (element.pre) {
        inVPre = false;
      }
      if (platformIsPreTag(element.tag)) {
        inPre = false;
      }
      // apply post-transforms
      for (var i = 0; i < postTransforms.length; i++) {
        postTransforms[i](element, options);
      }
    }

    function trimEndingWhitespace (el) {
      // remove trailing whitespace node
      if (!inPre) {
        var lastNode;
        while (
          (lastNode = el.children[el.children.length - 1]) &&
          lastNode.type === 3 &&
          lastNode.text === ' '
        ) {
          el.children.pop();
        }
      }
    }

    function checkRootConstraints (el) {
      if (el.tag === 'slot' || el.tag === 'template') {
        warnOnce(
          "Cannot use <" + (el.tag) + "> as component root element because it may " +
          'contain multiple nodes.',
          { start: el.start }
        );
      }
      if (el.attrsMap.hasOwnProperty('v-for')) {
        warnOnce(
          'Cannot use v-for on stateful component root element because ' +
          'it renders multiple elements.',
          el.rawAttrsMap['v-for']
        );
      }
    }

    parseHTML(template, {
      warn: warn$2,
      expectHTML: options.expectHTML,
      isUnaryTag: options.isUnaryTag,
      canBeLeftOpenTag: options.canBeLeftOpenTag,
      shouldDecodeNewlines: options.shouldDecodeNewlines,
      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
      shouldKeepComment: options.comments,
      outputSourceRange: options.outputSourceRange,
      start: function start (tag, attrs, unary, start$1, end) {
        // check namespace.
        // inherit parent ns if there is one
        var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

        // handle IE svg bug
        /* istanbul ignore if */
        if (isIE && ns === 'svg') {
          attrs = guardIESVGBug(attrs);
        }

        var element = createASTElement(tag, attrs, currentParent);
        if (ns) {
          element.ns = ns;
        }

        {
          if (options.outputSourceRange) {
            element.start = start$1;
            element.end = end;
            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
              cumulated[attr.name] = attr;
              return cumulated
            }, {});
          }
          attrs.forEach(function (attr) {
            if (invalidAttributeRE.test(attr.name)) {
              warn$2(
                "Invalid dynamic argument expression: attribute names cannot contain " +
                "spaces, quotes, <, >, / or =.",
                {
                  start: attr.start + attr.name.indexOf("["),
                  end: attr.start + attr.name.length
                }
              );
            }
          });
        }

        if (isForbiddenTag(element) && !isServerRendering()) {
          element.forbidden = true;
          warn$2(
            'Templates should only be responsible for mapping the state to the ' +
            'UI. Avoid placing tags with side-effects in your templates, such as ' +
            "<" + tag + ">" + ', as they will not be parsed.',
            { start: element.start }
          );
        }

        // apply pre-transforms
        for (var i = 0; i < preTransforms.length; i++) {
          element = preTransforms[i](element, options) || element;
        }

        if (!inVPre) {
          processPre(element);
          if (element.pre) {
            inVPre = true;
          }
        }
        if (platformIsPreTag(element.tag)) {
          inPre = true;
        }
        if (inVPre) {
          processRawAttrs(element);
        } else if (!element.processed) {
          // structural directives
          processFor(element);
          processIf(element);
          processOnce(element);
        }

        if (!root) {
          root = element;
          {
            checkRootConstraints(root);
          }
        }

        if (!unary) {
          currentParent = element;
          stack.push(element);
        } else {
          closeElement(element);
        }
      },

      end: function end (tag, start, end$1) {
        var element = stack[stack.length - 1];
        // pop stack
        stack.length -= 1;
        currentParent = stack[stack.length - 1];
        if (options.outputSourceRange) {
          element.end = end$1;
        }
        closeElement(element);
      },

      chars: function chars (text, start, end) {
        if (!currentParent) {
          {
            if (text === template) {
              warnOnce(
                'Component template requires a root element, rather than just text.',
                { start: start }
              );
            } else if ((text = text.trim())) {
              warnOnce(
                ("text \"" + text + "\" outside root element will be ignored."),
                { start: start }
              );
            }
          }
          return
        }
        // IE textarea placeholder bug
        /* istanbul ignore if */
        if (isIE &&
          currentParent.tag === 'textarea' &&
          currentParent.attrsMap.placeholder === text
        ) {
          return
        }
        var children = currentParent.children;
        if (inPre || text.trim()) {
          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
        } else if (!children.length) {
          // remove the whitespace-only node right after an opening tag
          text = '';
        } else if (whitespaceOption) {
          if (whitespaceOption === 'condense') {
            // in condense mode, remove the whitespace node if it contains
            // line break, otherwise condense to a single space
            text = lineBreakRE.test(text) ? '' : ' ';
          } else {
            text = ' ';
          }
        } else {
          text = preserveWhitespace ? ' ' : '';
        }
        if (text) {
          if (!inPre && whitespaceOption === 'condense') {
            // condense consecutive whitespaces into single space
            text = text.replace(whitespaceRE$1, ' ');
          }
          var res;
          var child;
          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
            child = {
              type: 2,
              expression: res.expression,
              tokens: res.tokens,
              text: text
            };
          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
            child = {
              type: 3,
              text: text
            };
          }
          if (child) {
            if (options.outputSourceRange) {
              child.start = start;
              child.end = end;
            }
            children.push(child);
          }
        }
      },
      comment: function comment (text, start, end) {
        // adding anyting as a sibling to the root node is forbidden
        // comments should still be allowed, but ignored
        if (currentParent) {
          var child = {
            type: 3,
            text: text,
            isComment: true
          };
          if (options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }
          currentParent.children.push(child);
        }
      }
    });
    return root
  }

  function processPre (el) {
    if (getAndRemoveAttr(el, 'v-pre') != null) {
      el.pre = true;
    }
  }

  function processRawAttrs (el) {
    var list = el.attrsList;
    var len = list.length;
    if (len) {
      var attrs = el.attrs = new Array(len);
      for (var i = 0; i < len; i++) {
        attrs[i] = {
          name: list[i].name,
          value: JSON.stringify(list[i].value)
        };
        if (list[i].start != null) {
          attrs[i].start = list[i].start;
          attrs[i].end = list[i].end;
        }
      }
    } else if (!el.pre) {
      // non root node in pre blocks with no attributes
      el.plain = true;
    }
  }

  function processElement (
    element,
    options
  ) {
    processKey(element);

    // determine whether this is a plain element after
    // removing structural attributes
    element.plain = (
      !element.key &&
      !element.scopedSlots &&
      !element.attrsList.length
    );

    processRef(element);
    processSlotContent(element);
    processSlotOutlet(element);
    processComponent(element);
    for (var i = 0; i < transforms.length; i++) {
      element = transforms[i](element, options) || element;
    }
    processAttrs(element);
    return element
  }

  function processKey (el) {
    var exp = getBindingAttr(el, 'key');
    if (exp) {
      {
        if (el.tag === 'template') {
          warn$2(
            "<template> cannot be keyed. Place the key on real elements instead.",
            getRawBindingAttr(el, 'key')
          );
        }
        if (el.for) {
          var iterator = el.iterator2 || el.iterator1;
          var parent = el.parent;
          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
            warn$2(
              "Do not use v-for index as key on <transition-group> children, " +
              "this is the same as not using keys.",
              getRawBindingAttr(el, 'key'),
              true /* tip */
            );
          }
        }
      }
      el.key = exp;
    }
  }

  function processRef (el) {
    var ref = getBindingAttr(el, 'ref');
    if (ref) {
      el.ref = ref;
      el.refInFor = checkInFor(el);
    }
  }

  function processFor (el) {
    var exp;
    if ((exp = getAndRemoveAttr(el, 'v-for'))) {
      var res = parseFor(exp);
      if (res) {
        extend(el, res);
      } else {
        warn$2(
          ("Invalid v-for expression: " + exp),
          el.rawAttrsMap['v-for']
        );
      }
    }
  }



  function parseFor (exp) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) { return }
    var res = {};
    res.for = inMatch[2].trim();
    var alias = inMatch[1].trim().replace(stripParensRE, '');
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      res.alias = alias.replace(forIteratorRE, '').trim();
      res.iterator1 = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.iterator2 = iteratorMatch[2].trim();
      }
    } else {
      res.alias = alias;
    }
    return res
  }

  function processIf (el) {
    var exp = getAndRemoveAttr(el, 'v-if');
    if (exp) {
      el.if = exp;
      addIfCondition(el, {
        exp: exp,
        block: el
      });
    } else {
      if (getAndRemoveAttr(el, 'v-else') != null) {
        el.else = true;
      }
      var elseif = getAndRemoveAttr(el, 'v-else-if');
      if (elseif) {
        el.elseif = elseif;
      }
    }
  }

  function processIfConditions (el, parent) {
    var prev = findPrevElement(parent.children);
    if (prev && prev.if) {
      addIfCondition(prev, {
        exp: el.elseif,
        block: el
      });
    } else {
      warn$2(
        "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
        "used on element <" + (el.tag) + "> without corresponding v-if.",
        el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']
      );
    }
  }

  function findPrevElement (children) {
    var i = children.length;
    while (i--) {
      if (children[i].type === 1) {
        return children[i]
      } else {
        if (children[i].text !== ' ') {
          warn$2(
            "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
            "will be ignored.",
            children[i]
          );
        }
        children.pop();
      }
    }
  }

  function addIfCondition (el, condition) {
    if (!el.ifConditions) {
      el.ifConditions = [];
    }
    el.ifConditions.push(condition);
  }

  function processOnce (el) {
    var once$$1 = getAndRemoveAttr(el, 'v-once');
    if (once$$1 != null) {
      el.once = true;
    }
  }

  // handle content being passed to a component as slot,
  // e.g. <template slot="xxx">, <div slot-scope="xxx">
  function processSlotContent (el) {
    var slotScope;
    if (el.tag === 'template') {
      slotScope = getAndRemoveAttr(el, 'scope');
      /* istanbul ignore if */
      if (slotScope) {
        warn$2(
          "the \"scope\" attribute for scoped slots have been deprecated and " +
          "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
          "can also be used on plain elements in addition to <template> to " +
          "denote scoped slots.",
          el.rawAttrsMap['scope'],
          true
        );
      }
      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
      /* istanbul ignore if */
      if (el.attrsMap['v-for']) {
        warn$2(
          "Ambiguous combined usage of slot-scope and v-for on <" + (el.tag) + "> " +
          "(v-for takes higher priority). Use a wrapper <template> for the " +
          "scoped slot to make it clearer.",
          el.rawAttrsMap['slot-scope'],
          true
        );
      }
      el.slotScope = slotScope;
    }

    // slot="xxx"
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
      // preserve slot as an attribute for native shadow DOM compat
      // only for non-scoped slots.
      if (el.tag !== 'template' && !el.slotScope) {
        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
      }
    }

    // 2.6 v-slot syntax
    {
      if (el.tag === 'template') {
        // v-slot on <template>
        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
        if (slotBinding) {
          {
            if (el.slotTarget || el.slotScope) {
              warn$2(
                "Unexpected mixed usage of different slot syntaxes.",
                el
              );
            }
            if (el.parent && !maybeComponent(el.parent)) {
              warn$2(
                "<template v-slot> can only appear at the root level inside " +
                "the receiving the component",
                el
              );
            }
          }
          var ref = getSlotName(slotBinding);
          var name = ref.name;
          var dynamic = ref.dynamic;
          el.slotTarget = name;
          el.slotTargetDynamic = dynamic;
          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
        }
      } else {
        // v-slot on component, denotes default slot
        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
        if (slotBinding$1) {
          {
            if (!maybeComponent(el)) {
              warn$2(
                "v-slot can only be used on components or <template>.",
                slotBinding$1
              );
            }
            if (el.slotScope || el.slotTarget) {
              warn$2(
                "Unexpected mixed usage of different slot syntaxes.",
                el
              );
            }
            if (el.scopedSlots) {
              warn$2(
                "To avoid scope ambiguity, the default slot should also use " +
                "<template> syntax when there are other named slots.",
                slotBinding$1
              );
            }
          }
          // add the component's children to its default slot
          var slots = el.scopedSlots || (el.scopedSlots = {});
          var ref$1 = getSlotName(slotBinding$1);
          var name$1 = ref$1.name;
          var dynamic$1 = ref$1.dynamic;
          var slotContainer = slots[name$1] = createASTElement('template', [], el);
          slotContainer.slotTarget = name$1;
          slotContainer.slotTargetDynamic = dynamic$1;
          slotContainer.children = el.children.filter(function (c) {
            if (!c.slotScope) {
              c.parent = slotContainer;
              return true
            }
          });
          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;
          // remove children as they are returned from scopedSlots now
          el.children = [];
          // mark el non-plain so data gets generated
          el.plain = false;
        }
      }
    }
  }

  function getSlotName (binding) {
    var name = binding.name.replace(slotRE, '');
    if (!name) {
      if (binding.name[0] !== '#') {
        name = 'default';
      } else {
        warn$2(
          "v-slot shorthand syntax requires a slot name.",
          binding
        );
      }
    }
    return dynamicArgRE.test(name)
      // dynamic [name]
      ? { name: name.slice(1, -1), dynamic: true }
      // static name
      : { name: ("\"" + name + "\""), dynamic: false }
  }

  // handle <slot/> outlets
  function processSlotOutlet (el) {
    if (el.tag === 'slot') {
      el.slotName = getBindingAttr(el, 'name');
      if (el.key) {
        warn$2(
          "`key` does not work on <slot> because slots are abstract outlets " +
          "and can possibly expand into multiple elements. " +
          "Use the key on a wrapping element instead.",
          getRawBindingAttr(el, 'key')
        );
      }
    }
  }

  function processComponent (el) {
    var binding;
    if ((binding = getBindingAttr(el, 'is'))) {
      el.component = binding;
    }
    if (getAndRemoveAttr(el, 'inline-template') != null) {
      el.inlineTemplate = true;
    }
  }

  function processAttrs (el) {
    var list = el.attrsList;
    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
    for (i = 0, l = list.length; i < l; i++) {
      name = rawName = list[i].name;
      value = list[i].value;
      if (dirRE.test(name)) {
        // mark element as dynamic
        el.hasBindings = true;
        // modifiers
        modifiers = parseModifiers(name.replace(dirRE, ''));
        // support .foo shorthand syntax for the .prop modifier
        if (modifiers) {
          name = name.replace(modifierRE, '');
        }
        if (bindRE.test(name)) { // v-bind
          name = name.replace(bindRE, '');
          value = parseFilters(value);
          isDynamic = dynamicArgRE.test(name);
          if (isDynamic) {
            name = name.slice(1, -1);
          }
          if (
            value.trim().length === 0
          ) {
            warn$2(
              ("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"")
            );
          }
          if (modifiers) {
            if (modifiers.prop && !isDynamic) {
              name = camelize(name);
              if (name === 'innerHtml') { name = 'innerHTML'; }
            }
            if (modifiers.camel && !isDynamic) {
              name = camelize(name);
            }
            if (modifiers.sync) {
              syncGen = genAssignmentCode(value, "$event");
              if (!isDynamic) {
                addHandler(
                  el,
                  ("update:" + (camelize(name))),
                  syncGen,
                  null,
                  false,
                  warn$2,
                  list[i]
                );
                if (hyphenate(name) !== camelize(name)) {
                  addHandler(
                    el,
                    ("update:" + (hyphenate(name))),
                    syncGen,
                    null,
                    false,
                    warn$2,
                    list[i]
                  );
                }
              } else {
                // handler w/ dynamic event name
                addHandler(
                  el,
                  ("\"update:\"+(" + name + ")"),
                  syncGen,
                  null,
                  false,
                  warn$2,
                  list[i],
                  true // dynamic
                );
              }
            }
          }
          if ((modifiers && modifiers.prop) || (
            !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
          )) {
            addProp(el, name, value, list[i], isDynamic);
          } else {
            addAttr(el, name, value, list[i], isDynamic);
          }
        } else if (onRE.test(name)) { // v-on
          name = name.replace(onRE, '');
          isDynamic = dynamicArgRE.test(name);
          if (isDynamic) {
            name = name.slice(1, -1);
          }
          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
        } else { // normal directives
          name = name.replace(dirRE, '');
          // parse arg
          var argMatch = name.match(argRE);
          var arg = argMatch && argMatch[1];
          isDynamic = false;
          if (arg) {
            name = name.slice(0, -(arg.length + 1));
            if (dynamicArgRE.test(arg)) {
              arg = arg.slice(1, -1);
              isDynamic = true;
            }
          }
          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
          if (name === 'model') {
            checkForAliasModel(el, value);
          }
        }
      } else {
        // literal attribute
        {
          var res = parseText(value, delimiters);
          if (res) {
            warn$2(
              name + "=\"" + value + "\": " +
              'Interpolation inside attributes has been removed. ' +
              'Use v-bind or the colon shorthand instead. For example, ' +
              'instead of <div id="{{ val }}">, use <div :id="val">.',
              list[i]
            );
          }
        }
        addAttr(el, name, JSON.stringify(value), list[i]);
        // #6887 firefox doesn't update muted state if set via attribute
        // even immediately after element creation
        if (!el.component &&
            name === 'muted' &&
            platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, 'true', list[i]);
        }
      }
    }
  }

  function checkInFor (el) {
    var parent = el;
    while (parent) {
      if (parent.for !== undefined) {
        return true
      }
      parent = parent.parent;
    }
    return false
  }

  function parseModifiers (name) {
    var match = name.match(modifierRE);
    if (match) {
      var ret = {};
      match.forEach(function (m) { ret[m.slice(1)] = true; });
      return ret
    }
  }

  function makeAttrsMap (attrs) {
    var map = {};
    for (var i = 0, l = attrs.length; i < l; i++) {
      if (
        map[attrs[i].name] && !isIE && !isEdge
      ) {
        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
      }
      map[attrs[i].name] = attrs[i].value;
    }
    return map
  }

  // for script (e.g. type="x/template") or style, do not decode content
  function isTextTag (el) {
    return el.tag === 'script' || el.tag === 'style'
  }

  function isForbiddenTag (el) {
    return (
      el.tag === 'style' ||
      (el.tag === 'script' && (
        !el.attrsMap.type ||
        el.attrsMap.type === 'text/javascript'
      ))
    )
  }

  var ieNSBug = /^xmlns:NS\d+/;
  var ieNSPrefix = /^NS\d+:/;

  /* istanbul ignore next */
  function guardIESVGBug (attrs) {
    var res = [];
    for (var i = 0; i < attrs.length; i++) {
      var attr = attrs[i];
      if (!ieNSBug.test(attr.name)) {
        attr.name = attr.name.replace(ieNSPrefix, '');
        res.push(attr);
      }
    }
    return res
  }

  function checkForAliasModel (el, value) {
    var _el = el;
    while (_el) {
      if (_el.for && _el.alias === value) {
        warn$2(
          "<" + (el.tag) + " v-model=\"" + value + "\">: " +
          "You are binding v-model directly to a v-for iteration alias. " +
          "This will not be able to modify the v-for source array because " +
          "writing to the alias is like modifying a function local variable. " +
          "Consider using an array of objects and use v-model on an object property instead.",
          el.rawAttrsMap['v-model']
        );
      }
      _el = _el.parent;
    }
  }

  /*  */

  function preTransformNode (el, options) {
    if (el.tag === 'input') {
      var map = el.attrsMap;
      if (!map['v-model']) {
        return
      }

      var typeBinding;
      if (map[':type'] || map['v-bind:type']) {
        typeBinding = getBindingAttr(el, 'type');
      }
      if (!map.type && !typeBinding && map['v-bind']) {
        typeBinding = "(" + (map['v-bind']) + ").type";
      }

      if (typeBinding) {
        var ifCondition = getAndRemoveAttr(el, 'v-if', true);
        var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
        // 1. checkbox
        var branch0 = cloneASTElement(el);
        // process for on the main node
        processFor(branch0);
        addRawAttr(branch0, 'type', 'checkbox');
        processElement(branch0, options);
        branch0.processed = true; // prevent it from double-processed
        branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
        addIfCondition(branch0, {
          exp: branch0.if,
          block: branch0
        });
        // 2. add radio else-if condition
        var branch1 = cloneASTElement(el);
        getAndRemoveAttr(branch1, 'v-for', true);
        addRawAttr(branch1, 'type', 'radio');
        processElement(branch1, options);
        addIfCondition(branch0, {
          exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
          block: branch1
        });
        // 3. other
        var branch2 = cloneASTElement(el);
        getAndRemoveAttr(branch2, 'v-for', true);
        addRawAttr(branch2, ':type', typeBinding);
        processElement(branch2, options);
        addIfCondition(branch0, {
          exp: ifCondition,
          block: branch2
        });

        if (hasElse) {
          branch0.else = true;
        } else if (elseIfCondition) {
          branch0.elseif = elseIfCondition;
        }

        return branch0
      }
    }
  }

  function cloneASTElement (el) {
    return createASTElement(el.tag, el.attrsList.slice(), el.parent)
  }

  var model$1 = {
    preTransformNode: preTransformNode
  };

  var modules$1 = [
    klass$1,
    style$1,
    model$1
  ];

  /*  */

  function text (el, dir) {
    if (dir.value) {
      addProp(el, 'textContent', ("_s(" + (dir.value) + ")"), dir);
    }
  }

  /*  */

  function html (el, dir) {
    if (dir.value) {
      addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"), dir);
    }
  }

  var directives$1 = {
    model: model,
    text: text,
    html: html
  };

  /*  */

  var baseOptions = {
    expectHTML: true,
    modules: modules$1,
    directives: directives$1,
    isPreTag: isPreTag,
    isUnaryTag: isUnaryTag,
    mustUseProp: mustUseProp,
    canBeLeftOpenTag: canBeLeftOpenTag,
    isReservedTag: isReservedTag,
    getTagNamespace: getTagNamespace,
    staticKeys: genStaticKeys(modules$1)
  };

  /*  */

  var isStaticKey;
  var isPlatformReservedTag;

  var genStaticKeysCached = cached(genStaticKeys$1);

  /**
   * Goal of the optimizer: walk the generated template AST tree
   * and detect sub-trees that are purely static, i.e. parts of
   * the DOM that never needs to change.
   *
   * Once we detect these sub-trees, we can:
   *
   * 1. Hoist them into constants, so that we no longer need to
   *    create fresh nodes for them on each re-render;
   * 2. Completely skip them in the patching process.
   */
  function optimize (root, options) {
    if (!root) { return }
    isStaticKey = genStaticKeysCached(options.staticKeys || '');
    isPlatformReservedTag = options.isReservedTag || no;
    // first pass: mark all non-static nodes.
    markStatic$1(root);
    // second pass: mark static roots.
    markStaticRoots(root, false);
  }

  function genStaticKeys$1 (keys) {
    return makeMap(
      'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
      (keys ? ',' + keys : '')
    )
  }

  function markStatic$1 (node) {
    node.static = isStatic(node);
    if (node.type === 1) {
      // do not make component slot content static. this avoids
      // 1. components not able to mutate slot nodes
      // 2. static slot content fails for hot-reloading
      if (
        !isPlatformReservedTag(node.tag) &&
        node.tag !== 'slot' &&
        node.attrsMap['inline-template'] == null
      ) {
        return
      }
      for (var i = 0, l = node.children.length; i < l; i++) {
        var child = node.children[i];
        markStatic$1(child);
        if (!child.static) {
          node.static = false;
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          var block = node.ifConditions[i$1].block;
          markStatic$1(block);
          if (!block.static) {
            node.static = false;
          }
        }
      }
    }
  }

  function markStaticRoots (node, isInFor) {
    if (node.type === 1) {
      if (node.static || node.once) {
        node.staticInFor = isInFor;
      }
      // For a node to qualify as a static root, it should have children that
      // are not just static text. Otherwise the cost of hoisting out will
      // outweigh the benefits and it's better off to just always render it fresh.
      if (node.static && node.children.length && !(
        node.children.length === 1 &&
        node.children[0].type === 3
      )) {
        node.staticRoot = true;
        return
      } else {
        node.staticRoot = false;
      }
      if (node.children) {
        for (var i = 0, l = node.children.length; i < l; i++) {
          markStaticRoots(node.children[i], isInFor || !!node.for);
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          markStaticRoots(node.ifConditions[i$1].block, isInFor);
        }
      }
    }
  }

  function isStatic (node) {
    if (node.type === 2) { // expression
      return false
    }
    if (node.type === 3) { // text
      return true
    }
    return !!(node.pre || (
      !node.hasBindings && // no dynamic bindings
      !node.if && !node.for && // not v-if or v-for or v-else
      !isBuiltInTag(node.tag) && // not a built-in
      isPlatformReservedTag(node.tag) && // not a component
      !isDirectChildOfTemplateFor(node) &&
      Object.keys(node).every(isStaticKey)
    ))
  }

  function isDirectChildOfTemplateFor (node) {
    while (node.parent) {
      node = node.parent;
      if (node.tag !== 'template') {
        return false
      }
      if (node.for) {
        return true
      }
    }
    return false
  }

  /*  */

  var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*(?:[\w$]+)?\s*\(/;
  var fnInvokeRE = /\([^)]*?\);*$/;
  var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

  // KeyboardEvent.keyCode aliases
  var keyCodes = {
    esc: 27,
    tab: 9,
    enter: 13,
    space: 32,
    up: 38,
    left: 37,
    right: 39,
    down: 40,
    'delete': [8, 46]
  };

  // KeyboardEvent.key aliases
  var keyNames = {
    // #7880: IE11 and Edge use `Esc` for Escape key name.
    esc: ['Esc', 'Escape'],
    tab: 'Tab',
    enter: 'Enter',
    // #9112: IE11 uses `Spacebar` for Space key name.
    space: [' ', 'Spacebar'],
    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
    up: ['Up', 'ArrowUp'],
    left: ['Left', 'ArrowLeft'],
    right: ['Right', 'ArrowRight'],
    down: ['Down', 'ArrowDown'],
    // #9112: IE11 uses `Del` for Delete key name.
    'delete': ['Backspace', 'Delete', 'Del']
  };

  // #4868: modifiers that prevent the execution of the listener
  // need to explicitly return null so that we can determine whether to remove
  // the listener for .once
  var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

  var modifierCode = {
    stop: '$event.stopPropagation();',
    prevent: '$event.preventDefault();',
    self: genGuard("$event.target !== $event.currentTarget"),
    ctrl: genGuard("!$event.ctrlKey"),
    shift: genGuard("!$event.shiftKey"),
    alt: genGuard("!$event.altKey"),
    meta: genGuard("!$event.metaKey"),
    left: genGuard("'button' in $event && $event.button !== 0"),
    middle: genGuard("'button' in $event && $event.button !== 1"),
    right: genGuard("'button' in $event && $event.button !== 2")
  };

  function genHandlers (
    events,
    isNative
  ) {
    var prefix = isNative ? 'nativeOn:' : 'on:';
    var staticHandlers = "";
    var dynamicHandlers = "";
    for (var name in events) {
      var handlerCode = genHandler(events[name]);
      if (events[name] && events[name].dynamic) {
        dynamicHandlers += name + "," + handlerCode + ",";
      } else {
        staticHandlers += "\"" + name + "\":" + handlerCode + ",";
      }
    }
    staticHandlers = "{" + (staticHandlers.slice(0, -1)) + "}";
    if (dynamicHandlers) {
      return prefix + "_d(" + staticHandlers + ",[" + (dynamicHandlers.slice(0, -1)) + "])"
    } else {
      return prefix + staticHandlers
    }
  }

  function genHandler (handler) {
    if (!handler) {
      return 'function(){}'
    }

    if (Array.isArray(handler)) {
      return ("[" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + "]")
    }

    var isMethodPath = simplePathRE.test(handler.value);
    var isFunctionExpression = fnExpRE.test(handler.value);
    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

    if (!handler.modifiers) {
      if (isMethodPath || isFunctionExpression) {
        return handler.value
      }
      return ("function($event){" + (isFunctionInvocation ? ("return " + (handler.value)) : handler.value) + "}") // inline statement
    } else {
      var code = '';
      var genModifierCode = '';
      var keys = [];
      for (var key in handler.modifiers) {
        if (modifierCode[key]) {
          genModifierCode += modifierCode[key];
          // left/right
          if (keyCodes[key]) {
            keys.push(key);
          }
        } else if (key === 'exact') {
          var modifiers = (handler.modifiers);
          genModifierCode += genGuard(
            ['ctrl', 'shift', 'alt', 'meta']
              .filter(function (keyModifier) { return !modifiers[keyModifier]; })
              .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
              .join('||')
          );
        } else {
          keys.push(key);
        }
      }
      if (keys.length) {
        code += genKeyFilter(keys);
      }
      // Make sure modifiers like prevent and stop get executed after key filtering
      if (genModifierCode) {
        code += genModifierCode;
      }
      var handlerCode = isMethodPath
        ? ("return " + (handler.value) + "($event)")
        : isFunctionExpression
          ? ("return (" + (handler.value) + ")($event)")
          : isFunctionInvocation
            ? ("return " + (handler.value))
            : handler.value;
      return ("function($event){" + code + handlerCode + "}")
    }
  }

  function genKeyFilter (keys) {
    return (
      // make sure the key filters only apply to KeyboardEvents
      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
      // key events that do not have keyCode property...
      "if(!$event.type.indexOf('key')&&" +
      (keys.map(genFilterCode).join('&&')) + ")return null;"
    )
  }

  function genFilterCode (key) {
    var keyVal = parseInt(key, 10);
    if (keyVal) {
      return ("$event.keyCode!==" + keyVal)
    }
    var keyCode = keyCodes[key];
    var keyName = keyNames[key];
    return (
      "_k($event.keyCode," +
      (JSON.stringify(key)) + "," +
      (JSON.stringify(keyCode)) + "," +
      "$event.key," +
      "" + (JSON.stringify(keyName)) +
      ")"
    )
  }

  /*  */

  function on (el, dir) {
    if (dir.modifiers) {
      warn("v-on without argument does not support modifiers.");
    }
    el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
  }

  /*  */

  function bind$1 (el, dir) {
    el.wrapData = function (code) {
      return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
    };
  }

  /*  */

  var baseDirectives = {
    on: on,
    bind: bind$1,
    cloak: noop
  };

  /*  */





  var CodegenState = function CodegenState (options) {
    this.options = options;
    this.warn = options.warn || baseWarn;
    this.transforms = pluckModuleFunction(options.modules, 'transformCode');
    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
    this.directives = extend(extend({}, baseDirectives), options.directives);
    var isReservedTag = options.isReservedTag || no;
    this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };
    this.onceId = 0;
    this.staticRenderFns = [];
    this.pre = false;
  };



  function generate (
    ast,
    options
  ) {
    var state = new CodegenState(options);
    var code = ast ? genElement(ast, state) : '_c("div")';
    return {
      render: ("with(this){return " + code + "}"),
      staticRenderFns: state.staticRenderFns
    }
  }

  function genElement (el, state) {
    if (el.parent) {
      el.pre = el.pre || el.parent.pre;
    }

    if (el.staticRoot && !el.staticProcessed) {
      return genStatic(el, state)
    } else if (el.once && !el.onceProcessed) {
      return genOnce(el, state)
    } else if (el.for && !el.forProcessed) {
      return genFor(el, state)
    } else if (el.if && !el.ifProcessed) {
      return genIf(el, state)
    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
      return genChildren(el, state) || 'void 0'
    } else if (el.tag === 'slot') {
      return genSlot(el, state)
    } else {
      // component or element
      var code;
      if (el.component) {
        code = genComponent(el.component, el, state);
      } else {
        var data;
        if (!el.plain || (el.pre && state.maybeComponent(el))) {
          data = genData$2(el, state);
        }

        var children = el.inlineTemplate ? null : genChildren(el, state, true);
        code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
      }
      // module transforms
      for (var i = 0; i < state.transforms.length; i++) {
        code = state.transforms[i](el, code);
      }
      return code
    }
  }

  // hoist static sub-trees out
  function genStatic (el, state) {
    el.staticProcessed = true;
    // Some elements (templates) need to behave differently inside of a v-pre
    // node.  All pre nodes are static roots, so we can use this as a location to
    // wrap a state change and reset it upon exiting the pre node.
    var originalPreState = state.pre;
    if (el.pre) {
      state.pre = el.pre;
    }
    state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
    state.pre = originalPreState;
    return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
  }

  // v-once
  function genOnce (el, state) {
    el.onceProcessed = true;
    if (el.if && !el.ifProcessed) {
      return genIf(el, state)
    } else if (el.staticInFor) {
      var key = '';
      var parent = el.parent;
      while (parent) {
        if (parent.for) {
          key = parent.key;
          break
        }
        parent = parent.parent;
      }
      if (!key) {
        state.warn(
          "v-once can only be used inside v-for that is keyed. ",
          el.rawAttrsMap['v-once']
        );
        return genElement(el, state)
      }
      return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
    } else {
      return genStatic(el, state)
    }
  }

  function genIf (
    el,
    state,
    altGen,
    altEmpty
  ) {
    el.ifProcessed = true; // avoid recursion
    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
  }

  function genIfConditions (
    conditions,
    state,
    altGen,
    altEmpty
  ) {
    if (!conditions.length) {
      return altEmpty || '_e()'
    }

    var condition = conditions.shift();
    if (condition.exp) {
      return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
    } else {
      return ("" + (genTernaryExp(condition.block)))
    }

    // v-if with v-once should generate code like (a)?_m(0):_m(1)
    function genTernaryExp (el) {
      return altGen
        ? altGen(el, state)
        : el.once
          ? genOnce(el, state)
          : genElement(el, state)
    }
  }

  function genFor (
    el,
    state,
    altGen,
    altHelper
  ) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
    var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

    if (state.maybeComponent(el) &&
      el.tag !== 'slot' &&
      el.tag !== 'template' &&
      !el.key
    ) {
      state.warn(
        "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
        "v-for should have explicit keys. " +
        "See https://vuejs.org/guide/list.html#key for more info.",
        el.rawAttrsMap['v-for'],
        true /* tip */
      );
    }

    el.forProcessed = true; // avoid recursion
    return (altHelper || '_l') + "((" + exp + ")," +
      "function(" + alias + iterator1 + iterator2 + "){" +
        "return " + ((altGen || genElement)(el, state)) +
      '})'
  }

  function genData$2 (el, state) {
    var data = '{';

    // directives first.
    // directives may mutate the el's other properties before they are generated.
    var dirs = genDirectives(el, state);
    if (dirs) { data += dirs + ','; }

    // key
    if (el.key) {
      data += "key:" + (el.key) + ",";
    }
    // ref
    if (el.ref) {
      data += "ref:" + (el.ref) + ",";
    }
    if (el.refInFor) {
      data += "refInFor:true,";
    }
    // pre
    if (el.pre) {
      data += "pre:true,";
    }
    // record original tag name for components using "is" attribute
    if (el.component) {
      data += "tag:\"" + (el.tag) + "\",";
    }
    // module data generation functions
    for (var i = 0; i < state.dataGenFns.length; i++) {
      data += state.dataGenFns[i](el);
    }
    // attributes
    if (el.attrs) {
      data += "attrs:" + (genProps(el.attrs)) + ",";
    }
    // DOM props
    if (el.props) {
      data += "domProps:" + (genProps(el.props)) + ",";
    }
    // event handlers
    if (el.events) {
      data += (genHandlers(el.events, false)) + ",";
    }
    if (el.nativeEvents) {
      data += (genHandlers(el.nativeEvents, true)) + ",";
    }
    // slot target
    // only for non-scoped slots
    if (el.slotTarget && !el.slotScope) {
      data += "slot:" + (el.slotTarget) + ",";
    }
    // scoped slots
    if (el.scopedSlots) {
      data += (genScopedSlots(el, el.scopedSlots, state)) + ",";
    }
    // component v-model
    if (el.model) {
      data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
    }
    // inline-template
    if (el.inlineTemplate) {
      var inlineTemplate = genInlineTemplate(el, state);
      if (inlineTemplate) {
        data += inlineTemplate + ",";
      }
    }
    data = data.replace(/,$/, '') + '}';
    // v-bind dynamic argument wrap
    // v-bind with dynamic arguments must be applied using the same v-bind object
    // merge helper so that class/style/mustUseProp attrs are handled correctly.
    if (el.dynamicAttrs) {
      data = "_b(" + data + ",\"" + (el.tag) + "\"," + (genProps(el.dynamicAttrs)) + ")";
    }
    // v-bind data wrap
    if (el.wrapData) {
      data = el.wrapData(data);
    }
    // v-on data wrap
    if (el.wrapListeners) {
      data = el.wrapListeners(data);
    }
    return data
  }

  function genDirectives (el, state) {
    var dirs = el.directives;
    if (!dirs) { return }
    var res = 'directives:[';
    var hasRuntime = false;
    var i, l, dir, needRuntime;
    for (i = 0, l = dirs.length; i < l; i++) {
      dir = dirs[i];
      needRuntime = true;
      var gen = state.directives[dir.name];
      if (gen) {
        // compile-time directive that manipulates AST.
        // returns true if it also needs a runtime counterpart.
        needRuntime = !!gen(el, dir, state.warn);
      }
      if (needRuntime) {
        hasRuntime = true;
        res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:" + (dir.isDynamicArg ? dir.arg : ("\"" + (dir.arg) + "\""))) : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
      }
    }
    if (hasRuntime) {
      return res.slice(0, -1) + ']'
    }
  }

  function genInlineTemplate (el, state) {
    var ast = el.children[0];
    if (el.children.length !== 1 || ast.type !== 1) {
      state.warn(
        'Inline-template components must have exactly one child element.',
        { start: el.start }
      );
    }
    if (ast && ast.type === 1) {
      var inlineRenderFns = generate(ast, state.options);
      return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
    }
  }

  function genScopedSlots (
    el,
    slots,
    state
  ) {
    // by default scoped slots are considered "stable", this allows child
    // components with only scoped slots to skip forced updates from parent.
    // but in some cases we have to bail-out of this optimization
    // for example if the slot contains dynamic names, has v-if or v-for on them...
    var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
      var slot = slots[key];
      return (
        slot.slotTargetDynamic ||
        slot.if ||
        slot.for ||
        containsSlotChild(slot) // is passing down slot from parent which may be dynamic
      )
    });

    // #9534: if a component with scoped slots is inside a conditional branch,
    // it's possible for the same component to be reused but with different
    // compiled slot content. To avoid that, we generate a unique key based on
    // the generated code of all the slot contents.
    var needsKey = !!el.if;

    // OR when it is inside another scoped slot or v-for (the reactivity may be
    // disconnected due to the intermediate scope variable)
    // #9438, #9506
    // TODO: this can be further optimized by properly analyzing in-scope bindings
    // and skip force updating ones that do not actually use scope variables.
    if (!needsForceUpdate) {
      var parent = el.parent;
      while (parent) {
        if (
          (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||
          parent.for
        ) {
          needsForceUpdate = true;
          break
        }
        if (parent.if) {
          needsKey = true;
        }
        parent = parent.parent;
      }
    }

    var generatedSlots = Object.keys(slots)
      .map(function (key) { return genScopedSlot(slots[key], state); })
      .join(',');

    return ("scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? (",null,false," + (hash(generatedSlots))) : "") + ")")
  }

  function hash(str) {
    var hash = 5381;
    var i = str.length;
    while(i) {
      hash = (hash * 33) ^ str.charCodeAt(--i);
    }
    return hash >>> 0
  }

  function containsSlotChild (el) {
    if (el.type === 1) {
      if (el.tag === 'slot') {
        return true
      }
      return el.children.some(containsSlotChild)
    }
    return false
  }

  function genScopedSlot (
    el,
    state
  ) {
    var isLegacySyntax = el.attrsMap['slot-scope'];
    if (el.if && !el.ifProcessed && !isLegacySyntax) {
      return genIf(el, state, genScopedSlot, "null")
    }
    if (el.for && !el.forProcessed) {
      return genFor(el, state, genScopedSlot)
    }
    var slotScope = el.slotScope === emptySlotScopeToken
      ? ""
      : String(el.slotScope);
    var fn = "function(" + slotScope + "){" +
      "return " + (el.tag === 'template'
        ? el.if && isLegacySyntax
          ? ("(" + (el.if) + ")?" + (genChildren(el, state) || 'undefined') + ":undefined")
          : genChildren(el, state) || 'undefined'
        : genElement(el, state)) + "}";
    // reverse proxy v-slot without scope on this.$slots
    var reverseProxy = slotScope ? "" : ",proxy:true";
    return ("{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}")
  }

  function genChildren (
    el,
    state,
    checkSkip,
    altGenElement,
    altGenNode
  ) {
    var children = el.children;
    if (children.length) {
      var el$1 = children[0];
      // optimize single v-for
      if (children.length === 1 &&
        el$1.for &&
        el$1.tag !== 'template' &&
        el$1.tag !== 'slot'
      ) {
        var normalizationType = checkSkip
          ? state.maybeComponent(el$1) ? ",1" : ",0"
          : "";
        return ("" + ((altGenElement || genElement)(el$1, state)) + normalizationType)
      }
      var normalizationType$1 = checkSkip
        ? getNormalizationType(children, state.maybeComponent)
        : 0;
      var gen = altGenNode || genNode;
      return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType$1 ? ("," + normalizationType$1) : ''))
    }
  }

  // determine the normalization needed for the children array.
  // 0: no normalization needed
  // 1: simple normalization needed (possible 1-level deep nested array)
  // 2: full normalization needed
  function getNormalizationType (
    children,
    maybeComponent
  ) {
    var res = 0;
    for (var i = 0; i < children.length; i++) {
      var el = children[i];
      if (el.type !== 1) {
        continue
      }
      if (needsNormalization(el) ||
          (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
        res = 2;
        break
      }
      if (maybeComponent(el) ||
          (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
        res = 1;
      }
    }
    return res
  }

  function needsNormalization (el) {
    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
  }

  function genNode (node, state) {
    if (node.type === 1) {
      return genElement(node, state)
    } else if (node.type === 3 && node.isComment) {
      return genComment(node)
    } else {
      return genText(node)
    }
  }

  function genText (text) {
    return ("_v(" + (text.type === 2
      ? text.expression // no need for () because already wrapped in _s()
      : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
  }

  function genComment (comment) {
    return ("_e(" + (JSON.stringify(comment.text)) + ")")
  }

  function genSlot (el, state) {
    var slotName = el.slotName || '"default"';
    var children = genChildren(el, state);
    var res = "_t(" + slotName + (children ? ("," + children) : '');
    var attrs = el.attrs || el.dynamicAttrs
      ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({
          // slot props are camelized
          name: camelize(attr.name),
          value: attr.value,
          dynamic: attr.dynamic
        }); }))
      : null;
    var bind$$1 = el.attrsMap['v-bind'];
    if ((attrs || bind$$1) && !children) {
      res += ",null";
    }
    if (attrs) {
      res += "," + attrs;
    }
    if (bind$$1) {
      res += (attrs ? '' : ',null') + "," + bind$$1;
    }
    return res + ')'
  }

  // componentName is el.component, take it as argument to shun flow's pessimistic refinement
  function genComponent (
    componentName,
    el,
    state
  ) {
    var children = el.inlineTemplate ? null : genChildren(el, state, true);
    return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
  }

  function genProps (props) {
    var staticProps = "";
    var dynamicProps = "";
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      var value = transformSpecialNewlines(prop.value);
      if (prop.dynamic) {
        dynamicProps += (prop.name) + "," + value + ",";
      } else {
        staticProps += "\"" + (prop.name) + "\":" + value + ",";
      }
    }
    staticProps = "{" + (staticProps.slice(0, -1)) + "}";
    if (dynamicProps) {
      return ("_d(" + staticProps + ",[" + (dynamicProps.slice(0, -1)) + "])")
    } else {
      return staticProps
    }
  }

  // #3895, #4268
  function transformSpecialNewlines (text) {
    return text
      .replace(/\u2028/g, '\\u2028')
      .replace(/\u2029/g, '\\u2029')
  }

  /*  */



  // these keywords should not appear inside expressions, but operators like
  // typeof, instanceof and in are allowed
  var prohibitedKeywordRE = new RegExp('\\b' + (
    'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
    'super,throw,while,yield,delete,export,import,return,switch,default,' +
    'extends,finally,continue,debugger,function,arguments'
  ).split(',').join('\\b|\\b') + '\\b');

  // these unary operators should not be used as property/method names
  var unaryOperatorsRE = new RegExp('\\b' + (
    'delete,typeof,void'
  ).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

  // strip strings in expressions
  var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

  // detect problematic expressions in a template
  function detectErrors (ast, warn) {
    if (ast) {
      checkNode(ast, warn);
    }
  }

  function checkNode (node, warn) {
    if (node.type === 1) {
      for (var name in node.attrsMap) {
        if (dirRE.test(name)) {
          var value = node.attrsMap[name];
          if (value) {
            var range = node.rawAttrsMap[name];
            if (name === 'v-for') {
              checkFor(node, ("v-for=\"" + value + "\""), warn, range);
            } else if (onRE.test(name)) {
              checkEvent(value, (name + "=\"" + value + "\""), warn, range);
            } else {
              checkExpression(value, (name + "=\"" + value + "\""), warn, range);
            }
          }
        }
      }
      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          checkNode(node.children[i], warn);
        }
      }
    } else if (node.type === 2) {
      checkExpression(node.expression, node.text, warn, node);
    }
  }

  function checkEvent (exp, text, warn, range) {
    var stipped = exp.replace(stripStringRE, '');
    var keywordMatch = stipped.match(unaryOperatorsRE);
    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
      warn(
        "avoid using JavaScript unary operator as property name: " +
        "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim()),
        range
      );
    }
    checkExpression(exp, text, warn, range);
  }

  function checkFor (node, text, warn, range) {
    checkExpression(node.for || '', text, warn, range);
    checkIdentifier(node.alias, 'v-for alias', text, warn, range);
    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
  }

  function checkIdentifier (
    ident,
    type,
    text,
    warn,
    range
  ) {
    if (typeof ident === 'string') {
      try {
        new Function(("var " + ident + "=_"));
      } catch (e) {
        warn(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())), range);
      }
    }
  }

  function checkExpression (exp, text, warn, range) {
    try {
      new Function(("return " + exp));
    } catch (e) {
      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
      if (keywordMatch) {
        warn(
          "avoid using JavaScript keyword as property name: " +
          "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim()),
          range
        );
      } else {
        warn(
          "invalid expression: " + (e.message) + " in\n\n" +
          "    " + exp + "\n\n" +
          "  Raw expression: " + (text.trim()) + "\n",
          range
        );
      }
    }
  }

  /*  */

  var range = 2;

  function generateCodeFrame (
    source,
    start,
    end
  ) {
    if ( start === void 0 ) start = 0;
    if ( end === void 0 ) end = source.length;

    var lines = source.split(/\r?\n/);
    var count = 0;
    var res = [];
    for (var i = 0; i < lines.length; i++) {
      count += lines[i].length + 1;
      if (count >= start) {
        for (var j = i - range; j <= i + range || end > count; j++) {
          if (j < 0 || j >= lines.length) { continue }
          res.push(("" + (j + 1) + (repeat$1(" ", 3 - String(j + 1).length)) + "|  " + (lines[j])));
          var lineLength = lines[j].length;
          if (j === i) {
            // push underline
            var pad = start - (count - lineLength) + 1;
            var length = end > count ? lineLength - pad : end - start;
            res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
          } else if (j > i) {
            if (end > count) {
              var length$1 = Math.min(end - count, lineLength);
              res.push("   |  " + repeat$1("^", length$1));
            }
            count += lineLength + 1;
          }
        }
        break
      }
    }
    return res.join('\n')
  }

  function repeat$1 (str, n) {
    var result = '';
    if (n > 0) {
      while (true) { // eslint-disable-line
        if (n & 1) { result += str; }
        n >>>= 1;
        if (n <= 0) { break }
        str += str;
      }
    }
    return result
  }

  /*  */



  function createFunction (code, errors) {
    try {
      return new Function(code)
    } catch (err) {
      errors.push({ err: err, code: code });
      return noop
    }
  }

  function createCompileToFunctionFn (compile) {
    var cache = Object.create(null);

    return function compileToFunctions (
      template,
      options,
      vm
    ) {
      options = extend({}, options);
      var warn$$1 = options.warn || warn;
      delete options.warn;

      /* istanbul ignore if */
      {
        // detect possible CSP restriction
        try {
          new Function('return 1');
        } catch (e) {
          if (e.toString().match(/unsafe-eval|CSP/)) {
            warn$$1(
              'It seems you are using the standalone build of Vue.js in an ' +
              'environment with Content Security Policy that prohibits unsafe-eval. ' +
              'The template compiler cannot work in this environment. Consider ' +
              'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
              'templates into render functions.'
            );
          }
        }
      }

      // check cache
      var key = options.delimiters
        ? String(options.delimiters) + template
        : template;
      if (cache[key]) {
        return cache[key]
      }

      // compile
      var compiled = compile(template, options);

      // check compilation errors/tips
      {
        if (compiled.errors && compiled.errors.length) {
          if (options.outputSourceRange) {
            compiled.errors.forEach(function (e) {
              warn$$1(
                "Error compiling template:\n\n" + (e.msg) + "\n\n" +
                generateCodeFrame(template, e.start, e.end),
                vm
              );
            });
          } else {
            warn$$1(
              "Error compiling template:\n\n" + template + "\n\n" +
              compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
              vm
            );
          }
        }
        if (compiled.tips && compiled.tips.length) {
          if (options.outputSourceRange) {
            compiled.tips.forEach(function (e) { return tip(e.msg, vm); });
          } else {
            compiled.tips.forEach(function (msg) { return tip(msg, vm); });
          }
        }
      }

      // turn code into functions
      var res = {};
      var fnGenErrors = [];
      res.render = createFunction(compiled.render, fnGenErrors);
      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
        return createFunction(code, fnGenErrors)
      });

      // check function generation errors.
      // this should only happen if there is a bug in the compiler itself.
      // mostly for codegen development use
      /* istanbul ignore if */
      {
        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
          warn$$1(
            "Failed to generate render function:\n\n" +
            fnGenErrors.map(function (ref) {
              var err = ref.err;
              var code = ref.code;

              return ((err.toString()) + " in\n\n" + code + "\n");
          }).join('\n'),
            vm
          );
        }
      }

      return (cache[key] = res)
    }
  }

  /*  */

  function createCompilerCreator (baseCompile) {
    return function createCompiler (baseOptions) {
      function compile (
        template,
        options
      ) {
        var finalOptions = Object.create(baseOptions);
        var errors = [];
        var tips = [];

        var warn = function (msg, range, tip) {
          (tip ? tips : errors).push(msg);
        };

        if (options) {
          if (options.outputSourceRange) {
            // $flow-disable-line
            var leadingSpaceLength = template.match(/^\s*/)[0].length;

            warn = function (msg, range, tip) {
              var data = { msg: msg };
              if (range) {
                if (range.start != null) {
                  data.start = range.start + leadingSpaceLength;
                }
                if (range.end != null) {
                  data.end = range.end + leadingSpaceLength;
                }
              }
              (tip ? tips : errors).push(data);
            };
          }
          // merge custom modules
          if (options.modules) {
            finalOptions.modules =
              (baseOptions.modules || []).concat(options.modules);
          }
          // merge custom directives
          if (options.directives) {
            finalOptions.directives = extend(
              Object.create(baseOptions.directives || null),
              options.directives
            );
          }
          // copy other options
          for (var key in options) {
            if (key !== 'modules' && key !== 'directives') {
              finalOptions[key] = options[key];
            }
          }
        }

        finalOptions.warn = warn;

        var compiled = baseCompile(template.trim(), finalOptions);
        {
          detectErrors(compiled.ast, warn);
        }
        compiled.errors = errors;
        compiled.tips = tips;
        return compiled
      }

      return {
        compile: compile,
        compileToFunctions: createCompileToFunctionFn(compile)
      }
    }
  }

  /*  */

  // `createCompilerCreator` allows creating compilers that use alternative
  // parser/optimizer/codegen, e.g the SSR optimizing compiler.
  // Here we just export a default compiler using the default parts.
  var createCompiler = createCompilerCreator(function baseCompile (
    template,
    options
  ) {
    var ast = parse(template.trim(), options);
    if (options.optimize !== false) {
      optimize(ast, options);
    }
    var code = generate(ast, options);
    return {
      ast: ast,
      render: code.render,
      staticRenderFns: code.staticRenderFns
    }
  });

  /*  */

  var ref$1 = createCompiler(baseOptions);
  var compile = ref$1.compile;
  var compileToFunctions = ref$1.compileToFunctions;

  /*  */

  // check whether current browser encodes a char inside attribute values
  var div;
  function getShouldDecode (href) {
    div = div || document.createElement('div');
    div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
    return div.innerHTML.indexOf('&#10;') > 0
  }

  // #3663: IE encodes newlines inside attribute values while other browsers don't
  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
  // #6828: chrome encodes content in a[href]
  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

  /*  */

  var idToTemplate = cached(function (id) {
    var el = query(id);
    return el && el.innerHTML
  });

  var mount = Vue.prototype.$mount;
  Vue.prototype.$mount = function (
    el,
    hydrating
  ) {
    el = el && query(el);

	// NABU-CUSTOMIZED
    /* istanbul ignore if */
    /*
    if (el === document.body || el === document.documentElement) {
      warn(
        "Do not mount Vue to <html> or <body> - mount to normal elements instead."
      );
      return this
    }
    */
    // NABU-END

    var options = this.$options;
    // resolve template/el and convert to render function
    if (!options.render) {
      var template = options.template;
      if (template) {
        if (typeof template === 'string') {
          if (template.charAt(0) === '#') {
            template = idToTemplate(template);
            /* istanbul ignore if */
            if (!template) {
              warn(
                ("Template element not found or is empty: " + (options.template)),
                this
              );
            }
          }
        } else if (template.nodeType) {
          template = template.innerHTML;
        } else {
          {
            warn('invalid template option:' + template, this);
          }
          return this
        }
      } else if (el) {
        template = getOuterHTML(el);
      }
      if (template) {
        /* istanbul ignore if */
        if (config.performance && mark) {
          mark('compile');
        }

        var ref = compileToFunctions(template, {
          outputSourceRange: application && application.configuration && application.configuration.development,
          shouldDecodeNewlines: shouldDecodeNewlines,
          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        }, this);
        var render = ref.render;
        var staticRenderFns = ref.staticRenderFns;
        options.render = render;
        options.staticRenderFns = staticRenderFns;

        /* istanbul ignore if */
        if (config.performance && mark) {
          mark('compile end');
          measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
        }
      }
    }
    return mount.call(this, el, hydrating)
  };

  /**
   * Get outerHTML of elements, taking care
   * of SVG elements in IE as well.
   */
  function getOuterHTML (el) {
    if (el.outerHTML) {
      return el.outerHTML
    } else {
      var container = document.createElement('div');
      container.appendChild(el.cloneNode(true));
      return container.innerHTML
    }
  }

  Vue.compile = compileToFunctions;

  return Vue;

}));


if (!nabu) { var nabu = {} }
if (!nabu.utils) { nabu.utils = {} }
if (!nabu.utils.schema) { nabu.utils.schema = {} }
if (!nabu.utils.schema.json) { nabu.utils.schema.json = {} }

nabu.utils.schema.addAsyncValidation = function(validations, promise, mapper) {
	if (validations.promises == null) {
		validations.promises = [];
		
		var originalFilter = validations.filter;
		validations.filter = function() {
			return nabu.utils.schema.addAsyncValidation(originalFilter.apply(validations, arguments));
		}
		
		var originalMap = validations.map;
		validations.map = function() {
			return nabu.utils.schema.addAsyncValidation(originalMap.apply(validations, arguments));
		}
	}
	if (validations.defer == null) {
		validations.defer = function(promise, mapper) {
			return nabu.utils.schema.addAsyncValidation(validations, promise, mapper);
		}
	}
	if (promise != null) {
		// we add the result of the promise to the validations themselves
		promise.then(function(result) {
			result = mapper != null && result != null ? mapper(result) : result;
			// we support the default result array from the backend
			// where unfortunately we have  "message" instead of a "title". where and when this discrepancy was introduced is unclear
			if (result != null && !(result instanceof Array)) {
				Object.keys(result).forEach(function(key) {
					if (result != null && !(result instanceof Array) && result[key] instanceof Array) {
						result = result[key].map(function(x) {
							if (x.title == null && x.message != null) {
								x.title = x.message;
							}
							if (x.severity != null) {
								x.severity = x.severity.toLowerCase();
							}
							return x;
						});
						// @2021-04-28: we want to allow info messages to pass through to be able to show informational metadata
						//result = result.filter(function(x) {
						//	return x.severity == "error";
						//});
					}
				});
			}
			if (result instanceof Array && result.length > 0) {
				nabu.utils.arrays.merge(validations, result);
			}
		});
		// we want to support other "enhanced" arrays better
		if (promise.promises instanceof Array) {
			nabu.utils.arrays.merge(validations.promises, promise.promises);	
		}
		else {
			// we add the promise so we can wait on it after
			validations.promises.push(promise);
		}
	}
	if (validations.then == null) {
		validations.then = function(successHandler, errorHandler, progressHandler) {
			new nabu.utils.promises(validations.promises).then(function() {
				if (successHandler instanceof Function) {
					successHandler(validations);
				}
				else if (successHandler.resolve) {
					successHandler.resolve(validations);
				}
			}, function(error) {
				validations.push({
					code: "internal",
					title: "%{validation::An error has occurred during validation}"
				});
				if (successHandler instanceof Function) {
					successHandler(validations);
				}
				else {
					successHandler.resolve(validations);
				}
			}, progressHandler);
		}
	}
	return validations;
};
	
// formats a value according to the definition
// will throw an exception if the value is not valid according to the schema
nabu.utils.schema.json.format = function(definition, value, resolver) {
	if (definition.$ref) {
		if (resolver) {
			definition = resolver(definition.$ref);
		}
		else {
			throw "Can not format value because definition has a reference in it and no resolver is provided";
		}
	}
	if (definition.type == "string") {
		// if we have a string, let's check if you have duration format, in that case we generate a date
		if ((definition.format == "date" || definition.format == "date-time") && typeof(value) == "string" && value.match(/[-]{0,1}P[YMDTHS0-9]+$/)) {
			value = nabu.utils.dates.addDuration(value);
			/*
			// TO BE DELETED
			var originalDuration = value;
			var factor = value.indexOf("-") == 0 ? -1 : 1;
			// drop the leading -
			if (factor < 0) {
				value = value.substring(1);
			}
			// the total duration in ms
			var duration = 0;
			var result = new Date();
			// not supported atm
			result.setMilliseconds(0);
			// skip P
			value = value.substring(1);
			// separate date part from time part
			var parts = value.split("T");
			// check for years
			var index = parts[0].indexOf("Y");
			if (index >= 0) {
				result.setYear(result.getFullYear() + (factor * parseInt(parts[0].substring(0, index))));
				parts[0] = parts[0].substring(index + 1);
			}
			index = parts[0].indexOf("M");
			if (index >= 0) {
				result.setMonth(result.getMonth() + (factor * parseInt(parts[0].substring(0, index))));
				parts[0] = parts[0].substring(index + 1);
			}
			index = parts[0].indexOf("D");
			if (index >= 0) {
				result.setDate(result.getDate() + (factor * parseInt(parts[0].substring(0, index))));
				parts[0] = parts[0].substring(index + 1);
			}
			if (parts.length >= 2) {
				index = parts[1].indexOf("H");
				if (index >= 0) {
					result.setHours(result.getHours() + (factor * parseInt(parts[1].substring(0, index))));
					parts[1] = parts[1].substring(index + 1);
				}
				index = parts[1].indexOf("M");
				if (index >= 0) {
					result.setMinutes(result.getMinutes() + (factor * parseInt(parts[1].substring(0, index))));
					parts[1] = parts[1].substring(index + 1);
				}
				index = parts[1].indexOf("S");
				if (index >= 0) {
					result.setSeconds(result.getSeconds() + (factor * parseInt(parts[1].substring(0, index))));
					parts[1] = parts[1].substring(index + 1);
				}
			}
			value = result;
			*/
		}
		
		if (definition.format == "binary" || definition.format == "byte") {
			if (value instanceof File || value instanceof Blob) {
				return value;
			}
			else if (typeof(value) == "string" || value instanceof Date) {
				return new Blob([value], {type : 'text/plain'});
			}
			else {
				return new Blob([JSON.stringify(value, null, 2)], {type : 'application/json'});
			}
		}
		else if (definition.format == "date" && value instanceof Date) {
			// depending on how you constructed the date, the time part may be local time or not
			// e.g. new Date("2018-01-01") is interpreted as 0 UTC (so 1 CET) and getting the date component is UTC is the same day
			// if you do new Date(2018, 1, 1), it is interpreted as 0 local time (so -1 vs UTC) and transforming to UTC gets you the previous day
			return value.getFullYear() + "-" + (value.getMonth() < 9 ? "0" : "") + (value.getMonth() + 1) + "-" + (value.getDate() < 10 ? "0" : "") + value.getDate();
//			return value.toISOString().substring(0, 10);
		}
		else if (definition.format == "date-time" && value instanceof Date) {
			return value.toISOString();
		}
		else if (definition.format == "time" && value instanceof Date) {
			return value.toISOString().substring("yyyy-MM-ddT".length);
		}
		if (value === false) {
			return "false";
		}
		// empty strings are interpreted as null
		else if (!value) {
			return null;
		}
		else {
			return typeof(value) === "string" ? value : new String(value);
		}
	}
	else if (definition.type == "number" || definition.type == "integer") {
		if (typeof(value) === "number") {
			return definition.type == "integer" ? parseInt(value) : value;
		}
		// undefined, empty string,... just return null
		else if (!value) {
			return null;
		}
		else {
			var number = new Number(value);
			if (isNaN(number)) {
				throw "Not a number: " + value;
			}
			if (definition.type == "integer") {
				number = parseInt(number);
			}
			return number;
		}
	}
	else if (definition.type == "boolean") {
		if (typeof(value) === "boolean") {
			return value;
		}
		else if (typeof(value) == "undefined" || value == null) {
			return null;
		}
		// if we don't do this, !!"false" actually results in true
		else if (typeof(value) == "string" && value.toLowerCase() === "false") {
			 return false;
		}
		else {
			return !!value;
		}
	}
	else if (definition.type == "array") {
		if (value == null) {
			return null;
		}
		else if (!(value instanceof Array)) {
			value = [value];
		}
		var result = [];
		for (var i = 0; i < value.length; i++) {
			result.push(nabu.utils.schema.json.format(definition.items, value[i], resolver));
		}
		return result;
	}
	else if (definition.type == "object") {
		// if we have no value, don't create an empty object
		if (value == null) {
			return null;
		}
		var result = {};
		if (definition.properties) {
			for (var key in definition.properties) {
				var formatted = nabu.utils.schema.json.format(definition.properties[key], value[key], resolver);
				// only set filled in values
				if (formatted != null) {
					result[key] = formatted;
				}
				else if (definition.required && definition.required.indexOf(key) >= 0) {
					// if we have a required boolean that does not have a value, we set it to false
					// this is to prevent the problem where a null-valued checkbox needs to be explicitly enabled and disabled to get "false"
					// even though booleans should be false by default
					if (definition.properties[key].type == "boolean") {
						result[key] = false;
					}
					else {
						throw "Missing required element: " + key;
					}
				}
			}
		}
		return result;
	}
	else {
		throw "Unsupported type: " + definition.type;
	}
};

nabu.utils.schema.json.normalize = function(definition, value, resolver, createNew, recursivelyCreateNew) {
	if (definition.$ref) {
		if (resolver) {
			definition = resolver(definition.$ref);
		}
		else {
			throw "Can not normalize value because definition has a reference in it and no resolver is provided";
		}
	}
	if (typeof(value) == "undefined") {
		if (createNew) {
			return nabu.utils.schema.json.instance(definition, resolver);
		}
		else {
			return null;
		}
	}
	else if (definition.type == "object" || (definition.type == null && definition.properties)) {
		// if the object is null, we can't normalize it (?) 
		// we _could_ start a new instance and fill it with empty fields, but not sure if that is better at this point
		if (definition.properties && value != null) {
			for (var key in definition.properties) {
				if (typeof(value[key]) == "undefined") {
					if (recursivelyCreateNew) {
						value[key] = nabu.utils.schema.json.instance(definition.properties[key], resolver);
					}	
				}
				else {
					value[key] = nabu.utils.schema.json.normalize(definition.properties[key], value[key], resolver, recursivelyCreateNew, recursivelyCreateNew);
				}
			}
		}
	}
	else if (definition.type == "array") {
		if (!(value instanceof Array)) {
			value = [value];
		}
		for (var i = 0; i < value.length; i++) {
			if (value[i] && definition.items) {
				value[i] = nabu.utils.schema.json.normalize(definition.items, value[i], resolver, recursivelyCreateNew, recursivelyCreateNew);
			}
		}
	}
	else if (value === "") {
		value = null;
	}
	else if (value && definition.type == "string" && (definition.format == "date" || definition.format == "date-time")) {
		value = new Date(value);
	}
	else if (value && definition.type == "string" && definition.format == "time") {
		var full = "1970-01-01T";
		full += value;
		value = new Date(full);
	}
	else if (typeof(value) == "string" && definition.type == "boolean") {
		value = value == "true";
	}
	// we receive base64
	else if (value && typeof(value) == "string" && (definition.format == "binary" || definition.format == "byte")) {
		var base64ToBlob = function(base, contentType) {
			var raw = window.atob(base);
			var rawLength = raw.length;
			var uInt8Array = new Uint8Array(rawLength);
			for (var i = 0; i < rawLength; ++i) {
				uInt8Array[i] = raw.charCodeAt(i);
			}
			return new Blob([uInt8Array], {type: contentType});
		};
		// TODO: should get content type from somewhere?
		value = base64ToBlob(value, "application/octet-stream");
	}
	return value;
}

nabu.utils.schema.json.instance = function(definition, resolver) {
	if (definition.$ref) {
		if (resolver) {
			definition = resolver(definition.$ref);
		}
		else {
			throw "Can not normalize value because definition has a reference in it and no resolver is provided";
		}
	}
	if (definition.type == "array") {
		return [];
	}
	else if (definition.type == "object") {
		return nabu.utils.schema.json.normalize(definition, {}, resolver);
	}
	else {
		return null;
	}
}

// will validate a value by a schema definition
nabu.utils.schema.json.validate = function(definition, value, required, resolver) {
	if (definition.$ref) {
		if (resolver) {
			definition = resolver(definition.$ref);
		}
		else {
			throw "Can not normalize value because definition has a reference in it and no resolver is provided";
		}
	}
	
	if (typeof(value) == "undefined") {
		value = null;
	}
	
	var messages = [];

	var missing = function() {
		if (required) {
			messages.push({
				soft: true,
				severity: "error",
				code: "required",
				title: "%{validation::The value is required}",
				priority: 0,
				values: {
					actual: false,
					expected: true
				},
				context: []
			});
		}
	}
	
	if (!definition) {
		if (required && (typeof(value) == "undefined" || value == null || value === "")) {
			missing();
		}
		return messages;
	}
	
	// indicates that it could not be parsed as the given data type
	var type = function(type) {
		messages.push({
			severity: "error",
			code: "type",
			title: "%{validation::The value '{actual}' is not a '{expected}'}",
			priority: -1,
			values: {
				actual: value,
				expected: type
			},
			context: []
		});
	}
	var minLength = function(value, minLength) {
		if (minLength != null && result.length < minLength) {
			messages.push({
				severity: "error",
				code: "minLength",
				title: "%{validation::The value must be at least {expected} long}",
				priority: -2,
				values: {
					actual: result.length,
					expected: minLength
				},
				context: []
			});
		}
	}
	var maxLength = function(value, maxLength) {
		if (maxLength != null && result.length > maxLength) {
			messages.push({
				severity: "error",
				code: "maxLength",
				title: "%{validation::The value can be at most {expected} long}",
				priority: -2,
				values: {
					actual: result.length,
					expected: maxLength
				},
				context: []
			});
		}
	}
	var exactLength = function(value, exactLength) {
		if (exactLength != null && (result.length > exactLength || result.length < exactLength)) {
			messages.push({
				severity: "error",
				code: "exactLength",
				title: "%{validation::The value must be {expected} long}",
				priority: -2,
				values: {
					actual: result.length,
					expected: exactLength
				},
				context: []
			});
		}
	}
	var pattern = function(value, pattern, patternComment) {
		if (pattern != null && !result.match(pattern)) {
			messages.push({
				severity: "error",
				code: "pattern",
				title: patternComment ? patternComment : "%{validation::The value '{actual}' does not match the expected pattern '{expected}'}",
				priority: patternComment ? -1 : -3,
				values: {
					actual: result,
					expected: pattern
				},
				context: []
			});
		}
	}
	var maximum = function(value, maximum, exclusiveMaximum) {
		if (value != null && ( (exclusiveMaximum != null && exclusiveMaximum && value >= maximum) || (maximum != null && value > maximum) )) {
			messages.push({
				severity: "error",
				code: "maximum",
				title: exclusiveMaximum != null ? "%{validation::The value {actual} should be smaller than {expected}}" : "%{validation::The value {actual} should be smaller than or equal to {expected}}",                
				priority: -2,
				values: {
					actual: value,
					expected: maximum,
					exclusive: !!exclusiveMaximum
				},
				context: []
			});
		}
	}
	var minimum = function(value, minimum, exclusiveMinimum) {
		if (value != null && ( (exclusiveMinimum != null && exclusiveMinimum && value <= minimum) || (minimum != null && value < minimum) )) {
			messages.push({
				severity: "error",
				code: "minimum",
				title: exclusiveMinimum != null ? "%{validation::The value {actual} should be bigger than {expected}}" : "%{validation::The value {actual} should be bigger than or equal to {expected}}",
				priority: -2,
				values: {
					actual: value,
					expected: minimum,
					exclusive: !!exclusiveMinimum
				},
				context: []
			});
		}
	}
	var enumeration = function(value, enumeration) {
		if (enumeration && enumeration.indexOf(value) < 0) {
			messages.push({
				severity: "error",
				code: "enum",
				title: "%{validation::The value {actual} does not match one of the possible values}",
				priority: -1,
				values: {
					actual: value,
					expected: enumeration
				},
				context: []
			});
		}
	}
	var maxItems = function(value, maxItems) {
		if (maxItems != null && value.length > maxItems) {
			messages.push({
				severity: "error",
				code: "maxItems",
				title: "%{validation::There are {actual} entries, can be at most {expected}}",
				priority: -2,
				values: {
					actual: value.length,
					expected: maxItems
				},
				context: []
			});
		}
	}
	var minItems = function(value, minItems) {
		if (minItems != null && value.length < minItems) {
			messages.push({
				severity: "error",
				code: "minItems",
				title: "%{validation::There are only {actual} entries, expecting at least {expected}}",
				priority: -2,
				values: {
					actual: value.length,
					expected: minItems
				},
				context: []
			});
		}
	}
	
	// always check enumeration
	enumeration(value, definition["enum"]);
	
	// the string checks can be done on all of these
	if (definition.type == "string" || definition.type == "number" || definition.type == "integer" || !definition.type) {
		// empty strings are interpreted as null
		if (value == null || value === "") {
			missing();
		}
		else {
			var result = typeof(value) === "string" ? value : new String(value);
			// json schema does not support an exact length, but we do in the backend, it will be seen as an identical min and max length
			if (definition.minLength == definition.maxLength) {
				exactLength(result, definition.minLength);
			}
			else {
				minLength(result, definition.minLength);
				maxLength(result, definition.maxLength);
			}
			pattern(result, definition.pattern, definition.patternComment);
		}
	}
	if (definition.type == "number" || definition.type == "integer") {
		var result = null;
		if (typeof(value) === "number") {
			result = value;
		}
		else if (typeof(value) != "undefined") {
			var number = new Number(value);
			if (isNaN(number)) {
				type(definition.type);
			}
			else {
				result = number;
			}
		}
		if (result != null) {
			maximum(result, definition.maximum, definition.exclusiveMaximum);
			minimum(result, definition.minimum, definition.exclusiveMinimum);
		}
		else {
			missing();
		}
	}
	else if (definition.type == "boolean") {
		if (value == null) {
			missing();
		}
	}
	else if (definition.type == "array") {
		if (value == null) {
			missing();
		}
		else {
			var result = !(value instanceof Array) ? [value] : value;
			if (!value.length) {
				missing();
			}
			else {
				maxItems(result, definition.maxItems);
				minItems(result, definition.minItems);
				
				if (definition.items) {
					for (var i = 0; i < result.length; i++) {
						var childMessages = nabu.utils.schema.json.validate(definition.items, result[i], false);
						for (var j = 0; j < childMessages.length; j++) {
							childMessages[j].context.push(i);
							messages.push(childMessages[j]);
						}
					}
				}
			}
		}
	}
	else if (definition.type == "object") {
		if (value == null) {
			missing();
		}
		else {
			if (definition.properties) {
				for (var key in definition.properties) {
					var child = value[key];
					var childMessages = nabu.utils.schema.json.validate(definition.properties[key], value[key], definition.required && definition.required.indexOf(key) >= 0);
					for (var j = 0; j < childMessages.length; j++) {
						childMessages[j].context.push(key);
						messages.push(childMessages[j]);
					}
				}
			}
		}
	}
	nabu.utils.schema.addAsyncValidation(messages);
	return messages;
};



if (!nabu) { nabu = {}; }
if (!nabu.services) { nabu.services = {}; }
if (!nabu.services.iterators) { nabu.services.iterators = {}; }

nabu.services.iterators.Static = function() {
	this.hasNext = function() {
		return false;
	}
	this.hasPrevious = function() {
		return false;
	}
	this.next = function(items, selected) {
		if (selected.length == 0) {
			nabu.utils.arrays.merge(selected, items);
		}
	}
	this.previous = function(items, selected) {
		// do nothing
	}
};

if (!nabu) { nabu = {}; }
if (!nabu.services) { nabu.services = {}; }
if (!nabu.services.iterators) { nabu.services.iterators = {}; }

/*
Parameters:
	- totalSize: the total size of the window
	- scrollSize: if you want to move the window, how much do you move it by, if nothing is set, it will move the window fully, for example a window of 2 would shift by 2.
	- loadNext: a handler to load the next data, it should expect these parameters:
		- items: the current items known by the list
		- amount: the amount of new items to be loaded
		- resultHandler: a function that should be called with an array of the new items once they are loaded
	- loop: whether or not to loop
	- initialOffset: for the initial items to be loaded, how much to offset them by, the offset should be within the scope of the items already present in the list
*/
nabu.services.iterators.Window = function(parameters) {
	var self = this;
	this.totalSize = parameters.totalSize;
	this.scrollSize = parameters.scrollSize ? parameters.scrollSize: this.totalSize;
	this.loadNext = parameters.loadNext;
	this.hasMore = true;
	this.loop = parameters.loop;
	this.initialOffset = parameters.initialOffset ? parameters.initialOffset : 0;

	this.next = function(items, selected) {

		// function to lazily load new items
		var loadNext = function(amount) {
			self.loadNext(items, amount, function(result) {
				// we assume there is nothing more
				if (result.length < amount) {
					self.hasMore = false;
				}
				// if we loaded less than the scroll size, we still need to merge some from the original
				if (amount < self.scrollSize) {
					nabu.utils.arrays.merge(selected, items.slice(items.length - amount, items.length));
				}
				// add the result to the items
				nabu.utils.arrays.merge(items, result);

				// merge the rest from the result
				nabu.utils.arrays.merge(selected, result.slice(0, Math.min(result.length, self.scrollSize - amount)));
			});
		};

		// nothing selected yet, select first
		if (selected.length == 0) {
			if (items.length < self.initialOffset + self.totalSize && self.loadNext) {
				loadNext(self.totalSize + self.initialOffset - items.length);
			}
			else {
				nabu.utils.arrays.merge(selected, items.slice(self.initialOffset, Math.min(self.totalSize + self.initialOffset, items.length)));
			}
		}
		else {
			var loopFunction = function(amountOfNewItems) {
				// make sure we don't include the same item twice
				amountOfNewItems = Math.min(self.scrollSize - amountOfNewItems, items.length - amountOfNewItems);
				var amountToRetain = Math.min(selected.length, self.totalSize - amountOfNewItems);
				// remove the items that do not need to be retained
				selected.splice(0, selected.length - amountToRetain);
				// merge the beginning
				nabu.utils.arrays.merge(selected, items.slice(0, amountOfNewItems));
			}
			// get index of last selected item
			var index = items.indexOf(selected[selected.length - 1]);
			if (index < 0) {
				throw "Could not find selected item in list";
			}
			// there are not enough elements
			else if (index + self.scrollSize >= items.length - 1 && self.loadNext) {
				loadNext(self.scrollSize - (items.length - 1 - index));
			}
			else if (index < items.length - 1) {
				var amountOfNewItems = Math.min(self.scrollSize, items.length - index - 1);
				var amountToRetain = Math.min(selected.length, self.totalSize - amountOfNewItems);
				// remove the items that do not need to be retained
				selected.splice(0, selected.length - amountToRetain);
				// merge the new items
				nabu.utils.arrays.merge(selected, items.slice(index + 1, index + 1 + amountOfNewItems));
				// if we did not add enough elements and loop is turned on, loop back to beginning
				if (amountOfNewItems < self.scrollSize && self.loop) {
					loopFunction(amountOfNewItems);
				}
			}
			else if (self.loop) {
				loopFunction(0);
			}
		}
	};
	this.previous = function(items, selected) {
		// no use in trying to select previous if nothing is selected yet
		if (selected.length > 0) {
			var loopFunction = function(amountOfNewItems) {
				amountOfNewItems = Math.min(self.scrollSize - amountOfNewItems, items.length - amountOfNewItems);
				var amountToRetain = Math.min(selected.length, self.totalSize - amountOfNewItems);
				// remove remaining items
				selected.splice(amountToRetain, selected.length - amountToRetain);
				// merge the new items
				nabu.utils.arrays.offer(selected, items.slice(items.length - amountOfNewItems, items.length));
			}
			// get index of first selected item
			var index = items.indexOf(selected[0]);
			if (index < 0) {
				throw "Could not find selected item in list";
			}
			// only do it if there are elements left
			else if (index > 0) {
				var amountOfNewItems = Math.min(self.scrollSize, index);
				var amountToRetain = Math.min(selected.length, self.totalSize - amountOfNewItems);
				// remove remaining items
				selected.splice(amountToRetain, selected.length - amountToRetain);
				// merge the new items
				nabu.utils.arrays.offer(selected, items.slice(index - amountOfNewItems, index));
				if (amountOfNewItems < self.scrollSize && self.loop) {
					loopFunction(amountOfNewItems);
				}
			}
			else if (self.loop) {
				loopFunction(0);
			}
		}
	};
	this.hasNext = function(items, selected) {
		if (self.loop && selected.length != items.length) {
			return true;
		}
		return selected.length == 0
			? items.length > 0
			: items.indexOf(selected[selected.length - 1]) < items.length - 1;
	};
	this.hasPrevious = function(items, selected) {
		if (self.loop && selected.length != items.length) {
			return true;
		}
		return selected.length > 0 && items.indexOf(selected[0]) > 0;
	};
	this.autosize = function(items, selected, amountOfChildren) {
		this.totalSize = amountOfChildren;
		// remove the last from selected
		if (this.totalSize < selected.length) {
			selected.splice(this.totalSize);
		}
		else if (this.totalSize > selected.length) {
			var index = items.indexOf(selected[selected.length - 1]);
			nabu.utils.arrays.merge(selected, items.slice(index + 1, index + 1 + Math.min((this.totalSize - selected.length), items.length - index)));
		}
	}
}

if (!Function.name) {
	Object.defineProperty(Function.prototype, "name", {
		get: function() {
			var matches = ("" + this).match(/^\s*function\s+([^\(\s]*)\s*/);
			return matches ? matches[1] : null;
		},
		configurable: true
	});
}
if (!nabu) { var nabu = {} };
if (!nabu.formatters) { nabu.formatters = {} };

nabu.formatters.markdown = {
	// each provider should be able to generate html from a syntax
	syntaxProviders: {
		// needs some very specific handling
		xml: function(content, parameters) {
			var result = "";
			var index = 0;
			while (index >= 0) {
				index = content.indexOf("<");
				// we have some other content at the start
				if (index > 0) {
					result += content.substring(0, index);
					content = content.substring(index);
					// it is now at the front
					index = 0;
				}
				if (index == 0) {
					// we are now in a tag, let's get the start of the tag and mark it as a variable
					var match = content.match(/^[^\s>]+/);
					result += "<span class='is-code-variable'>" + nabu.formatters.markdown.formatTextAsHtml(match[0]) + "</span>";
					content = content.substring(match[0].length);
					// let's see where the end is
					var end = content.indexOf(">");
					// we have stuff between our tag and the end
					if (end > 0) {
						var tagContent = content.substring(0, end);
						content = content.substring(end);
						end = 0;
						var strings = nabu.formatters.markdown.encodeStrings(tagContent);
						tagContent = strings.content;
						tagContent = tagContent.replace(/\b([\w]+[\s]*)=/g, "<span class='is-code-keyword'>$1=</span>")
						result += nabu.formatters.markdown.decodeStrings(tagContent, strings);
					}
					// fix the end tag
					if (end == 0) {
						result += "<span class='is-code-variable'>" + nabu.formatters.markdown.formatTextAsHtml(">") + "</span>";
						content = content.substring(1);
					}
				}
			}
			return result;
		},
		html: "xml",
		css: function(content, parameters) {
			return nabu.formatters.markdown.encodeCode(
				content, 
				null, 
				/\/\*.*\*\//s, 
				/\b(:[\w]+)[\s]*\(/g,
				/(\.[a-zA-Z]+[\w-]*)\b/g,
				nabu.formatters.markdown.keywords.css,
				parameters
			)
		},
		scss: function(content, parameters) {
			var keywords = ["@mixin", "@include"];
			nabu.utils.arrays.merge(keywords, nabu.formatters.markdown.keywords.css);
			return nabu.formatters.markdown.encodeCode(
				content, 
				/\/\/.*$/m, 
				/\/\*.*\*\//s, 
				/\b([:\w]+)[\s]*\(/g,
				/((?:\$|\.)[a-zA-Z]+[\w-]*)\b/g,
				keywords,
				parameters
			)
		},
		sql: function(content, parameters) {
			return nabu.formatters.markdown.encodeCode(
				content, 
				/--.*$/m, 
				null, 
				/\b([\w.]+)\(/g,
				null,
				nabu.formatters.markdown.keywords.sql,
				parameters
			)
		},
		glue: function(content, parameters) {
			return nabu.formatters.markdown.encodeCode(
				content, 
				/#.*$/m, 
				null, 
				/\b([\w.]+)\(/g,
				null,
				nabu.formatters.markdown.keywords.default.filter(function (x) { return ["new"].indexOf(x) < 0 }),
				parameters
			)
		},
		python: "glue",
		java: function(content, parameters) {
			return nabu.formatters.markdown.encodeCode(
				content, 
				/\/\/.*$/m, 
				/\/\*.*\*\//s, 
				/\b([\w]+)\(/g,
				null,
				nabu.formatters.markdown.keywords.default,
				parameters
			)
		},
		javascript: "java",
		json: "java",
		text: function(content, parameters) {
			return nabu.formatters.markdown.formatTextAsHtml(content, true);
		}
	},
	keywords: {
		css: ["!default", "!important", "@media"],
		sql: ["select", "update", "delete", "insert", "create", "drop", "from", "where", "order by", "group by", "limit", "offset", "table", "index", "and", "or", "current_timestamp"],
		default: ["abstract", "null", "continue", "for", "new", "switch", "assert", "default", "goto", "package", "synchronized", "boolean", "do", "if", "private", "this", "break", "double", "implements", "protected", "throw", "byte", "else", "import", "public", "throws", "case", "enum", "instanceof", "return", "transient", "catch",
			"extends", "int", "short", "try", "char", "final", "interface", "static", "void", "class", "finally", "long", "strictfp", "volatile", "const", "float", "native", "super", "while", "true", "false"]
	},
	encodeCode: function(content, singleLineRegex, multiLineRegex, methodRegex, variableRegex, keywords, parameters) {
		// we assume the prevalence of strings in comments is less than comments in strings...?
		var strings = nabu.formatters.markdown.encodeStrings(
			content
		);
		content = strings.content;
		
		var comments = nabu.formatters.markdown.encodeComments(
			content,
			singleLineRegex, 
			multiLineRegex
		);
		content = comments.content;

		// already do basic encoding before we generate html
		content = nabu.formatters.markdown.formatTextAsHtml(content, true);
				
		// keywords
		if (keywords && keywords.length) {
			content = content.replaceAll(new RegExp("(?:\\b)(" + keywords.join("|") + ")(?:\\b)", "g"), "<span class='is-code-keyword'>$1</span>");
		}

		// methods
		if (methodRegex != null) {
			content = content.replaceAll(methodRegex, "<span class='is-code-method'>$1</span>(");
		}

		// variables
		if (variableRegex != null) {
			content = content.replaceAll(variableRegex, "<span class='is-code-variable'>$1</span>");
		}
		
		content = nabu.formatters.markdown.decodeComments(content, comments);
		content = nabu.formatters.markdown.decodeStrings(content, strings);
		return content;
	},
	asHtml: function(blocks, parameters) {
		var html = [];
		// we used named promises with an id so we can inject the resolved value
		var promises = {};
		// the current list stack (can be mixture of ul and ol)
		var listStack = [];
		var reduceList = function(amount) {
			for (var i = (amount ? amount : listStack.length) - 1; i >= 0; i--) {
				var includeTrailing = listStack.length >= 2;
				// a nested list must be within a <li> itself!
				html.push("</" + listStack.pop() + ">" + (includeTrailing ? "</li>" : ""));
			}
		}
		var pushList = function(tag) {
			// a nested list must be within a <li> itself!
			html.push((listStack.length > 0 ? "<li>" : "") + "<" + tag + " class='is-list is-variant-article'>");
			listStack.push(tag);
		}
		blocks.forEach(function(block) {
			// terminate any lists before continuing
			if (block.type != "ul" && block.type != "ol" && listStack.length > 0) {
				reduceList();
			}
			var formatted = [];
			// regular content
			if (["h1", "h2", "h3", "h4", "h5", "h6", "p"].indexOf(block.type) >= 0) {
				// if we have a header, inject a local anchor
				if (block.type.indexOf("h") == 0) {
					formatted.push("<a id='" + block.linkId + "'></a>");
				}
				formatted.push(
					"<" + block.type + " class='is-" + block.type + " is-variant-article'>"
					+ nabu.formatters.markdown.formatContentAsHtml(block.content, parameters)
					+ "</" + block.type + ">"
				);
			}
			else if (block.type == "code") {
				var result = nabu.formatters.markdown.formatCodeAsHtml(block.content, block.syntax, parameters);
				// if we get back a promise, we need to resolve it asynchronously
				// we will inject a placeholder to be replaced later
				if (result.then) {
					var id = crypto ? crypto.randomUUID() : "code-" + Math.random();
					formatted.push("<code class='is-code is-variant-article' target='" + (block.syntax ? block.syntax : "text") + "' data-resolve-id='" + id + "'>");
					promises[id] = result;
				}
				else {
					formatted.push("<code class='is-code is-variant-article' target='" + (block.syntax ? block.syntax : "text") + "'>");
					formatted.push(result);
				}
				formatted.push("</code>");
			}
			else if (block.type == "quote") {
				formatted.push(
					"<blockquote class='is-quote is-variant-article'>"
					+ nabu.formatters.markdown.formatTextAsHtml(block.content, parameters)
					+ "</blockquote>"
				);
			}
			else if (block.type == "ul" || block.type == "ol") {
				// if our depth is bigger than the current list stack, we need to add some lists
				while (block.depth > listStack.length) {
					formatted.push((listStack.length > 0 ? "<li>" : "") + "<ul class='is-list is-variant-article'>");
					listStack.push("ul");
				}
				if (block.depth < listStack.length - 1) {
					reduceList(listStack.length - (block.depth + 1));
				}
				// we need to add one more list
				if (block.depth == listStack.length) {
					pushList(block.type);
				}
				// otherwise make sure we have the correct type of list
				else if (listStack[listStack.length - 1] != block.type) {
					reduceList(1);
					pushList(block.type);
				}
				formatted.push(
					"<li>"
					+ nabu.formatters.markdown.formatContentAsHtml(block.content, parameters)
					+ "</li>"
				);
			}
			else if (block.type == "table") {
				formatted.push("<table class='is-table is-variant-article'>");
				var headers = block.rows.filter(function(x) {
					return x.header;
				});
				var body = block.rows.filter(function(x) {
					return !x.header;
				});
				if (headers.length) {
					formatted.push("<thead>");
					headers.forEach(function(header) {
						formatted.push("<tr>");
						header.columns.forEach(function(column) {
							formatted.push(
								"<th colspan='" + (column.colspan ? column.colspan : 1) + "'>"
								+ nabu.formatters.markdown.formatContentAsHtml(column.content, parameters)
								+ "</th>"
							);
						});
						formatted.push("</tr>");
					});
					formatted.push("</thead>");
				}
				if (body.length) {
					formatted.push("<tbody>");
					body.forEach(function(row) {
						formatted.push("<tr>");
						row.columns.forEach(function(column) {
							formatted.push(
								"<td colspan='" + (column.colspan ? column.colspan : 1) + "'>"
								+ nabu.formatters.markdown.formatContentAsHtml(column.content, parameters)
								+ "</td>"
							);
						});
						formatted.push("</tr>");
					});
					formatted.push("</tbody>");
				}
				formatted.push("</table>");
			}
			else if (block.type == "block") {
				// we might want to set some custom style stuff
				formatted.push("<div class='is-" + (block.direction ? block.direction : "row") + " is-variant-article'>");
				var reverseDirection = block.direction == "column" ? "row" : "column";
				var dimensionConfiguration = block.configuration.filter(function(x) {
					return x.key == "dimensions";
				})[0];
				var dimensions = dimensionConfiguration ? dimensionConfiguration.value.split(",") : [];
				block.blocks.forEach(function(block, index) {
					var style = "";
					style += "flex-basis: 0; flex-grow: " + (index < dimensions.length ? dimensions[index] : "1") + ";";
					formatted.push("<div class='is-" + reverseDirection + " is-variant-article' style='" + style + "'>");
					var resultHtml = nabu.formatters.markdown.asHtml([block], parameters);
					formatted.push(resultHtml.content);
					nabu.utils.objects.merge(promises, resultHtml.promises);
					formatted.push("</div>");
				});
				formatted.push("</div>");
			}
			nabu.utils.arrays.merge(html, formatted);
		});
		// finish any lists we were building
		while (listStack.length) {
			reduceList();
		}
		for (var i = 0; i < html.length - 1; i++) {
			// if our current element ends with </li>
			if (html[i].indexOf("</li>") == html[i].length - "</li>".length) {
				// and the next element is a supporting <li> injected for nested lists
				if (html[i + 1].indexOf("<li><ul") == 0 || html[i + 1].indexOf("<li><ol") == 0) {
					// we remove the </li> from the previous entry and the <li> from the latter entry
					html[i] = html[i].substring(0, html[i].length - "</li>".length);
					html[i + 1] = html[i + 1].substring("<li>".length);
				}
			}
		}
		return {
			content: nabu.formatters.markdown.replaceVariables(html.join("\n"), parameters),
			promises: promises
		}
	},
	replacePromises: function(promises) {
		Object.keys(promises).forEach(function(x) {
			promises[x].then(function(result) {
				var element = document.querySelector("[data-resolve-id=\"" + x + "\"]");
				if (element && result) {
					element.innerHTML = result;
				}
			})
		})
	},
	// you can use variables with the syntax ${}. this allows you to create templates
	replaceVariables: function(html, parameters) {
		if (parameters && parameters.variables) {
			Object.keys(parameters.variables).forEach(function(key) {
				html = html.replace(new RegExp("\\$\\{" + key + "\\}", "g"), parameters.variables[key]);
			});
		}
		return html;
	},
	formatTextAsHtml: function(content, includeSpaces) {
		content = content.replace(/&/g, "&amp;");
		content = content.replace(/</g, "&lt;");
		content = content.replace(/>/g, "&gt;");
		content = content.replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;");
		content = content.replace(/\n/g, "<br/>");
		if (includeSpaces) {
			content = content.replace(/[ ]{2}/g, "&nbsp;&nbsp;");
		}
		return content;
	},
	// interprets inline things as html
	formatContentAsHtml: function(content, parameters) {
		// we currently don't encode, this allows for inline html annotating!
		// content = nabu.formatters.markdown.formatTextAsHtml(content);
		
		// we don't want stuff _inside_ code quotes to get annotated, e.g. "`my_test_function`" should not have the _ be interpreted
		var encodeCodes = [];
		while (content.match(/``(.*?)``/)) {
			var inlineCode = content.match(/``(.*?)``/)[0];
			content = content.replace(inlineCode, "::encoded-inline-code-" + encodeCodes.length + "::");
			inlineCode = inlineCode.replace(/``(.*?)``/g, "$1")
			encodeCodes.push("<code class='is-code is-variant-inline'>" + nabu.formatters.markdown.formatTextAsHtml(inlineCode) + "</code>");
		}
		while (content.match(/`(.*?)`/)) {
			var inlineCode = content.match(/`(.*?)`/)[0];
			console.log("inline code is", inlineCode);
			content = content.replace(inlineCode, "::encoded-inline-code-" + encodeCodes.length + "::");
			inlineCode = inlineCode.replace(/`(.*?)`/g, "$1")
			encodeCodes.push("<code class='is-code is-variant-inline'>" + nabu.formatters.markdown.formatTextAsHtml(inlineCode) + "</code>");
		}

		// replace escaped with placeholders
		content = content.replace(/\\\*/g, "::escaped-asterisk::");
		content = content.replace(/\\_/g, "::escaped-underscore::");
		content = content.replace(/\\\+/g, "::escaped-plus::");
		content = content.replace(/\\~/g, "::escaped-tilde::");
		content = content.replace(/\\`/g, "::escaped-backtick::");
		content = content.replace(/\\@/g, "::escaped-at::");
		content = content.replace(/\\#/g, "::escaped-hashtag::");

		// bold + italic
		content = content.replace(/\*\*\*(.*?)\*\*\*/g, "<em>$1</em>");
		// bold
		content = content.replace(/\*\*(.*?)\*\*/g, "<b>$1</b>");
		content = content.replace(/__(.*?)__/g, "<b>$1</b>");
		// italic
		content = content.replace(/\*(.*?)\*/g, "<i>$1</i>");
		content = content.replace(/_(.*?)_/g, "<i>$1</i>");
		// delete
		content = content.replace(/~~(.*?)~~/g, "<del>$1</del>");
		// CUSTOM
		// add
		content = content.replace(/\+\+(.*?)\+\+/g, "<ins>$1</ins>");
		// code
		content = content.replace(/``(.*?)``/g, "<code class='is-code is-variant-inline'>$1</code>");
		content = content.replace(/`(.*?)`/g, "<code class='is-code is-variant-inline'>$1</code>");

		// CUSTOM
		// video embeds with classes
		content = content.replace(/!!\[(.*?)#(.*?)\]\((.*?)\)/g, "<video alt='$1' class='is-video is-variant-article $2' controls frameborder='0' allowfullscreen><source src='$3'/></video>");
		// video embeds with styling
		content = content.replace(/!!\[(.*?)\?(.*?)\]\((.*?)\)/g, "<video alt='$1' class='is-video is-variant-article' style='$2' controls frameborder='0' allowfullscreen><source src='$3'/></video>");
		// video embeds
		content = content.replace(/!!\[(.*?)\]\((.*?)\)/g, "<video alt='$1' class='is-video is-variant-article' controls frameborder='0' allowfullscreen><source src='$2'/></video>");

		// image embeds with classes
		content = content.replace(/!\[(.*?)#(.*?)\]\((.*?)\)/g, "<img alt='$1' src='$3' class='is-image is-variant-article $2'/>");
		// image embeds with styling
		content = content.replace(/!\[(.*?)\?(.*?)\]\((.*?)\)/g, "<img alt='$1' style='$2' src='$3' class='is-image is-variant-article'/>");
		// image embeds
		content = content.replace(/!\[(.*?)\]\((.*?)\)/g, "<img alt='$1' src='$2' class='is-image is-variant-article'/>");

		// external links
		content = content.replace(/\[(.*?)\]\(((?:http|https):\/\/.*?)\)/g, "<a rel='norel nofollow noopener' href='$2' class='is-link is-variant-article is-target-external'>$1</a>");

		// fragment links: point to an embedded anchor on this page
		content = content.replace(/\[(.*?)\]\((#.*?)\)/g, "<a href='" + window.location.pathname + "$2' class='is-link is-variant-article is-target-internal'>$1</a>");

		// internal links
		content = content.replace(/\[(.*?)\]\((.*?)\)/g, "<a href='$2' class='is-link is-variant-article is-target-internal'>$1</a>");

		// whitespace
		content = content.replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;");
		content = content.replace("\n", "<br/>");
		
		// CUSTOM
		// tags
		if (parameters && parameters.tagUrl) {
			content = content.replace(/(^|[\s]+)#([\w/-]+)/g, "$1<a class='is-link is-variant-tag is-target-internal' href='" + parameters.tagUrl + "$2'>$2</a>");
		}
		if (parameters && parameters.userUrl) {
			content = content.replace(/(^|[\s]+)@([\w/-]+)/g, "$1<a class='is-link is-variant-user is-target-internal' href='" + parameters.userUrl + "$2'>$2</a>");
		}

		// replace escaped with placeholders
		content = content.replace(/::escaped-asterisk::/g, "*");
		content = content.replace(/::escaped-underscore::/g, "_");
		content = content.replace(/::escaped-plus::/g, "+");
		content = content.replace(/::escaped-tilde::/g, "~");
		content = content.replace(/::escaped-backtick::/g, "`");
		content = content.replace(/::escaped-at::/g, "@");
		content = content.replace(/::escaped-hashtag::/g, "#");

		encodeCodes.forEach(function(encodeCode, index) {
			content = content.replace("::encoded-inline-code-" + index + "::", encodeCode);
		});
		
		return content;
	},
	encodeStrings: function(content) {
		var index = 0;
		var match = null;
		var strings = [];
		var startIndex = 0;
		// whether we allow linefeeds in the string or not, very few languages allow for this (actually only glue...?)
		var allowLinefeeds = false;
		var skipIndex = 0;
		while (startIndex >= 0) {
			// if we have match, find the end
			if (match != null) {
				index = content.indexOf(match, startIndex + 1);
				// if we have no match, we want to keep searching
				if (index < 0) {
					skipIndex = startIndex + 1;
					match = null;
				}
				// if we don't allow linefeeds, we check that the match is not beyond a linefeed
				if (match != null && !allowLinefeeds) {
					// check that it is not past a linefeed
					var linefeedIndex = content.indexOf("\n", startIndex + 1);
					if (linefeedIndex >= 0 && linefeedIndex < index) {
						match = null;
						skipIndex = linefeedIndex + 1;
					}
				}
				if (match != null) {
					if (index >= 0) {
						var string = content.substring(startIndex, index + 1);
						content = content.replace(string, "::encoded-string-" + strings.length + "::");
						strings.push(string);
						match = null;
					}
					else {
						break;
					}
				}
			}
			// if we don't have a match anymore, find the next string
			if (match == null) {
				var singleIndex = content.indexOf("'", skipIndex);
				var doubleIndex = content.indexOf("\"", skipIndex);
				if ((singleIndex >= 0 && doubleIndex >= 0 && singleIndex < doubleIndex) || (singleIndex >= 0 && doubleIndex < 0)) {
					match = "'";
					startIndex = singleIndex;
				}
				else if ((singleIndex >= 0 && doubleIndex >= 0 && singleIndex > doubleIndex) || (singleIndex < 0 && doubleIndex >= 0)) {
					match = "\"";
					startIndex = doubleIndex;
				}
				else {
					startIndex = -1;
				}
			}
		}
		return {
			strings: strings,
			content: content
		}
	},
	decodeStrings: function(content, strings) {
		strings.strings.forEach(function(string, index) {
			content = content.replace("::encoded-string-" + index + "::", "<span class='is-code-string'>" + nabu.formatters.markdown.formatTextAsHtml(string) + "</span>");
		});
		return content;
	},
	encodeComments: function(content, singleLineRegex, multiLineRegex) {
		// we want to preprocess comments and strings, we don't want to accidently highlight stuff in there
		// multiline comments
		var multilineComments = [];
		if (multiLineRegex) {
			while (content.match(multiLineRegex)) {
				var comment = content.match(multiLineRegex)[0];
				content = content.replace(comment, "::encoded-multi-comment-" + multilineComments.length + "::");
				multilineComments.push(comment);
			}
		}
		
		var singlelineComments = [];
		if (singleLineRegex) {
			while (content.match(singleLineRegex)) {
				var comment = content.match(singleLineRegex)[0];
				content = content.replace(comment, "::encoded-single-comment-" + singlelineComments.length + "::");
				singlelineComments.push(comment);
			}
		}
		return {
			single: singlelineComments,
			multi: multilineComments,
			content: content
		}
	},
	decodeComments: function(content, comments) {
		comments.single.forEach(function(comment, index) {
			content = content.replace("::encoded-single-comment-" + index + "::", "<span class='is-code-comment is-variant-single'>" + nabu.formatters.markdown.formatTextAsHtml(comment) + "</span>");
		});
		comments.multi.forEach(function(comment, index) {
			content = content.replace("::encoded-multi-comment-" + index + "::", "<span class='is-code-comment is-variant-multi'>" + nabu.formatters.markdown.formatTextAsHtml(comment) + "</span>");
		});
		return content;
	},
	formatCodeAsHtml: function(content, syntax, parameters) {
		if (!syntax || !nabu.formatters.markdown.syntaxProviders[syntax]) {
			syntax = "text";
		}
		while (typeof(syntax) == "string" || syntax instanceof String) {
			syntax = nabu.formatters.markdown.syntaxProviders[syntax];
		}
		return syntax(content, parameters);
	},
	parse: function(content, parameters) {
		if (content == null) {
			return [];
		}
		// if you pass in an element
		if (content.innerHTML) {
			content = content.innerHTML;
		}
		// we are working line based
		var lines = content.split(/\n/);
		
		// we have "block" elements like paragraph that can contain multiple lines
		// and we have "line" element like header which can only contain one line
		// the parse methods groups the lines into elements and annotates them
		var blocks = [];
		var currentBlock = null;
		// the current block wrapper
		var blockWrapper = null;
		var finalizeBlock = function() {
			if (currentBlock) {
				blocks.push(currentBlock);
				currentBlock = null;
			}
		}
		var lineBlock = function(parameters) {
			// finalize what we were working on
			finalizeBlock();
			blocks.push(parameters);
			if (parameters.type.match(/^h[0-9]+$/)) {
				parameters.linkId = parameters.content.replace(/[^\w]+/g, "-").toLowerCase();
			}
		}
		var pushBlock = function(parameters, force) {
			// there is a block of a different type ongoing
			if (currentBlock && (currentBlock.type != parameters.type || force)) {
				finalizeBlock();
				currentBlock = parameters;
			}
			else if (currentBlock && currentBlock.content == null) {
				currentBlock.content = content;
			}
			// there is a block of the same type ongoing, append this
			else if (currentBlock) {
				currentBlock.content += "\n" + parameters.content;
			}
			// set as new block
			else {
				currentBlock = parameters;
			}
		}
		// simply add content to the current block
		var pushContent = function(content) {
			// if we have no block, start a paragraph
			if (!currentBlock) {
				currentBlock = {
					type: "p",
					content: content
				}
			}
			else if (currentBlock.content == null) {
				currentBlock.content = content;
			}
			else {
				currentBlock.content += "\n" + content;
			}
		}
		// you can assign a function if you want to prevent parsing
		// this can be useful for example when you have a code block
		var parseEvaluator = null;
		for (var i = 0; i < lines.length; i++) {
			var line = lines[i].trim();
			var parseLine = true;
			// if we are for example in a code block, we don't interpret the content, this is for later processing
			if (parseEvaluator) {
				parseLine = parseEvaluator(line, lines[i]);
			}
			if (!parseLine) {
				continue;
			}
			// empty lines serve to delineate block elements, so if we are in a block element, close it
			// of we are in a line element, we do nothing, it is just visual demarcation
			else if (line.length == 0) {
				finalizeBlock();
			}
			// we have content
			else {
				// headers
				if (line.indexOf("######") == 0) {
					lineBlock({
						type: "h6",
						content: line.substring("######".length).trim()
					})
				}
				else if (line.indexOf("#####") == 0) {
					lineBlock({
						type: "h5",
						content: line.substring("#####".length).trim()
					})
				}
				else if (line.indexOf("####") == 0) {
					lineBlock({
						type: "h4",
						content: line.substring("####".length).trim()
					})
				}
				else if (line.indexOf("###") == 0) {
					lineBlock({
						type: "h3",
						content: line.substring("###".length).trim()
					})
				}
				else if (line.indexOf("##") == 0) {
					lineBlock({
						type: "h2",
						content: line.substring("##".length).trim()
					})
				}
				else if (line.indexOf("#") == 0) {
					lineBlock({
						type: "h1",
						content: line.substring("#".length).trim()
					})
				}

				// quote
				else if (line.indexOf(">") == 0) {
					pushBlock({
						type: "quote",
						content: line.substring(">".length).trim()
					})
				}

				// uber code block that can contain (unparsed) other code blocks
				else if (line.indexOf("````") == 0) {
					var syntax = line.substring("````".length).trim();
					pushBlock({
						type: "code",
						syntax: syntax.length > 0 ? syntax : null
					});
					parseEvaluator = function(content, raw) {
						// if we have the end of the code block, stop the parse evaluator
						if (content == "````") {
							finalizeBlock();
							parseEvaluator = null;
						}
						// otherwise, just append it
						else {
							pushContent(raw);
						}
					}
				}
				// regular code block
				else if (line.indexOf("```") == 0) {
					var syntax = line.substring("```".length).trim();
					pushBlock({
						type: "code",
						syntax: syntax.length > 0 ? syntax : null
					});
					parseEvaluator = function(content, raw) {
						// if we have the end of the code block, stop the parse evaluator
						if (content == "```") {
							finalizeBlock();
							parseEvaluator = null;
						}
						// otherwise, just append it
						else {
							pushContent(raw);
						}
					}
				}

				// CUSTOM
				// a way to nest blocks, to create more complex layouts
				// the amount of -- can be used to nest blocks, each start and end are matched
				// you can use > to create column layouts and ^ to create row layouts
				// so for instance content between two -> is grouped in a block marked as a column layout
				// you can nest further with for instance --> to create a nested block with column layout or --^ to create a nested block with row layout
				// combine this with say images or videos or stuff like that to create prettier layouts
				// you can add configuration to do slightly more dynamic layouting, for example:
				// -> 1,2
				// <-
				// the default configuration for columns is "dimensions" so this is basically the flex dimension of each child (any additional children have 1)
				// so in this example we want the first child to take up 1/3 of the width and the second to take up 2/3
				else if (line.match(/^[-]+(>|\^).*/)) {
					var configuration = line.replace(/^[-]+(?:>|\^)(.*)/, "$1").trim();
					line = line.replace(/^([-]+(?:>|\^)).*/, "$1").trim();
					var depth = line.length - line.replace(/^[-]+/, "").length;
					var direction = line.indexOf(">") > 0 ? "row" : "column";
					console.log("starting block", line);
					// finalize whatever block we were working on
					if (currentBlock && currentBlock.type != "block") {
						finalizeBlock();
					}
					var parent = {
						blockWrapper: blockWrapper,
						blocks: blocks,
						parseEvaluator: parseEvaluator
					}
					blockWrapper = {
						configuration: [],
						parent: parent,
						type: "block",
						direction: direction,
						depth: depth,
						blocks: []
					}
					if (configuration) {
						configuration.split(";").forEach(function(single) {
							var index = single.indexOf("=");
							var key = index > 0 ? single.substring(0, index) : null;
							var value = index > 0 ? single.substring(index + 1) : single;
							// the default configuration is "dimensions" where you can state (in flex terminology) how big something is (default is 1)
							blockWrapper.configuration.push({
								key: key == null ? "dimensions" : key,
								value: value
							})
						});
					}
					// make sure we push it to the parent blocks as well
					blocks.push(blockWrapper);
					blocks = blockWrapper.blocks;
				}
				else if (line.match(/^(<|\^)[-]+$/)) {
					var depth = line.length - line.replace(/[-]+$/, "").length;
					var direction = line.indexOf("<") == 0 ? "row" : "column";
					console.log("stopping block", line, blockWrapper, direction, depth);
					// we are finishing the current block
					if (blockWrapper && blockWrapper.direction == direction && blockWrapper.depth == depth) {
						console.log("actually stopping!");
						// inherit from potentially parent nested
						var parent = blockWrapper.parent;
						blockWrapper.parent = null;
						delete blockWrapper.parent;
						finalizeBlock();
						parseEvaluator = parent.parseEvaluator;
						blocks = parent.blocks;
						blockWrapper = parent.blockWrapper;
					}
				}

				// line, can be used for page break or the like
				else if (line == "---" || line == "___" || line == "***") {
					pushBlock({
						type: "hr"
					})
				}

				// unordered list
				else if (line.indexOf("-") == 0 || line.indexOf("+") == 0 || line.indexOf("*") == 0) {
					pushBlock({
						type: "ul",
						// the depth of the list is determined by the amount of whitespace in front of it
						depth: lines[i].indexOf(line.substring(0, 1)),
						content: line.substring(1).trim()
					}, true)
				}

				// ordered list
				else if (line.match(/^[0-9]+\..*/)) {
					pushBlock({
						type: "ol",
						// the depth of the list is determined by the amount of whitespace in front of it
						depth: lines[i].indexOf(line.substring(0, 1)),
						number: parseInt(line.replace(/^([0-9]+)\..*/, "$1")),
						content: line.replace(/^[0-9]+\.(.*)/, "$1").trim()
					}, true)
				}

				// footnotes
				else if (line.match(/^\[\^[0-9]+\].*/)) {
					pushBlock({
						type: "footnote",
						number: parseInt(line.replace(/^\[\^([0-9]+)\].*/, "$1")),
					}, true)
				}

				// CUSTOM
				// comments
				else if (line == "/*") {
					// start a new comment block
					pushBlock({
						type: "comment"
					});
					// set the evaluator to capture internal content
					parseEvaluator = function(content) {
						// if we have the end of the code block, stop the parse evaluator
						if (content == "*/") {
							parseEvaluator = null;
						}
						// otherwise, just append it
						else {
							pushContent(content);
						}
					}
				}

				// table
				else if (line.indexOf("|") == 0) {
					pushBlock({
						type: "table",
						rows: [],
						// contains column styling options
						styling: []
					});
					// every line is a new row
					// until we meet a row with ---, we assume we are doing header rows
					// we support colspans by chaining pipes, for instance
					// |test||test2||
					// |col1|col2|col3|col4|
					// in this case test would span over col1 and col2 (2 pipes at the end) and test2 would span over col3 and col4
					var tableHeader = true;
					parseEvaluator = function(line) {
						// before we do anything, we want to encode escaped | so we don't accidently hit them
						line = line.replace(/\\\|/g, "::encoded-pipe::");

						// if it does not start with a pipe, we have finalized our table and want to return to normal parsing
						if (line.indexOf("|") != 0) {
							// if we get to the end of the table without any ---, we need to retroactively unset all the header booleans
							if (tableHeader) {
								currentBlock.rows.forEach(function(row) {
									row.header = false;
								})
							}
							finalizeBlock();
							parseEvaluator = null;
							// continue regular parsing of this row
							return true;
						}
						var columns = [];
						// we need to parse the columns
						var pipeIndex = 0;
						// as long as we have pipe indexes, we have columns
						while (pipeIndex >= 0) {
							// we remove the leading pipe (there should be only one at this point)
							line = line.replace(/^[|]+/, "");
							// we get the next pipe index
							pipeIndex = line.indexOf("|");
							// if we have one, we have content
							if (pipeIndex >= 0) {
								var columnContent = line.substring(0, pipeIndex).trim();
								line = line.substring(pipeIndex);
								if (columnContent.match(/^[-]+$/)) {
									currentBlock.styling.push({
										align: "left"
									});
									tableHeader = false;
									continue;
								}
								else if (columnContent.match(/^:[-]+$/)) {
									currentBlock.styling.push({
										align: "left"
									})
									tableHeader = false;
									continue;
								}
								else if (columnContent.match(/^[-]+:$/)) {
									currentBlock.styling.push({
										align: "right"
									})
									tableHeader = false;
									continue;
								}
								else if (columnContent.match(/^:[-]+:$/)) {
									currentBlock.styling.push({
										align: "center"
									})
									tableHeader = false;
									continue;
								}
								// a content column
								else {
									// we need to calculate the colspan depending on the amount of pipes that follow
									var lengthWithPipe = line.length;
									// remove all pipes except for the last one
									line = line.replace(/^[|]*(\|.*)/, "$1");
									var colspan = lengthWithPipe - line.length;
									// decode encoded
									columnContent = columnContent.replace(/::encoded-pipe::/g, "|");
									columns.push({
										content: columnContent,
										colspan: colspan + 1
									})
								}
							}
						}
						if (columns.length > 0) {
							var row = {
								columns: columns,
								header: tableHeader
							};
							// add it to the table
							currentBlock.rows.push(row);
						}
					}
					// parse this row as well
					parseEvaluator(line);
				}

				// continuation of current block
				else {
					pushContent(line);
				}
			}
		}
		// finalize whatever we had ongoing
		finalizeBlock();
		// normalize the depths, for instance some chat models generate an ordered list with "1. something" then include an unordered list but offset it with 3 spaces (instead of 1) to visually match with the parent list
		// however, these depth differences can lead to a lot of unwanted list generation
		var previousDepth = 0;
		var depthReference = 0;
		var depthReduction = 0;
		blocks.forEach(function(block) {
			// we want to update to a reference depth
			if (depthReference > 0) {
				if (block.depth > depthReference) {
					block.depth -= depthReduction;
				}
				// if we dip below the reference point, stop rewriting
				else if (block.depth < depthReference) {
					depthReference = 0;
					depthReduction = 0;
				}
			}
			// if we are offset by more than 1, reduce it to 1
			else if (block.depth > previousDepth + 1) {
				depthReference = previousDepth + 1;
				depthReduction = block.depth - depthReference;
				block.depth -= depthReduction;
			}
			previousDepth = block.depth;
		});
		return blocks;
	}
}
if (!nabu) { nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }

nabu.utils.objects = {
	copy: function(content) {
		// the new way! not in IE and not in safari before march 2020
		if (navigator && navigator.clipboard && navigator.clipboard.writeText) {
			navigator.clipboard.writeText(typeof(content) == "string" ? content : JSON.stringify(content));
		}
		else {
			var area = document.createElement("textarea");
			// Prevent zooming on iOS
			area.style.fontSize = '12pt';
			// Reset box model
			area.style.border = '0';
			area.style.padding = '0';
			area.style.margin = '0';
			// Move element out of screen horizontally
			area.style.position = 'absolute';
			area.style.left = '-9999px';
			// Move element to the same position vertically
			var yPosition = window.pageYOffset || document.documentElement.scrollTop;
			area.style.top = yPosition + "px";
			
			area.setAttribute('readonly', '');
			area.value = typeof(content) == "string" ? content : JSON.stringify(content);
			document.body.appendChild(area);
			area.select();
			document.execCommand("copy");
		}
	},
	deepClone: function(original) {
		return JSON.parse(JSON.stringify(original));	
	},
	clone: function(original) {
		if (original instanceof Array) {
			return original.map(function(single) {
				return nabu.utils.objects.clone(single);
			});
		}
		else if (typeof(original) != "object" || original == null) {
			return original;
		}
		else {
			var copy = {};
			nabu.utils.objects.merge(copy, original);
			return copy;
		}
	},
	retain: function(original, values) {
		for (var key in original) {
			if (values.indexOf(key) < 0) {
				delete original[key];
			}
		}
		return original;
	},
	remove: function(original, values) {
		for (var key in original) {
			if (values.indexOf(key) >= 0) {
				delete original[key];
			}
		}
		return original;
	},
	merge: function(original) {
		if (original instanceof Array) {
			var args = [];
			// the arguments aren't really an array, can't use default merge stuff
			for (var i = 1; i < arguments.length; i++) {
				args.push(arguments[i]);
			}
			// for each entry in the original, perform a merge
			for (var i = 0; i < original.length; i++) {
				args.unshift(original[i]);
				nabu.utils.objects.merge.apply(null, args);
				args.shift();
			}
		}
		else {
			for (var i = 1; i < arguments.length; i++) {
				if (arguments[i]) {
					var overwrite = typeof(arguments[i].$overwrite) == "undefined" ? true : arguments[i].$overwrite;
					for (var key in arguments[i]) {
						if (key == "$overwrite") {
							continue;
						}
						if (arguments[i][key] instanceof Array) {
							if (overwrite) {
								original[key] = arguments[i][key];
							}
							else {
								if (!original[key]) {
									original[key] = [];
								}
								nabu.utils.arrays.merge(original[key], arguments[i][key]);
							}
						}
						// typeof(null) is object
						else if (typeof arguments[i][key] == "object" && arguments[i][key] != null && !(arguments[i][key] instanceof Date)) {
							if (!original[key]) {
								original[key] = arguments[i][key];
							}
							else {
								nabu.utils.objects.merge(original[key], arguments[i][key]);
							}
						}
						else if (typeof arguments[i][key] != "undefined") {
							if (!original[key] || overwrite) {
								original[key] = arguments[i][key];
							}
						}
					}
				}
			}
		}
	},
	get: function(original, path, separator) {
		if (!separator) {
			separator = "/";
		}
		var parts = path.split(separator);
		for (var i = 0; i < parts.length; i++) {
			original = original[parts[i]];
			if (!original) {
				break;
			}
		}
		return original ? original : null;
	}
};

if (!nabu) { nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }

nabu.utils.stage = function(object, parameters) {
	if (!parameters) {
		parameters = {};
	}
	if (!parameters.observer) {
		// defaults to the vuejs observer
		parameters.observer = function(context) {
			if (context.__ob__ && context.__ob__.dep && context.__ob__.dep.notify) {
				context.__ob__.dep.notify();
			}
		}
	}
	if (object instanceof Array) {
		// default merge true
		if (typeof(parameters.added) == "undefined") {
			parameters.added = true;
		}
		// default merge removed
		if (typeof(parameters.removed) == "undefined") {
			parameters.removed = true;
		}
		// default merge removed
		if (typeof(parameters.spliced) == "undefined") {
			parameters.spliced = true;
		}

		var shim = [];
		shim.$original = object;
		shim.$changed = function() {
			var changed = (shim.pushed && shim.pushed.length)
				|| (shim.unshifted && shim.unshifted.length)
				|| (shim.popped && shim.popped.length)
				|| (shim.shifted && shim.shifted.length)
				|| (shim.spliced && shim.spliced.length);
			// if no changes exist at this level, go deep
			if (!changed) {
				for (var i = 0; i < shim.length; i++) {
					changed = changed || (!!shim[i].$changed && shim[i].$changed());
					if (changed) {
						break;
					} 
				}
			}
			return changed;
		}
		var initialize = function() {
			for (var i = 0; i < object.length; i++) {
				if (!parameters.shallow && (object[i] instanceof Array || typeof(object[i]) == "object") && !(object[i] instanceof Date)) {
					shim.push(nabu.utils.stage(object[i], parameters));
				}
				else {
					shim.push(object[i]);
				}
			}
			shim.pushed = [];
			shim.unshifted = [];
			shim.popped = [];
			shim.shifted = [];
			shim.spliced = [];
		};
		initialize();
		if (parameters.added) {
			// wrap the push
			var oldPush = shim.push;
			shim.push = function() {
				shim.pushed.push.apply(shim.pushed, arguments);
				oldPush.apply(shim, arguments);
				if (shim.__ob__) {
					shim.__ob__.observeArray(arguments);
				}
				parameters.observer(shim);
			};
			// wrap the unshift
			var oldUnshift = shim.unshift;
			shim.unshift = function() {
				shim.unshifted.push.apply(shim.unshifted, arguments);
				oldUnshift.apply(shim, arguments);
				if (shim.__ob__) {
					shim.__ob__.observeArray(arguments);
				}
				parameters.observer(shim);
			};
		}
		if (parameters.removed) {
			// wrap the pop
			var oldPop = shim.pop;
			shim.pop = function() {
				var popped = oldPop.apply(shim);
				if (popped) {
					shim.popped.push(popped);
					parameters.observer(this);
				}
			};
			// wrap the shift
			var oldShift = shim.shift;
			shim.shift = function() {
				shim.shifted.push(oldShift.apply(shim));
				parameters.observer(this);
			};
		}
		// if we are not staging the removal but we are staging the adding, it is possible something is added and removed in the staging area
		// but later applied because the added is still being done
		else if (parameters.added) {
			var oldPop = shim.pop;
			shim.pop = function() {
				var popped = oldPop.apply(shim);
				var stageIndex = shim.pushed.indexOf(popped);
				if (stageIndex >= 0) {
					shim.pushed.splice(stageIndex, 1);
				}
				stageIndex = shim.unshifted.indexOf(popped);
				if (stageIndex >= 0) {
					shim.unshifted.splice(stageIndex, 1);
				}
			};
			// wrap the shift
			var oldShift = shim.shift;
			shim.shift = function() {
				var shifted = oldShift.apply(shim);
				var stageIndex = shim.pushed.indexOf(shifted);
				if (stageIndex >= 0) {
					shim.pushed.splice(stageIndex, 1);
				}
				stageIndex = shim.unshifted.indexOf(shifted);
				if (stageIndex >= 0) {
					shim.unshifted.splice(stageIndex, 1);
				}
			};
		}
		if (parameters.spliced) {
			// splice is slightly tricker so use with caution
			var oldSplice = shim.splice;
			shim.oldSplice = oldSplice;
			shim.splice = function(index, length) {
				var args = [];
				for (var i = 2; i < arguments.length; i++) {
					args.push(arguments[i]);
				}
				shim.spliced.push({
					starting: shim[index],
					added: args,
					removed: oldSplice.apply(shim, arguments)
				});
				if (args.length && shim.__ob__) {
					shim.__ob__.observeArray(arguments);
				}
				parameters.observer(this);
			};
		}
		else {
			var oldSplice = shim.splice;
			shim.splice = function(index, length) {
				var removed = oldSplice.apply(shim, arguments);
				for (var i = 0; i < removed.length; i++) {
					var index = object.indexOf(removed[i].$original ? removed[i].$original : removed[i]);
					if (index >= 0) {
						object.splice(index, 1);
					}
					// remove from staging if necessary
					var stageIndex = shim.pushed.indexOf(removed[i]);
					if (stageIndex >= 0) {
						shim.pushed.splice(stageIndex, 1);
					}
					stageIndex = shim.unshifted.indexOf(removed[i]);
					if (stageIndex >= 0) {
						shim.unshifted.splice(stageIndex, 1);
					}
				}
				var args = [];
				for (var i = 2; i < arguments.length; i++) {
					args.push(arguments[i]);
				}
				if (args.length && shim.__ob__) {
					shim.__ob__.observeArray(arguments);
				}
				parameters.observer(this);
				return removed;
			}
			shim.spliceSuperficial = function(index, length) {
				oldSplice.apply(shim, arguments);
			}
		}
		shim.$commit = function() {
			// first perform the "add" methods, to have more reference points for splicing
			if (shim.pushed) {
				for (var i = 0; i < shim.pushed.length; i++) {
					object.push(shim.pushed[i]);
				}
			}
			if (shim.unshifted) {
				for (var i = 0; i < shim.unshifted.length; i++) {
					object.unshift(shim.unshifted[i]);
				}
			}
			if (shim.spliced) {
				for (var i = 0; i < shim.spliced.length; i++) {
					var index = object.indexOf(shim.spliced[i].starting.$original ? shim.spliced[i].starting.$original : shim.spliced[i].starting);
					if (index >= 0) {
						// splice in the new stuff
						if (parameters.added) {
							object.splice.bind(object, index, 0).apply(object, shim.spliced[i].added);
						}
						// remove old stuff
						if (parameters.removed) {
							for (var j = 0; j < shim.spliced[i].removed.length; j++) {
								index = object.indexOf(shim.spliced[i].removed[j].$original ? shim.spliced[i].removed[j].$original : shim.spliced[i].removed[j]);
								if (index >= 0) {
									object.splice(index, 1);
								}
								else {
									console.log("Can not find spliced element", shim.spliced[i].removed[j]);
								}
							}
						}
					}
					else {
						console.log("Can not find splice start point", shim.spliced[i].starting);
					}
				}
			}
			if (shim.popped) {
				for (var i = 0; i < shim.popped.length; i++) {
					var index = object.indexOf(shim.popped[i].$original ? shim.popped[i].$original : shim.popped[i]);
					if (index >= 0) {
						object.splice(index, 1);
					}
					else {
						console.log("Can not find popped element", shim.shifted[i]);
					}
				}
			}
			if (shim.shifted) {
				for (var i = 0; i < shim.shifted.length; i++) {
					// new elements don't have an $original
					var index = object.indexOf(shim.shifted[i].$original ? shim.shifted[i].$original : shim.shifted[i]);
					if (index >= 0) {
						object.splice(index, 1);
					}
					else {
						console.log("Can not find shifted element", shim.shifted[i]);
					}
				}
			}
			// apply the merge where possible
			for (var i = 0; i < shim.length; i++) {
				if (shim[i].$commit) {
					shim[i].$commit();
				}
			}
			// after commit do a rollback to resync
			shim.$rollback();
		};
		shim.$rollback = function() {
			// reset elements
			if (shim.spliceSuperficial) {
				shim.spliceSuperficial(0, shim.length);
			}
			else {
				shim.splice(0, shim.length);
			}
			// reinitialize
			initialize();
		};
		return shim;
	}
	else if (typeof(object) == "object" && !(object instanceof Date)) {
		// create a new object to hold updates
		var shim = {};
		shim.$original = object;
		shim.$rollback = function() {
			for (var key in object) {
				var ignoreField = parameters.ignoreFields && parameters.ignoreFields.indexOf(key) >= 0;
				// recursively shim
				if (!ignoreField && object[key] != null && (object[key] instanceof Array || typeof(object[key]) == "object") && !(object[key] instanceof Date)) {
					shim[key] = nabu.utils.stage(object[key], parameters);
				}
				else {
					shim[key] = object[key];
				}
			}
		}
		shim.$changed = function() {
			var changed = false;
			for (var key in shim) {
				if (shim[key] && shim[key].$changed) {
					changed = shim[key].$changed();
				}
				// skip hidden fields for comparison
				else if (key.substring(0, 1) != "$") {
					changed = object[key] != shim[key];
				}
				if (changed) {
					break;
				}
			}
			return changed;
		}
		// sync it
		shim.$rollback();
		shim.$commit = function() {
			// merge the new stuff in
			for (var key in shim) {
				// don't merge back inserted
				if (key.substring(0, 1) == "$") {
					continue;
				}
				if (shim[key] != null && shim[key].$commit && (shim[key] instanceof Array || typeof(shim[key]) == "object")) {
					shim[key].$commit();
				}
				else {
					object[key] = shim[key];
				}
			}
			// after commit do a rollback to resync
			shim.$rollback();
		}
		return shim;
	}
	else {
		throw "Can only shim arrays of objects or objects";
	}
};

if (Vue && Vue.mixin) {
	Vue.mixin({
		computed: {
			$stage: function() { return nabu.utils.stage }
		}
	});
}

if (!nabu) { nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }

nabu.utils.arrays = {
	merge: function(original) {
		for (var i = 1; i < arguments.length; i++) {
			if (arguments[i] instanceof Array) {
				for (var j = 0; j < arguments[i].length; j++) {
					original.push(arguments[i][j]);
				}
			}
			else if (typeof arguments[i] != "undefined") {
				original.push(arguments[i]);
			}
		}
		return original;
	},
	offer: function(original) {
		for (var i = 1; i < arguments.length; i++) {
			if (arguments[i] instanceof Array) {
				for (var j = arguments[i].length - 1; j >= 0; j--) {
					original.unshift(arguments[i][j]);
				}
			}
			else if (typeof arguments[i] != "undefined") {
				original.unshift(arguments[i]);
			}
		}
		return original;
	},
	remove: function(array) {
		for (var i = 1; i < arguments.length; i++) {
			if (arguments[i] instanceof Array) {
				for (var j = 0; j < arguments[i].length; j++) {
					nabu.utils.arrays.remove(array, arguments[i][j]);
				}
			}
			else {
				var index = array.indexOf(arguments[i]);
				if (index >= 0) {
					array.splice(index, 1);
				}
			}
		}
	},
	flatten: function(array, field, includeUndefined) {
		var results = [];
		for (var i = 0; i < array.length; i++) {
			if (array[i][field] || includeUndefined) {
				results.push(array[i][field]);
			}
		}
		return results;
	},
	find: function(array, parameters, amount) {
		if (typeof amount == "undefined") {
			amount = 1;
		}
		var results = [];
		for (var i = 0; i < array.length; i++) {
			var matches = true;
			for (var key in parameters) {
				if ((parameters[key] instanceof Array && parameters[key].indexOf(array[i][key]) < 0) || (!(parameters[key] instanceof Array) && array[i][key] != parameters[key])) {
					matches = false;
					break;
				}
			}
			if (matches) {
				results.push(array[i]);
			}
			if (amount != 0 && results.length >= amount) {
				break;
			}
		}
		if (amount == 1) {
			return results.length == 0 ? null : results[0];
		}
		else {
			return results;
		}
	},
	clear: function(array) {
		array.splice(0, array.length);
	},
	unique: function(array) {
		return array.filter(function(value, index, self) {
			// only allow it if it is the first occurence
			return self.indexOf(value) === index;
		});
	},
	hash: function(array, hasher) {
		return array.reduce(function(result, x) {
			var hash = hasher(x);
			if (!result[hash]) {
				result[hash] = [];
			}
			result[hash].push(x);
			return result;
		}, {});
	}
};

if (!nabu) { nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }

nabu.utils.string = {
	quotePattern: function(pattern) {
		var special = /([\[\]\^\$\|\(\)\\\+\*\?\{\}\=\!])/gi;
		return pattern.replace(special, '\\$1');
	}
};
if (!nabu) { nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }

nabu.utils.elements = {
	first: function(element) {
		if (element.firstChild) {
			var child = element.firstChild;
			while (child) {
				if (child.nodeType === 1) {
					return child;
				}
				child = child.nextSibling;
			}
		}
		return null;
	},
	next: function(element) {
		if (element.nextSibling) {
			var sibling = element.nextSibling;
			while (sibling) {
				if (sibling.nodeType === 1) {
					return sibling;
				}
				sibling = sibling.nextSibling;
			}
		}
		return null;
	},
	previous: function(element) {
		if (element.previousSibling) {
			var sibling = element.previousSibling;
			while (sibling) {
				if (sibling.nodeType === 1) {
					return sibling;
				}
				sibling = sibling.previousSibling;
			}
		}
		return null;
	},
	clear: function(element) {
		var children = element.childNodes;
		for (var i = children.length - 1; i >= 0; i--) {
			var child = children.item(i);
			var locked = child && child.getAttribute && child.getAttribute("locked") == "true";
			if (!locked) {
				element.removeChild(child);
			}
		}
		/*
		while(element.firstChild) {
			element.removeChild(element.firstChild);
		}
		*/
	},
	inViewport: function(element) {
		var rect = element.getBoundingClientRect();
		return rect.top >= 0
			&& rect.left >= 0
			&& rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
			&& rect.right <= (window.innerWidth || document.documentElement.clientWidth);
	},
	sanitize: function(element, parameters) {
		var allowedTags = ["a", "b", "i", "u", "em", "strong", "h1", "h2", "h3", "h4", "h5", "h6", "h7", "p", "table", "ul", 
			"li", "tr", "td", "thead", "tbody", "th", "ol", "font", "br", "span", "div", "pre", "blockquote", "code", "img", "video", "source", "article"];
		// we dont allow the form
		if (parameters && parameters.allowFormElements) {
			allowedTags.push("input");
		}
		var allowedAttributes = ["style", "href", "target", "rel", "src", "alt", "title", "class", "colspan", "rowspan", "controls", "frameborder", "allowfullscreen"];
		return nabu.utils.elements.clean(element, allowedTags, null, allowedAttributes, null, parameters && parameters.allowDataAttributes, parameters && parameters.allowLinkIds);
	},
	clean: function(element, allowedTags, tagsToRemove, allowedAttributes, attributesToRemove, allowDataAttributes, allowLinkIds) {
		var returnAsString = false;
		// previously we checked whether or not the incoming element is a string
		// typeof(element) == "string"
		// the assumption is (presumably) that the incoming element can be either a string or a html document element
		// however, if you send in a number or a boolean or any other primitive type, it will bypass the string check and be treated like an element, which is not what we want
		// because this (in the end), means we send back the full template _with_ the additional <div> wrapper element, which simply adds complexity to the html
		if (!(element instanceof HTMLElement)) {
			returnAsString = true;
			var div = document.createElement("div");
			div.innerHTML = element;
			element = div;
		}
	
		var removeAttributes = function (child) {
			if (allowedAttributes || attributesToRemove) {
				for (var j = child.attributes.length - 1; j >= 0; j--) {
					var attr = child.attributes.item(j);
					if (allowLinkIds && attr.name.toLowerCase() == "id" && child.tagName.toLowerCase() == "a") {
						continue;
					}
					if (allowedAttributes && allowedAttributes.indexOf(attr.name) < 0) {
						if (!allowDataAttributes || attr.name.indexOf("data-") < 0) {
							child.removeAttribute(attr.name);
							continue;
						}
					}
					if (attributesToRemove && attributesToRemove.indexOf(attr.name) >= 0) {
						child.removeAttribute(attr.name);
						continue;
					}
					// in the past we removed "javascript:" only from href attributes
					// now we remove it from _all_ attributes, just to make sure. you can for example also inject it in src="" attributes for img, iframe,...
					// @2023-01-04 because we do >= 0, this may actually be slightly too broad
					// but if we check for == 0, we _have_ to trim it first
					// if this causes issues, we can change it later 
					if (attr.value.indexOf("javascript:") >= 0) {
						child.removeAttribute(attr.name);
					}
					// self contained xss prevention
					// e.g. <a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">test</a>
					// possibly no longer an issue since 2017 in all major browsers
					// again very few legitimate usecases...
					else if (attr.value.trim && attr.value.trim().indexOf("data:") == 0) {
						child.removeAttribute(attr.name);
					}
				}
			}
		};

		var recursiveStrip = function (element) {
			removeAttributes(element);
			for (var i = element.childNodes.length - 1; i >= 0; i--) {
				if (element.childNodes[i].nodeType == 1) {
					if (tagsToRemove && tagsToRemove.indexOf(element.childNodes[i].nodeName.toLowerCase()) >= 0) {
						element.removeChild(element.childNodes[i]);
					}
					else {
						recursiveStrip(element.childNodes[i]);
						if (!allowedTags || allowedTags.indexOf(element.childNodes[i].nodeName.toLowerCase()) < 0) {
							var child = element.childNodes[i];
							var insertRef = child;
							for (var j = child.childNodes.length - 1; j >= 0; j--) {
								insertRef = element.insertBefore(child.childNodes[j], insertRef);
							}
							element.removeChild(child);
						}
					}
				}
			}
		}

		var template = document.createElement("div");
		if (typeof(element) == "object" && element.nodeType === 1) {
			template.appendChild(element);
		}
		else {
			template.innerHTML = element;
		}
		recursiveStrip(template);
		return returnAsString ? element.innerHTML : template;
	},
	inlineCss: function(element, recursive, media, elementAcceptor, rules) {
		if (!elementAcceptor) {
			elementAcceptor = function(x) {
				var tagName = x.tagName.toLowerCase();
				var blacklist = ["br", "strong", "i", "b", "u", "hr", "center"];
				return blacklist.indexOf(tagName) < 0;
			}
		}
		/*// https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration
		var style = window.getComputedStyle(element, null);
		// the "style" object also has a length & item() method where you can loop over all the properties
		// however, this is currently not supported in server side rendering and in the browser it lists _everything_
		// this leads to extremely bloated inline css, it is better to target a number of properties
		var result = "";
		for (var i = 0; i < properties.length; i++) {
			if (result != "") {
				result += ";"
			}
			result += properties[i] + ":" + style.getPropertyValue(properties[i]);
		}
		element.setAttribute("test", result.replace("\"", "'"));*/
		
		if (!rules) {
			rules = nabu.utils.elements.cssRules(media);
			// we want to split the rules up, if you have a rule with a "," in the selector, make multiple rules out of it
			// this prevents us from matching a rule to an element but not knowing which part actually made the match
			// and thus not being able to deduce how specific the rule is
			if (true) {
				var splitRules = [];
				rules.forEach(function(rule) {
					var depth = 0;
					var start = 0;
					var parts = [];
					var value = rule.selectorText;
					for (var j = 0; j < rule.selectorText.length; j++) {
						if (value.charAt(j) == "(") {
							depth++;
						}
						else if (value.charAt(j) == ")") {
							depth--;
						}
						else if (value.charAt(j) == "," && depth == 0) {
							parts.push(value.substring(start, j));
							start = j + 1;
						}
					}
					parts.push(value.substring(start, value.length));
					parts.forEach(function(part) {
						if (part.trim()) {
							splitRules.push({
								selectorText: part,
								cssText: rule.cssText
							});
						}
					});
				});
				rules = splitRules;
			}
		}

		var maxLength = function(selector) {
			var max = 0;
			var parts = selector.split(/[\s]*,[\s]*/);
			for (var i = 0; i < parts.length; i++) {
				if (parts[i].length > max) {
					max = parts[i].length;
				}
			}
			return max;
		}
		var inlineAll = function() {
			var elements = [];
			var applied = [];
			rules.forEach(function(rule) {
				try {
					var nodeList = document.body.querySelectorAll(rule.selectorText);
					for (var i = 0; i < nodeList.length; i++) {
						// basic check to see if we are dealing with a node
						if (nodeList.item(i).nodeType == 1 && nodeList.item(i).hasAttribute && !nodeList.item(i).hasAttribute("original-style")) {
							var index = elements.indexOf(nodeList.item(i));
							if (index < 0) {
								index = elements.length;
								elements.push(nodeList.item(i));
								applied.push([]);
							}
							applied[index].push({selectorText: rule.selectorText, cssText: rule.cssText});
						}
					}
				}
				catch (exception) {
					console.info("Failed to run selector", rule.selectorText, exception);
				}
			});
			elements.forEach(function(element, index) {
				if (element.hasAttribute) {
					// make sure rules are in proper order
					applied[index].sort(function(a, b) {
						return maxLength(a.selectorText) - maxLength(b.selectorText);
					});
					var result = "";
					for (var i = 0; i < applied[index].length; i++) {
						if (result != "") {
							result += ";"
						}
						result += applied[index][i].cssText.replace(/.*\{[\s]*(.*)[\s]*\}.*/, "$1");
					}
					if (!element.hasAttribute("original-style")) {
						element.setAttribute("original-style", element.getAttribute("style") ? element.getAttribute("style") : " ");
					}
					if (element.getAttribute("original-style") && element.getAttribute("original-style").trim() != "") {
						result = element.getAttribute("original-style") + ";" + result;
					}
					element.setAttribute("style", result);
				}
				else {
					console.log("skipping", typeof(element), element);
				}
			});
		};
		
		if (true) {
			inlineAll();
		}
		else if (elementAcceptor(element)) {
			var css = nabu.utils.elements.css(element, rules);
			var result = "";
			for (var i = 0; i < css.length; i++) {
				if (result != "") {
					result += ";"
				}
				result += css[i].replace(/.*\{[\s]*(.*)[\s]*\}.*/, "$1");
			}
			if (!element.hasAttribute("original-style")) {
				element.setAttribute("original-style", element.getAttribute("style") ? element.getAttribute("style") : " ");
			}
			if (element.getAttribute("original-style") && element.getAttribute("original-style").trim() != "") {
				result = element.getAttribute("original-style") + ";" + result;
			}
			element.setAttribute("style", result);
		}
		
		if (false && recursive) {
			var child = nabu.utils.elements.first(element);
			while (child) {
				// skip children that are already done
				if (!child.hasAttribute("original-style")) {
					nabu.utils.elements.inlineCss(child, recursive, media, elementAcceptor, rules);
				}
				child = nabu.utils.elements.next(child);
			}
		}
	},
	cssRules: function(media) {
		var result = [];
		var sheets = document.styleSheets;
		for (var l = 0; l < sheets.length; l++) {
			try {
				var rules = sheets.item(l).rules || sheets.item(l).cssRules;
				for (var i = 0; i < rules.length; i++) {
					var rule = rules.item(i);
					if (media && rule.media) {
						var isCorrectMedia = false;
						for (var j = 0; j < rule.media.length; j++) {
							if (rule.media.item(j).toString() == media) {
								isCorrectMedia = true;
								break;
							}
						}
						if (isCorrectMedia) {
							// in new browsers, there is support for getting the rules inside the media
							var mediaRules = rule.rules || rule.cssRules;
							// otherwise we cheat
							if (!mediaRules) {
								var style = document.createElement("style");
								style.setAttribute("type", "text/css");
		//						style.appendChild(document.createTextNode(rule.cssText.replace(/@media.*?\{(.*)\}[\s]*/, "$1")));
								style.innerHTML = rule.cssText.replace(/@media.*?\{[\s]*(.*)[\s]*\}[\s]*/, "$1");
								document.head.appendChild(style);
								mediaRules = document.styleSheets[document.styleSheets.length - 1].cssRules;
								document.head.removeChild(style);
							}
							if (mediaRules) {
								for (var k = 0; k < mediaRules.length; k++) {
									if (mediaRules.item(k).selectorText) {
										result.push(mediaRules.item(k));
									}
								}
							}
						}
					}
					else if (!media) {
						if (rule.selectorText) {
							result.push(rule);
						}
					}
				}
			}
			catch(exception) {
				// ignore
			}
		}
		return result;
	},
	css: function(element, rules) {
		var result = [];
		var matches = element.matches || element.webkitMatchesSelector || element.mozMatchesSelector  || element.msMatchesSelector || element.oMatchesSelector;
		if (matches) {
			for (var i = rules.length - 1; i >= 0; i--) {
				try {
					if (matches.call(element, rules[i].selectorText)) {
						result.push({ selector: rules[i].selectorText, rule: rules[i].cssText});
					}
				}
				catch(e) {
					// we delete the rule, so we don't retry it
					rules.splice(i, 1);
				}
			}
		}
		var maxLength = function(selector) {
			var max = 0;
			var parts = selector.split(/[\s]*,[\s]*/);
			for (var i = 0; i < parts.length; i++) {
				if (matches.call(element, parts[i]) && parts[i].length > max) {
					max = parts[i].length;
				}
			}
			return max;
		}
		// we sort from least specific to most specific so if we print them out, the most specific will be last and "win"
		result.sort(function(a, b) {
			return maxLength(a.selector) - maxLength(b.selector);
		});
		return result.map(function(x) { return x.rule });
	}
};

if (!nabu) { nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }

nabu.utils.dates = {
	dayOfWeek: function(date) {
		// starts on sunday
		var day = date.getDay() - 1;
		if (day < 0) {
			day = 6;
		}
		return day;
	}, 
	months: function() {
		var months = [];
		months.push("%{date::January}");
		months.push("%{date::February}");
		months.push("%{date::March}");
		months.push("%{date::April}");
		months.push("%{date::May}");
		months.push("%{date::June}");
		months.push("%{date::July}");
		months.push("%{date::August}");
		months.push("%{date::September}");
		months.push("%{date::October}");
		months.push("%{date::November}");
		months.push("%{date::December}");
		return months;
	},
	days: function() {
		var days = [];
		days.push("%{date::Monday}");
		days.push("%{date::Tuesday}");
		days.push("%{date::Wednesday}");
		days.push("%{date::Thursday}");
		days.push("%{date::Friday}");
		days.push("%{date::Saturday}");
		days.push("%{date::Sunday}");
		return days;
	},
	addDuration: function(duration, date) {
		// laziness
		var value = duration;
		var factor = value.indexOf("-") == 0 ? -1 : 1;
		// drop the leading -
		if (factor < 0) {
			value = value.substring(1);
		}
		// the total duration in ms
		var duration = 0;
		var result = date ? new Date(date.getTime()) : new Date();
		// not supported atm
		result.setMilliseconds(0);
		// skip P
		value = value.substring(1);
		// separate date part from time part
		var parts = value.split("T");
		// check for years
		var index = parts[0].indexOf("Y");
		if (index >= 0) {
			result.setYear(result.getFullYear() + (factor * parseInt(parts[0].substring(0, index))));
			parts[0] = parts[0].substring(index + 1);
		}
		index = parts[0].indexOf("M");
		if (index >= 0) {
			result.setMonth(result.getMonth() + (factor * parseInt(parts[0].substring(0, index))));
			parts[0] = parts[0].substring(index + 1);
		}
		index = parts[0].indexOf("D");
		if (index >= 0) {
			result.setDate(result.getDate() + (factor * parseInt(parts[0].substring(0, index))));
			parts[0] = parts[0].substring(index + 1);
		}
		if (parts.length >= 2) {
			index = parts[1].indexOf("H");
			if (index >= 0) {
				result.setHours(result.getHours() + (factor * parseInt(parts[1].substring(0, index))));
				parts[1] = parts[1].substring(index + 1);
			}
			index = parts[1].indexOf("M");
			if (index >= 0) {
				result.setMinutes(result.getMinutes() + (factor * parseInt(parts[1].substring(0, index))));
				parts[1] = parts[1].substring(index + 1);
			}
			index = parts[1].indexOf("S");
			if (index >= 0) {
				result.setSeconds(result.getSeconds() + (factor * parseInt(parts[1].substring(0, index))));
				parts[1] = parts[1].substring(index + 1);
			}
		}
		return result;
	}
};

if (!nabu) { nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }

nabu.utils.gtin = {
	validate: function(code, gtinLength, countryCode) {
		var regexValidate = function (value) {
			var prefix = countryCode != null ? countryCode : "";
			var pattern = prefix + "[0-9]{" + (gtinLength - prefix.length) + "}";
			return new RegExp(pattern).test(code);
		};
		var moduloValidate = function(value) {
			var calculation = (value.substring(0, value.length - 1).split(/\B/).reduce(function(sum, x, index) { 
				var reverseIndex = value.toString().length - index;
				return sum + ((reverseIndex % 2 == 0 ? 3 : 1) * x);
			}, 0)) % 10;
			var result = (calculation + parseInt(value.substring(value.length - 1, value.length))) % 10;
			return result == 0;
		};
		return regexValidate(code) && moduloValidate(code);
	}
};
if (!nabu) { nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }

nabu.utils.jwt = {
	parse: function(token) {
		var base64Url = token.split('.')[1];
		var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
		var jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
			return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
		}).join(''));
		return JSON.parse(jsonPayload);
	}
};
if (!nabu) { var nabu = {}; }
if (!nabu.services) { nabu.services = {}; }

// parameters are:
// - definition: the string content or parsed content of the swaggerfile
// - executor: function(parameters) where parameters:
// 		host (includes scheme), method, url, headers, data, contentType, secure
nabu.services.SwaggerClient = function(parameters) {
	var self = this;
	this.swagger = null;
	this.operations = {};
	this.secure = false;
	this.host = null;
	this.executor = parameters.executor;
	this.normalize = parameters.normalize;
	this.parseError = parameters.parseError;
	this.rememberHandler = parameters.remember;
	this.remembering = false;
	this.rememberPromise = null;
	this.definitionProcessors = [];
	this.language = null;
	this.bearer = parameters.bearer;
	this.toggledFeatures = [];
	this.geoPosition = null;
	this.offlineHandler = parameters.offlineHandler;
	this.requestEnrichers = [];

	// allow global registering of request enrichers
	// it is hard to pick the _exact_ spot in the service startup sequence
	// we want to allow you to pick in as early as possible
	if (application.configuration.requestEnrichers) {
		nabu.utils.arrays.merge(self.requestEnrichers, application.configuration.requestEnrichers);
	}
	
	if (!this.executor) {
		if (nabu.utils && nabu.utils.ajax) {
			this.executor = function(parameters) {
				var language = self.language;
				if (!language) {
					language = application && application.configuration && application.configuration.applicationLanguage != 'unavailable' ? application.configuration.applicationLanguage : null;
				}
				if (language) {
					parameters.language = language;
				}
				var promise = new nabu.utils.promise();
				if (parameters.map) {
					promise.map(parameters.map);
				}
				parameters.progress = promise.onprogress;
				nabu.utils.ajax(parameters).then(function(response) {
					var raw = response;
					var contentType = response.getResponseHeader("Content-Type");
					if (contentType && contentType.indexOf("application/json") >= 0) {
						response = JSON.parse(response.responseText);
						if (parameters.definition) {
							response = nabu.utils.schema.json.normalize(parameters.definition, response, self.definition.bind(self), true, self.normalize);
						}
					}
					else if (contentType && contentType.indexOf("text/html") >= 0) {
						response = response.responseText;
					}
					else if (response.status == 204) {
						response = null;
					}
					else if (response.responseType == "blob") {
						response = response.response;
					}
					// we are never (?) interested in the original XMLHTTPRequest
					else {
						if (!response.responseText) {
							response = null;
						}
						else {
							response = response.responseText;
						}
					}
					// we want to allow you to manipulate the resulting data based on the raw response (e.g. to extract http headers)
					if (parameters.$$rawMapper) {
						response = parameters.$$rawMapper(response, raw);
					}
					// TODO: are you ever interested in anything else but the response text?
					promise.resolve(response);
				}, function(error) {
					// if we have an offline handler, call it
					if ((error.status == 502 || error.status == 503) && self.offlineHandler) {
						self.offlineHandler(error);
					}
					var requireAuthentication = error.status == 401;
					// for blob we do not get a responseText and this errors out
					// instead we get a response of type blob
					// TODO: we could still parse this blob as JSON because it contains json but I will implement this as needed
					if (self.parseError && (!parameters || parameters.responseType != "blob")) {
						var contentType = error.getResponseHeader("Content-Type");
						if (contentType && (contentType.indexOf("application/json") >= 0 || contentType.indexOf("application/problem+json") >= 0)) {
							error = JSON.parse(error.responseText);
						}
					}
					var rememberSuccess = function() {
						parameters.remember = true;
						// if we finalized the remember, our bearer token may have been updated!
						// make sure we use the correct one, the parameters might have none or an old one
						if (self.bearer) {
							parameters.bearer = self.bearer;
						}
						self.executor(parameters).then(
							function(response) {
								promise.resolve(response);
							},
							function(error) {
								promise.reject(error);
							});
					};
					var rememberFailure = function() {
						promise.reject(error);
					};
					// if we are currently not remembering, start a cycle
					if (requireAuthentication && !parameters.remember && self.rememberHandler && !self.remembering && !parameters.$$skipRemember) {
						self.remembering = true;
						self.rememberPromise = new nabu.utils.promise();
						self.rememberHandler().then(
							function() {
								self.rememberPromise.resolve();
								self.remembering = false;
								rememberSuccess();
							},
							function(error) {
								self.rememberPromise.resolve();
								self.remembering = false;
								rememberFailure(error);
							});
					}
					// if we are remembering, use the promise
					else if (requireAuthentication && !parameters.remember && self.remembering && !parameters.$$skipRemember) {
						self.rememberPromise.then(
							rememberSuccess,
							rememberFailure);
					}
					else {
						promise.reject(error);
					}
				});
				return promise;
			};
		}
		else {
			throw "No executor";
		}
	}
	
	this.remember = function() {
		if (self.rememberHandler) {
			self.remembering = true;
			self.rememberPromise = new nabu.utils.promise();
			return self.rememberHandler().then(
				function() {
					self.rememberPromise.resolve();
					self.remembering = false;
				},
				function() {
					self.rememberPromise.resolve();
					self.remembering = false;
				}
			);
		}
		else {
			var promise = new nabu.utils.promise();
			promise.reject();
			return promise;
		}
	}

	this.loadDefinition = function(definition) {
		this.swagger = typeof(definition) == "string" ? JSON.parse(definition) : definition

		if (this.swagger.swagger != "2.0") {
			throw "Only swagger 2.0 is currently supported";	
		}

		this.operations = {};
		if (this.swagger && this.swagger.paths) {
			Object.keys(self.swagger.paths).forEach(function (path) {
				Object.keys(self.swagger.paths[path]).forEach(function (method) {
					var operation = self.swagger.paths[path][method];
					self.operations[operation.operationId] = {
						id: operation.operationId,
						parameters: operation.parameters,
						path: path,
						method: method,
						responses: operation.responses,
						consumes: operation.consumes,
						produces: operation.produces,
						security: operation.security,
						tags: operation.tags,
						summary: operation.summary
					}
					// we want to add extensions as well cause this can expose additional features available
					Object.keys(self.swagger.paths[path][method]).forEach(function(key) {
						if (key.indexOf("x-") == 0) {
							self.operations[operation.operationId][key] = self.swagger.paths[path][method][key];
						}
					});
				});
			});
		}
		this.secure = this.swagger.schemes.indexOf("https") >= 0;
		this.host = this.swagger.host && parameters.useHost ? (this.secure ? "https://" : "http://") + this.swagger.host : null;
		for (var i = 0; i < this.definitionProcessors.length; i++) {
			this.definitionProcessors[i](self);
		}
	}
	
	this.addDefinitionProcessor = function(processor) {
		if (Object.keys(this.operations).length) {
			processor(self);
		}
		this.definitionProcessors.push(processor);
	}
	
	
	// load the initial definition
	if (parameters.definition) {
		this.loadDefinition(parameters.definition);
	}
	
	this.operation = function(name) {
		return self.operations[name];
	};
	
	this.parameters = function(name, parameters) {
		if (!self.operations[name]) {
			throw "Unknown operation: " + name;
		}
		var operation = self.operations[name];
		var path = operation.path;
		if (self.swagger.basePath && self.swagger.basePath != "/") {
			path = self.swagger.basePath + (path.substring(0, 1) == "/" ? "" : "/") + path;
		}
		if (path.substring(0, 1) != "/") {
			path = "/" + path;
		}
		var query = {};
		var headers = {};
		var data = null;
		var pathParameters = {};
		
		for (var i = 0; i < operation.parameters.length; i++) {
			// we don't check header parameters as they may be injected by the browser and or ajax library
			if (operation.parameters[i].required && operation.parameters[i].in != "header" && (!parameters || typeof(parameters[operation.parameters[i].name]) == "undefined" || parameters[operation.parameters[i].name] == null)) {
				throw "Missing required parameter for " + name + ": " + operation.parameters[i].name;
			}
			if (parameters && parameters.hasOwnProperty(operation.parameters[i].name)) {
				var value = parameters[operation.parameters[i].name];
				if (operation.parameters[i].schema) {
					value = this.format(operation.parameters[i].schema, value);
				}
				// for query parameters etc, they might not have a schema
				else if (operation.parameters[i].type) {
					value = this.format(operation.parameters[i], value);
				}
				if (value instanceof Array) {
					var collectionFormat = operation.parameters[i].collectionFormat ? operation.parameters[i].collectionFormat : "csv";
					// the "multi" collection format is handled by the query part (the only one who currently supports it)
					if (collectionFormat != "multi") {
						var result = "";
						for (var j = 0; j < value.length; j++) {
							if (result.length > 0) {
								if (collectionFormat == "csv") {
									result += ",";
								}
								else if (collectionFormat == "ssv") {
									result += " ";
								}
								else if (collectionFormat == "tsv") {
									result += "\t";
								}
								else if (collectionFormat == "pipes") {
									result += "|";
								}
								else {
									throw "Unsupported collection format: " + collectionFormat;
								}
							}
							result += encodeURIComponent(value[j]);
						}
						value = result;
					}
				}
				if (operation.parameters[i].in == "path") {
					path = path.replace(new RegExp("\{[\\s]*" + operation.parameters[i].name + "[^}]*\}"), value);
					pathParameters[operation.parameters[i].name] = value;
				}
				else if (value != null && value !== "" && typeof(value) != "undefined") {
					if (operation.parameters[i].in == "query") {
						if (value != null) {
							query[operation.parameters[i].name] = value;
						}
					}
					else if (operation.parameters[i].in == "header") {
						if (value != null) {
							headers[operation.parameters[i].name] = value;
						}
					}
					else if (operation.parameters[i].in == "body") {
						data = value;
					}
					else {
						throw "Invalid 'in': " + operation.parameters[i].in;
					}
				}
			}
		}

		Object.keys(query).forEach(function (key) {
			if (query[key] instanceof Array) {
				for (var i = 0; i < query[key].length; i++) {
					// don't include null values
					if (query[key][i] != null) {
						path += path.indexOf("?") >= 0 ? "&" : "?";
						path += encodeURIComponent(key) + "=" + encodeURIComponent(query[key][i]);
					}
				}
			}
			else if (query[key] != null) {
				path += path.indexOf("?") >= 0 ? "&" : "?";
				path += encodeURIComponent(key) + "=" + encodeURIComponent(query[key]);
			}
		});
		
		var definition = operation.responses && operation.responses[200] ? operation.responses[200].schema : null;
		if (definition && definition.$ref) {
			definition = this.definition(definition.$ref);
		}
		var result = {
			method: operation.method,
			host: self.host,
			url: path,
			data: data,
			headers: headers,
			definition: definition,
			path: pathParameters,
			query: query
		};
		// even if no security is explicitly required, it can be interesting to pass it along
		// the service might want to differentiate internally
		if (self.bearer) { // operation.security
			result.bearer = self.bearer;
		}
		if (self.geoPosition) {
			result.headers["Geo-Position"] = self.geoPosition.latitude + ";" + self.geoPosition.longitude;
		}
		self.requestEnrichers.forEach(function(x) {
			x(result);	
		});
		// if the operation only accepts octet-stream, let's do that
		if (operation.consumes && operation.consumes.length == 1 && operation.consumes[0] == "application/octet-stream") {
			result.contentType = "application/octet-stream";
		}
		if (self.toggledFeatures.length) {
			result.headers.Feature = "";
			self.toggledFeatures.forEach(function(x) {
				if (result.headers.Feature != "") {
					result.headers.Feature += ";";
				}
				result.headers.Feature += x.name + "=" + (x.enabled == true);
			});
		}
		// added solely for readability in development
		if (application && application.configuration && application.configuration.development) {
			result.headers["X-Service-Id"] = name;
		}
		if (parameters && parameters["$serviceContext"] && parameters["$serviceContext"] != "default") {
			result.headers["X-Service-Context"] = parameters["$serviceContext"];
		}
		if (parameters && parameters["$accept"]) {
			result.headers["Accept"] = parameters["$accept"];
		}
		return result;
	};
	
	this.execute = function(name, parameters, map, async) {
		var operation = self.operations[name];
		if (!operation) {
			throw "Can not resolve operation: " + name;
		}
		else if (!operation.hasOwnProperty("isBinary")) {
			var isBinary = false;
			if (operation.responses["200"]) {
				var response = operation.responses["200"];
				var schema = null;
				if (response && response.schema) {
					schema = self.resolve(response.schema);
					if (schema) {
						isBinary = schema.type == "string" && schema.format == "binary";
					}
				}
			}
			operation.isBinary = isBinary;
		}
		if (operation.executor) {
			return operation.executor(parameters, map);
		}
		else {
			var executorParameters = self.parameters(name, parameters);
			if (map) {
				executorParameters.map = map;
			}
			if (async != null) {
				executorParameters.async = async;
			}
			if (parameters && parameters.$$rawMapper) {
				executorParameters.$$rawMapper = parameters.$$rawMapper;
			}
			if (parameters && parameters.$$skipRemember) {
				executorParameters.$$skipRemember = parameters.$$skipRemember;
			}
			if (operation.isBinary) {
				executorParameters.responseType = "blob";
			}
			else if (parameters && parameters["$responseType"]) {
				executorParameters.responseType = parameters["$responseType"];
			}
			return self.executor(executorParameters);
		}
	};
	
	this.format = function(definition, value) {
		if (definition.$ref) {
			definition = this.definition(definition.$ref);
		}
		return nabu.utils.schema.json.format(definition, value, self.definition.bind(self));
	};
	
	this.definition = function(ref) {
		if (ref.indexOf("#/definitions/") == 0) {
			ref = ref.substring("#/definitions/".length);
		}
		var definition = this.swagger.definitions[ref];
		if (!definition) {
			throw "Could not find definition: " + ref;
		}
		return definition;
	};
	
	this.resolve = function(element, resolved) {
		if (!resolved) {
			return this.resolve(element, {});
		}
		if (typeof(element) == "string") {
			element = this.definition(element);
		}
		var self = this;
		if (element.schema && element.schema["$ref"]) {
			element = nabu.utils.objects.deepClone(element);
			if (!resolved[element.schema["$ref"]]) {
				resolved[element.schema["$ref"]] = this.resolve(this.definition(element.schema["$ref"]), resolved);
			}
			element.schema = resolved[element.schema["$ref"]];
		}
		else if (element.items && element.items["$ref"]) {
			element = nabu.utils.objects.deepClone(element);
			if (!resolved[element.items["$ref"]]) {
				resolved[element.items["$ref"]] = this.resolve(this.definition(element.items["$ref"]), resolved);
			}
			element.items = resolved[element.items["$ref"]];
		}
		// if you have an inline array (so without ref), we still want to recursively resolve any definitions withing
		else if (element.items && element.items.properties) {
			element = nabu.utils.objects.deepClone(element);
			Object.keys(element.items.properties).map(function(key) {
				element.items.properties[key] = self.resolve(element.items.properties[key], resolved);
			});
		}
		else if (element["$ref"]) {
			if (!resolved[element["$ref"]]) {
				resolved[element["$ref"]] = this.resolve(this.definition(element["$ref"]), resolved);
			}
			return resolved[element["$ref"]];
		}
		else if (element.properties) {
			element = nabu.utils.objects.deepClone(element);
			Object.keys(element.properties).map(function(key) {
				element.properties[key] = self.resolve(element.properties[key], resolved);
			});
		}
		return element;
	}
	
	return this;
};

// parameters should contain a list of "swaggers" definitions in either string or JSON format
nabu.services.SwaggerBatchClient = function(parameters) {
	var self = this;
	this.clients = [];

	// load all the swagger clients
	for (var i = 0; i < parameters.swaggers.length; i++) {
		this.clients.push(new nabu.services.SwaggerClient({
			definition: parameters.swaggers[i],
			executor: parameters.executor
		}));
	}
	
	// dispatch to the correct swagger client
	this.execute = function(name, parameters) {
		for (var i = 0; i < self.clients.length; i++) {
			if (self.clients[i].operations[name]) {
				return self.clients[i].execute(name, parameters);
			}
		}
		throw "Unknown operation: " + name;
	};
	
	this.parameters = function(name, parameters) {
		for (var i = 0; i < self.clients.length; i++) {
			if (self.clients[i].operations[name]) {
				return self.clients[i].parameters(name, parameters);
			}
		}
		throw "Unknown operation: " + name;	
	};
};



if (!nabu) { var nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }
if (!nabu.handlers) { nabu.handlers = {}; }

// set default handlers for ajax
nabu.handlers.ajax = {
	error: function(request) {
		if (request.status != 0) {
			console.log("Could not fullfill ajax request", request);
		}
	},
	success: function(request) {
		if (request.target) {
			document.getElementById(request.target).innerHTML = request.responseText;
		}
	}
};

/**
parameters:
	host: the host server (e.g. for mobile apps)
	url: the target
	method: GET, POST,...
	user, pass,
	async (false does not work on firefox 3+?)
	opened: the handler for when the connection is opened
	sent: the handler for when the request is sent
	loading: the handler for when the request is loading
	completed: the handler for when the request is completed
	success: the handler for when completed successfully
	error: the handler for when completed unsuccessfully
	headers: any headers you want to pass along in an associative form
	target: the default "success" handler will see if there is a target, if so, it will put the response directly into that element
	data: the data to be sent to the target (for post requests this should be in the same form as GET: key=value&key2=value2...)
	params: an associative array which acts as data in a post and url parameters in a get
	contentType: the content type of the data,
	binary: boolean to indicate whether content should be sent as binary blob (automatically set for image content types),
	progress: a handler that is triggered periodically on progress of request,
	cache: false: whether or not to cache the result
	language: the language you want to set
	bearer: the bearer token you want to set (if any)
*/
nabu.utils.ajax = function(parameters) {
	var enableCaching = false;
	var newXmlHttpRequest = function() {
		if (window.XMLHttpRequest) {
			// code for IE7+, Firefox, Chrome, Opera, Safari
			return new window.XMLHttpRequest();
		}
		else {
			// code for IE6, IE5
			try {
				return new ActiveXObject("Msxml2.XMLHTTP");
			}
			catch (e1) {
				try {
					return new ActiveXObject("Microsoft.XMLHTTP");
				}
				catch (e2) {
					try {
						return new ActiveXObject("Msxml2.XMLHTTP.6.0");
					}
					catch (e3) {
						return new ActiveXObject("Msxml2.XMLHTTP.3.0");
					}
				}
			}
		}
		throw "Could not get request";
	}

	var request = newXmlHttpRequest();

	if (parameters.responseType) {
		request.responseType = parameters.responseType;
	}

	if (!parameters.url) {
		throw "Could not find url";
	}

	// in mobile mode, we want to explicitly target the server
	// this is one of the few references where we keep the server-replacement of variables because this is baked into the building process
	if (!parameters.host && false) {
		parameters.host = "${environment('url')}";
	}

	// if we have a host, prefix it to the url
	if (parameters.host) {
		var host = parameters.host;
		// does not end with a "/"
		if (host.indexOf("/", host.length - 1) < 0) {
			host += "/";
		}
		// the host ends with "/", so we need to make sure the url does not start with it
		if (parameters.url.substring(0, 1) == "/") {
			parameters.url = host + parameters.url.substring(1);
		}
		else {
			parameters.url = host + parameters.url;
		}
	}

	if (!parameters.method) {
		parameters.method = "GET";
	}
	else {
		parameters.method = parameters.method.toUpperCase();
	}

	if (parameters.parameters) {
		var tmp = "";
		for (var key in parameters.parameters) {
			tmp += (tmp == "" ? "" : "&") + encodeURIComponent(key) + "=" + encodeURIComponent(parameters.parameters[key]);
		}
		// if it's a get or something else with data attached, append them to
		// the url, this assumes no "?"
		if (parameters.method == "GET" || parameters.data) {
			parameters.url += "?" + tmp;
		}
		// otherwise it's data
		else {
			parameters.data = tmp;
		}
	}

	if (parameters.async == null) {
		parameters.async = true;
	}

	// apparently opera can not handle "null" being sent, so check
	// note that firefox does not seem to accept "false" (meaning synchronous)
	// communication
	if (parameters.user) {
		request.open(parameters.method.toUpperCase(), parameters.url, parameters.async, parameters.user, parameters.pass);
	}
	else {
		request.open(parameters.method.toUpperCase(), parameters.url, parameters.async);
	}

	var acceptHeader = false;
	if (parameters.headers) {
		for (var key in parameters.headers) {
			request.setRequestHeader(key, parameters.headers[key]);
			if (key.toUpperCase() == "ACCEPT") {
				acceptHeader = true;
			}
		}
	}

	if (parameters.target) {
		request.target = parameters.target;
	}

	var promise = new nabu.utils.promise(parameters);
	
	// the request.onprogress gets a single "event" parameter which has:
	// event.loaded  the amount of data currently transfered
	// event.total  the total amount of data to be transferred
	var progressFunction = null;
	if (parameters.progress) {
		progressFunction = parameters.progress;
	}
	else {
		progressFunction = promise.onprogress;
	}
	
	// if we have a progress function, we need to register it either for the upload side or the download side
	// when we do a GET, we assume the download can be big (e.g. downloading a file)
	// otherwise, we assume the request to be big
	if (progressFunction) {
		if (parameters.method == null || parameters.method.toUpperCase() == "GET") {
			request.onprogress = progressFunction;
		}
		else {
			request.upload.onprogress = progressFunction;
		}
	}

	// in the future we may not want to abort the request if there are multiple promise subscribers
	// or if the promise has already been completed
	// in that case we should only cancel the request if all subscribers want it cancelled
	promise.cancel(function(reason) {
		request.abort();
	});
	
	request.onreadystatechange = function() {
		switch (request.readyState) {
			case 0:
				// not initialized, do nothing
			break;
			// request set up
			case 1:
				if (parameters.opened) {
					parameters.opened(request);
				}
			break;
			// request sent
			case 2:
				if (parameters.sent) {
					parameters.sent(request);
				}
			break;
			// started loading response
			case 3:
				if (parameters.loading) {
					parameters.loading(request);
				}
			break;
			// response loaded
			case 4:
				if (request.status >= 200 && request.status < 300) {
					// if we have an etag, cache it as well
					if (enableCaching && (parameters.cache || request.getResponseHeader("ETag")) && request.responseText) {
						var key = JSON.stringify(parameters);
						localStorage.setItem(key, JSON.stringify({
							status: request.status,
							statusText: request.statusText,
							responseText: request.responseText,
							contentType: request.getResponseHeader("Content-Type")
						}));
					}
					if (parameters.success) {
						parameters.success(request);
					}
					else if (parameters.completed) {
						parameters.completed(request);
					}
					else if (nabu.handlers.ajax.success) {
						nabu.handlers.ajax.success(request);
					}
					promise.succeed(request);
				}
				// this indicates that the http request was aborted
				// seems to be the response in case of offline - tested in airplane mode on android
				else if (request.status == 0) {
					var responded = false;
					var response = null;
					// always check cache
					if (enableCaching) {
						var key = JSON.stringify(parameters);
						response = localStorage.getItem(key);
					}
					if (response != null) {
						responded = true;
						var result = JSON.parse(response);
						result.getResponseHeader = function(header) {
							if (header.toLowerCase() == "content-type") {
								return result.contentType;
							}
							return null;
						};
						promise.resolve(result);
					}
					if (parameters.cancelled && !responded) {
						parameters.cancelled(request);
					}
					if (!responded) {
						promise.fail(request);
					}
				}
				else {
					if (parameters.error) {
						parameters.error(request);
					}
					else if (parameters.completed) {
						parameters.completed(request);
					}
					else if (nabu.handlers.ajax.error) {
						nabu.handlers.ajax.error(request);
					}
					promise.fail(request);
				}
			break;
		}
	}

	if (!acceptHeader) {
		request.setRequestHeader("Accept", "application/json");		//, text/html
	}

	// encoding file/blob to base64 is async, need a promise to contain it
	var encodingPromises = [];
	var encodingPromise = null;
	
	// need to add these headers for post
	if (parameters.method.toUpperCase() == "POST" || parameters.method.toUpperCase() == "PUT" || parameters.method.toUpperCase() == "DELETE" || parameters.method.toUpperCase() == "PATCH") {
		// if we are sending an object as data, jsonify it
		if (parameters.data && typeof(parameters.data) == "object" && !(parameters.data instanceof File) && !(parameters.data instanceof Blob)) {
			var isObject = function(object) {
				return object != null && typeof(object) == "object" && !(object instanceof File) && !(object instanceof Blob) 
					&& !(object instanceof Date) && !(object instanceof Array);
			}
			var baseEncode = function(object) {
				var keys = Object.keys(object);
				keys.filter(function(key) { return object[key] instanceof Blob || object[key] instanceof File }).map(function(key) {
					var reader = new FileReader();
					reader.readAsDataURL(object[key]);
					var promise = new nabu.utils.promise();
					encodingPromises.push(promise);
					reader.onload = function() {
						var result = reader.result;
						var index = result.indexOf(",");
						object[key] = result.substring(index + 1);
						promise.resolve();
					};
				});
				// encode recursively
				keys.forEach(function(key) {
					if (object[key] instanceof Array && object[key].length) {
						object[key].forEach(function(instance) {
							if (isObject(instance)) {
								baseEncode(instance);
							}
						})
					}
					else if (isObject(object[key])) {
						baseEncode(object[key]);
					}
				});
			}
			baseEncode(parameters.data);
			if (encodingPromises.length) {
				encodingPromise = new nabu.utils.promises(encodingPromises);
			}
			if (encodingPromise != null) {
				encodingPromise.then(function() {
					parameters.data = JSON.stringify(parameters.data);		
				});
			}
			else {
				parameters.data = JSON.stringify(parameters.data);
			}
			parameters.contentType = "application/json";
		}
		// @2023-04-19: if you have a file, you have metadata in some specific fields (name and type). sometimes you have a blob (e.g. resized image from a file) and you want to attach the same metadata
		else if (parameters.data instanceof Blob) {
			if (parameters.data.name) {
				request.setRequestHeader("Content-Disposition", "attachment; filename=" + parameters.data.name);
				if (!parameters.contentType || parameters.contentType == "application/octet-stream") {
					if (parameters.data.name.match(/.*\.png/i)) {
						parameters.contentType = "image/png";
					}
					else if (parameters.data.name.match(/.*\.jpg/i) || parameters.data.name.match(/.*\.jpeg/i)) {
						parameters.contentType = "image/jpeg";
					}
					else if (parameters.data.type) {
						parameters.contentType = parameters.data.type;
					}
				}
			}
			if (!parameters.contentType) {
				parameters.contentType = "application/octet-stream";
			}
		}
		if (!parameters.contentType && parameters.data) {
			parameters.contentType = "application/x-www-form-urlencoded";
		}
		if (parameters.contentType) {
			request.setRequestHeader("Content-Type", parameters.contentType);
			if (parameters.binary || (parameters.contentType.substring(0, 6) == "image/" && !(parameters.data instanceof Blob))) {
				parameters.data = nabu.utils.binary.blob(parameters.data, parameters.contentType);
			}
		}
	}
	else {
		parameters.data = null;
	}
	
	if (parameters.language) {
		request.setRequestHeader("Accept-Language", parameters.language);
	}
	
	if (parameters.bearer) {
		request.setRequestHeader("Authorization", "Bearer " + parameters.bearer);
	}
	
	if (encodingPromise != null) {
		encodingPromise.then(function() {
			request.send(parameters.data ? parameters.data : null);	
		});
	}
	else {
		request.send(parameters.data ? parameters.data : null);
	}
	return promise;
};

nabu.utils.binary = {
	blob: function(binaryData, contentType, sliceSize) {
  		contentType = contentType ? contentType : "application/octet-stream";
  		sliceSize = sliceSize ? sliceSize : 512;
		var bytes = [];
		for (var offset = 0; offset < binaryData.length; offset += sliceSize) {
			var slice = binaryData.slice(offset, Math.min(offset + sliceSize, binaryData.length));
			var byteNumbers = new Array(slice.length);
			for (var i = 0; i < slice.length; i++) {
				byteNumbers[i] = slice.charCodeAt(i);
			}

			bytes.push(new Uint8Array(byteNumbers));
		}
		return new Blob(bytes, { type: contentType });
	}
};



/*
This file contains a basic router that allows you to go to a state using an alias.
It has the ability to optionally bind an URL to a state with or without parameters.
On initial load it can deduce the state from the URL by using routeInitial();
Note that you can toggle the usage of hashtags.

A route can be registered using the register:

router.register({
	alias: "theAliasForTheRoute",
	enter: function(anchor, parameters, mask),
	url: "/path/to/{myVar}/{myOtherVar}
});

For route authorization you can register a function that has the following spec:

function(anchor, route, parameters, previousRoute, previousParameters)

It should return either a boolean indicating whether or not the route is allowed, nothing or null if it's allowed or a structured object of an alternative route:
{ 
	alias: mandatory,
	properties: if required by the alias,
	anchor: if none is given, the original anchor is used,
	mask: if none is given, the original mask boolean is used
}

When creating a router instance you can pass in a global enter method.
These global methods are called with exactly the same parameters as the route-specific enter/leaves but adds one more parameter at the end: the return of the specific enter/leave (if any)

*/

if (!nabu) { var nabu = {}; }
if (!nabu.services) { nabu.services = {}; }
if (!nabu.utils) { nabu.utils = {}; }

nabu.services.Router = function(parameters) {
	var self = this;
	this.defaultAnchor = parameters.defaultAnchor ? parameters.defaultAnchor : "main";
	this.useHash = parameters.useHash ? true : false;
	// all the routes available
	this.routes = [];
	this.enter = parameters.enter ? parameters.enter : null;
	this.unknown = parameters.unknown ? parameters.unknown : null;
	this.authorizer = parameters.authorizer ? parameters.authorizer : null;
	this.chosen = parameters.chosen ? parameters.chosen : null;
	this.useParents = parameters.useParents ? true : false;

	this.previousUrl = null;
	this.changingHash = false;
	this.initials = [];
	
	this.parents = [];
	this.urlRewriter = parameters.urlRewriter;

	window.addEventListener("popstate", function(event) {
		var state = event.state;
		var alias = state ? state.alias : null;
		var anchor = state ? state.anchor : null;
		// we want to prevent accidental hash changes from triggering a reroute
		// for a client integration they had <a> elements that updated the hashtag but this always triggered a popstate
		if (alias || !self.initials.length) {
			var initial = self.initials.pop();
			if (!alias) {
				self.routeInitial(anchor, state ? state.parameters : null, true);
			}
			else if (initial && !self.useParents) {
				self.routeAll(alias, state ? state.parameters : null, anchor, false);
			}
			else {
				// @2025-05-13: when hitting "back", the "lastRoute" in the vue service (see application.js) is NOT updated which means page builder does not correctly highlight the states in the buttons that are based on routing
				// it is unclear why "mask" was set to true here but it seems ok to set it to false again
				self.route(alias, state ? state.parameters : null, anchor, false, false, true);
			}
		}
	}, false);
	
	this.get = function(alias) {
		var routes = this.sort();
		for (var i = 0; i < routes.length; i++) {
			if (routes[i].alias == alias) {
				return routes[i];
			}
		}
		return null;
	};
	
	this.list = function(alias) {
		return this.sort();
	};

	// route to a new alias
	this.route = function(alias, parameters, anchor, mask, initial, back, embedded) {
		// we do it this way to preserve backwards compatibility
		var anchorEmpty = !anchor;
		if (!anchor) {
			anchor = self.defaultAnchor;
		}
		var chosenRoute = null;
		var routes = self.sort();
		for (var i = 0; i < routes.length; i++) {
			if (routes[i].alias == alias) {
				chosenRoute = routes[i];
				break;
			}
		}
		if (chosenRoute == null && self.unknown) {
			chosenRoute = self.unknown(alias, parameters, anchor);
		}
		if (chosenRoute == null) {
			throw "Unknown route: " + alias;
		}
		if (self.authorizer) {
			var result = self.authorizer(anchor, chosenRoute, parameters);
			if (typeof(result) == "boolean" && !result) {
				return false;
			}
			else if (typeof(result) == "object" && result) {
				return self.route(
					result.alias,
					result.parameters,
					result.anchor ? result.anchor : (anchorEmpty ? null : anchor),
					typeof(result.mask) == "undefined" ? mask : result.mask
				);
			}
		}
		
		// if we are using parents, we need the correct anchor for the chosen
		if (self.useParents && chosenRoute.parent != null && anchorEmpty) {
			var parent = self.get(chosenRoute.parent);
			if (parent && parent.defaultAnchor) {
				anchor = parent.defaultAnchor;
			}
		}
		
		// if we enable this feature, we will NOT redraw the parent if you route directly to it
		// however currently we also don't remove (from the DOM) any trailing children that were previously rendered
		// we could add that, but in other places pages also re-render if you trigger them multiple times
		// instead, at the end, we push the page to the parent stack, allowing some reuse of parents in case you route directly to them
		var routeDirectlyToParent = chosenRoute.defaultAnchor && false;
		
		var parentUrl = null;
		var parentEnter = null;
		// TODO: allow for async parents by having the routeParent return (optionally) a promise and wait on that to render the child
		// if we are in need of a parent construct for this route, build it (or reuse it)
		//if (self.useParents) {
		// @2024-10-10: we want to be able to embed items that have a parent
		// e.g. we have an "event list" page which has an "event skeleton" as parent which in turn has the basic "skeleton" as parent
		// if we then have a situation where we want to quickly embed the "event list" page, we can't without rendering all the parents as well, breaking the overall page where we are embedding
		// up until now we generally made "component" pages that had no parent and were embedded in a wrapper page
		// however, doing this retroactively, especially for a page with a lot of query parameters and other settings which all have to be mapped to that embedded component, this quickly becomes tedious
		// it is unclear if the current check correctly targets ONLY embeds of that nature
		//if (self.useParents && (anchorEmpty || anchor == "body")) {
		// @2024-10-24: the above checks breaks the "back" button if parents have to be rebuilt!
		if (self.useParents && !embedded) {
			var parentAlias = chosenRoute.parent;
			if (routeDirectlyToParent) {
				parentAlias = chosenRoute.alias;
			}
			// if it is an initial route and we don't have a parent, we want to search for a generic initial skeleton (both for backwards compatibility and less explicit configuration)
			// note that if we are doing a non-masked route on a bookmarkable url (so we are about to update the url), we _force_ the existence of a parent as well
			// this to allow us to be consistent when the bookmarkable url is refreshed upon
			if (!parentAlias && (initial || (!mask && chosenRoute.url))) {
				var initialRoute = self.getInitial(anchor, parameters, mask);
				// if we are opening that route, don't use it!
				if (initialRoute && initialRoute.route.alias != alias) {
					parentAlias = initialRoute.route.alias;
				}
				// if we don't have a parent, no hard feelings, but we assume that we need to mount in the body then
				else {
					anchor = "body";
					self.parents.splice(0);
				}
			}
			if (parentAlias) {
				var routeParent = this.routeParent(parentAlias, parameters);
				var parentAnchor = routeParent.anchor;
				parentUrl = routeParent.url;
				parentEnter = routeParent.enter;
				// if we didn't specify an anchor to route in, use the parent anchor
				if (anchorEmpty) {
					anchor = parentAnchor;
				}
				// all done!
				if (routeDirectlyToParent) {
					self.updateUrl(parentAlias, routeParent.url, parameters, chosenRoute.query, anchor);
					// make sure we return a promise to be compatible even if we rendered nothing at all!
					if (parentEnter == null) {
						parentEnter = new nabu.utils.promise();
						parentEnter.resolve();
					}
					return parentEnter;
				}
			}
			// if we have no explicit parent, we need to route in the currently available parent, that means _its_ default anchor (if any)
			else {
				if (anchorEmpty && self.parents.length > 0 && self.parents[self.parents.length - 1].defaultAnchor) {
					anchor = self.parents[self.parents.length - 1].defaultAnchor;
				}
				// if we have no noteworthy parents, root in body
				else if (anchorEmpty && self.parents.length == 0) {
					anchor = "body";
				}
			}
			
		}
		
		// the chosen might set a spinner or some such
		// if we go for an alternative with a different parent, that could pose a problem however!
		if (self.chosen) {
			var alternative = self.chosen(anchor, chosenRoute, parameters);
			if (alternative && alternative.route) {
				chosenRoute = alternative.route;
			}
			if (alternative && alternative.parameters) {
				parameters = alternative.parameters;
			}
			if (alternative && typeof(alternative.mask) != "undefined") {
				mask = alternative.mask;
			}
		}
		
		var enterReturn = chosenRoute.enter(anchor, parameters, mask, parentEnter);
		if (self.enter != null) {
			self.enter(anchor, chosenRoute, parameters, enterReturn, mask);
		}
		// update the current URL if the state has a URL attached to it (don't update if initial, we use keep using that url)
		if (chosenRoute.url && !mask && !initial && !back && !chosenRoute.initial) {
			var queryParameters = [];
			if (chosenRoute.query) {
				nabu.utils.arrays.merge(queryParameters, chosenRoute.query);
			}
			// we must remove the query parameters from the parent url, otherwise they will be preprended to the child url
			// note that we can't guarantee the child has the same query parameters so we need to readd them as well
			// also important: this fixes the situation where you are browsing in the parent skeleton, set some query parameters, then load a child page
			// it would go from
			// inbox?type=c7406e441b09448889d58cba98c0c952
			// to inbox?type=c7406e441b09448889d58cba98c0c952/detail/0966d35e233e429a9127fccc6c894d1a
			// but we wanted: inbox/detail/0966d35e233e429a9127fccc6c894d1a?type=c7406e441b09448889d58cba98c0c952
			// however, the problem that is not solved yet is if you are in the child and the parent wants to update the query parameters but the child is not aware of the query parameters...
			var indexOfQueryParams = parentUrl == null ? -1 : parentUrl.indexOf("?");
			if (indexOfQueryParams >= 0) {
				parentUrl.substring(indexOfQueryParams + 1).split("&").forEach(function(part) {
					var parts = part.split("=");
					// need key value to be able to set it
					if (parts.length == 2) {
						if (queryParameters.indexOf(parts[0]) < 0) {
							queryParameters.push(parts[0]);
						}
						// if there is no value yet in parameters, set it
						if (!parameters.hasOwnProperty(parts[0])) {
							parameters[parts[0]] = parts[1];
						}
					}
				})
				parentUrl = parentUrl.substring(0, indexOfQueryParams);
			}
			self.updateUrl(chosenRoute.alias, parentUrl == null ? chosenRoute.url : parentUrl.replace(/[/]+$/, "") + "/" + chosenRoute.url.replace(/^[/]+/, ""), parameters, queryParameters, anchor);
		}
		// the state is already correct if initial
		else if (!initial && !back && !chosenRoute.initial) {
			self.updateState(chosenRoute.alias, parameters, chosenRoute.query, anchor);
		}
		// you have to push the initial state, apparently you need to push state twice, otherwise you don't get event.state in the popstate option
		// that would mean, if you go to a initial page, then one link deep and "back", it doesn't work...
		else if (initial) {
			self.updateState(chosenRoute.alias, parameters, chosenRoute.query, anchor);
		}
		
		// we are ourselves a parent, push to the parent!
		if (chosenRoute.defaultAnchor && chosenRoute.url && !chosenRoute.initial && !routeDirectlyToParent) {
			var parentRoute = chosenRoute;
			var calculateUrlTemplate = function(route) {
				var url = route.url ? route.url : "";
				if (route.parent) {
					url = calculateUrlTemplate(self.get(route.parent)) + "/" + url
				}
				return url.replace(/[/]{2,}/g, "/");
			}
		
			var renderedUrl = this.localizeUrl(this.templateUrl(calculateUrlTemplate(parentRoute), parameters, parentRoute.query));
			parentRoute = nabu.utils.objects.clone(parentRoute);
			parentRoute.renderedUrl = renderedUrl;
			self.parents.push(parentRoute);
		}
		
		self.initials.push(null);
		return enterReturn;
	};
	
	this.routeParent = function(alias, parameters) {
		var parentRoute = this.get(alias);
		if (!parentRoute) {
			throw "Could not find parent route: " + alias;
		}

		// parents can also make use of query parameters, however they will not be present in the "parameters" object unless the children have the same parameters
		// so in this case, if the parent requires query parameters, we explicitly get them
		// we don't merge them into the parameters object by reference but instead we merge the parameters into the query params
		if (parentRoute.query) {
			var queryParameters = self.getQueryParameters(parentRoute.query);
			nabu.utils.objects.merge(queryParameters, parameters);
			parameters = queryParameters;
		}
		
		var alreadyRouted = false;		
		// first check if we have the parent routed in the current stack
		for (var i = this.parents.length - 1; i >= 0; i--) {
			if (this.parents[i].alias == alias) {
				// remove the other parents after this
				if (i < this.parents.length - 1) {
					this.parents.splice(i + 1);
				}
				alreadyRouted = true;
				break;
			}
		}
		
		var parentEnter = null;
		
		
		var calculateUrl = function() {
			// check if we have a parent with its own rendered url, this will already incorporate the urls from its parent so should be fine
			for (var i = self.parents.length - 1; i >= 0; i--) {
				if (self.parents[i].renderedUrl) {
					return self.parents[i].renderedUrl;
				}
			}
			return null;
		}
		var url = calculateUrl();

		var calculateUrlTemplate = function(route) {
			var url = route.url ? route.url : "";
			if (route.parent) {
				url = calculateUrlTemplate(self.get(route.parent)) + "/" + url
			}
			return url.replace(/[/]{2,}/g, "/");
		}
		
		// if we have a parent route with a url, check that it still matches the current parent that is routed, otherwise we may have to remove it
		// for example if you have a parent url with an id in it, if the id changes the parent has to be rerendered
		if (parentRoute.url && !parentRoute.initial) {
			var renderedUrl = this.localizeUrl(this.templateUrl(calculateUrlTemplate(parentRoute), parameters, parentRoute.query));
			// "unroute" so to speak
			if (alreadyRouted && renderedUrl != url) {
				this.parents.splice(this.parents.length - 1, 1);
				alreadyRouted = false;
				
				// recalculate the url, we bumped a parent
				url = calculateUrl();
			}
		}
		
		// this particular parent is not yet routed, check if it itself has a parent
		if (!alreadyRouted) {
			var grandParentEnter = parentRoute.parent != null ? self.routeParent(parentRoute.parent, parameters) : null;
			// if we have added a grandparent, recalculate our local url
			if (grandParentEnter) {
				url = calculateUrl();
			}
			// if we have no parent, we are assumed to route in the body
			var anchor = grandParentEnter == null ? "body" : grandParentEnter.anchor;
			if (anchor == "body") {
				// clear all the parents, we are starting over
				self.parents.splice(0);
			}
			try {
				// always mask parent routes
				parentEnter = parentRoute.enter(anchor, parameters, true, grandParentEnter ? grandParentEnter.enter : null);
				// TODO: might need to differentiate if we want the same parent but with different parameters!
				
				// we have a url, do some cloning shizzle...?
				if (parentRoute.url && !parentRoute.initial) {
					parentRoute = nabu.utils.objects.clone(parentRoute);
					// the template is always global, relocalize it for this purpose...
					var renderedUrl = this.localizeUrl(this.templateUrl(parentRoute.url, parameters, parentRoute.query));
					if (url != null) {
						url = url.replace(/[/]+$/, "") + "/" + renderedUrl.replace(/^[/]+/, "");
					}
					else {
						url = renderedUrl;
					}
					parentRoute.renderedUrl = url;
				}
				self.parents.push(parentRoute);
			}
			catch (exception) {
				if (anchor != "body" && !document.querySelector("#" + anchor)) {
					console.log("The anchor '" + anchor + "' is unavailable for routing parent '" + parentRoute.alias + "', parents can currently not be nested in asynchronous grandparents, check if parent '" + parentRoute.parent + "' has an asynchronous action");
				}
				throw exception;
			}
		}
		
		// because we are routing new content, whatever parents were routed in the "default" tag of the current parent will be overwritten on route
		return {
			anchor: parentRoute.defaultAnchor ? parentRoute.defaultAnchor : self.defaultAnchor,
			url : url,
			enter: parentEnter
		}
	};
	
	this.template = function(alias, parameters) {
		var route = this.findByAlias(alias, parameters, null, false);
		if (self.useParents) {
			var url = null;
			var routeToCheck = route;
			while (routeToCheck) {
				if (routeToCheck.url) {
					url = routeToCheck.url + (url == null ? "" : "/" + url);
				}
				if (routeToCheck.parent) {
					routeToCheck = self.get(routeToCheck.parent);
				}
				else {
					break;
				}
			}
			return url ? this.templateUrl(url, parameters, route.query) : null;
		}
		else {
			return route && route.url ? this.templateUrl(route.url, parameters, route.query) : null;
		}
	};
	
	this.bookmark = function(alias, parameters, anchor) {
		if (window.history) {
			if (!parameters) {
				parameters = {};
			}
			window.history.pushState({ alias: alias, anchor: anchor, parameters: parameters }, alias, self.template(alias, parameters));
			self.previousUrl = self.getUrl();
		}
	};
	
	this.templateUrl = function(url, parameters, query) {
		for (var key in parameters) {
			url = url.replace(new RegExp("{[\s]*" + key.replace("$", "\\$") + "[\s]*:[^}]+}"), parameters[key]).replace(new RegExp("{[\s]*" + key.replace("$", "\\$") + "[\s]*}"), parameters[key]);
		}
		url = url.replace(/[\/]{2,}/, "/");
		if (query && parameters) {
			var first = true;
			for (var i = 0; i < query.length; i++) {
				var value = parameters[query[i]];
				if (typeof(value) != "undefined" && value != null) {
					if (first) {
						url += "?";
						first = false;
					}
					else {
						url += "&";
					}
					url += encodeURIComponent(query[i]) + "=" + encodeURIComponent(parameters[query[i]]);
				}
			}
		}
		if (this.urlRewriter && this.urlRewriter.outgoing) {
			url = this.urlRewriter.outgoing(url);
		}
		// replace any straggling variables with the key word "default"
		url = url.replace(/\{[^}]+}/, "default");
		// replace double slashes as well
		return (self.useHash && url.substring(0, 1) != "#" ? "#" + url : (application && application.configuration ? application.configuration.root : "/") + url.replace(/^[/]+/, "")).replace(/[/]{2,}/, "/");
	};
	
	this.getUrl = function() {
		var url = self.useHash ? window.location.hash : window.location.pathname + (window.location.search ? window.location.search : "");
		if (self.useHash && url.substring(0, 1) != "#") {
			url = "#" + url;
		}
		return url ? url : "/";
	};
	
	this.updateUrl = function(alias, url, parameters, query, anchor) {
		url = self.templateUrl(url, parameters, query);
		/*if (self.useHash) {
			self.changingHash = true;
			window.location.hash = url;
		}*/
		if (window.history && url != self.getUrl()) {
			if (!parameters) {
				parameters = {};
			}
			try {
				window.history.pushState({ alias: alias, anchor: anchor, parameters: parameters }, alias, url);
			}
			catch (exception) {
				// ignore, probably can't serialize it, no worries
			}
			self.previousUrl = self.getUrl();
		}
	};
	
	this.updateState = function(alias, parameters, query, anchor) {
		// if we route directly to an element, we can't replay it
		if (typeof(anchor) == "string") {
			try {
				window.history.pushState({ alias: alias, anchor: anchor, parameters: parameters }, alias, self.getUrl());
			}
			catch (exception) {
				// ignore, probably can't serialize it, no worries
			}
		}
	};

	this.sorted = false;
	this.sort = function() {
		// the clone used in the below got highlighted as a bottleneck in a performance review
		// instead we only sort once, assuming the first time we actually get routes etc, all routes have been registered
		// this small change improved performance of that particular page by 30% (it was a repeat with nested pages etc)
		if (!this.sorted) {
			this.sorted = true;
			this.routes.sort(function(a, b) {
				// lowest priority has to be sorted to the back of the array so they get picked last
				return (typeof(b.priority) == "undefined" ? 0 : b.priority)
					- (typeof(a.priority) == "undefined" ? 0 : a.priority);
			});
		}
		return this.routes;
		// sort the routes based on priority
		// this allows for default routes to be defined and overwritten
		// we clone the list because the list is generally watched
		// if you are showing all the routes in a dropdown for instance, then perform a get()
		// the actual get will trigger a sort, will change the dropdown values, etc in a loop
		var cloned = nabu.utils.objects.clone(this.routes);
		cloned.sort(function(a, b) {
			// lowest priority has to be sorted to the back of the array so they get picked last
			return (typeof(b.priority) == "undefined" ? 0 : b.priority)
				- (typeof(a.priority) == "undefined" ? 0 : a.priority);
		});
		return cloned;
	}

	this.getPath = function() {
		var path = null;
		if (self.useHash) {
			path = window.location.hash && window.location.hash.length > 1 ? window.location.hash.substring(1) : "/";
		}
		else {
			path = self.localizeUrl(window.location.pathname ? window.location.pathname : "/");
		}
		if (!path) {
			path = "/";
		}
		return path;
	}
	
	// the query should be an array of string
	this.getQueryParameters = function(query) {
		var path = this.getPath();
		var queryIndex = path.indexOf("?");
		var queryParameters = queryIndex >= 0 ? path.substring(queryIndex) : window.location.search;
		var parts = queryParameters.substring(1).split("&");
		var parameters = {};
		for (var j = 0; j < parts.length; j++) {
			var index = parts[j].indexOf("=");
			var key = null, value = null;
			if (index >= 0) {
				key = decodeURIComponent(parts[j].substring(0, index));
				value = decodeURIComponent(parts[j].substring(index + 1));
			}
			else {
				key = decodeURIComponent(parts[j]);
				value = null;
			}
			var values = parts[j].split("=");
			if (query.indexOf(key) >= 0) {
				if (parameters[key] != null) {
					if (!(parameters[key] instanceof Array)) {
						parameters[key] = [parameters[key]];
					}
					parameters[key].push(value);
				}
				else {
					parameters[key] = value;
				}
			}
		}
		return parameters;
	}

	this.findRoute = function(path, initial) {
		if (!path) {
			path = "/";
		}
		if (this.urlRewriter && this.urlRewriter.incoming) {
			path = this.urlRewriter.incoming(path);
		}
		var chosenRoute = null;
		var parameters = {};
		var queryIndex = path.indexOf("?");
		var queryParameters = queryIndex >= 0 ? path.substring(queryIndex) : window.location.search;
		if (queryIndex >= 0) {
			path = path.substring(0, queryIndex);
		}
		// we strip trailing slashes
		path = path.replace(/[/]+$/, "");
		if (path == "") {
			path = "/";
		}
		var routes = this.sort();
		for (var i = 0; i < routes.length; i++) {
			if (routes[i].url && ((!initial && !routes[i].initial) || (initial && routes[i].initial))) {
				var urls = routes[i].url instanceof Array ? routes[i].url : [routes[i].url];
				var found = false;
				
				var parentUrl = null;
				// we resolve the parent url which should be prepended if available
				if (this.useParents && routes[i].parent) {
					var tmp = routes[i];
					while (tmp && tmp.parent) {
						tmp = routes.filter(function(x) {
							return x.alias == tmp.parent;
						})[0];
						if (tmp && tmp.url) {
							parentUrl = parentUrl == null ? tmp.url : tmp.url.replace(/[/]+$/, "") + "/" + parentUrl.replace(/^[/]+/, "");
						}
					}
				}
				
				for (var k = 0; k < urls.length; k++) {
					var urlToMatch = urls[k];
					if (parentUrl != null) {
						urlToMatch = parentUrl.replace(/[/]+$/, "") + "/" + urlToMatch.replace(/^[/]+/, "")
					}
					var template = "^" + urlToMatch.replace(/\{[\s]*[^}:]+[\s]*:[\s]*([^}]+)[\s]*\}/g, "($1)").replace(/\{[\s]*[^}]+[\s]*\}/g, "([^/]+)") + "$";
					template = template.replace(/\./g, "\\.");
					var matches = path.match(template);
					if (matches) {
						var variables = urlToMatch.match(template);
						if (!variables) {
							throw "Could not extract variables from: " + urlToMatch;
						}
						if (variables.length != matches.length) {
							throw "The amount of variables does not equal the amount of values";
						}
						// the first hit is the entire string
						for (var j = 1; j < variables.length; j++) {
							parameters[variables[j].substring(1, variables[j].length - 1).replace(/:.*$/, "")] = matches[j];
						}
						chosenRoute = routes[i];
						if (chosenRoute.query) {
							var parts = queryParameters.substring(1).split("&");
							for (var j = 0; j < parts.length; j++) {
								var index = parts[j].indexOf("=");
								var key = null, value = null;
								if (index >= 0) {
									key = decodeURIComponent(parts[j].substring(0, index));
									value = decodeURIComponent(parts[j].substring(index + 1));
								}
								else {
									key = decodeURIComponent(parts[j]);
									value = null;
								}
								var values = parts[j].split("=");
								if (chosenRoute.query.indexOf(key) >= 0) {
									if (parameters[key] != null) {
										if (!(parameters[key] instanceof Array)) {
											parameters[key] = [parameters[key]];
										}
										parameters[key].push(value);
									}
									else {
										parameters[key] = value;
									}
								}
							}
						}
						found = true;
						break;
					}
				}
				if (found) {
					break;
				}
			}
		}
		return chosenRoute == null ? null : {
			route: chosenRoute,
			parameters: parameters
		};
	};

	this.localizeUrl = function(url) {
		var root = (application && application.configuration && application.configuration.root ? application.configuration.root : "/");
		if (url.length >= root.length && url.substring(0, root.length) == root) {
			url = "/" + url.substring(root.length);
		}
		// the root always ends on "/" for predictability, however, the url itself might not end in a "/", it is optional for the root page
		// in that case, we actually match the root minus the trailing "/", this means home
		else if (url.length == root.length - 1 && url == root.substring(0, root.length - 1)) {
			url = "/";
		}
		return url;
	};
	
	this.getInitial = function(anchor, parameters, mask) {
		var initial = null;
		// check for initial route to build framework around data
		if (self.useHash) {
			initial = self.findRoute(window.location.hash && window.location.hash.length > 1 ? window.location.hash.substring(1) : "/", true);
		}
		else {
			initial = self.findRoute(self.localizeUrl(window.location.pathname ? window.location.pathname : "/"), true);
		}
		return initial;
	};

	this.routeInitial = function(anchor, parameters, mask) {
		var current = null;
		current = self.findRoute(self.getPath());
		if (self.useParents) {
			return self.route(current ? current.route.alias : "unknown", current ? current.parameters : parameters, anchor, mask, true);
		}
		else {
			var initial = self.getInitial(anchor, parameters, mask);
			return self.routePage(initial, current, parameters, anchor, mask);
		}
	};
	
	this.routeAll = function(alias, parameters, anchor, mask) {
		var initialRoute = null;
		var chosenRoute = null;
		var routes = this.sort();
		for (var i = 0; i < routes.length; i++) {
			if (routes[i].alias == alias) {
				if (routes[i].initial && !initialRoute) {
					initialRoute = routes[i];
				}
				else if (!routes[i].initial && !chosenRoute) {
					chosenRoute = routes[i];
				}
			}
			else if (routes[i].initial && !initialRoute && alias.match(routes[i].alias)) {
				initialRoute = routes[i];
			}
		}
		self.routePage(
			initialRoute == null ? null : { route: initialRoute, parameters: parameters}, 
			chosenRoute == null ? null : { route: chosenRoute, parameters: parameters }, 
			parameters, anchor, mask, true);
	};
		
	// the initial route on page load
	this.routePage = function(initial, current, parameters, anchor, mask, updateUrl) {
		if (!anchor) {
			anchor = self.defaultAnchor;
		}
		
		// look for an initial route that has no url, it is the default initial
		if (initial == null) {
			for (var i = 0; i < self.routes.length; i++) {
				if (self.routes[i].initial && !self.routes[i].url) {
					initial = {
						route: self.routes[i],
						parameters: self.routes[i].parameters
					};
					break;
				}	
			}
		}
		
		if (initial != null) {
			if (self.authorizer) {
				var result = self.authorizer("body", initial.route, initial.parameters, null, null);
				if (typeof(result) == "object" && result) {
					initial = self.findByAlias(
						result.alias,
						result.parameters,
						"body",
						true
					);
					if (initial == null) {
						throw "Could not find initial route: " + result.alias;
					}
					else {
						initial = {
							route: initial,
							parameters: result.parameters
						}
					}
				}
			}
			self.initials.push(initial);
			initial.route.enter("body", initial.parameters, null, null);
		}
		if (!current && self.unknown) {
			var unknown = self.unknown(null, parameters, anchor);
			if (unknown) {
				current = {
					route: unknown,
					parameters: parameters
				};
			}
		}
		if (!current) {
			throw "Unknown initial route";
		}
		if (current != null) {
			if (self.authorizer) {
				var result = self.authorizer(anchor, current.route, current.parameters, null, null);
				if (typeof(result) == "object" && result) {
					var alternativeRoute = self.findByAlias(
						result.alias,
						result.parameters,
						result.anchor ? result.anchor : anchor,
						false
					);
					if (alternativeRoute == null) {
						throw "Could not find alternative route: " + result.alias;
					}
					current = {
						route: alternativeRoute,
						parameters: result.parameters
					}
					if (!mask) {
						if (alternativeRoute.url && (typeof(alternativeRoute.mask) == "undefined" || !alternativeRoute.mask)) {
							self.updateUrl(alternativeRoute.alias, alternativeRoute.url, result.parameters);
						}
						self.updateUrl(alternativeRoute.alias, alternativeRoute.url, parameters);
					}
					else {
						self.updateState(alternativeRoute.alias, parameters);
					}
				}
			}
			if (self.chosen) {
				var alternative = self.chosen(anchor, current.route, parameters ? parameters : current.parameters, null, null);
				if (alternative && alternative.route) {
					current.route = alternative.route;
				}
				if (alternative && alternative.parameters) {
					if (parameters) {
						parameters = alternative.parameters;
					}
					else {
						current.parameters = alternative.parameters;
					}
				}
			}
			var enterReturn = current.route.enter(anchor, current.parameters, null, null);
			if (self.enter != null) {
				self.enter(anchor, current.route, parameters ? parameters : current.parameters, null, null, enterReturn);
				if (updateUrl) {
					self.updateUrl(current.route.alias, current.route.url, parameters);	
				}
				else {
					self.updateState(current.route.alias, parameters ? parameters : current.parameters, current.query, anchor);
				}
			}
			return enterReturn;
		}
		return null;
	};
	
	this.findByAlias = function(alias, parameters, anchor, initial) {
		var chosenRoute = null;
		for (var i = 0; i < self.routes.length; i++) {
			if (self.routes[i].alias == alias && (initial || !self.routes[i].initial)) {
				chosenRoute = self.routes[i];
				break;
			}
		}
		if (chosenRoute == null && self.unknown) {
			chosenRoute = self.unknown(alias, parameters, anchor);
		}
		return chosenRoute;
	};

	this.register = function(route) {
		self.routes.push(route);
		return route;
	};
	
	this.unregister = function(route) {
		if (typeof(route) == "string") {
			route = self.routes.filter(function(x) {
				return x.alias == route;
			})[0];
		}
		if (route) {
			var index = self.routes.indexOf(route);
			if (index >= 0) {
				self.routes.splice(index, 1);
			}
		}
	};

	this.previousUrl = this.getUrl();
}

nabu.utils.router = {
	// get the anchor to render in
	anchor: function(anchor) {
		var element = typeof(anchor) === "object" ? anchor : document.getElementById(anchor);
		if (!element && anchor == "body") {
			element = document.body;
		}
		return element;
	},
	// get the current rendering target you are in
	self: function(element) {
		while (element && !element.hasAttribute("route")) {
			element = element.parentNode;
		}
		return element;
	}
}


if (!nabu) { var nabu = {}; }
if (!nabu.services) { nabu.services = {}; }

// if you need custom parameters in your service input, consider a service builder that uses the $initialize.resolve to send back the actual service instance
nabu.services.ServiceManager = function() {
	var self = this;
	this.$definitions = [];
	this.$instances = [];
	this.$promises = {};
	this.$optionals = {};
	
	for (var i = 0; i < arguments.length; i++) {
		this.$definitions.push(arguments[i]);
	}
	
	// we use this service both to load the actual service itself as well as get a promise for a dependency
	// especially dependencies can toggle the "optional" boolean to indicate that they could use a particular service but are not required to have it
	// if the actual service never loads, there is never a call with optional false, so we can resolve it later
	this.$promise = function(fullName, optional) {
		if (!self.$promises[fullName]) {
			self.$promises[fullName] = new nabu.utils.promise();
		}
		// if you are optionally waiting for this, we set it IF it has no value yet
		// if it is already set to true (or worse: false), we leave it
		if (optional) {
			if (!self.$optionals.hasOwnProperty(fullName)) {
				self.$optionals[fullName] = true;
			}
		}
		else {
			self.$optionals[fullName] = false;
		}
		return self.$promises[fullName];
	}
	
	this.$initialize = function() {
		var promise = new nabu.utils.promise();
		var resolver = function() {
			promise.resolve(self);
		};
		this.$register(this.$definitions).then(resolver, resolver);
		// at this point, regardless of the setup, we should have an overall view of all the services that exist
		// if any promises are still set to optional, they are likely never going to resolve, resolve them now
		Object.keys(self.$optionals).forEach(function(key) {
			if (self.$optionals[key] == true) {
				console.log("resolving optional dependency to", key);
				self.$promise(key).resolve();
			}
		})
		return promise;
	}
	
	this.$register = function(services, target, parentName) {
		if (!target) {
			target = self;
		}
		if (!(services instanceof Array)) {
			services = [services];
		}
		
		
		var promises = [];
		
		var initializeSingle = function(instance, name, promise) {
			var fullName = (parentName ? parentName + "." : "") + name;
			var result = instance.$initialize ? instance.$initialize() : null;
			if (result) {
				// we assume a promise
				if (result.then) {
					var staged = false;
					if (result.staged) {
						result.staged(function(service) {
							if (service && name) {
								target[name] = service;
								self.$instances.push(service);
								staged = true;
							}
						});
					}
					result.then(function(service) {
						if (service && name) {
							service.$initialized = new Date();
							if (!staged) {
								target[name] = service;
								self.$instances.push(service);
							}
							promise.resolve(service);
						}
						else {
							self.$instances.push(instance);
							promise.resolve(instance);
						}
					}, function(error) {
						promise.reject(error);
					});
				}
				// we assume that you returned the actual service instance
				else if (name) {
					target[name] = result;
					self.$instances.push(result);
					promise.resolve(result);
				}
			}
			else {
				target[name] = instance;
				self.$instances.push(instance);
				promise.resolve(instance);
			}
		};
		
		for (var i = 0; i < services.length; i++) {
			// deprecated because named functions do not survive minification, only here for backwards compatibility
			if (services[i] instanceof Function) {
				var instance = new services[i](self);
				var name = services[i].name 
					? services[i].name.substring(0, 1).toLowerCase() + services[i].name.substring(1) 
					: null;
				if (instance.$initialize) {
					initializeSingle(instance, name);
				}
			}
			else {
				var names = Object.keys(services[i]);
				for (var j = 0; j < names.length; j++) {
					var name = names[j].substring(0, 1).toLowerCase() + names[j].substring(1);
					var fullName = (parentName ? parentName + "." : "") + name;
					if (services[i][names[j]] instanceof Function) {
						var instance = new services[i][names[j]](self);
						var promise = self.$promise(fullName);
						promises.push(promise);
						promise.then(function(instance) {
							instance.$initialized = new Date();
						});
						initializeSingle(instance, name, promise);
					}
					else {
						target[name] = {};
						promises.push(this.$register([services[i][names[j]]], target[name], fullName));
					}
				}
			}
		}
		return new nabu.utils.promises(promises);
	}
	
	this.$clear = function() {
		var promises = [];
		for (var i = 0; i < this.$instances.length; i++) {
			if (this.$instances[i].$initialized) {
				if (this.$instances[i].$clear) {
					var result = this.$instances[i].$clear();
					this.$instances[i].$initialized = new Date();
					if (result && result.then) {
						promises.push(result);
					}
				}
			}
		}
		return new nabu.utils.promises(promises);
	}

	this.$switchLanguage = function() {
		var promises = [];
		for (var i = 0; i < this.$instances.length; i++) {
			if (this.$instances[i].$initialized) {
				if (this.$instances[i].$switchLanguage) {
					var result = this.$instances[i].$switchLanguage();
					this.$instances[i].$initialized = new Date();
					if (result && result.then) {
						promises.push(result);
					}
				}
			}
		}
		return new nabu.utils.promises(promises);
	}
}

/*
Contains a promise implementation that has been retroactively made compatible with Q
A "q" service is also provided that can be used to call it much like you would $q in angular
*/

if (!nabu) { var nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }
if (!nabu.services) { nabu.services = {}; }

nabu.utils.when = function(promises) {
	return new nabu.utils.promises(promises);
};
nabu.utils.wait = function(promise, timeout, handler) {
	var self = this;
	this.timer = setTimeout(handler, timeout);
	this.cancel = function() {
		clearTimeout(self.timer);
	};
	promise.then(this.cancel);
};
nabu.utils.promise = function(parameters) {
	var self = this;
	this.state = null;
	this.cancelHandlers = [];
	this.successHandlers = [];
	this.errorHandlers = [];
	this.progressHandlers = [];
	this.stagedHandlers = [];
	this.stagedResult = null;
	this.response = null;
	this.parameters = parameters;
	this.mapper = [];
	this.succeed = function(response) {
		if (!self.state) {
			if (self.mapper.length) {
				for (var i = 0; i < self.mapper.length; i++) {
					response = self.mapper[i](response);
				}
			}
			self.response = response;
			self.state = "success";
			for (var i = 0; i < self.successHandlers.length; i++) {
				if (self.successHandlers[i] instanceof Function) {
					self.successHandlers[i](response);
				}
				else if (self.successHandlers[i].resolve) {
					self.successHandlers[i].resolve(response);
				}
			}
		}
	};
	this.stage = function(stagedResult) {
		if (!self.stagedResult) {
			self.stagedResult = stagedResult;
			for (var i = 0; i < self.stagedHandlers.length; i++) {
				if (self.stagedHandlers[i] instanceof Function) {
					self.stagedHandlers[i](response);
				}
				else if (self.stagedHandlers[i].resolve) {
					self.stagedHandlers[i].resolve(stagedResult);
				}
			}
		}
	};
	this.staged = function(handler) {
		self.stagedHandlers.push(handler);
		// if already staged, call immediately
		if (self.stagedResult != null) {
			if (handler instanceof Function) {
				handler(self.stagedResult);
			}
			else if (handler.resolve) {
				handler.resolve(self.stagedResult);
			}
		}
		return self;
	};
	this.resolve = function(response) {
		self.succeed(response);
	};
	this.fail = function(response) {
		if (!self.state) {
			self.response = response;
			self.state = "error";
			for (var i = 0; i < self.errorHandlers.length; i++) {
				if (self.errorHandlers[i] instanceof Function) {
					self.errorHandlers[i](response);
				}
				else if (self.errorHandlers[i].reject) {
					self.errorHandlers[i].reject(response);
				}
			}
		}
	};
	this.reject = function(response) {
		self.fail(response);
	};
	this.success = function(handler) {
		self.successHandlers.push(handler);
		// if already resolved, call immediately
		if (self.state == "success") {
			if (handler instanceof Function) {
				handler(self.response);
			}
			else if (handler.resolve) {
				handler.resolve(self.response);
			}
		}
		return self;
	};
	this.error = function(handler) {
		self.errorHandlers.push(handler);
		// if already resolved, call immediately
		if (self.state == "error") {
			if (handler instanceof Function) {
				handler(self.response);
			}
			else if (handler.reject) {
				handler.reject(self.response);
			}
		}
		return self;
	};
	this.onprogress = function(event) {
		if (self.progressHandlers) {
			for (var i = 0; i < self.progressHandlers.length; i++) {
				self.progressHandlers[i](event, self.parameters);
			}
		}
	};
	this.progress = function(progressHandler) {
		self.progressHandlers.push(progressHandler);
	};
	this.then = function(successHandler, errorHandler, progressHandler, cancelHandler) {
		if (successHandler) {
			self.success(successHandler);
		}
		if (errorHandler) {
			self.error(errorHandler);
		}
		if (progressHandler) {
			self.progress(progressHandler);
		}
		// TODO: we need to immediately run cancel handlers if already cancelled
		if (cancelHandler) {
			self.cancelHandlers.push(cancelHandler);
		}
		return self;
	};
	this.map = function(mapper) {
		if (mapper instanceof Array) {
			nabu.utils.arrays.merge(self.mapper, mapper);
		}
		else if (mapper instanceof Function) {
			self.mapper.push(mapper);
		}
	};
	this.cancel = function(cancelHandler) {
		this.cancelHandlers.push(cancelHandler);
	},
	// by cancelling a promise we simply remove all handlers
	// note that this can not be done on an already resolved promise
	// TODO: in the future we may want to abort the underlying asynchronous action (usually XMLHTTPRequest)
	// TODO: we may want to update the state to indicate cancellation
	this.abort = function(reason) {
		if (this.state == null) {
			this.successHandlers.splice(0);
			this.errorHandlers.splice(0);
			this.progressHandlers.splice(0);
			this.stagedHandlers.splice(0);
			this.cancelHandlers.forEach(function(handler) {
				handler(self, reason);
			});
		}
	};
};
nabu.utils.promises = function(promises) {
	var self = this;
	this.promises = promises ? promises : [];
	this.resolution = null;
	this.cancelHandlers = [];
	this.successHandlers = [];
	this.errorHandlers = [];
	this.progressHandlers = [];
	this.state = null;
	this.response = null;
	// we want to keep track of the current progress of all the promises combined
	// the promises will be running in parallel, so the progress updates will be mixed
	// we don't want to jump from 10/100 to 20/50, then back to 24/100 etc
	this.progressIndicators = {};
	
	this.resolver = function() {
		if (self.state == null) {
			var failed = 0;
			var succeeded = 0;
			var responses = [];
			for (var i = 0; i < self.promises.length; i++) {
				if (self.promises[i].state == "success") {
					succeeded++;
					responses.push(self.promises[i].response);
				}
				else if (self.promises[i].state == "error") {
					failed++;
					responses.push(self.promises[i].response);
				}
			}
			if (succeeded == self.promises.length) {
				self.response = responses;
				self.state = "success";
				for (var i = 0; i < self.successHandlers.length; i++) {
					if (self.successHandlers[i] instanceof Function) {
						self.successHandlers[i](responses);
					}
					else if (self.successHandlers[i].resolve) {
						self.successHandlers[i].resolve(responses);
					}
				}
			}
			else if (succeeded + failed == self.promises.length) {
				self.response = responses;
				self.state = "error";
				for (var i = 0; i < self.errorHandlers.length; i++) {
					if (self.errorHandlers[i] instanceof Function) {
						self.errorHandlers[i](responses);
					}
					else if (self.errorHandlers[i].reject) {
						self.errorHandlers[i].reject(responses);
					}
				}
			}
		}
	};
	
	this.onprogress = function(event, parameters) {
		// if we have a target, we calculate the total
		if (event.target) {
			self.progressIndicators[event.target] = event;
			var total = 0;
			var loaded = 0;
			Object.values(self.progressIndicators).forEach(function(x) {
				total += x.total;
				loaded += x.loaded;
			});
			//event.loaded = loaded;
			//event.total = total;
		}
		if (self.progressHandlers) {
			for (var i = 0; i < self.progressHandlers.length; i++) {
				self.progressHandlers[i](event, parameters);
			}
		}
	};

	for (var i = 0; i < this.promises.length; i++) {
		this.promises[i]
			.success(this.resolver)
			.error(this.resolver)
			.progress(this.onprogress);
	}
	this.progress = function(progressHandler) {
		self.progressHandlers.push(progressHandler);
	};
	this.success = function(handler) {
		self.successHandlers.push(handler);
		// if already resolved, call immediately
		if (self.state == "success") {
			if (handler instanceof Function) {
				handler(self.response);
			}
			else if (handler.resolve) {
				handler.resolve(self.response);
			}
		}
		return self;
	};
	this.error = function(handler) {
		self.errorHandlers.push(handler);
		// if already resolved, call immediately
		if (self.state == "error") {
			if (handler instanceof Function) {
				handler(self.response);
			}
			else if (handler.reject) {
				handler.reject(self.response);
			}
		}
		return self;
	};
	this.then = function(successHandler, errorHandler, progressHandler, cancelHandler) {
		if (successHandler) {
			self.success(successHandler);
		}
		if (errorHandler) {
			self.error(errorHandler);
		}
		if (progressHandler) {
			self.progress(progressHandler);
		}
		// TODO: we need to immediately run cancel handlers if already cancelled
		if (cancelHandler) {
			self.cancelHandlers.push(cancelHandler);
		}
		return self;
	};
	// see other promise for documentation
	this.cancel = function(cancelHandler) {
		this.cancelHandlers.push(cancelHandler);
	},
	this.abort = function(reason) {
		if (this.state == null) {
			this.successHandlers.splice(0);
			this.errorHandlers.splice(0);
			this.progressHandlers.splice(0);
			this.cancelHandlers.forEach(function(handler) {
				handler(self, reason);
			});
			// we assume you want this to bubble down, make configurable if not
			this.promises.forEach(function(promise) {
				promise.abort();
			});
		}
	};
	this.resolver();
}

nabu.services.Q = function Q() {
	this.defer = function(promise, result) {
		// if you pass in a promise, we build on that, this only makes sense if you send back a different result, otherwise use the original promise
		if (promise && typeof(result) != "undefined") {
			var newPromise = new nabu.utils.promise();
			newPromise.stage(result);
			promise.then(function(object) {
				newPromise.resolve(result);
			}, newPromise);
			return newPromise;
		}
		else {
			return new nabu.utils.promise();
		}
	};
	this.all = function() {
		var array = [];
		for (var i = 0; i < arguments.length; i++) {
			if (arguments[i] instanceof Array) {
				for (var j = 0; j < arguments[i].length; j++) {
					array.push(arguments[i][j]);
				}
			}
			else {
				array.push(arguments[i]);
			}
		}
		return new nabu.utils.promises(array);
	};
	this.resolve = function(result) {
		var promise = this.defer();
		promise.resolve(result);
		return promise;
	};
	this.reject = function(result) {
		var promise = this.defer();
		promise.reject(result);
		return promise;
	};
	this.wait = function(promise, timeout, handler) {
		return new nabu.utils.wait(promise, timeout, handler);
	};
}

if (!nabu) { var nabu = {} };
if (!nabu.services) { nabu.services = {} };

nabu.services.Cookies = function Cookies($services) {
	this.set = function(name, value, days, domain) {
		var expires = "";
		if (days) {
			var date = new Date();
			date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
			expires = "; expires=" + date.toUTCString();
		}
		document.cookie = name + "=" + value + expires + "; path=" + (application && application.configuration ? application.configuration.cookiePath : "/")
			+ (domain ? ";domain=" + domain : "");
	};
	this.get = function(name, defaultValue) {
		name += "=";
		var cookies = document.cookie.split(';');
		for (var i = 0; i < cookies.length; i++) {
			var cookie = cookies[i];
			while (cookie.charAt(0) == ' ') {
				cookie = cookie.substring(1, cookie.length);
			}
			if (cookie.indexOf(name) == 0) {
				return cookie.substring(name.length, cookie.length);
			}
		}
		return defaultValue ? defaultValue : null;
	};
	this.unset = function(name, domain) {
		this.set(name, "", -1, domain);
	}
}

if (!nabu) { var nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }
if (!nabu.utils.misc) { nabu.utils.misc = {}; }

// the generator should generate a place holder that can (preferably) be updated in place (e.g. through reactivity) for non-resolved keys
// the cacher should be able to store and update a result in such a way that it is reflected everywhere
// the mapper (optional) should resolve the key from the resultset
// 	if no mapper is present, we assume the result array is in the same order as the ids we resolved
nabu.utils.misc.BatchResolver = function(resolver, cacher, generator, mapper, timeout) {
	if (!timeout) {
		timeout = 50;
	}
	if (!generator) {
		generator = function() { return  {} };
	}
	var toResolve = [];
	var timer = null;
	return function(key) {
		var stringified = JSON.stringify(key);
		var cached = cacher(stringified);
		if (cached) {
			return cached;
		}
		if (timer) {
			clearTimeout(timer);
			timer = null;
		}
		var result = generator(key);
		cacher(stringified, result);
		toResolve.push(key);
		timer = setTimeout(function() {
			var keys = toResolve.splice(0, toResolve.length);
			resolver(keys).then(function(result) {
				var array = null;
				if (result && !(result instanceof Array)) {
					Object.keys(result).map(function(key) {
						if (result[key] instanceof Array) {
							array = result[key];
						}
					});
				}
				else {
					array = result;
				}
				if (array) {
					// if we have a mapper, update the keys array
					if (mapper) {
						keys = array.map(mapper);
					}
					// set it all in the cache
					for (var i = 0; i < array.length; i++) {
						cacher(keys[i], array[i]);
					}
				}
			});
		}, timeout);
		return result;
	}	
}
// this directive takes a header (presumed at the top of the page) and will slide it away when you scroll down
// the first time you scroll up however, the menu pops back up
Vue.directive("sticky-header", {
	bind: function(element, binding) {
		element.setAttribute("n-sticky-header", "true");
		var previousScrollTop = document.body.scrollTop;
		var height = element.getBoundingClientRect().height;
		element["$n-sticky-header-listener"] = function(event) {
			if (height == 0) {
				height = element.getBoundingClientRect().height;
			}
			// at initial position or scrolling upwards, show the menu
			if (document.body.scrollTop <= height || document.body.scrollTop < previousScrollTop) {
				element.style.top = "0px";
			}
			else {
				element.style.top = "-" + (binding.value ? binding.value : height) + "px";
			}
			previousScrollTop = document.body.scrollTop;
		};
		window.addEventListener("scroll", element["$n-sticky-header-listener"]);
	},
	unbind: function(element) {
		element.removeAttribute("n-sticky-header");
		if (element["$n-sticky-header-listener"]) {
			console.log("Removing event listener");
			window.removeEventListener("scroll", element["$n-sticky-header-listener"]);
		}
	}
});
Vue.directive("select-on", {
	bind: function(element, binding) {
		
		var target = element.__vue__ ? element.__vue__ : element;
		
		target["$n-select-on-handler"] = function ($event) {
			if ( !$event || !$event.target ) {
				console.warn("A valid DOM event should be provided as the first argument");
				return;
			}
			try {
				setTimeout(function () {
					$event.target.select();
				}, 1);
			}
			catch (error) {
				console.log("error selecting element content", error, $event.target);
			}
		};
		
		if (element.__vue__) {
			target.$on(binding.arg, target["$n-select-on-handler"]);
		}
		else {
			element.addEventListener(binding.arg, target["$n-select-on-handler"]);
		}
	},
	unbind: function(element, binding) {
		var target = element.__vue__ ? element.__vue__ : element;
		if (target["$n-select-on-handler"]) {
			if (element.__vue__) {
				target.$off(binding.arg, target["$n-select-on-handler"]);
			}
			else {
				element.removeEventListener(binding.arg, target["$n-select-on-handler"]);
			}
		}
	}
});
// this directive adds functionality to a component so it autocloses if you click anywhere else
// additionally you can add specific "auto-close" attributes to certain elements inside that should also close the element
Vue.directive("auto-close", {
	bind: function(element, binding) {
		if (binding.value) {
			var keys = binding.modifiers ? Object.keys(binding.modifiers) : null;
			element["$n-auto-close-listener"] = function(event) {
				// it still has to be in the document to be valid
				var close = event.target != element && !element.contains(event.target) && document.body.contains(event.target);
				var inside = false;
				if (!close && element.contains(event.target)) {
					var find = event.target;
					var attribute = "auto-close";
					// we can look for specific auto-closes
					if (keys.length) {
						attribute += "-" + keys[0];
					}
					while (find != element) {
						if (find.hasAttribute(attribute) && find.getAttribute(attribute) != "false") {
							close = true;
							inside = true;
							break;
						}
						find = find.parentNode;
					}
				}
				if (close && binding.value) {
					binding.value(inside, event);
				}
			};
			window.addEventListener("click", element["$n-auto-close-listener"], true);
		}
	},
	unbind: function(element) {
		if (element["$n-auto-close-listener"]) {
			window.removeEventListener("click", element["$n-auto-close-listener"], true);
		}
	}
});


if (!nabu) { var nabu = {} }
if (!nabu.tmp) { nabu.tmp = {} }

// contain timeouts that are linked
nabu.tmp.timeouts = {};

Vue.directive("timeout", {
	bind: function(element, binding) {
		var keys = null;
		if (binding.modifiers) {
			keys = Object.keys(binding.modifiers);
		}
		var timeout = 600;
		var handle = null;
		if (keys) {
			for (var i = 0; i < keys.length; i++) {
				if (keys[i].match("[0-9]+")) {
					timeout = new Number(keys[i]);
				}
				else {
					handle = keys[i];
				}
			}
		}
		
		var target = element.__vue__ ? element.__vue__ : element;

		target["$n-timeout-handle"] = null;
		target["$n-timeout-handler"] = function() {
			if (handle != null) {
				if (nabu.tmp.timeouts[handle] != null) {
					clearTimeout(nabu.tmp.timeouts[handle]);
				}
			}
			else if (element["$n-timeout-handle"] != null) {
				clearTimeout(element["$n-timeout-handle"]);
			}
			var timer = setTimeout(function() {
				binding.value();
			}, timeout);
			
			if (handle != null) {
				nabu.tmp.timeouts[handle] = timer;
			}
			else {
				element["$n-timeout-handle"] = timer;
			}
		};
		
		if (element.__vue__) {
			target.$on(binding.arg, target["$n-timeout-handler"]);
		}
		else {
			element.addEventListener(binding.arg, target["$n-timeout-handler"]);
		}
	},
	unbind: function(element, binding) {
		var target = element.__vue__ ? element.__vue__ : element;
		if (target["$n-timeout-handler"]) {
			if (element.__vue__) {
				target.$off(binding.arg, target["$n-timeout-handler"]);
			}
			else {
				element.removeEventListener(binding.arg, target["$n-timeout-handler"]);
			}
		}
	}
});
// adds or removes css class based on event (default click)
Vue.directive("css", {
	bind: function(element, binding) {
		if (binding.value) {
			element = binding.value;
			if (element.$el) {
				element = element.$el;
			}
		}
		var target = element.__vue__ ? element.__vue__ : element;
		
		var clazz = Object.keys(binding.modifiers)[0];
		
		target["$n-css-handler"] = function() {
			if (element.classList.contains(clazz)) {
				element.classList.remove(clazz);
			}
			else {
				element.classList.add(clazz);
			}
		}
		
		if (element.__vue__) {
			target.$on(binding.arg ? binding.arg : "click", target["$n-css-handler"]);
		}
		else {
			target.addEventListener(binding.arg ? binding.arg : "click", target["$n-css-handler"]);
		}
	},
	unbind: function(element, binding) {
		if (binding.value) {
			element = binding.value;
		}
		var target = element.__vue__ ? element.__vue__ : element;
		if (target["$n-css-handler"]) {
			if (element.__vue__) {
				target.$off(binding.arg, target["$n-css-handler"]);
			}
			else {
				target.removeEventListener(binding.arg, target["$n-css-handler"]);
			}
		}
	}
});
Vue.directive("action", {
	bind: function(element, binding, vnode) {
		var native = ["click", "hover", "mouseover", "mouseout"];
		
		var handler = function(event) {
			element.setAttribute("disabled", "disabled");
			var result = binding.value(event);
			if (result && result.then) {
				var span = document.createElement("span");
				span.setAttribute("class", "n-icon n-icon-spinner");
				span.setAttribute("style", "display: inline-block; text-align: center");
				element.appendChild(span);
				var handler = function() {
					element.removeAttribute("disabled");
					element.removeChild(span);
				};
				result.then(handler, handler);
			}
			else {
				element.removeAttribute("disabled");
			}
		};
		
		if (!binding.arg || native.indexOf(binding.arg) >= 0) {
			element.addEventListener(binding.arg ? binding.arg : "click", handler);
		}
		else {
			vnode.context.$on(binding.arg, handler);
		}
	}
});
if (!nabu) { var nabu = {} }
if (!nabu.tmp) { nabu.tmp = {} }

nabu.tmp.groups = {};

Vue.directive("group", {
	bind: function(element, binding) {
		var component = element.__vue__;
		if (component) {
			var group = binding.arg ? binding.arg : binding.value;
			if (typeof(nabu.tmp.groups[group]) == "undefined") {
				nabu.tmp.groups[group] = [];
			}
			if (nabu.tmp.groups[group].indexOf(component) < 0) {
				nabu.tmp.groups[group].push(component);
				component.$group = nabu.tmp.groups[group];
			
				for (var i = 0; i < nabu.tmp.groups[group].length; i++) {
					nabu.tmp.groups[group][i].$emit("$vue.group.added", component);
				}
			}
		}
	},
	update: function(element, binding) {
		var component = element.__vue__;
		if (component) {
			var found = false;
			var group = binding.arg ? binding.arg : binding.value;
			for (var key in nabu.tmp.groups) {
				var index = nabu.tmp.groups[key].indexOf(component);
				if (index >= 0) {
					if (group == key) {
						found = true;
					}
					else {
						nabu.tmp.groups[key].splice(index, 1);
						for (var i = 0; i < nabu.tmp.groups[key].length; i++) {
							nabu.tmp.groups[key][i].$emit("$vue.group.removed", component);
						}
					}
				}
			}
			if (!found) {
				if (typeof(nabu.tmp.groups[group]) == "undefined") {
					nabu.tmp.groups[group] = [];
				}
				nabu.tmp.groups[group].push(component);
				component.$group = nabu.tmp.groups[group];
			
				for (var i = 0; i < nabu.tmp.groups[group].length; i++) {
					nabu.tmp.groups[group][i].$emit("$vue.group.added", component);
				}
			}
		}
	},
	unbind: function(element, binding) {
		var component = element.__vue__;
		if (component) {
			for (var key in nabu.tmp.groups) {
				var index = nabu.tmp.groups[key].indexOf(component);
				if (index >= 0) {
					nabu.tmp.groups[key].splice(index, 1);
					for (var i = 0; i < nabu.tmp.groups[key].length; i++) {
						nabu.tmp.groups[key][i].$emit("$vue.group.removed", component);
					}
				}
			}
		}
	}
});

Vue.mixin({
	beforeDestroy: function() {
		if (Object.keys(nabu.tmp.groups).length) {
			var removeFromGroups = function(component) {
				for (var key in nabu.tmp.groups) {
					var index = nabu.tmp.groups[key].indexOf(component);
					if (index >= 0) {
						nabu.tmp.groups[key].splice(index, 1);
						for (var i = 0; i < nabu.tmp.groups[key].length; i++) {
							nabu.tmp.groups[key][i].$emit("$vue.group.removed", component);
						}
					}
				}
			}
		
			var recurse = function(component) {
				removeFromGroups(component);
				for (var i = 0; i < component.$children.length; i++) {
					recurse(component.$children[i]);
				}
			}
		
			recurse(this);
		}
	}
});
Vue.directive("route-render", {
	// the argument should be the name of the route, any value is passed in as parameters
	// the modifier is interpreted as the anchor to route it to
	// we use the inserted to make sure the parent exists and nextTick to ensure that it is rendered correctly and we have access to __vue__
	inserted: function(element, binding, vnode) {
		Vue.nextTick(function() {
			var keys = binding.modifiers ? Object.keys(binding.modifiers) : null;
			
			var parameters = {
				alias: binding.arg ? binding.arg : binding.value.alias,
				parameters: binding.arg ? binding.value : binding.value.parameters
			}
			
			if (parameters.alias) {
				var result = vnode.context.$services.router.route(parameters.alias, parameters.parameters, element, true);
				
				if (binding.value && binding.value.created) {
					binding.value.created(result);
				}
				
				if (result && result.then) {
					result.then(function(component) {
						element["n-route-component"] = component;
						if (keys && keys.length) {
							if (vnode.context[keys[0]] instanceof Function) {
								vnode.context[keys[0]](component);
							}
							else {
								vnode.context.$refs[keys[0]] = component;
							}
						}
						if (binding.value && binding.value.mounted) {
							binding.value.mounted(component);
						}
						var getParent = function(element) {
							while (element) {
								element = element.parentNode;
								if (element && element.__vue__) {
									return element.__vue__;
								}
							}
							return null;
						}
						var parent = getParent(element);
						if (parent && parent.$children) {
							parent.$children.push(component);
							component.$parent = parent;
						}
						else if (vnode.context.$children) {
							vnode.context.$children.push(component);
							component.$parent = vnode.context;
						}
						if (parent && parent.$root) {
							component.$root = parent.$root;
						}
						else if (vnode.context.$root) {
							component.$root = vnode.context.$root;
						}
					});
				}
				else {
					if (binding.value && binding.value.mounted) {
						binding.value.mounted(result);
					}
				}
				var cloneParameters = function(parameters) {
					var result = {};
					Object.keys(parameters).forEach(function(x) {
						// page and cell are just big...
						if (x != "page" && x != "cell") {	//  && x != "parameters"
							result[x] = parameters[x];
						}
					});
					return result;
				}
				var lightParameters = {
					alias: binding.arg ? binding.arg : binding.value.alias,
					parameters: cloneParameters(binding.arg ? binding.value : binding.value.parameters)
				}
				try {
					element["n-route-render-route-json"] = JSON.stringify(lightParameters);
				}
				catch (exception) {
					console.warn("Could not marshal route render parameters", exception);				
				}
				element["n-route-render-route"] = parameters;
			}
		});
	},
	unbind: function(element, binding, vnode) {
		// cascade a destroy to underlying elements
		var destroy = function(element) {
			for (var i = 0; i < element.childNodes.length; i++) {
				// first recursively destroy any vms that might exist
				if (element.childNodes[i].nodeType == 1) {
					destroy(element.childNodes[i]);
				}
			}
			// then destroy the vm itself (if there is one)
			if (element.__vue__ && element.__vue__.$destroy) {
				element.__vue__.$destroy();
			}
		}
		destroy(element);
	},
	update: function(element, binding, vnode) {
		// the update can be called before the insert + nextTick has initially triggered
		// we only want to re-render if we have rendered in the first place
		// otherwise we can have multiple renders
		// this stripping is currently focused on page-builder, in the future we should extract this to a configurable set of parameters
		// page and cell are just big and shouldn't change operationally...
		// component is for page-arbitrary, we send in the component itself... which is not serializable
		var reserved = ["page", "cell", "component"];		//  "parameters"
		var cloneParameters = function(parameters) {
			var result = {};
			Object.keys(parameters).forEach(function(x) {
				if (reserved.indexOf(x) < 0) {
					result[x] = parameters[x];
				}
			});
			return result;
		}
		if (element["n-route-render-route"]) {
			var keys = binding.modifiers ? Object.keys(binding.modifiers) : null;
		
			var parameters = {
				alias: binding.arg ? binding.arg : binding.value.alias,
				parameters: binding.arg ? binding.value : binding.value.parameters
			}
			
			var lightParameters = {
				alias: binding.arg ? binding.arg : binding.value.alias,
				parameters: cloneParameters(binding.arg ? binding.value : binding.value.parameters)
			}
		
			var stringifiedParameters = null;
			// note that this was added because of page-arbitrary which contains non-serializable parameters
			// should page-arbitrary not update properly, we can have another look at this
			try {
				stringifiedParameters = JSON.stringify(lightParameters);
			}
			catch (exception) {
				console.warn("Could not marshal route render parameters", exception);
			}
			// if we can't stringify the parameters, assume it is not updated
			// otherwise we end up in an infinite update loop
			var isExactCopy = stringifiedParameters == null || element["n-route-render-route-json"] == stringifiedParameters;
		
			if (!isExactCopy) {
				element["n-route-render-route-json"] = stringifiedParameters;
			
				var isSameAlias = element["n-route-render-route"]
					&& element["n-route-render-route"].alias == parameters.alias;
					
					
				// if we have the same alias and only the parameters are different, check if the component supports live loading of new parameters
				// if so, the component can still decide a rerender is necessary
				if (isSameAlias && element["n-route-component"] && element["n-route-component"].setRouteParameters) {
					var rerender = element["n-route-component"].setRouteParameters(parameters.parameters);
					if (!rerender) {
						return null;
					}
				}
			
				// if it is the same alias and the exact same parameters object, the details are already known
				var isSame = isSameAlias
					&& element["n-route-render-route"].parameters == parameters.parameters;
					
				// check the child content of the parameters by reference, maybe the parent is a new object but it contains the same data
				if (!isSame && element["n-route-render-route"] && element["n-route-render-route"].parameters && parameters.parameters) {
					var parameterKeys = Object.keys(parameters.parameters);
					var availableParameterKeys = Object.keys(element["n-route-render-route"].parameters);
					if (parameterKeys.length == availableParameterKeys.length) {
						isSame = true;
						for (var i = 0; i < parameterKeys.length; i++) {
							if (reserved.indexOf(parameterKeys[i]) < 0 && element["n-route-render-route"].parameters[parameterKeys[i]] != parameters.parameters[parameterKeys[i]]) {
								// even if by reference they are different, do an in-depth check
								if (JSON.stringify(element["n-route-render-route"].parameters[parameterKeys[i]]) == JSON.stringify(parameters.parameters[parameterKeys[i]])) {
									continue;
								}
								isSame = false;
								break;
							}
						}
					}
				}

				if (!isSame) {
					element["n-route-render-route"] = parameters;
					if (!binding.value.rerender || binding.value.rerender()) {
						// in a past version, we required a different alias as well before we rerendered
						// perhaps we can do a strict mode?
						var result = vnode.context.$services.router.route(parameters.alias, parameters.parameters, element, true);
						if (binding.value && binding.value.created) {
							binding.value.created(result);
						}
						if (result && result.then) {
							result.then(function(component) {
								
								// remove previous comopnent
								if (element["n-route-component"]) {
									var previousComponent = element["n-route-component"];
									// unregister with the children there
									if (previousComponent.$parent && previousComponent.$parent.$children) {
										var index = previousComponent.$parent.$children.indexOf(previousComponent);
										if (index >= 0) {
											previousComponent.$parent.$children.splice(index, 1);
										}
									}
								}
								
								var getParent = function(element) {
									while (element) {
										element = element.parentNode;
										if (element && element.__vue__) {
											return element.__vue__;
										}
									}
									return null;
								}
								var parent = getParent(element);
								if (parent && parent.$children) {
									parent.$children.push(component);
									component.$parent = parent;
								}
								else if (vnode.context.$children) {
									vnode.context.$children.push(component);
									component.$parent = vnode.context;
								}
								if (parent && parent.$root) {
									component.$root = parent.$root;
								}
								else if (vnode.context.$root) {
									component.$root = vnode.context.$root;
								}
								
								element["n-route-component"] = component;
								if (keys && keys.length) {
									if (vnode.context[keys[0]] instanceof Function) {
										vnode.context[keys[0]](component);
									}
									else {
										vnode.context.$refs[keys[0]] = component;
									}
								}
								if (binding.value.mounted) {
									binding.value.mounted(component);
								}
							});
						}
						else {
							if (binding.value.mounted) {
								binding.value.mounted(result);
							}
						}
					}
				}
			}
		}
	}
});

if (!nabu) { var nabu = {} }
if (!nabu.tmp) { nabu.tmp = {} }

nabu.tmp.visibleElementListeners = [];
nabu.tmp.visibleElementTimeout = null;

window.addEventListener("scroll", function(event) {
	if (nabu.tmp.visibleElementTimeout) {
		clearTimeout(nabu.tmp.visibleElementTimeout);
		nabu.tmp.visibleElementTimeout = null;
	}
	nabu.tmp.visibleElementTimeout = setTimeout(function() {
		nabu.tmp.visibleElementListeners.map(function(listener) {
			var visible = nabu.utils.elements.inViewport(listener.element);
			// visibility has changed
			if (visible != listener.visible) {
				listener.visible = visible;
				if (listener.target) {
					listener.target.$visible = visible;
				}
				if (listener.handler) {
					listener.handler(visible);
				}
			}
		});
	}, 100);
}, true);

Vue.directive("visible", {
	bind: function(element, binding) {
		var target = element.__vue__;
		var result = {
			element: element,
			target: target,
			handler: binding.value,
			visible: false
		};
		nabu.tmp.visibleElementListeners.push(result);
		if (target) {
			Vue.set(target, "$visible", false);
		}
		// we only know after rendering which are visible and which aren't
		Vue.nextTick(function() {
			result.visible = nabu.utils.elements.inViewport(element);
			if (result.visible) {
				if (result.target) {
					result.target.$visible = result.visible;
				}
				if (result.handler) {
					result.handler(result.visible);
				}
			}
		});
	},
	unbind: function(element, binding) {
		var current = nabu.tmp.visibleElementListeners.filter(function(x) { return x.element == element })[0];
		if (current) {
			nabu.tmp.visibleElementListeners.splice(nabu.tmp.visibleElementListeners.indexOf(current), 1);
		}
	}
});


// the argument should be the name of the route, any value is passed in as parameters
// the modifier is interpreted as the anchor to route it to
Vue.directive("content", function(element, binding, vnode) {
	var content = binding.value;
	var keys = null;
	if (binding.modifiers) {
		keys = Object.keys(binding.modifiers);
	}
	// always clear the element
	nabu.utils.elements.clear(element);
	
	var rewriteLinks = function() {
		if (application && application.services && application.services.router) {
			var results = element.querySelectorAll("a");
			var addListener = function(href) {
				return function(event) {
					var route = application.services.router.router.findRoute(href, false);
					if (route) {
						application.services.router.route(route.route.alias, route.parameters);
					}
					event.stopPropagation();
					event.preventDefault();	
				}
			}
			// rewrite links in this page to click handlers
			for (var i = 0; i < results.length; i++) {
				var href = results.item(i).getAttribute("href");
				if (href && href.indexOf("/") == 0) {
					results.item(i).addEventListener("click", addListener(href));
				}
			}
		}
	};

	if (content != null && typeof(content) != "undefined") {
		var parameters = {};
		if (keys && keys.indexOf("parameterized") >= 0) {
			parameters = content;
			content = content.value;
		}
		if (content != null && typeof(content) != "undefined") {
			var compile = (keys && keys.indexOf("compile") >= 0) || parameters.compile;
			var sanitize = (keys && keys.indexOf("sanitize") >= 0) || parameters.sanitize;
			var allowDataAttributes = keys.indexOf("allowDataAttributes") >= 0 || parameters.allowDataAttributes;
			var allowFormElements = keys.indexOf("allowFormElements") >= 0 || parameters.allowFormElements;
			var allowLinkIds = keys.indexOf("allowLinkIds") >= 0 || parameters.allowLinkIds;

			var sanitizeParameters = {
				allowDataAttributes: allowDataAttributes,
				allowFormElements: allowFormElements,
				allowLinkIds: allowLinkIds
			};

			// we interpret this as plain string data, that means making sure everything is escaped and whitespace is adhered to
			if ((keys && keys.indexOf("plain") >= 0) || parameters.plain) {
				if (typeof(content) != "string") {
					if (content.innerHTML) {
						content = content.innerHTML;
					}
					else {
						content = "" + content;
					}
				}
				content = content.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
				.replace(/\n/g, "<br/>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;");
				// breaks default wrapping..
				//.replace(/ /g, "&nbsp;");
			}
			// the sanitize routine sends back "element.innerHTML" by default if you pass it a string
			// however, if that string started out with a raw ampersand (e.g. "test&test")
			// the sanitize will do nothing except basically element.innerHTML = "test&test"; return element.innerHTML;
			// that single action will however change the content into "test&amp;test" to make it HTML-compatible
			// if we combine this with the "plain" encoding, we get double-encoded ampersands
			// in theory the plain encoding already prevents injection and is very unlikely to be needed in combination with an actual sanitize routine which selectively removes html elements/attrs
			else if (sanitize) {
				// compiling content has NO use if it is first sanitized as this will throw away any custom components you might have
				// instead if we compile, we sanitize the resulting content which _is_ useful
				// note that the structure of this code is a bit weird but that is due to organic growth and the need to minimize changes
				if (!compile) {
					content = nabu.utils.elements.sanitize(content, sanitizeParameters);
				}
			}
			if (typeof(content) == "string" && content.trim().length == 0) { // content.match(/^[ \t]+$/)
				element.appendChild(document.createTextNode(content));
				//element.innerHTML = content;
			}
			else if (compile) {
				var context = {};
				Object.keys(vnode.context.$props).map(function(key) {
					if (typeof(vnode.context.$props[key]) !== "undefined") {
						context[key] = vnode.context.$props[key];
					}
				});
				// data overwrites props if necessary
				Object.keys(vnode.context.$data).map(function(key) {
					if (typeof(vnode.context.$data[key]) !== "undefined") {
						context[key] = vnode.context.$data[key];
					}
				});
				var component = Vue.extend({
					data: function() {
						return context;
					},
					template: "<div>" + (typeof(content) == "string" ? content : content.innerHTML) + "</div>" 
				});
				content = new component();
				content.$mount();
				
				if (sanitize) {
					nabu.utils.elements.sanitize(content.$el, sanitizeParameters);
				}

				var insertBefore = null;
				for (var i = content.$el.childNodes.length - 1; i >= 0; i--) {
					if (insertBefore == null) {
						insertBefore = element.appendChild(content.$el.childNodes[i]);
					}
					else {
						insertBefore = element.insertBefore(content.$el.childNodes[i], insertBefore);
					}
				}
				rewriteLinks();
			}
			else if (content instanceof HTMLElement) {
				element.appendChild(content);
				rewriteLinks();
			}
			else {
				if (content.indexOf("<") >= 0) {
					element.innerHTML = content;
				}
				else {
					// this will escape HTML, however we already do that potentially so we don't want to do that here because it can lead to double escaping
					// element.appendChild(document.createTextNode(content));
					var tmp = document.createElement("span");
					tmp.innerHTML = content;
					element.appendChild(tmp);
				}
				rewriteLinks();
			}
		}
	}
});

 
// this directive takes a header (presumed at the top of the page) and will slide it away when you scroll down
// the first time you scroll up however, the menu pops back up
Vue.directive("fixed-header", {
	bind: function(element, binding) {
		var result = binding.value;
		if (result != null && result == false) {
			return;
		}
		var originalPosition = element.style.position;
		var originalMargin = element.style.marginBottom;
		
		element.style.transition = "position 0.3s linear, top 0.3s linear";
		var y = window.pageYOffset + element.getBoundingClientRect().top;
		var height = element.getBoundingClientRect().height;
		var toggled = false;
		var div = document.createElement("div");
		div.setAttribute("class", "fixed-header-spacer");
		var inserted = false;
		element["$n-fixed-header-listener"] = function(event) {
			if (!inserted && element.parentNode) {
				inserted = true;
				element.parentNode.insertBefore(div, element);
			}
			if (height == 0) {
				height = element.getBoundingClientRect().height;
			}
			if (y == 0 && element.style.position != "fixed") {
				y = window.pageYOffset + element.getBoundingClientRect().top;
			}
			// this kicks in the first time it goes out of view
			if (element.getBoundingClientRect().top < 0 && element.style.position != "fixed") {
				div.style.height = height + "px";
				element.style.position = "fixed";
				element.style.top = "0px";
				element.style.marginBottom = height + "px";
				element.setAttribute("fixed", "true");
				toggled = true;
			}
			// turn it off if we scroll up again
			else if (element.style.position == "fixed" && window.pageYOffset < y) {
				div.style.height = "0px";
				element.style.position = originalPosition;
				element.style.marginBottom = originalMargin;
				element.removeAttribute("fixed");
			}
		};
		window.addEventListener("scroll", element["$n-fixed-header-listener"]);
	},
	unbind: function(element) {
		if (element["$n-fixed-header-listener"]) {
			console.log("Removing event listener");
			window.removeEventListener("scroll", element["$n-fixed-header-listener"]);
		}
	}
});
Vue.directive("focus", {
	inserted: function(element, binding, vnode) {
		if (typeof(binding.value) == "undefined" || !!binding.value) {
			Vue.nextTick(function() {
				var children = element.getElementsByTagName("input");
				if (!children.length) {
					children = element.getElementsByTagName("textarea");
				}
				if (children.length) {
					children[0].focus();
				}
				else {
					element.focus();
				}
			});
		}
	}
});
Vue.directive("route", function(element, binding, vnode) {
	// the argument should be the name of the route, any value is passed in as parameters
	// the modifier is interpreted as the anchor to route it to
	var alias = binding.arg ? binding.arg : binding.value.alias;
	var parameters = binding.arg ? binding.value : binding.value.parameters;
	var url = vnode.context.$services.router.template(alias, parameters);
	var keys = null;
	if (binding.modifiers) {
		keys = Object.keys(binding.modifiers);
	}
	var all = keys.indexOf("all") >= 0;
	if (all) {
		keys.splice(keys.indexOf("all"), 1);
	}
	if (keys && keys.indexOf("absolute") >= 0) {
		url = (application && application.configuration && application.configuration.url ? application.configuration.url : window.location.protocol + "//" + window.location.host) + url;
		keys.splice(keys.indexOf("absolute"), 1);
	}
	var mask = false;
	if (keys && keys.indexOf("mask") >= 0) {
		mask = true;
		keys.splice(keys.indexOf("mask"), 1);
	}
	var onclick = function(event) {
		if (!routing) {
			var anchor = null;
			if (keys && keys.indexOf("self") >= 0) {
				anchor = nabu.utils.router.self(element);
			}
			else if (keys && keys.length) {
				anchor = keys[0];
			}
			routing = true;
			if (all) {
				vnode.context.$services.router.routeAll(alias, parameters, anchor, mask);
			}
			else {
				vnode.context.$services.router.route(alias, parameters, anchor, mask);
			}
			routing = false;
		}
		return false;
	};
	// make sure we don't trigger twice
	var routing = false;
	// make sure we don't do anything else
	if (element.tagName.toLowerCase() == "a") {
		element.setAttribute("href", url);
//			element.setAttribute("href", "javascript:void(0)");
		// internet explorer and edge do _not_ send out a popstate event when we change the hash with a href
		// for this reason we register an onclick that is executed before the href and returns false to stop the default href behavior
		// this gives us clean hrefs for server-side rendering / social media sharing / ... yet a functional route change in all browsers
		element.onclick = onclick;	
	}
	else {
		element.onclick = onclick;
	}
});
Vue.directive("bubble", {
	bind: function(element, binding, vnode) {
		var event = binding.arg ? binding.arg : "input";
		vnode.componentInstance.$on(event, function() {
			var parameters = [];
			for (var i = 0; i < arguments.length; i++) {
				parameters.push(arguments[i]);
			}
			if (!binding.value || !!binding.value.apply(vnode.context, parameters)) {
				// add the event before calling the emit
				parameters.unshift(event);
				vnode.context.$emit.apply(vnode.context, parameters);
			}
		});
	}
});
Vue.directive("swipe", {
	bind: function(element, binding) {
		element.$$touchStart = function(event) {
			element.$$touches = event.touches[0];
		}
		var keys = Object.keys(binding.modifiers);
		var variance = 50;
		for (var i = 0; i < keys.length; i++) {
			if (parseInt(keys[i]) == keys[i]) {
				variance = parseInt(keys[i]);
				keys.splice(i, 1);
				break;
			}
		}
		element.$$touchMove = function(event) {
			if (element.$$touches) {
				var fromX = element.$$touches.clientX;
				var fromY = element.$$touches.clientY;
				
				var toX = event.touches[0].clientX;
				var toY = event.touches[0].clientY;
				
				var diffX = toX - fromX;
				var diffY = toY - fromY;
				
				var trigger = false;
				// we prioritize left/right over up/down
				if (Math.abs(diffX) > Math.abs(diffY)) {
					// swipe right
					if (diffX > variance) {
						if (!keys.length || keys.indexOf("right") >= 0) {
							trigger = true;
						}
					}
					// swipe left
					else if (diffX < 0 - variance) {
						if (!keys.length || keys.indexOf("left") >= 0) {
							trigger = true;
						}
					}
				}
				else {
					// swipe down
					if (diffY > variance) {
						if (!keys.length || keys.indexOf("down") >= 0) {
							trigger = true;
						}
					}
					// swipe up
					else if (diffY < 0 - variance) {
						if (!keys.length || keys.indexOf("up") >= 0) {
							trigger = true;
						}	
					}
				}
				if (trigger) {
					binding.value(event);
				}
			}
		}
		element.$$touchStop = function(event) {
			element.$$touches = null;
		}
		element.addEventListener("touchstart", element.$$touchStart); 
		element.addEventListener("touchmove", element.$$touchMove);
		element.addEventListener("touchstop", element.$$touchStop);
	},
	unbind: function(element, binding) {
		element.removeEventListener("touchstart", element.$$touchStart); 
		element.removeEventListener("touchmove", element.$$touchMove);
		element.removeEventListener("touchstop", element.$$touchStop);
	}
});

if (!nabu) { nabu = {}; }
if (!nabu.vue) { nabu.vue = {}; }

nabu.vue.objects = {
	merge: function(original) {
		if (original instanceof Array) {
			var args = [];
			// the arguments aren't really an array, can't use default merge stuff
			for (var i = 1; i < arguments.length; i++) {
				args.push(arguments[i]);
			}
			// for each entry in the original, perform a merge
			for (var i = 0; i < original.length; i++) {
				args.unshift(original[i]);
				nabu.vue.objects.merge.apply(null, args);
				args.shift();
			}
		}
		else {
			for (var i = 1; i < arguments.length; i++) {
				if (arguments[i]) {
					var overwrite = typeof(arguments[i].$overwrite) == "undefined" ? true : arguments[i].$overwrite;
					for (var key in arguments[i]) {
						if (key == "$overwrite") {
							continue;
						}
						if (arguments[i][key] instanceof Array) {
							if (overwrite) {
								original[key] = arguments[i][key];
							}
							else {
								if (!original[key]) {
									original[key] = [];
								}
								nabu.vue.arrays.merge(original[key], arguments[i][key]);
							}
						}
						// typeof(null) is object
						else if (typeof arguments[i][key] == "object" && arguments[i][key] != null && !(arguments[i][key] instanceof Date)) {
							if (!original[key]) {
								Vue.set(original, key, arguments[i][key]);
							}
							else {
								nabu.vue.objects.merge(original[key], arguments[i][key]);
							}
						}
						else if (typeof arguments[i][key] != "undefined") {
							if (!original[key] || overwrite) {
								Vue.set(original, key, arguments[i][key]);
							}
						}
					}
				}
			}
		}
	}
}
if (!nabu) { var nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }
if (!nabu.utils.vue) { nabu.utils.vue = {}; }

nabu.utils.vue.Loader = Vue.component("n-loader", {
	template: "<span class='n-icon n-icon-spinner n-loader fa spinner fas fa-spinner' style='display: block; text-align: center; margin: auto;'></span>"
})

nabu.utils.vue.prompt = function(render, parameters) {
	var root = document.createElement("div");
	root.setAttribute("class", "n-prompt is-modal" + (parameters && parameters.class ? " " + parameters.class : ""));
	document.body.appendChild(root);
	
	var container;
	
	if (parameters && parameters.raw) {
		container = root;
	}
	else {
		var container = document.createElement("div");
		container.setAttribute("class", "n-prompt-container is-modal-content");
		root.appendChild(container);
	}
	
	var escapeListener = function(event) {
		if (event.keyCode == 27) {
			document.body.removeChild(root);
			document.removeEventListener("keydown", escapeListener);
			promise.reject();
		}
	};
	document.addEventListener("keydown", escapeListener);

	root.addEventListener("click", function(event) {
		if (event.target == root) {
			document.body.removeChild(root);
			document.removeEventListener("click", escapeListener);
			promise.reject();
		}
	});
	
	var promise = new nabu.utils.promise();
	
	if (parameters && parameters.slow && this.$render) {
		this.$render({ target: container, content: new nabu.utils.vue.Loader() });
	}
	
	var removeRoot = function() {
		if (root.parentNode == document.body) {
			document.body.removeChild(root);
			document.removeEventListener("keydown", escapeListener);
		}
	}
	
	var activate = function(component) {
		component.$resolve = function(object) {
			removeRoot();
			if (!promise.state) {
				promise.resolve(object);
			}
		};
		component.$reject = function(object) {
			removeRoot();
			if (!promise.state) {
				promise.reject(object);
			}
		}
		// if someone on the outside resolves the promise, make sure we call the functions
		promise.then(removeRoot, removeRoot);
	};
	if (typeof(render) == "string" && render.indexOf("#") < 0 && this.$services && this.$services.router) {
		this.$services.router.route(render, parameters, container).then(activate);
	}
	else if (this.$render) {
		this.$render({ target: container, content: render, activate: activate});
	}
	else {
		nabu.utils.vue.render({ target: container, content: render, activate: activate});
	}
	return promise;
};

// parameters are:
// - message: the message to show
// - type: question, warning, error
// - ok: the text for the ok button
// - cancel: the text for the cancel button
// - variant: the variant to use
nabu.utils.vue.confirm = function(parameters) {
	return nabu.utils.vue.prompt.bind(this)(function() {
		var component = Vue.extend({ 
			template: "#n-confirm",
			data: function() {
				return {
					title: null,
					ok: null,
					cancel: null,
					type: null,
					message: null,
					rejectable: true
				}
			},
			methods: {
				getIcon: function() {
					if (this.type == "question") {
						return "question-circle-o";
					}
					else if (this.type == "warning") {
						return "exclamation-triangle";
					}
					else if (this.type == "error") {
						return "exclamation-circle";
					}
				},
				resolve: function() {
					this.$resolve();
				},
				translate: function(value) {
					// slightly messed up regex to avoid %{} replacement if templating is turned on (backwards compatibility)
					return parameters && parameters.translator ? parameters.translator(value) : 
						(value && value.replace ? value.replace(/%[{](?:[a-zA-Z]+[:]+|)([^}]+)}/, "$1") : value);
				}
			}
		});
		return new component({ data: parameters });
	}, {class:"is-variant-" + (this.variant ? this.variant : "confirm")});
};

nabu.utils.vue.wait = function(parameters) {
	return nabu.utils.vue.prompt.bind(this)(function() {
		var component = Vue.extend({ 
			template: "#n-confirm",
			data: function() {
				return {
					title: null,
					ok: null,
					cancel: null,
					type: null,
					message: null,
					rejectable: false,
					failed: false,
					result: null
				}
			},
			activate: function(done) {
				var self = this;
				parameters.promise.then(function(result) {
					if (parameters.success != null) {
						nabu.utils.objects.merge(self, parameters.success);
					}
					self.result = result;
					done();
					if (parameters.success == null) {
						self.resolve();
					}
				}, function(result) {
					if (parameters.failure != null) {
						nabu.utils.objects.merge(self, parameters.failure);
					}
					self.failed = true;
					self.result = result;
					done();
					if (parameters.failure == null) {
						self.resolve();
					}
				});
			},
			methods: {
				resolve: function() {
					if (this.failed) {
						this.$reject(this.result);
					}
					else {
						this.$resolve(this.result);
					}
				}
			}
		});
		return new component({ data: parameters});
	}, { slow: true, class: "n-prompt-wait" });
};

Vue.mixin({
	computed: {
		$prompt: function() { return nabu.utils.vue.prompt },
		$confirm: function() { return nabu.utils.vue.confirm },
		$wait: function() { return nabu.utils.vue.wait }
	}
});

if (!nabu) { var nabu = {} }
if (!nabu.tmp) { nabu.tmp = {} }

nabu.tmp.panes = Vue.extend({
	data: function() {
		return {
			panes: []
		}
	}
});

nabu.tmp.panes = new nabu.tmp.panes();

Vue.directive("pane", {
	bind: function(element, binding) {
		element.classList.add("v-pane-" + nabu.tmp.panes.panes.length);
		if (binding.value) {
			element.paneValue = binding.value;
		}
		if (!element.hasAttribute("id")) {
			element.setAttribute("id", "v-pane-" + nabu.tmp.panes.panes.length);
		}
		nabu.tmp.panes.panes.push(element);
	},
	unbind: function(element, binding) {
		var index = nabu.tmp.panes.panes.indexOf(element);
		if (index >= 0) {
			// we decrease the counters of all the panes after this one
			for (var i = index + 1; i < nabu.tmp.panes.panes.length; i++) {
				if (element.hasAttribute("id") && element.getAttribute("id").match("v-pane-[0-9]+")) {
					element.setAttribute("id", "v-pane-" + i);
				}
				element.classList.remove("v-pane-" + i);
				element.classList.add("v-pane-" + (i - 1));
			}
			// remove the element from the panes
			nabu.tmp.panes.panes.splice(index, 1);
		}
		element.paneValue = null;
	}
});

Vue.component("n-pane-crumbs", {
	template: "<div class='n-pane-crumbs'><div @mouseover='highlight(pane)' @mouseout='unhighlight()' @click='select(pane)' v-for='pane in $window.nabu.tmp.panes.panes'><span v-if='pane.name'>{{pane.name}}</span></div></div>",
	methods: {
		highlight: function(pane) {
			this.unhighlight();
			pane.$el.classList.add("v-pane-hover");
		},
		unhighlight: function() {
			for (var i = 0; i < nabu.tmp.panes.panes.length; i++) {
				nabu.tmp.panes.panes[i].$el.classList.remove("v-pane-hover");
			}
		}
	}
});

Vue.component("n-panes", {
	template: "<div class='n-panes'><slot></slot></div>"
});

Vue.component("n-pane", {
	props: {
		name: {
			type: String,
			required: false
		}
	},
	template: "<div class='n-pane'><n-pane-crumbs/><slot></slot></div>",
	data: function() {
		return {
			index: 0
		}
	},
	mounted: function() {
		this.register();
	},
	updated: function() {
		this.register();
	},
	methods: {
		register: function() {
			if (nabu.tmp.panes.panes.indexOf(this) < 0) {
				this.$el.classList.add("v-pane-" + nabu.tmp.panes.panes.length);
				if (!this.$el.hasAttribute("id")) {
					this.$el.setAttribute("id", "v-pane-" + nabu.tmp.panes.panes.length);
				}
				nabu.tmp.panes.panes.push(this);
				this.setReverse();
			}
		},
		setReverse: function() {
			for (var i = 0; i < nabu.tmp.panes.panes.length; i++) {
				var element = nabu.tmp.panes.panes[i].$el;
				if (element.hasAttribute("v-pane-reverse-index")) {
					element.classList.remove("v-pane-reverse-" + element.getAttribute("v-pane-reverse-index"));
				}
				element.setAttribute("v-pane-reverse-index", nabu.tmp.panes.panes.length - 1 - i);
				element.classList.add("v-pane-reverse-" + element.getAttribute("v-pane-reverse-index"));
			}
		}
	},
	beforeDestroy: function() {
		var index = nabu.tmp.panes.panes.indexOf(this);
		if (index >= 0) {
			// we decrease the counters of all the panes after this one
			for (var i = index + 1; i < nabu.tmp.panes.panes.length; i++) {
				var element = nabu.tmp.panes.panes[i].$el;
				if (element.hasAttribute("id") && element.getAttribute("id").match("v-pane-[0-9]+")) {
					element.setAttribute("id", "v-pane-" + i);
				}
				element.classList.remove("v-pane-" + i);
				element.classList.add("v-pane-" + (i - 1));
			}
			this.setReverse();
			// remove the element from the panes
			nabu.tmp.panes.panes.splice(index, 1);
		}
	}
});
if (!nabu) { var nabu = {}; }
if (!nabu.services) { nabu.services = {}; }

nabu.services.VueService = function(component, parameters) {
	component.render = function(done) {
		// do nothing, a service has no DOM presence
		return done();
	}
	
	var service = function($services) {
		var activate = function(instance) {
			var callActivated = function() {
				// call the activated hook
				if (instance.$options.activated) {
					var activated = instance.$options.activated instanceof Array ? instance.$options.activated : [instance.$options.activated];
					for (var i = 0; i < activated.length; i++) {
						activated[i].call(instance);
					}
				}
			};
			if (instance.$options && instance.$options.activate) {
				if (instance.$options.activate instanceof Array) {
					var promises = [];
					var process = function(activation) {
						var promise = $services.q.defer();
						promises.push(promise);
						var done = function(result) {
							promise.resolve(result);
						};
						activation.call(instance, done);
					}
					for (var i = 0; i < instance.$options.activate.length; i++) {
						process(instance.$options.activate[i]);
					}
					var resultingPromise = $services.q.defer();
					$services.q.all(promises).then(function(x) {
						callActivated();
						var resultingService = null;
						if (x) {
							for (var i = 0; i < x.length; i++) {
								if (x[i]) {
									resultingService = x[i];
								}
							}
						}
						// don't allow a service instance to be returned in the done by default
						//resultingPromise.resolve(resultingService ? resultingService : instance);
						resultingPromise.resolve(instance);
					}, resultingPromise);
					return resultingPromise;
				}
				else {
					var promise = $services.q.defer();
					var done = function(result) {
						callActivated();
						// don't allow a service instance to be returned in the done by default
						//promise.resolve(result ? result : instance);
						promise.resolve(instance);
					};
					instance.$options.activate.call(instance, done);
					return promise;
				}
			}
			else {
				var promise = $services.q.defer();
				callActivated();
				promise.resolve(instance);
				return promise;
			}
		};
		
		this.$initialize = function() {
			var instance = new component({ data: { "$services": $services }});
			if (instance.$options.clear) {
				instance.$clear = function() {
					var clears = instance.$options.clear instanceof Array ? instance.$options.clear : [instance.$options.clear];
					var promises = [];
					var callClear = function(clear) {
						var promise = new nabu.utils.promise();
						var done = function() {
							promise.resolve();
						};
						clear.call(instance, done);
						return promise;
					};
					for (var i = 0; i < clears.length; i++) {
						promises.push(callClear(clears[i]));
					}
					return new nabu.utils.promises(promises);
				}
			}
			if (instance.$options.switchLanguage) {
				instance.$switchLanguage = function() {
					var switchLanguages = instance.$options.switchLanguage instanceof Array ? instance.$options.switchLanguage : [instance.$options.switchLanguage];
					var promises = [];
					var callSwitchLanguage = function(switchLanguage) {
						var promise = new nabu.utils.promise();
						var done = function() {
							promise.resolve();
						};
						switchLanguage.call(instance, done);
						return promise;
					};
					for (var i = 0; i < switchLanguages.length; i++) {
						promises.push(callSwitchLanguage(switchLanguages[i]));
					}
					return new nabu.utils.promises(promises);
				}
			}
			if (parameters && parameters.lazy) {
				instance.$lazy = function() {
					if (!instance.$lazyInitialized) {
						instance.$lazyInitialized = new Date();
						return activate(instance);
					}
					else {
						var promise = $services.q.defer();
						promise.resolve(instance);
						return promise;
					}
				};
			}
			if (!parameters || !parameters.lazy) {
				var serviceDependencies = [];
				if (instance.$options.services) {
					nabu.utils.arrays.merge(serviceDependencies, instance.$options.services);
				}
				if (instance.$options.optionalServices) {
					instance.$options.optionalServices.forEach(function(x) {
						serviceDependencies.push({
							name: x,
							optional: true
						})
					});
				}
				// if we have service dependencies, make sure they are loaded first
				if (serviceDependencies.length) {
					var promises = [];
					for (var i = 0; i < serviceDependencies.length; i++) {
						// this is either a string (this was the case for quite a long time)
						// or an object with a "name" and an "optional" field to indicate whether the service is absolutely necessary
						var serviceDependency = serviceDependencies[i];
						var promise = $services.$promise(serviceDependency.name ? serviceDependency.name : serviceDependency, serviceDependency.optional);
						if (!promise) {
							throw "Could not find service dependency: " + serviceDependencies[i];
						}
						promises.push(promise);
					}
					var promise = new nabu.utils.promise();
					promise.stage(instance);
					new nabu.utils.promises(promises).then(function() {
						// create a new instance
						// this service may have dependencies in the form of watchers, computed properties... to remote services
						// these are not set up correctly if they are not available at creation time
						// @2017-11-07: we use promise staging now to preemtively send back the instance preventing the need for double creation
						//instance = new component({ data: { "$services": $services }});
						activate(instance).then(promise, promise);
					});
					return promise;
				}
				else {
					return activate(instance);
				}
			}
			else {
				return instance;
			}
		}
		
	}
	
	if (parameters && parameters.name) {
		var parts = parameters.name.split(".");
		var target = window;
		for (var i = 0; i < parts.length - 1; i++) {
			if (!target[parts[i]]) {
				target[parts[i]] = {};
			}
			target = target[parts[i]];
		}
		target[parts[parts.length - 1]] = service;
	}
	
	return service;
}

// mixin an activation sequence for lazy service loading
Vue.mixin({
	initialize: function(done) {
		var serviceDependencies = [];
		if (this.$options.services) {
			nabu.utils.arrays.merge(serviceDependencies, this.$options.services);
		}
		if (this.$options.optionalServices) {
			this.$options.optionalServices.forEach(function(x) {
				serviceDependencies.push({
					name: x,
					optional: true
				})
			});
		}
		if (serviceDependencies.length) {
			if (!this.$services) {
				throw "No service provider found";
			}
			var promises = [];
			for (var i = 0; i < serviceDependencies.length; i++) {
				var name = serviceDependencies[i].name ? serviceDependencies[i].name : serviceDependencies[i].split(".");
				var target = this.$services;
				for (var j = 0; j < name.length; j++) {
					if (!target) {
						throw "Could not find service: " + this.$options.services[i];
					}
					target = target[name[j]];
				}
				if (!target.$lazyInitialized && target.$lazy) {
					var result = target.$lazy();
					if (result.then) {
						promises.push(result); 
					}
				}
			}
			this.$services.q.all(promises).then(function() {
				done();
			});
		}
		else {
			done();
		}
	}
});
var vi = function(element) {
	if (typeof(element) == "string") {
		element = document.querySelector(element);
	}
	while (element && !element.__vue__) {
		element = element.parentNode;
	}
	return element ? element.__vue__ : null;
}

Vue.config.optionMergeStrategies.activate = function (toVal, fromVal) {
	var result = [];
	if (fromVal instanceof Array) {
		nabu.utils.arrays.merge(result, fromVal);
	}
	else if (fromVal) {
		result.push(fromVal);
	}
	if (toVal instanceof Array) {
		nabu.utils.arrays.merge(result, toVal);
	}
	else if (toVal) {
		result.push(toVal);
	}
	return result;
}

Vue.config.optionMergeStrategies.activated = Vue.config.optionMergeStrategies.activate;
Vue.config.optionMergeStrategies.clear = Vue.config.optionMergeStrategies.activate;
Vue.config.optionMergeStrategies.services = Vue.config.optionMergeStrategies.activate;
Vue.config.optionMergeStrategies.asyncWatch = Vue.config.optionMergeStrategies.watch;
Vue.config.optionMergeStrategies.asyncComputed = Vue.config.optionMergeStrategies.computed;

Vue.mixin({
	// the activate() routine is done by the time we are mounted
	// start computed and watchers that depend on that now
	activated: function() {
		if (this.$options.asyncComputed) {
			var computed = this.$options.asyncComputed instanceof Array ? this.$options.asyncComputed : [this.$options.asyncComputed]; 		
			for (var i = 0; i < computed.length; i++) {
				Vue.util.initComputed(this, computed[i]);
			}
		}
		if (this.$options.asyncWatch) {
			Vue.util.initWatch(this, this.$options.asyncWatch);
		}
	},
	/*
	uncomment for debugging
	updated: function() {
		console.log("updated", this.$options.template);	
	},
	*/
	methods: {
		// re-add the $appendTo, the router depends on it
		$appendTo: function(element) {
			element.appendChild(this.$el);
		},
		$dispatch: function(event) {
			var args = [];
			for (var i = 1; i < arguments.length; i++) {
				args.push(arguments[i]);
			}
			var call = function(context) {
				if (context && context.$options && context.$options.events) {
					var names = Object.keys(context.$options.events);
					for (var i = 0; i < names.length; i++) {
						if (event == names[i]) {
							var result = context.$options.events[names[i]].apply(context, args);
							// if the method returns "true", we need to keep going deeper
							if (result !== true) {
								return true;
							}
							break;
						}
					}
					if (context.$parent) {
						call(context.$parent);
					}
				}
				return false;
			}
			call(this);
		},
		$remove: function() {
			if (this.$el && this.$el.parentNode) {
				this.$el.parentNode.removeChild(this.$el);
			}
		},
		$redirect: function(url) {
			window.location = url;
		}
	},
	// re-add the ready lifecycle state
	mounted: function() {
		this.$mounted = true;
		if (this.$options.ready) {
			var self = this;
			this.$nextTick(function () {
				if (self.$options.ready instanceof Array) {
					for (var i = 0; i < self.$options.ready.length; i++) {
						self.$options.ready[i].call(self);
					}
				}
				else {
					self.$options.ready.call(self);
				}
			});
		}
	},
	// $children and $refs are no longer reactive
	// need a way in the parent to know when a child has been added (e.g. for label calculation in forms)
	ready: function() {
		this.$readied = true;
		if (this.$parent) {
			this.$parent.$emit("$vue.child.added", this);
		}
		this.$emit("hook:ready");
	},
	computed: {
		$window: function() { return window },
		$document: function() { return document },
		$self: function() { return this }
	}
});

Vue.views = {};
Vue.services = {};
Vue.view = function(name, component) {
	if (component) {
		// assume template id matches
		if (component.template == null) {
			component.template = "#" + name;
		}
		Vue.views[name] = {
			original: component,
			component: Vue.component(name, component)
		};
		
	}
	return Vue.views[name].component;
};
Vue.service = function(name, component, parameters) {
	if (component) {
		Vue.services[name] = nabu.services.VueService(Vue.extend(component, parameters));
	}
	return Vue.services[name];
};

window.addEventListener("load", function () {
	application.bootstrap(function($services) {
		Object.keys(Vue.views).map(function(name) {
			var component = Vue.views[name].original;
			var route = { 
				priority: component.priority,
				alias: component.alias ? component.alias : name,
				category: component.category,
				description: component.description,
				name: component.name != name ? component.name : null,
				icon: component.icon,
				accept: component.accept,
				// we call it "init" because "initialize" is already taken in vue...
				initialize: component.init,
				enter: function(properties) {
					var component = Vue.view(name);
					return new component({propsData: properties});
				},
				query: [],
				parameters: {}
			};
			if (component.url) {
				route.url = component.url;
			}
			// this is dangerous, it automatically exposes it to user input
			// we have never used this and if we want to reintroduce it, it will be done explicitly
			if (component.props && false) {
				Object.keys(component.props).map(function(key) {
					// if it does not exist in the url, assume query parameter
					if (!route.url || route.url.indexOf("{" + key + "}") < 0) {
						route.query.push(key);
					}
				});
			}
			// safer and we can still pass in from other pages!
			else if (component.props) {
				Object.keys(component.props).map(function(key) {
					if (!route.url || route.url.indexOf("{" + key + "}") < 0) {
						route.parameters[key] = {
							type: "string"
						}
					}
				});
			}
			$services.router.register(route);
		});
		return $services.$register(Vue.services);
	});
});

Vue.component("n-view", {
	template: "<div v-route-render='{alias: alias, parameters: $attrs, mounted: register }'></div>",
	props: {
		alias: {
			type: String,
			required: true
		}
	},
	methods: {
		register: function(component) {
			if (this.$listeners) {
				var self = this;
				Object.keys(this.$listeners).forEach(function(event) {
					component.$on(event, self.$listeners[event]);
				})
			}
		}
	}
});


if (!nabu) { var nabu = {}; }
if (!nabu.components) { nabu.components = {}; }
if (!nabu.services) { nabu.services = {}; }
if (!nabu.state) { nabu.state = {}; }
if (!nabu.utils) { nabu.utils = {}; }

/*
TODO:

recursive routing:

you can add a sublist of routes to any route or you can explicitly set a "parent" on a route which is the name of another route.
the parent route must have an anchor where we can route children by default, this anchor must be defined in the route itself (default to something like route alias + "-main")
if the parent route indicated is an initial route, we do a full render

by default every route without a parent (and not initial), is assumed to have _some_ initial route which is checked for

-> how to check what is actually already routed?
	> perhaps check the dom tree parents to see what routes they already have? if parent is already routed, leave it at that

*/
nabu.services.VueRouter = function(routerParameters) {
	var self = this;
	this.components = {};
	this.router = new nabu.services.Router(routerParameters);

	this.useProps = routerParameters.useProps;
	this.route = function(alias, parameters, anchor, mask) {
		return self.router.route(alias, parameters, anchor, mask);
	}
	this.routeInitial = function(anchor) {
		return this.router.routeInitial(anchor);
	};
	this.updateUrl = this.router.updateUrl;
	this.routeAll = this.router.routeAll;
	this.bookmark = this.router.bookmark;
	this.register = function(route) {
		route = self.create(route);
		self.router.register(route);
		return route;
	};
	this.unregister = this.router.unregister;
	this.template = function(alias, parameters) {
		return self.router.template(alias, parameters);
	};
	this.get = function(alias) {
		return self.router.get(alias);
	};
	this.list = function() {
		return self.router.list();
	};
	this.create = function(route) {
		if (route.enter) {
			var originalEnter = route.enter;
			route.enter = function(anchor, parameters, mask, parentEnter) {
				var promise = new nabu.utils.promise();
				
				var render = function() {
					var component = null;
					if (originalEnter) {
						component = originalEnter(parameters, mask);
					}
					else if (route.component) {
						if (typeof(route.component) == "string") {
							component = eval(route.component);
							component = new component(self.useProps ? {propsData: parameters} : { data: parameters });
						}
						else {
							component = new route.component(self.useProps ? {propsData: parameters} : { data: parameters });
						}
					}
					var element = typeof(anchor) === "object" ? anchor : document.getElementById(anchor);
					if (!element && anchor == "body") {
						element = document.body;
					}
					return nabu.utils.vue.render({
						target: element,
						content: component,
						ready: function(component) {
							// this hook is meant for system actions, not someone defining the route
							if (route.postProcess) {
								route.postProcess(parameters, component);
							}
							// this hook is meant for people defining the route who want to do special stuff
							if (route.ready) {
								route.ready(parameters, component);
							}
							promise.resolve(component);
						},
						prepare: function(element) {
							// enrich the anchor with contextually relevant information
							element.setAttribute("route", route.alias);
							element.leave = route.leave;
						}
					});
				};
				var promises = [];
	
				// if the parent returns a promise, wait on that as well
				if (parentEnter && parentEnter.then) {
					promises.push(parentEnter);
				}
				
				// make sure we register any leaves that can object to leaving the current route
				var element = typeof(anchor) === "object" ? anchor : document.getElementById(anchor);
				if (!element && anchor == "body") {
					element = document.body;
				}
				if (element) {
					var leaver = function(element) {
						for (var i = 0; i < element.childNodes.length; i++) {
							if (element.childNodes[i].nodeType == 1) {
								leaver(element.childNodes[i]);
							}
						}
						if (element.leave) {
							var result = element.leave(element);
							if (result && result.then) {
								promises.push(result);
							}
						}
					}
					leaver(element);
				}
				
				// initialize any lazy services
				if (route.services && routerParameters.services) {
					for (var i = 0; i < route.services.length; i++) {
						var name = route.services[i].split(".");
						var target = routerParameters.services;
						for (var j = 0; j < name.length; j++) {
							if (!target) {
								throw "Could not find service: " + route.services[i];
							}
							target = target[name[j]];
						}
						if (!target) {
							throw "Could not find service '" + route.services[i] + "' for route: " + route.alias;
						}
						if (target.$lazy && !target.lazyInitialized) {
							target.lazyInitialized = new Date();
							var result = target.$lazy();
							if (result.then) {
								promises.push(result);
							}
						}
					}
				}

				new nabu.utils.promises(promises).then(function() {
					render();
				}, promise);
				return promise;
			};
		}
		var originalLeave = route.leave;
		route.leave = function(element) {
			if (element) {
				// removing this while routing to the same thing (with an activate so a delayed render)
				// means that the attribute is immediately removed (disabling styling based on it) and only reintroduced with a delay
				// this causes visual flickering
				//element.removeAttribute("route");
				delete element.leave;
			}
			if (originalLeave) {
				originalLeave(element);
			}
		};
		return route;
	};
}


if (!nabu) { var nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }
if (!nabu.utils.vue) { nabu.utils.vue = {}; }

// Parameters are:
// - target: a element, a vue component or the id of an element (required)
// - content: the component to add, this can be string (set as innerhtml), a vue component that is mounted or a simple element
// - prepare: a handler that receives the element where the content will be added
// - ready: a function called when it was successfully added
// - append: if set to true, it doesn't clear the content
nabu.utils.vue.render = function(parameters) {
	var anchor = typeof(parameters.target) === "object" ? parameters.target : document.getElementById(parameters.target);
	if (!anchor && parameters.target == "body") {
		anchor = document.body;
	}
	if (!anchor) {
		throw "Target not found: " + parameters.target + " in: " + document.body.innerHTML;
	}
	var element = anchor.$el ? anchor.$el : anchor;
	if (!parameters.append) {
		var destroy = function(element, root) {
			for (var i = 0; i < element.childNodes.length; i++) {
				if (!root && element.getAttribute("unclearable") != "true" && element.getAttribute("unclearable") != true) {
					// first recursively destroy any vms that might exist
					if (element.childNodes[i].nodeType == 1) {
						destroy(element.childNodes[i]);
					}
				}
			}
			// if you define a template and the _root_ of that template is another component (e.g. data-table-list has data-common-content as root)
			// then there is only one HTML element in the DOM and it has the root component attached to it, not the actual component
			// so in the example above, the __vue__ points to a data-common-content instance, NOT a data-table-list instance
			// if you inspect that root element and check out the parent, it is the original component
			// it has no dedicated html element available to it so it can't be found with __vue__
			// however, it has the exact same $el available as the component itself
			// this means, if we have a parent with the exact same $el as the child we actually found with __vue__, we also destroy it
			// we had issues where tables were not releasing their subscriptions because their destroy was never being called
			var parentToDestroy = null
			if (element.__vue__ && element.__vue__.$parent && element.__vue__.$el && element.__vue__.$parent.$el === element.__vue__.$el && element.__vue__.$parent.$destroy) {
				parentToDestroy = element.__vue__.$parent;
			}
			// then destroy the vm itself (if there is one)
			if (element.__vue__ && element.__vue__.$destroy) {
				element.__vue__.$destroy();
			}
			if (parentToDestroy) {
				parentToDestroy.$destroy();
			}
		}
		destroy(element);
	}
	var component = parameters.content;
	// if we have a return value, we need to add it to the anchor
	if (component) {
		if (component instanceof Function) {
			component = component(element);
		}
		// if you return a string, we assume it is a template id
		if (typeof component == "string" && component.substring(0, 1) == "#") {
			var extended = Vue.extend({
				template: component
			});
			component = new extended({ data: parameters });
		}
		// a function to complete the appending of the component to the anchor
		var complete = function(resolvedContent) {
			// call the activated hook before we start mounting
			if (component.$options && component.$options.activated) {
				var activated = component.$options.activated instanceof Array ? component.$options.activated : [component.$options.activated];
				for (var i = 0; i < activated.length; i++) {
					activated[i].call(component);
				}
			}
			if (component.$mount) {
				if (!component.$parent) {
					var possible = element;
					while (possible && !possible.__vue__) {
						possible = possible.parentNode;
					}
					if (possible && possible.__vue__) {
						component.$parent = possible.__vue__;
						component.$root = component.$parent.$root ? component.$parent.$root : component.$parent;
					}
				}
			}
			// unless we explicitly want to append content, wipe the current content
			if (!parameters.append) {
				if (anchor.clear) {
					anchor.clear();
				}
				else if (element) {
					nabu.utils.elements.clear(element);
				}
			}
			if (component.$mount) {
				var mounted = null;
				if (!component.$el) {
					mounted = component.$mount();
				}
				else {
					component.$remove();
					mounted = component;
				}
			}

			if (resolvedContent) {
				component = resolvedContent;
			}
			if (parameters.prepare) {
				parameters.prepare(element, component);
			}
			// it's a vue component
			if (component.$appendTo) {
				component.$appendTo(element);
			}
			else if (typeof(component) === "string") {
				element.innerHTML += component;
			}
			// we assume it's a html element
			else {
				element.appendChild(component);
			}
			if (element && element.scroll) {
				// @2023-11-29: this forces a layout which incurs a _lot_ of overhead
				// by disabling this we sped up a particular page from 38s to 8s rendering time
				//element.scroll(0, 0);
			}
			if (component.$options && component.$options.template) {
				if (component.$options.template.substring(0, 1) == "#") {
					var id = component.$options.template.substring(1);
					element.setAttribute("template", id);
					var template = document.getElementById(id);
					for (var i = 0; i < template.attributes.length; i++) {
						if (template.attributes[i].name != "id" && template.attributes[i].value != "x/templates") {
							element.setAttribute(template.attributes[i].name, template.attributes[i].value);
						}
					}
				}
			}
			if (parameters.ready) {
				parameters.ready(component);
			}
		};
		// it's a vue component
		if (component.$mount) {
			if (parameters.activate) {
				parameters.activate(component);
			}
			// if we have an activate method, call it, it can perform asynchronous actions
			if (component && component.$options && (component.$options.activate || component.$options.initialize)) {
				// if we are going to do asynchronous stuff, have the option for a loader
				if (parameters.loader) {
					parameters.loader(element);
				}
				var promises = [];
				var process = function(method, promises) {
					var promise = new nabu.utils.promise();
					promises.push(promise);
					var done = function(result) {
						promise.resolve(result);
					};
					method.call(component, done);
				}
				if (component.$options.initialize instanceof Array) {
					for (var i = 0; i < component.$options.initialize.length; i++) {
						process(component.$options.initialize[i], promises);
					}
				}
				else if (component.$options.initialize) {
					process(component.$options.initialize, promises);
				}
				// we wait for all initialization to be done before the activate kicks in
				new nabu.utils.promises(promises).then(function() {
					promises = [];
					if (component.$options.activate instanceof Array) {
						for (var i = 0; i < component.$options.activate.length; i++) {
							process(component.$options.activate[i], promises);
						}
					}
					else if (component.$options.activate) {
						process(component.$options.activate, promises);
					}
					new nabu.utils.promises(promises).then(function(x) {
						complete();
					});
				});
			}
			else {
				complete();
			}
		}
		// for HTML components we simply stop
		else {
			// it's a promise
			if (component.success) {
				component.success(function(result) {
					complete(result.responseText);
				});
			}
			else {
				complete();
			}
		}
	}
	return component;
}
Vue.mixin({
	computed: {
		$render: function() { return nabu.utils.vue.render }
	}
});
if (!nabu) { var nabu = {} }
if (!nabu.utils) { nabu.utils = {} }
if (!nabu.utils.vue) { nabu.utils.vue = {} }

nabu.utils.vue.transform = function(object, format, parse) {
	if (!object.__ob__) {
		throw "The object is not observable, use 'Vue.observe(object, true)' first";
	}
	var result = {
		state: {}
	};
	Vue.observe(result, true);
	nabu.utils.objects.merge(result.state, format(object));
	object.__ob__.dep.addSub({
		update: function() {
			console.log("updating original object", object);
			if (result instanceof Object) {
				nabu.utils.objects.merge(result.state, format(object));
			}
			else {
				result = format(object);
			}
		}
	});
	result.__ob__.dep.addSub({
		update: function() {
			console.log("updating target object", result);
			if (object instanceof Object) {
				nabu.utils.objects.merge(object, parse(result.state));
			}
			else {
				object = parse(result.state);
			}
		}
	});
	return result.state;
}

Vue.mixin({
	methods: {
		$transform: nabu.utils.vue.transform
	}
});
Vue.mixin({
	data: function() {
		return {
			$fetched: {}
		}
	},
	// we add some fetchers (if necessary)
	created: function() {
		if (this.$options.fetch) {
			var self = this;
			var createFetch = function(name, fetch, operation, operationParameters, mapper, resolve, inject) {
				var getAmountOfParams = function(f) {
					if (f) {
						var string = f.toString();
						if (typeof(string) == "string") {
							// can't do ".*" because there is no "dotall" modifier (though /s _does_ work on chrome, it does not on firefox)
							// instead [^]* will match any character that is not nothing...
							// but that does not work on server-side, so switch to [\s\S]
							var parameters = string.replace(/^[^(]*\(([^)]*)\)[\s\S]*/g, "$1").trim();
							if (parameters.length == 0) {
								return 0;
							}
							else {
								return parameters.split(",").length;
							}
						}
						else {
							throw "No stringification support for functions";
						}
					}
					return 0;
				}
				
				var amountOfInjected = inject
					? (inject instanceof Array ? inject.length : 1)
					: 0;
				
				var isFunction = (fetch instanceof Function && getAmountOfParams(fetch) > amountOfInjected)
					|| (operationParameters instanceof Function && getAmountOfParams(operationParameters) > amountOfInjected);

				// set initial value of null for resolved stuff
				self.$data.$fetched[name] = null;
				
				var state = {
					promise: null,
					originalPromise: null,
					name: name,
					first: null
				}
				
				var getter = function() {
					if (state.first == null) {
						state.first = true;
					}
					else {
						state.first = false;
					}
					var promise = state.promise;
					var originalPromise = state.originalPromise;
					var name = state.name;
					
					// we can still inject parameters
					var parameters = [];
					// we have an actual function, let's build parameters
					if (isFunction) {
						// because we update the name, the initial null set is wrong
						// this means we can not return the correct one until the function is called
						// this means we can not return the intermediate null value for watching
						if (resolve) {
							throw "You can not combine a function and a resolve requirement";
						}
						for (var i = 0; i < arguments.length; i++) {
							parameters.push(arguments[i]);
						}
						// we add the parameters so we can cache identical calls
						name += JSON.stringify(parameters);
						// we keep a special promise for each input combination
						originalPromise = self.$data.$fetched["_original_promise_" + name];
						promise = self.$data.$fetched["_promise_" + name];
					}
					if (!promise) {
						promise = self.$services.q.defer();
					}
					
					if (!originalPromise) {
						// if we have a string, we are dependent on another variable
						// that variable has to be a promise itself (e.g. through another fetch)
						if (fetch && typeof(fetch) == "string") {
							originalPromise = self[fetch];
						}
						// if we have a function, we want to execute it with the parameters we have received
						// and create a unique entry for those parameters
						else if (isFunction || fetch instanceof Function || operationParameters instanceof Function) {
							var operationParametersToUse = operationParameters;
							// we can inject other parameters that are promises, we want to wait for them to be resolved
							var promises = [];
							if (typeof(inject) == "string") {
								var parameter = self[inject];
								if (parameter.then) {
									promises.push(parameter);
								}
								parameters.push(parameter);
							}
							else if (inject instanceof Array) {
								for (var i = 0; i < inject.length; i++) {
									var parameter = self[inject[i]];
									if (parameter.then) {
										promises.push(parameter);
									}
									parameters.push(parameter);
								}
							}

							// we have at least some promises, we want to wait for them to be resolved
							if (promises.length) {
								originalPromise = self.$services.q.defer();
								self.$services.q.all(promises).then(function(results) {
									// all the promises are resolved, lets update the parameters array with the actual values
									for (var i = 0; i < parameters.length; i++) {
										if (parameters[i].then) {
											// this only works because we know our promise library immediately runs functions added by then
											// if the promise is already resolved
											parameters[i].then(function(result) {
												parameters[i] = result;
											});
										}
									}
									// now call the actual function and feedback the result to the original promise
									if (fetch instanceof Function) {
										var fetchResult = fetch.apply(self, parameters);
										console.log("fetch", name, fetchResult);
										if (fetchResult && fetchResult.then) {
											fetchResult.then(originalPromise, originalPromise);
										}
										else {
											originalPromise.resolve(typeof(fetchResult) == "undefined" ? null : fetchResult);
										}
									}
									else {
										operationParametersToUse = operationParameters.apply(self, parameters);
										self.$services.swagger.execute(operation, operationParametersToUse).then(originalPromise, originalPromise);
									}
								});
							}
							else {
								if (fetch instanceof Function) {
									originalPromise = fetch.apply(self, parameters);
								}
								else {
									operationParametersToUse = operationParameters.apply(self, parameters);
									originalPromise = self.$services.swagger.execute(operation, operationParametersToUse);
								}
							}
						}
						// if we get here and there are still functions, they have no input parameters
						else if (fetch) {
							originalPromise = fetch;
						}
						else {
							originalPromise = self.$services.swagger.execute(operation, operationParameters);
						}
						originalPromise.then(function(result) {
							if (typeof(result) == "undefined") {
								result = null;
							}
							else {
								if (mapper) {
									if (mapper instanceof Function) {
										result = mapper.call(self, result);
									}
									else if (mapper instanceof Array) {
										for (var i = 0; i < mapper.length; i++) {
											result = mapper[i].call(self, result);
										}
									}
								}
							}
							// we do a "clean" update
							if (self.$data.$fetched[name] instanceof Array && result instanceof Array) {
								self.$data.$fetched[name].splice(0, self.$data.$fetched[name].length);
								nabu.utils.arrays.merge(self.$data.$fetched[name], result);
							}
							else {
								self.$data.$fetched[name] = result;
							}
							promise.resolve(self.$data.$fetched[name]);
						}, promise);
						
						if (isFunction) {
							self.$data.$fetched["_original_promise_" + name] = originalPromise;
							self.$data.$fetched["_promise_" + name] = promise;
						}
						else {
							state.promise = promise;
							state.originalPromise = originalPromise;
						}
					}
					if (!promise.refresh) {
						promise.refresh = function() {
							// don't refresh if it is the first call
							// other by the simple act of getting the promise you initialize it once
							// and then immediately again by refreshing it
							if (!state.first) {
								this.state = null;
								// reset the original promise
								state.originalPromise = null;
								// trigger the get again with any arguments you gave
								var args = [];
								for (var i = 0; i < arguments.length; i++) {
									args.push(arguments[i]);
								}
								getter.apply(self, arguments);
							}
							return promise;
						};
					}
					if (!promise.resolved) {
						promise.resolved = function() {
							return self.$data.$fetched[name];
						}
					}
					return resolve ? self.$data.$fetched[name] : promise;
				}
				
				Object.defineProperty(self, name, { 
					enumerable: true,
					get: isFunction ? function() { return getter } : getter
				});
			};
			
			// TODO: add "fetch" support instead of operation: can start from an existing value
			for (var i = 0; i < this.$options.fetch.length; i++) {
				for (var key in this.$options.fetch[i]) {
					var value = this.$options.fetch[i][key];
					createFetch(
						key, 
						typeof(value) == "string" ? value : value.fetch, 
						typeof(value) == "string" ? value : value.operation, 
						typeof(value) == "string" ? null : value.parameters,
						typeof(value) == "string" ? null : value.map,
						typeof(value) == "string" ? null : value.resolve,
						typeof(value) == "string" ? null : value.inject
					);
				}
			}
		}
	}
});

Vue.config.optionMergeStrategies.fetch = Vue.config.optionMergeStrategies.activate;
Vue.component("n-input-date", {
	props: {
		value: {
			required: true
		},
		minimum: {
			required: false
		},
		maximum: {
			required: false
		},
		parser: {
			type: Function,
			required: false
		},
		formatter: {
			type: Function,
			required: false
		},
		// you can pass in a filter function that should return "true" if the passed in date is allowed 
		allow: {
			type: Function,
			required: false
		},
		yearsDropdown: {
			type: Boolean,
			required: false,
			default: false
		},
		yearsFrom: {
			type: Number,
			required: false,
			default: -5
		},
		yearsTo: {
			type: Number,
			required: false,
			default: 5
		},
		includeHours: {
			type: Boolean,
			required: false
		},
		includeMinutes: {
			type: Boolean,
			required: false
		},
		includeSeconds: {
			type: Boolean,
			required: false
		},
		"default": {
			required: false
		},
		translator: {
			type: Function,
			required: false
		}
	},
	template: "#n-input-date",
	data: function() {
		return {
			date: null,
			day: null,
			month: null,
			year: null,
			hours: null,
			minutes: null,
			seconds: null,
			updating: false,
			internalChange: false
		};
	},
	created: function() {
		this.setValue(this.value);
	},
	watch: {
		date: function(newValue) {
			if (newValue) {
				this.day = newValue.getDay();
				this.month = newValue.getMonth();
				this.year = newValue.getFullYear();
				this.hours = newValue.getHours();
				this.minutes = newValue.getMinutes();
				this.seconds = newValue.getSeconds();
			}
		},
		value: function(newValue) {
			if (this.internalChange) {
				this.internalChange = false;
			}
			else {
				this.setValue(newValue);
			}
		},
		years: function (newValue) {
			if (newValue) {
				if (newValue.indexOf(this.year) < 0) {
					this.year = newValue[0];
					this.selectYear(this.year);
				}
				else {
					this.selectYear(this.year);
				}
			}
                }
	},
	methods: {
		setValue: function(newValue) {
			if (!newValue) {
				this.date = new Date();
			}
			else if (newValue instanceof Date) {
				this.date = this.value;
			}
			else {
				this.date = this.parse(newValue);
			}
		},
		incrementMonth: function(amount) {
			return new Date(
				this.date.getFullYear(), 
				this.date.getMonth() + amount, 
				this.date.getDate(),
				this.includeHours ? (this.hours ? parseInt(this.hours) : 0) : 0,
				this.includeMinutes ? (this.minutes ? parseInt(this.minutes) : 0) : 0,
				this.includeSeconds ? (this.seconds ? parseInt(this.seconds) : 0) : 0
			);
		},
		canIncrementMonth: function(amount) {
			if (this.yearsDropdown && this.years.length > 0) {
				var minYear = Math.min.apply(Math, this.years);
				var maxYear = Math.max.apply(Math, this.years);
				var newDate = this.incrementMonth(amount);
				var newDateYear = newDate.getFullYear();
				
				if ( newDateYear >= minYear && newDateYear <= maxYear ) {
					return true;
				}
				return false;
			}
			else if (amount < 0) {
				return !this.minimum ? true : this.incrementMonth(amount) >= this.minimum;
			}
			else {
				return !this.maximum ? true : this.incrementMonth(amount) <= this.maximum;
			}
		},
		parse: function(date) {
			if (!date) {
				return null;
			}
			else if (this.parser) {
				return this.parser(date);
			}
			// defaults to "yyyy-MM-dd HH:mm:ss" format
			return new Date(
				parseInt(date.substring(0, 4)), 
				// 0-based
				parseInt(date.substring(5, 7)) - 1,
				parseInt(date.substring(8, 10)), 
				this.includeHours && date.length >= 13 ? parseInt(date.substring(11,13)) : 0, // hours,
				this.includeMinutes && date.length >= 16 ? parseInt(date.substring(14,16)) : 0, // minutes
				this.includeSeconds && date.length >= 19 ? parseInt(date.substring(17,19)) : 0, // seconds
				0 // milliseconds
			); 
		},
		format: function(date) {
			if (!date) {
				return null;
			}
			else if (this.formatter) {
				return this.formatter(date);
			}
			var result = date.getFullYear() + "-";
			var month = date.getMonth() + 1;
			result += (month < 10 ? "0" : "") + month + "-";
			var day = date.getDate();
			result += (day < 10 ? "0" : "") + day;
			if (this.includeHours) {
				result += " ";
				result += (this.hours < 10 ? "0" : "") + (this.hours ? parseInt(this.hours) : 0);
			}
			if (this.includeMinutes) {
				result += ":";
				result += (this.minutes < 10 ? "0" : "") + (this.minutes ? parseInt(this.minutes) : 0);
			}
			if (this.includeSeconds) {
				result += ":";
				result += (this.seconds < 10 ? "0" : "") + (this.seconds ? parseInt(this.seconds) : 0);
			}
			return result;
		},
		isToday: function(date) {
			var today = new Date();
			return date.getFullYear() == today.getFullYear() && date.getMonth() == today.getMonth() && date.getDate() == today.getDate();
		},
		isSelected: function(date) {
			if (!this.value) {
				return false;
			}
			var parsed = this.parse(this.value);
			return parsed.getFullYear() == date.getFullYear()
				&& parsed.getMonth() == date.getMonth()
				&& parsed.getDate() == date.getDate();
		},
		isAvailable: function(date) {
			return this.allow == null || this.allow(date);
		},
		select: function(date) {
			if (date) {
				date = new Date(
					date.getFullYear(),
					date.getMonth(),
					date.getDate(),
					this.includeHours ? (this.hours ? parseInt(this.hours) : 0) : 0,
					this.includeMinutes ? this.minutes : 0,
					this.includeSeconds ? this.seconds : 0,
					0
				);
			}
			if (this.isAvailable(date)) {
				this.date = date;
				this.internalChange = true;
				this.$emit("input", this.format(date));
			}
		},
		translate: function(value) {
			// slightly messed up regex to avoid %{} replacement if templating is turned on (backwards compatibility)
			return this.translator ? this.translator(value) : 
				(value && value.replace ? value.replace(/%[{](?:[a-zA-Z]+[:]+|)([^}]+)}/, "$1") : value);
		},
		// TODO: refactor to reuse select()
		selectYear: function(year) {
			if (year) {
				var date = new Date(
					year,
					this.date.getMonth(),
					this.date.getDate(),
					this.includeHours ? (this.hours ? parseInt(this.hours) : 0) : 0,
					this.includeMinutes ? this.minutes : 0,
					this.includeSeconds ? this.seconds : 0,
					0
				);
				var isAvailable = this.isAvailable(date);
				var counter = 1;
				// find the nearest date in this year that is still allowed
				while (!isAvailable) {
					var tmp = new Date(
						year,
						this.date.getMonth(),
						this.date.getDate() - counter++,
						this.includeHours ? (this.hours ? parseInt(this.hours) : 0) : 0,
						this.includeMinutes ? this.minutes : 0,
						this.includeSeconds ? this.seconds : 0,
						0
					);
					if (tmp.getFullYear() != year) {
						break;
					}
					isAvailable = this.isAvailable(tmp);
					if (isAvailable) {
						date = tmp;
					}
				}
				// if no dates in the past are allowed, check in the future?
				counter = 1;
				while (!isAvailable) {
					var tmp = new Date(
						year,
						this.date.getMonth(),
						this.date.getDate() + counter++,
						this.includeHours ? (this.hours ? parseInt(this.hours) : 0) : 0,
						this.includeMinutes ? this.minutes : 0,
						this.includeSeconds ? this.seconds : 0,
						0
					);
					if (tmp.getFullYear() != year) {
						break;
					}
					isAvailable = this.isAvailable(tmp);
					if (isAvailable) {
						date = tmp;
					}
				}
				
				// we either have the original date or an allowed date within that year, either way, we want to visualize the change in the popup
				this.date = date;

				// we never want to emit it
				// it's very weird that your date choice changes if you are scrolling through the years
				
				if (isAvailable && this.default != null) {
					this.date = date;
					this.internalChange = true;
					//this.$emit("input", this.format(date));
				}
				else if (isAvailable && !this.default){
					this.date = date;
					//this.$emit("input", null);
				}
			}
		}
	},
	computed: {
		days: function() {
			var days = [];
			days.push(this.translate("%{date::Mo}"));
			days.push(this.translate("%{date::Tu}"));
			days.push(this.translate("%{date::We}"));
			days.push(this.translate("%{date::Th}"));
			days.push(this.translate("%{date::Fr}"));
			days.push(this.translate("%{date::Sa}"));
			days.push(this.translate("%{date::Su}"));
			return days;
		},
		months: function() {
			var months = [];
			months.push(this.translate("%{date::January}"));
			months.push(this.translate("%{date::February}"));
			months.push(this.translate("%{date::March}"));
			months.push(this.translate("%{date::April}"));
			months.push(this.translate("%{date::May}"));
			months.push(this.translate("%{date::June}"));
			months.push(this.translate("%{date::July}"));
			months.push(this.translate("%{date::August}"));
			months.push(this.translate("%{date::September}"));
			months.push(this.translate("%{date::October}"));
			months.push(this.translate("%{date::November}"));
			months.push(this.translate("%{date::December}"));
			return months;
		},
		weeks: function() {
			var cells = [];
			var weeks = [[]];
			var week = 0;
			var firstDay = new Date(this.date.getFullYear(), this.date.getMonth(), 1);
			var offset = firstDay.getDay() === 0 ? 6 : firstDay.getDay() - 1;
			var lastDay = new Date(this.date.getFullYear(), this.date.getMonth() + 1, 0);
			var daysInMonth = lastDay.getDate();

			// add empty cells at the front
			for (var i = 0; i < offset; i++) {
				cells.push({
					label: null,
					value: null
				});
			}

			// add days in month
			for (var i = 0; i < daysInMonth; i++) {
				cells.push({
					label: i + 1,
					value: new Date(this.date.getFullYear(), this.date.getMonth(), i + 1)
				});
			}

			// add empty cells at the back
			if (cells.length % 7 > 0) {
				var amountToAdd = 7 - (cells.length % 7);
				for (var i = 0; i < amountToAdd; i++) {
					cells.push({
						label: null,
						value: null
					});
				}
			}
			
			// divide days in weeks
			for (var i = 0; i < cells.length; i++) {
				weeks[week].push(cells[i]);
				if (weeks[week].length % 7 === 0) {
					week += 1;
					weeks.push([]);
				}
			}
			return weeks;
		},
		years: function() {
			var today = new Date();
			var yearToday = Number(today.getFullYear());

			var yearFrom = yearToday + Number(this.yearsFrom);
			var yearTo = yearToday + Number(this.yearsTo);
			var diff = Number(yearTo - yearFrom);
			
			var years = [];
			if ( diff > 0 ) {
				for (var i=0; i < diff -1 ; i++) {
					years[i]=yearFrom + i+1;
				}
				years.unshift(yearFrom);
				years.push(yearTo);
			}
			// not sure what this does at time of backporting so disabled for now
			//else {
			//	years.push(yearToday);
			//}
			
			return years;
		}
	}
});
Vue.component("n-input-file", {
	props: {
		value: {
			type: Array,
			required: true
		},
		types: {
			type: Array,
			required: false
		},
		// amount of files allowed (default unlimited)
		amount: {
			required: false
		},
		// in bytes, you can explicitly pass in 0 to set to unlimited
		maxFileSize: {
			type: Number,
			required: false	
		},
		disabled: {
			type: Boolean,
			required: false,
			default: false
		},
		browseLabel: {
			type: String,
			required: false
		},
		dropLabel: {
			type: String,
			required: false
		},
		browseIcon: {
			type: String,
			required: false
		},
		visualiseSelectedFiles: {
			type: Boolean,
			required: false,
			default: false
		},
		deleteIcon: {
			type: String,
			required: false,
			default: "times"
		},
		restrictionMessage: {
			type: String,
			required: false
		},
		// a json schema component stating the definition
		schema: {
			type: Object,
			required: false
		},
		required: {
			type: Boolean,
			required: false,
			// explicitly set default value to null, otherwise vue will make it false which we can't distinguish from "not set"
			default: null
		},
		visualizeFileNames: {
			type: Boolean,
			required: false,
			default: false
		},
		buttonClass: {
			required: false
		},
		capture: {
			type: String,
			required: false,
			default: null
		},
		fileNameDeleteClass: {
			required: false
		},
		fileNameContainerClass: {
			required: false
		},
		fileNameRowClass: {
			required: false
		},
		fileNameClass: {
			required: false
		}
	},
	template: "#n-input-file",
	data: function() {
		return {
			// used to dynamically create new file names
			counter: 0,
			dragging: false,
			messages: []
		}
	},
	methods: {
		dragOver: function($event) {
			this.dragging = true; 
			$event.preventDefault();
		},
		hasDropSupport: function () {
			var div = document.createElement("div");
			return (("draggable" in div) || ("ondragstart" in div && "ondrop" in div)) && "FormData" in window && "FileReader" in window;
		},
		selectFiles: function(event) {
			var result = this.addFiles(event.target.files || event.dataTransfer.files);
			event.preventDefault();
			event.stopPropagation();
			this.$refs.input.value = "";
			return result;
		},
		addFiles: function(fileList) {
			var notAllowed = [];
			var changed = this.makeRoomFor(fileList.length);
			for (var i = 0; i < fileList.length; i++) {
				if ((!this.amount || this.value.length < this.amount) && this.isAllowedType(fileList.item(i).type) && this.isAllowedSize(fileList.item(i).size)) {
					changed = true;
					this.value.push(fileList.item(i));
				}
				else {
					notAllowed.push(fileList.item(i));
				}
			}
			this.validate();
			if (changed) {
				this.$emit("change", this.value);
			}
			return notAllowed;
		},
		// if we add more files then allowed, drop the oldest ones
		makeRoomFor: function(amount) {
			if (this.amount != null && this.amount > 0) {
				var tooMany = (this.value.length + amount) - this.amount;
				if (tooMany > 0) {
					this.value.splice(0, tooMany);
					return true;
				}
			}
			return false;
		},
		pasteFiles: function(event) {
			var files = event.clipboardData ? event.clipboardData.items : null;
			var notAllowed = [];
			if (files) {
				var changed = this.makeRoomFor(files.length);
				for (var i = 0; i < files.length; i++) {
					if ((!this.amount || this.value.length < this.amount) && this.isAllowedType(files[i].type) && this.isAllowedSize(files[i].size)) {
						var blob = files[i].getAsFile();
						changed = true;
						this.value.push(new File([blob], "pasted_file_" + this.counter++, { type: files[i].type}));
					}
					else {
						notAllowed.push(files[i]);
					}
				}
				if (changed) {
					this.$emit("change", this.value);
				}
			}
			return notAllowed;
		},
		isAllowedType: function(type) {
			return !this.types || !this.types.length || (type && (this.types.indexOf(type) >= 0 || this.types.indexOf(type.replace(/\/.*$/, "") + "/*") >= 0));
		},
		isAllowedSize: function(size) {
			if (!this.maxFileSize) {
				return true;
			}
			if (size == null) {
				return false;
			}
			return size <= this.maxFileSize ? true : false;
		},
		isAllAllowedSize: function() {
			var self = this;
			return this.value.reduce(function(current, file) {
				return current && self.isAllowedSize(file.size);
			}, true);
		},
		isAllAllowedType: function() {
			var self = this;
			return this.value.reduce(function(current, file) {
				return current && self.isAllowedType(file.type);
			}, true);
		},		
		browse: function() {
			this.$refs.input.click();
		},
		removeFile: function (file) {
			this.value.splice(this.value.indexOf(file),1);
			this.$emit("change", this.value);
		},
		validate: function(soft) {
			this.messages.splice(0);
			var messages = [];
			var mandatory = nabu.utils.vue.form.mandatory(this);
			if (!this.isAllAllowedType()) {
				var title = "This file type is not allowed";
				messages.push({
					severity: "error",
					code: "invalidFileType",
					title: title,
					priority: -1,
					values: {
						actual: this.value.map(function(x) { return x.type }),
						expected: this.types
					},
					context: [this]
				});
			}
			if (!this.isAllAllowedSize()) {
				var title = "This file is too big, the maximum file size is {maxFileSize}";
				if (this.maxFileSize < 1024 * 1024) {
					title = title.replace("{maxFileSize}", (this.maxFileSize / 1024) + "kb");
				}
				else {
					title = title.replace("{maxFileSize}", (this.maxFileSize / (1024 * 1024)) + "mb");
				}
				messages.push({
					severity: "error",
					code: "invalidFileSize",
					title: title,
					priority: -1,
					values: {
						actual: this.value.map(function(x) { return x.size }),
						expected: this.maxFileSize
					},
					context: [this]
				});
			}
			if (mandatory && this.value.length < 1) {
				messages.push({
					soft: true,
					severity: "error",
					code: "required",
					title: "The value is required",
					priority: 0,
					values: {
						actual: false,
						expected: true
					},
					context: [this]
				});
			}
			nabu.utils.arrays.merge(self.messages, nabu.utils.vue.form.localMessages(self, messages));
			return messages;
		}	
	}
});

Vue.component("n-input-combo", {
	props: {
		value: {
			required: true
		},
		labels: {
			type: Array,
			required: false
		},
		initialLabel: {
			required: false
		},
		filter: {
			type: Function,
			required: false
		},
		// used to format the value into the input once selected from the dropdown
		formatter: {
			type: Function,
			required: false
		},
		// used to extract the actual value from the suggested items
		extracter: {
			type: Function,
			required: false
		},
		// the input field itself has to be plain text (the formatter)
		// however, in the dropdowns (and in the future multiselect?) we can use html
		prettyFormatter: {
			type: Function,
			required: false
		},
		// used to resolve an extracted value into a valid item usually returned by filter
		resolver: {
			type: Function,
			required: false
		},
		items: {
			required: false
		},
		nillable: {
			type: Boolean,
			default: true
		},
		allowTyping: {
			type: Boolean,
			default: true
		},
		timeout: {
			type: Number,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		autoclose: {
			type: Boolean,
			required: false,
			default: true
		},
		disabled: {
			type: Boolean,
			required: false,
			default: false
		},
		name: {
			type: String,
			required: false
		},
		autocomplete: {
			type: String,
			// for chrome, if we only set it to "off", we still get the auto suggestions popup that layers over everything....
			default: window.navigator.userAgent.indexOf("Chrome") >= 0 ? "nothing" : "off"
		},
		autoselectSingle: {
			type: Boolean,
			required: false
		},
		caseInsensitive: {
			type: Boolean,
			required: false,
			default: false
		},
		allowTypeMatch: {
			type: Boolean,
			required: false,
			default: false
		},
		// the text to show when there are no hits
		emptyValue: {
			type: String,
			required: false
		},
		// the text to show while the hits are being calculated
		calculatingValue: {
			type: String,
			required: false
		},
		// the text to show to reset the current choice (value must not be null)
		resetValue: {
			type: String,
			required: false
		},
		reloadOnFocus: {
			type: Boolean,
			required: false,
			default: true
		}
	},
	template: "#n-input-combo",
	data: function() {
		return {
			label: null,
			showLabels: false,
			showValues: false,
			values: [],
			content: null,
			timer: null,
			updatingContent: false,
			actualValue: null,
			// the value selected with the keys
			keyValue: null,
			// whether or not the async filter is busy
			filtering: false,
			stillFocused: false
		}
	},
	mounted: function() {
		if (this.labels) {
			this.label = this.initialLabel && this.labels.indexOf(this.initialLabel) >= 0 ? this.initialLabel : this.labels[0];
		}
		if (this.filter && !this.disabled) {
			try {
				this.filterItems(this.content, this.label, null, true);
			}
			catch (exception) {
				console.error("Could not perform initial filter", exception);
			}
		}
		else if (this.items) {
			if (this.items.then) {
				var self = this;
				this.items.then(function(items) {
					nabu.utils.arrays.merge(self.values, items);
					self.synchronizeValue(true);
				});
			}
			else {
				nabu.utils.arrays.merge(this.values, this.items);
				this.synchronizeValue(true);
			}
		}
		// do a synchronization if we do not have an extracter, we are not dependend on values being loaded then, the resolver does make it possible
		if (!this.extracter || this.resolver) {
			this.synchronizeValue(true);
		}
	},
	computed: {
		formatted: function() {
			return this.formatter && this.actualValue != null ? this.formatter(this.actualValue) : this.actualValue;
		}
	},
	methods: {
		cleanupFormatted: function(formatted) {
			return formatted && formatted.replace ? formatted.replace(/<[^>]+>/g, "").trim() : formatted;
		},
		focusOn: function($event) {
			var self = this;
			this.stillFocused = true;
			// in the address component you have multiple combos after one another
			// filling in a correct value in one, enables the next one and puts focus on it
			// however, we can trigger that by clicking anywhere with the mouse (so not on this combo)
			// it seems the focus event is triggered before the mouse event that triggers the auto close
			// so the showvalues is briefly set to true by the on focus and immediately set to false by the auto close
			// for this reason, we do the showvalues in a tiny timeout to circumvent this behavior
			setTimeout(function() {
				if (self.stillFocused) {
					// the problem is if your combo box has values that are dependent on another value in the form, you may have changed that value
					// by reloading here, we make sure the dropdown shows relevant items
					// only relevant if we can filter?
					if (self.reloadOnFocus && self.filter) {
						// by default we filter on what is there
						var contentToFilter = self.content;
						// if however the current content matches exactly with the current value, we filter with no content
						// otherwise, you get a very limited dropdown
						// this is consistent with the filter that occurs in updateValue
						if (self.content && self.actualValue) {
							var actualValue = self.cleanupFormatted(self.formatter ? self.formatter(self.actualValue) : self.actualValue);
							if (actualValue == contentToFilter) {
								contentToFilter = null;
							}
						}
						self.filterItems(contentToFilter, self.label);
					}
					self.showValues = true;
				}
			}, 100);
		},
		focusOut: function($event) {
			var self = this;
			// if you didn't select one but you did start typing
			if (self.value == null && self.keyValue != null && self.content != null && self.content.trim().length > 0) {
				var keyValue = self.keyValue;
				self.keyValue = null;
				self.updateValue(keyValue);
			}
		},
		synchronizeValue: function(initial) {
			var self = this;
			var hadValue = this.actualValue != null;
			if (this.value != null) {
				if (this.extracter) {
					// only look for a match if we haven't found one already
					// normally in the initial state, a match should be found but once we start filtering it might disappear
					// at that point we can't match it anymore even though it is a "valid" value
					if (!this.actualValue || this.extracter(this.actualValue) != this.value) {
						for (var i = 0; i < this.values.length; i++) {
							if (this.extracter(this.values[i]) == this.value) {
								this.actualValue = this.values[i];
								break;
							}
						}
					}
					// if we can't resolve it against the initial listing, use the resolver (if it exists)
					if (this.resolver != null && (!this.actualValue || this.extracter(this.actualValue) != this.value)) {
						var result = this.resolver(this.value);
						if (result != null && result.then) {
							result.then(function(actualValue) {
								// you are likely using the same service for filter and resolve
								// the filter should send back an array of items
								if (actualValue instanceof Array) {
									actualValue = actualValue[0];
								}
								self.actualValue = actualValue;
								if (initial) {
									self.content = self.actualValue != null ? (self.formatter ? self.formatter(self.actualValue) : self.actualValue) : null;
								}
								self.$emit("label", self.actualValue != null ? (self.formatter ? self.formatter(self.actualValue) : self.actualValue) : null);
							});
						}
						else if (result != null) {
							self.actualValue = result;
							self.$emit("label", self.actualValue != null ? (self.formatter ? self.formatter(self.actualValue) : self.actualValue) : null);
						}
					}
				}
				else {
					this.actualValue = this.value;
				}
			}
			else if (!this.nillable && this.values.length > 0) {
				// it could be that we have already emitted a newly selected value (that we selected here) but that is not reflected yet
				// so check that we don't get stuck in a loop between updating, filterItems and synchronizeValue
				if (!this.updatingContent || !this.actualValue) {
					this.updateValue(this.values[0]);
				}
			}
			else {
				this.actualValue = null;
			}
			// only update the content if this is the initial setting
			// afterwards people just type and it remains
			if (initial) {
				// if we did not have a value before, we stranded mid-type, no need to wipe it
				if (this.actualValue != null || hadValue) {
					// should be handled by formatted computed?
					//this.content = this.actualValue != null ? (this.formatter ? this.formatter(this.actualValue) : this.actualValue) : null;
				}
			}
			self.$emit("label", self.actualValue != null ? (self.formatter ? self.formatter(self.actualValue) : self.actualValue) : null);
			
			if (this.keyValue && this.values.indexOf(this.keyValue) < 0) {
				this.keyValue = null;
			}
			
			if (this.keyValue == null) {
				this.setKeyValue();
			}
		},
		validateKey: function($event) {
			if (!this.allowTyping) {
				$event.preventDefault();
				$event.stopPropagation();
			}	
		},
		validateEnter: function($event) {
			if (this.keyValue != null) {
				$event.preventDefault();
				$event.stopPropagation();
				var value = this.keyValue;
				this.keyValue = null;
				this.updateValue(value);
				this.showValues = false;
			}
		},
		validateTab: function($event) {
			if (this.keyValue != null && $event.shiftKey == false && this.showValues) {
				var value = this.keyValue;
				this.keyValue = null;
				this.updateValue(value);
			}
			this.showValues = false;
		},
		doEscape: function() {
			this.showValues = false;
			this.keyValue = null;
		},
		moveUp: function($event) {
			this.showValues = true;
			if (this.keyValue == null) {
				var index = this.value ? this.values.indexOf(this.value) : -1;
				if (index > 0) {
					this.keyValue = this.values[index - 1];
				}
				else {
					this.keyValue = this.values.length ? this.values[0] : null;
				}
			}
			else {
				var index = this.values.indexOf(this.keyValue);
				if (index < 0) {
					this.keyValue = this.values.length ? this.values[0] : null;
				}
				else if (index > 0) {
					this.keyValue = this.values[index - 1];
				}
				this.scrollTo("pondering");
			}
			$event.preventDefault();
			$event.stopPropagation();
		},
		moveDown: function($event) {
			this.showValues = true;
			if (this.keyValue == null) {
				var index = this.value ? this.values.indexOf(this.value) : -1;
				if (index >= 0) {
					if (index < this.values.length - 1) {
						this.keyValue = this.values[index + 1];
					}
					else {
						this.keyValue = this.value;
					}
				}
				else {
					this.keyValue = this.values.length ? this.values[0] : null;
				}
			}
			else {
				var index = this.values.indexOf(this.keyValue);
				if (index < 0) {
					this.keyValue = this.values.length ? this.values[0] : null;
				}
				else if (index < this.values.length - 1) {
					this.keyValue = this.values[index + 1];
				}
				this.scrollTo("pondering");
			}
			$event.preventDefault();
			$event.stopPropagation();
		},
		scrollTo: function(clazz) {
			var target = this.$el.querySelector("." + clazz);
			if (target) {
				target.parentNode.scrollTop = target.offsetTop - (target.parentNode.offsetHeight / 2);
			}
		},
		clear: function() {
			this.content = null;
			if (this.filter) {
				this.filterItems(this.content, this.label);
			}
		},
		refilter: function() {
			this.filterItems(this.content, this.label);
		},
		setKeyValue: function() {
			var self = this;
			if (self.showValues && self.keyValue == null) {
				if (self.value && self.values.indexOf(self.value) >= 0) {
					self.keyValue = self.value;
				}
				else if (self.values.length) {
					self.keyValue = self.values[0];
				}
			}
		},
		filterItems: function(content, label, match, initial) {
			// if we trigger a filterItems with no content, we might be doing this right after we have selected a match
			// in this case we might want to explicitly close the value dropdown
			// which means, in such a case, the caller is responsible for explicitly showing the items if still relevant
			if (this.stillFocused && content) {
				this.showValues = true;
			}
			var result = this.filter(content, label);
			// if we have a promise, set filtering to true before we clear the values
			// once the values are cleared, we might want to show the placeholder
			this.filtering = !!result.then;
			this.values.splice(0, this.values.length);
			if (result instanceof Array) {
				nabu.utils.arrays.merge(this.values, result);
				this.synchronizeValue(initial);
				if (match) {
					if (this.checkForMatch(content) != null) {
						this.filterItems(null, label, false);
					}
				}
				if (this.value == null && this.autoselectSingle && result.length == 1) {
					this.updateValue(result[0]);
				}
			}
			else if (result.then) {
				var self = this;
				result.then(function(results) {
					self.values.splice(0, self.values.length);
					// if it is not an array, find the first array child, rest service returns always have a singular root
					if (!(results instanceof Array)) {
						for (var key in results) {
							if (results[key] instanceof Array) {
								results = results[key];
								break;
							}
						}
					}
					if (results && results.length) {
						nabu.utils.arrays.merge(self.values, results);
					}
					self.synchronizeValue(initial);
					if (match) {
						if (self.checkForMatch(content) != null) {
							self.filterItems(null, label, false);
						}
					}
					if (this.value == null && this.autoselectSingle && results != null && results.length == 1) {
						this.updateValue(results[0]);
					}
					self.filtering = false;
				}, function() {
					self.filtering = false;
				});
			}
		},
		checkForMatch: function(value) {
			var match = null;
			for (var i = 0; i < this.values.length; i++) {
				var formatted = this.cleanupFormatted(this.values[i] != null && this.formatter ? this.formatter(this.values[i]) : this.values[i]);
				if (formatted == value || (this.caseInsensitive && formatted.toLowerCase && value && value.toLowerCase && formatted.toLowerCase() == value.toLowerCase())) {
					match = this.values[i];
					break;
				}
			}
			// only update the value if it matches a value in the dropdown list 
			if (match != null || (!value && this.nillable)) {
				this.updatingContent = true;
				this.actualValue = value;
				this.$emit("input", this.extracter && match ? this.extracter(match) : match, this.formatter && match ? this.formatter(match) : match, this.label);
				this.$emit("label", this.formatter && match ? this.formatter(match) : match, this.label);
			}
			// if it is nillable and the current bound value has some value, reset it to null
			else if (this.nillable && this.value) {
				this.updatingContent = true;
				this.$emit("input", null);
				this.$emit("label", null);
			}
			return match;
		},
		updateContent: function(value) {
			// explicitly set it, the v-model does not always seem to work in combination with the input event?
			this.content = value;

			// if you have no value left AND nillable is an option, we _do_ want to reset the value to null
			var match = this.allowTypeMatch || (!value && this.nillable) ? this.checkForMatch(value) : null;
			
			// hide dropdown if you have a match by typing
			if (match) {
				this.showValues = false;
				this.keyValue = null;
			}

			// try to finetune the results
			if (this.filter) {
				if (this.timer) {
					clearTimeout(this.timer);
					this.timer = null;
				}
				if (this.timeout) {
					var self = this;
					this.timer = setTimeout(function() {
						self.filterItems(match || !value ? null : value, self.label, !match && this.allowTypeMatch);
					}, this.timeout);
				}
				else {
					this.filterItems(match || !value ? null : value, this.label, !match && this.allowTypeMatch);
				}
			 }
		},
		// if we hide immediately on blur, we don't register the click event anymore
		hideSlowly: function() {
			var self = this;
			setTimeout(function() {
				self.showValues = false;
			}, 500);
		},
		// you select something from the dropdown
		updateValue: function(value) {
			this.keyValue = null;
			this.updatingContent = true;
			this.actualValue = value;
			this.$emit("input", this.extracter && value ? this.extracter(value) : value, this.formatter && value ? this.formatter(value) : value, value, this.label);
			// backwards compatibility
			this.$emit("label", this.formatter && value ? this.formatter(value) : value, this.label);
			// should be handled by formatted computed?
			//this.content = value != null && this.formatter ? this.formatter(value) : value;
			// reset the results to match everything once you have selected something
			if (this.filter) {
				if (this.timer) {
					clearTimeout(this.timer);
					this.timer = null;
				}
				if (this.timeout) {
					var self = this;
					this.timer = setTimeout(function() {
						self.filterItems(null, self.label, false);
					}, this.timeout);
				}
				else {
					this.filterItems(null, this.label, false);
				}
			 }
		},
		selectLabel: function(label) {
			this.content = null;
			if (this.filter) {
				this.filterItems(this.content, label);
			}
			this.label = label;
		}
	},
	watch: {
		items: function(newValue) {
			if (newValue && newValue.then) {
				var self = this;
				newValue.then(function(items) {
					self.values.splice(0, self.values.length);
					nabu.utils.arrays.merge(self.values, items);
					self.synchronizeValue(true);
				});
			}
			else {
				this.values.splice(0, this.values.length);
				if (newValue) {
					nabu.utils.arrays.merge(this.values, newValue);
					this.synchronizeValue(true);
				}
			}
		},
		value: function(newValue, oldValue) {
			if (this.updatingContent) {
				this.synchronizeValue(false);
				this.updatingContent = false;
			}
			else {
				this.synchronizeValue(true);
			}
			this.keyValue = null;
			this.setKeyValue();
		},
		disabled: function(newValue, oldValue) {
			if (newValue == false && oldValue == true) {
				if (this.filter) {
					this.filterItems(this.content, this.label);
				}
			}
		},
		labels: function(newValue) {
			// if the current label is no longer valid, change it
			if (this.label && newValue.indexOf(this.label) < 0) {
				this.label = newValue.length ? newValue[0] : null;
				this.filterItems(this.content, this.label);
			}
		},
		showValues: function(newValue) {
			if (newValue) {
				var self = this;
				this.keyValue = null;
				this.setKeyValue();
				Vue.nextTick(function() {
					self.scrollTo("active");
				});
			}
			else {
				this.keyValue = null;
			}
		},
		formatted: function(newValue) {
			if (newValue) {
				this.content = this.cleanupFormatted(newValue);
			}
			// we can also empty it out
			else if (!this.value) {
				this.content = "";
			}
		}
	}
});



Vue.component("n-input-combo2", {
	template: "#n-input-combo2",
	props: {
		value: {
			required: true
		},
		// if you have a value, you can pass in a label preventing the need to resolve it to visualize it
		initialRawValues: {
			type: Array
		},
		name: {
			required: false,
		},
		placeholder: {
			type: String
		},
		placeholderSelected: {
			type: String
		},
		items: {
			type: Array,
			required: false
		},
		filter: {
			type: Function,
			required: false
		},
		nillable: {
			type: Boolean,
			default: true
		},
		// used to format the value into the input once selected from the dropdown
		formatter: {
			type: Function,
			required: false
		},
		// used to extract the actual value from the suggested items
		extracter: {
			type: Function,
			required: false
		},
		// the input field itself has to be plain text (the formatter)
		// however, in the dropdowns (and in the future multiselect?) we can use html
		prettyFormatter: {
			type: Function,
			required: false
		},
		// allows you to group items together
		grouper: {
			type: Function,
			required: false
		},
		resolver: {
			type: Function,
			required: false
		},
		// the text to show when there are no hits
		emptyValue: {
			type: String,
			required: false
		},
		// the text to show while the hits are being calculated
		calculatingValue: {
			type: String,
			required: false
		},
		// the text to show to reset the current choice (value must not be null)
		resetValue: {
			type: String,
			required: false
		},
		// the text to show to select all
		selectAllValue: {
			type: String,
			required: false
		},
		searchInDropdown: {
			type: Boolean,
			required: false
		},
		useCheckbox: {
			type: Boolean,
			default: false
		},
		allowTyping: {
			type: Boolean,
			default: false
		},
		disabled: {
			type: Boolean,
			required: false,
			default: false
		},
		timeout: {
			type: Number,
			default: 600
		},
		showTags: {
			type: Boolean,
			default: false
		},
		// set to 0 to get unlimited
		maxAmountOfTags: {
			default: 3
		},
		showAmount: {
			type: Boolean,
			default: false
		},
		deleteTagIcon: {
			type: String,
			default: "times"
		},
		autoclose: {
			type: Boolean,
			required: false,
			default: true
		},
		// by default we load once and don't reload unless necessary
		// you can also reload the data on focus, assuming external values will have triggered a change in the listing
		loadOnFocus: {
			type: Boolean,
			default: false
		}
	},
	data: function() {
		return {
			// whether or not the data should be reloaded if it is needed
			dirty: false,
			showValues: false,
			// when you are allowed to type, filter the results
			search: null,
			// debounce on search changes
			searchTimer: null,
			filteredValues: [],
			potentialValues: [],
			// the actual raw values of the currently selected value(s)
			// note that the raw values are generally structures
			// if these structures are being fed from a REST service, it is entirely possible to have multiple versions in memory of the same object
			// when data is returned from the webservice, we will match the extracted value against the rawvalues, if it matches we replace the object
			rawValues: [],
			calculating: true,
			updating: false,
			focused: false,
			// the current value you have selected with your keys
			keyValue: null,
			// whether we have searched at all
			hasSearched: false,
			// keep track of the last search value, don't run again if it hasn't changed
			lastSearch: null,
			initialized: false
		}
	},
	created: function() {
		// if we have a value, check if we have a label, if not, we must initialize
		if (this.value != null) {
			if (this.initialRawValues != null && this.initialRawValues.length) {
				nabu.utils.arrays.merge(this.rawValues, this.initialRawValues);
				this.synchronize(this.value);
			}
			else {
				this.synchronize(this.value);
			}
		}
	},
	computed: {
		visibleRawValues: function() {
			if (this.maxAmountOfTags != null && this.maxAmountOfTags > 0) {
				return this.rawValues.slice(Math.max(0, this.rawValues.length - this.maxAmountOfTags), this.rawValues.length);
			}
			return this.rawValues;
		},
		hiddenAmount: function() {
			if (this.maxAmountOfTags != null && this.maxAmountOfTags > 0) {
				return Math.max(0, this.rawValues.length  - this.maxAmountOfTags);
			}
			return 0;
		},
		multiple: function() {
			return this.value instanceof Array;
		},
		groups: function() {
			var groups = {};
			if (this.grouper) {
				var self = this;
				this.potentialValues.forEach(function(single) {
					var group = self.grouper(single);
					if (group != null) {
						if (!groups[group]) {
							groups[group] = [];
						}
						groups[group].push(single);
					}
				})
			}
			return groups;
		},
		ungrouped: function() {
			var items = [];
			if (this.grouper) {
				this.potentialValues.forEach(function(single) {
					var group = self.grouper(single);
					if (group == null) {
						items.push(single);
					}
				});
			}
			else {
				nabu.utils.arrays.merge(items, this.potentialValues);
			}
			return items;
		},
		currentPlaceholder: function() {
			if (!this.multiple || this.value == null || this.value.length == 0 || !this.placeholderSelected) {
				return this.placeholder;
			}
			else {
				return this.placeholderSelected.replace("{amount}", this.value.length);
			}
		}
	},
	methods: {
		markDirty: function() {
			this.dirty = true;
		},
		click: function() {
			// the click should only do something if the input box is disabled in which case we can't trigger the focus
			if (!this.disabled && !this.allowTyping) {
				// load if necessary
				this.load();
				this.showValues = true;
			}
		},
		focus: function() {
			if (!this.disabled) {
				if (this.loadOnFocus) {
					this.dirty = true;
				}
				this.load();
				this.showValues = true;
			}
		},
		deselect: function(rawValue) {
			if (rawValue == null) {
				this.rawValues.splice(0);
			}
			else {
				var index = this.rawValues.indexOf(rawValue);
				this.rawValues.splice(index, 1);
			}
		},
		getExtracted: function(entry) {
			if (this.extracter && entry != null) {
				entry = this.extracter(entry);
			}
			return entry;
		},
		getPrettyFormatted: function(entry) {
			if (this.prettyFormatter && entry != null) {
				return this.prettyFormatter(entry);
			}
			else {
				return this.getFormatted(entry);
			}
		},
		getFormatted: function(entry) {
			if (this.formatter && entry != null) {
				entry = this.formatter(entry);
			}
			return entry;
		},
		getPlainFormatted: function(entry) {
			var formatted = this.getFormatted(entry);
			if (formatted && formatted.replace) {
				formatted = formatted.replace(/<[^>]+>/g, "");
			}
			return formatted;
		},
		isEqual: function(entry1, entry2) {
			if (this.extracter) {
				return this.extracter(entry1) == this.extracter(entry2);
			}
			else {
				return JSON.stringify(entry1) == JSON.stringify(entry2);
			}
		},
		showIfFocus: function() {
			if (this.$refs.searchInput == document.activeElement) {
				this.showValues = true;
			}
		},
		initializeKeyValue: function() {
			// if you have no key value yet, we just take the first one
			if (this.keyValue == null) {
				this.keyValue = this.potentialValues[0];
			}
		},
		commitKeyValue: function($event) {
			if (this.keyValue != null) {
				this.toggle(this.keyValue);
			}
			$event.stopPropagation();
			$event.preventDefault();
		},
		moveUp: function($event) {
			this.moveKeyValue(-1);
			$event.stopPropagation();
			$event.preventDefault();
		},
		moveDown: function($event) {
			this.moveKeyValue(1);
			$event.stopPropagation();
			$event.preventDefault();
		},
		moveKeyValue: function(amount) {
			// only relevant if you can see something
			this.showValues = true;
			this.initializeKeyValue();
			if (this.keyValue != null) {
				var index = this.potentialValues.indexOf(this.keyValue);
				index += amount;
				if (index < this.potentialValues.length && index >= 0) {
					this.keyValue = this.potentialValues[index];
					var self = this;
					Vue.nextTick(function() {
						// make sure it is visible
						var list = self.$refs.valueList.querySelectorAll("li");
						var target = list.item(index);
						target.scrollIntoView({
							behavior: "smooth", 
							block: "center"
						});
					})
				}
			}
		},
		load: function() {
			var valueToSearch = this.search;
			if (valueToSearch != null && valueToSearch.trim() == "") {
				valueToSearch = null;
			}
			// if we are in the singular usecase and the search matches the formatted value of the current item, don't search for that
			if (!this.multiple && this.rawValues.length && this.getPlainFormatted(this.rawValues[0]) == valueToSearch) {
				valueToSearch = null;
			}
			// if the combo is not marked as dirty, only reload if necessary
			if (!this.dirty) {
				if (this.hasSearched) {
					if (valueToSearch == this.lastSearch) {
						return;
					}
				}
				else {
					this.hasSearched = true;
				}
			}
			this.lastSearch = valueToSearch;
			// unset dirty, we are recalculating!
			this.dirty = false;
			
			var self = this;
			self.calculating = true;
			
			// if we get multiple instances of the same data structure we want to ensure we have only one version in memory to ensure that all the equality checks keep working
			// otherwise there are way too many "easy" mistakes to make
			var normalize = function(results) {
				if (results) {
					for (var i = 0; i < results.length; i++) {
						var match = self.rawValues.filter(function(single) {
							return self.isEqual(single, results[i]);
						})[0];
						if (match) {
							results[i] = match;
						}
					}
				}
				return results;
			}
			if (this.items) {
				self.potentialValues.splice(0);
				nabu.utils.arrays.merge(this.potentialValues, normalize(this.items));
				self.calculating = false;
				self.showIfFocus();
			}
			else if (this.filter) {
				var result = this.filter(valueToSearch);
				if (result && result.then) {
					result.then(function(result) {
						self.potentialValues.splice(0);
						// check if it contains an array!
						if (result != null && !(result instanceof Array)) {
							Object.keys(result).forEach(function(key) {
								if (!(result instanceof Array)) {
									if (result[key] instanceof Array) {
										result = result[key];
									}
								}	
							});
						}
						if (result instanceof Array) {
							nabu.utils.arrays.merge(self.potentialValues, normalize(result));
						}
						self.calculating = false;
						self.showIfFocus();
					})
				}
				else if (result instanceof Array) {
					self.potentialValues.splice(0);
					nabu.utils.arrays.merge(self.potentialValues, normalize(result));
					self.calculating = false;
					self.showIfFocus();
				}
				else {
					console.error("The provided result is not a list of available options", result);
					self.calculating = false;
				}
			}
			else {
				console.error("The provided items can not be resolved to a list of available options", result);
				self.calculating = false;
			}
		},
		// make sure we have the necessary values in our raw list
		synchronize: function(values) {
			if (values == null) {
				values = [];
			}
			else if (!(values instanceof Array)) {
				values = [values];
			}
			var self = this;
			// if we actually have values
			if (values.length > 0) {
				// and we have an extracter
				if (this.extracter) {
					// in the beginning we might have one or more values for the component
					// however we will not have the corresponding raw values
					// we need to resolve them
					// hopefully they are available in the potential values but they might not be at which point we need to switch to the resolver
					// if other components alter the values, we might have a mismatched length
					if (this.rawValues.length != values.length) {
						var missing = [];
						// if we have an extracter, we need to extract all the values from the potential to match them with the ones we have
						var toMatch = this.extracter ? this.potentialValues.map(function(x) { return self.extracter(x) }) : this.potentialValues;
						
						// don't trigger until we have to
						// at first we were immediately targetting the rawValues array, but because of the async nature of the resolve (usually), the watcher would trigger twice, first updating the value to null, then the proper value
						// however, any update listeners might conclude (incorrectly) that the value was updated
						var localRawValues = [];
						
						nabu.utils.arrays.merge(localRawValues, values.map(function(single) {
							var index = toMatch.indexOf(single);
							if (index < 0) {
								missing.push(single);
							}
							return index >= 0 ? self.potentialValues[index] : null;
						}));
						var resolver = this.resolver;
						if (resolver == null && this.items != null && this.items.length > 0) {
							resolver = function(entry) {
								if (!(entry instanceof Array)) {
									entry = [entry];
								}
								return self.items.filter(function(x) {
									return entry.indexOf(self.extracter ? self.extracter(x) : x) >= 0;
								})
							}
						}
						// if we can't resolve it against the initial listing, use the resolver (if it exists)
						if (missing.length && resolver != null) {
							var result = resolver(this.multiple ? missing : missing[0]);
							var mergeValues = function(actualValues) {
								if (!(actualValues instanceof Array)) {
									actualValues = [actualValues];
								}
								var toMatch = self.extracter ? actualValues.map(function(x) { return self.extracter(x) }) : actualValues;
								var remove = [];
								missing.forEach(function(single) {
									var targetIndex = values.indexOf(single);
									var matchIndex = toMatch.indexOf(single);
									if (matchIndex >= 0) {
										localRawValues.splice(targetIndex, 1, actualValues[matchIndex]);
									}
									else {
										remove.unshift(single);
										console.warn("Can not resolve existing value", single);
									}
								});
								remove.forEach(function(single) {
									var targetIndex = values.indexOf(single);
									// remove the null placeholder
									localRawValues.splice(targetIndex, 1);
									// remove the value that we can not resolve
									values.splice(targetIndex, 1);
								});
								// add the necessary splice parameters
								localRawValues.unshift(self.rawValues.length);
								localRawValues.unshift(0);
								self.rawValues.splice.apply(self.rawValues, localRawValues);
								//self.emitLabel();
							};
							if (result != null && result.then) {
								result.then(mergeValues);
							}
							else if (result != null) {
								mergeValues(result);
							}
						}
					}
				}
				// if we don't have an extracter, the raw values are the same as the actual values
				else {
					nabu.utils.arrays.merge(this.rawValues, values);
				}
			}
			// if we have no value but it is not nillable, we select the first potential value
			else if (!this.nillable && this.potentialValues.length > 0) {
				this.rawValues.push(this.potentialValues[0]);
			}
			// make sure we have no raw values left
			else {
				this.rawValues.splice(0);
			}
		},
		toggleAll: function() {
			if (this.rawValues.length == this.potentialValues.length) {
				this.rawValues.splice(0);
			}
			else {
				var parameters = [];
				parameters.push(0);
				parameters.push(0);
				var self = this;
				// push only the ones not in the list yet
				nabu.utils.arrays.merge(parameters, this.potentialValues.filter(function(x) {
					return self.rawValues.indexOf(x) < 0;
				}));
				this.rawValues.splice.apply(this.rawValues, parameters);
			}
		},
		toggle: function(entry) {
			var index = this.rawValues.indexOf(entry);
			if (index < 0) {
				if (!this.multiple) {
					this.rawValues.splice(0);
				}
				this.rawValues.push(entry);
				// if you can't select multiple, close the popup
				if (!this.multiple) {
					this.showValues = false;
				}
			}
			else {
				// we only want to allow deselection if you have at least one other value or it can be reset to nill
				if (this.rawValues.length >= 2 || this.nillable) {
					this.rawValues.splice(index, 1);
				}
			}
		}
	},
	watch: {
		calculating: function(newValue) {
			if (!newValue && !this.initialized) {
				if (this.value != null) {
					this.synchronize(this.value);
				}
				this.initialized = true;
			}
		},
		// if our potential values change, our key value is reset
		potentialValues: function() {
			this.keyValue = null;	
		},
		// push to values
		rawValues: function() {
			var self = this;
			this.updating = true;
			if (this.multiple) {
				var labels = [];
				var parameters = this.rawValues.map(function(single) {
					labels.push(self.getFormatted(single));
					return self.getExtracted(single);
				});
				parameters.unshift(this.value.length);
				parameters.unshift(0);
				// we want it to be one atomic action
				this.value.splice.apply(this.value, parameters);
				// emit labels separately
				this.$emit("label", labels);				
			}
			else {
				// update the search text to match the formatted value
				// we don't actually want to reload the values at this point which is why we set the boolean
				this.searchUpdatedSelf = true;
				this.search = this.getPlainFormatted(this.rawValues[0]);
				this.$emit("input", 
					this.getExtracted(this.rawValues[0]), 
					this.getFormatted(this.rawValues[0]), 
					this.rawValues[0]
				);
			}
		},
		value: {deep: true, handler: function() {
			if (this.updating) {
				this.updating = false;
			}
			else {
				this.synchronize(this.value);
			}
		}},
		search: function(newValue) {
			if (this.searchUpdatedSelf) {
				this.searchUpdatedSelf = false;
			}
			else {
				// if you emptied it out 
				if (!this.multiple && this.nillable && (newValue == null || newValue.trim() == "")) {
					this.$emit("input", null);
				}
				if (this.searchTimer) {
					clearTimeout(this.searchTimer);
					this.searchTimer = null;
				}
				this.searchTimer = setTimeout(this.load, 600);
			}
		}
	}
});

Vue.component("n-form-date", {
	props: {
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		edit: {
			type: Boolean,
			required: false,
			default: true
		},
		required: {
			type: Boolean,
			required: false,
			default: null
		},
		name: {
			type: String,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		pattern: {
			type: String,
			required: false
		},
		patternComment: {
			type: String,
			required: false
		},
		minLength: {
			type: Number,
			required: false
		},
		maxLength: {
			type: Number,
			required: false
		},
		type: {
			type: String,
			required: false,
			default: "text"
		},
		hide: {
			type: Boolean,
			required: false,
			default: null
		},
		disabled: {
			type: Boolean,
			required: false
		},
		validator: {
			type: Function,
			required: false
		},
		unique: {
			type: Boolean,
			required: false
		},
		parser: {
			type: Function,
			required: false
		},
		formatter: {
			type: Function,
			required: false
		},
		minimum: {
			required: false
		},
		maximum: {
			required: false
		},
		allow: {
			type: Function,
			required: false
		},
		// whether you want a string or a date as object
		stringify: {
			type: Boolean,
			required: false,
			default: false
		},
		// the timeout is the timeout that is used when manually typing the date
		// make sure this is high enough, because once it times out, the system will try to parse whatever there is to a date
		// so if you just typed "1" and it immediately parses it, this becomes very annoying
		// also: selenium can't handle a timeout of 0 as it sends key by key, so the first key triggers a date generation and the other keys are just pasted after the date
		timeout: {
			type: Number,
			required: false,
			default: 600
		},
		// selenium has problems clearing the popup if the timeout is below say 100ms
		// because when the popup opens, it grabs focus (presumably) and the clear goes to the popup, not the input form
		popup: {
			type: Number,
			required: false
		},
		yearsDropdown: {
			type: Boolean,
			required: false,
			default: true
		},
		yearsFrom: {
			type: Number,
			required: false
		},
		yearsTo: {
			type: Number,
			required: false
		},
		includeHours: {
			type: Boolean,
			required: false,
			default: false
		},
		includeMinutes: {
			type: Boolean,
			required: false,
			default: false
		},
		includeSeconds: {
			type: Boolean,
			required: false,
			default: false
		},
		timestamp: {
			type: Boolean,
			required: false,
			default: false
		},
		secondsTimestamp: {
			type: Boolean,
			required: false,
			default: false
		},
		"default": {
			required: false
		},		
		disableTextInput: {
			type: Boolean,
			required: false
		},
		info: {
			type: String,
			required: false
		},
		before: {
			type: String,
			required: false
		},
		after: {
			type: String,
			required: false
		},
		localTime: {
			type: Boolean,
			default: false
		},
		translator: {
			type: Function,
			required: false
		}
	},
	template: "#n-form-date",
	data: function() {
		return {
			messages: [],
			valid: null,
			show: false,
			date: null,
			customizedSchema: null,
			lastParsed: null
		}
	},
	computed: {
		dynamicPattern: function() {
			// if we have a custom formatter, we have no pattern
			if (!this.formatter) {
				// the basic pattern
				var pattern = '^[0-9]{4}-(0?[1-9]|1[012])-(0?[1-9]|[12][0-9]|3[01])';
				if (this.includeHours) {
					pattern += " [0-9]{2}";
					if (this.includeMinutes) {
						pattern += ":[0-9]{2}";
						if (this.includeSeconds) {
							pattern += ":[0-9]{2}";
						}
					}
				}
				pattern += "$";
				return pattern;
			}
		},
		defaultValue: function () {
			return this.default;
		}
	},
	created: function() {
		if (!this.value && this.default) {
			this.$emit("input", this.default);
		}
		if (this.schema) {
			// we are expecting timestamp, but this won't validate correctly because we are working with strings
			if (this.schema.type == "integer") {
				this.customizedSchema = nabu.utils.objects.deepClone(this.schema);
				this.customizedSchema.type = "string";
				this.customizedSchema.format = "date-time";
			}
			else {
				this.customizedSchema = this.schema;
			}
		}
		if (this.value instanceof Date || typeof(this.value) == "number") {
			this.date = this.formatValue(this.value);
		}
		// if it is a number but in a string or something, parse it
		else if (this.value != null && !isNaN(this.value)) {
			this.date = this.formatValue(parseInt(this.value));
		}
		else if (typeof(this.value) == "string") {
			var parsed = this.valueToDate(this.value);
			this.date = this.formatValue(parsed);
			// if it should not be stringified and we have a string, emit that
			if (!this.stringified) {
				this.$emit("input", parsed, this.value);
				this.$emit("label", this.value);
			}
		}
		else {
			this.date = this.value;
		}
	},
	methods: {
		formatValue: function(value) {
			var date = value instanceof Date ? value : new Date(this.secondsTimestamp ? value * 1000 : value);
			if (this.formatter) {
				date = this.formatter(date);
			}
			else {
				// because we depend on ISO string (which returns in UTC), we manually increment the date with the local timezone offset
				// presumably you don't want to edit the date in UTC but rather in local time
				date = new Date(
					date.getFullYear(),
					date.getMonth(),
					date.getDate(),
					date.getHours(),
					date.getMinutes() - date.getTimezoneOffset(),
					date.getSeconds(),
					0
				);
				if (this.includeHours && this.includeMinutes && this.includeSeconds) {
					date = date.toISOString().substring(0, 19).replace("T", " ");
				}
				else if (this.includeHours && this.includeMinutes) {
					date = date.toISOString().substring(0, 16).replace("T", " ");
				}
				else if (this.includeHours) {
					date = date.toISOString().substring(0, 13).replace("T", " ");
				}
				else {
					date = date.toISOString().substring(0, 10);
				}
			}
			return date;
		},
		// not used?
		updateValue: function(value) {
			if (this.stringify) {
				this.$emit("input", value);
			}
			else {
				this.$emit("input", this.valueToDate(value), value);
				this.$emit("label", value);
			}
		},
		isAvailable: function(date) {
			return this.allow == null || this.allow(date);
		},
		dateValidate: function(value) {
			var messages = [];
			if (this.validator) {
				var childMessages = this.validator(value);
				if (childMessages) {
					nabu.utils.arrays.merge(messages, childMessages);
				}
			}
			if (value == "") {
				value = null;
			}
			var parsed = value == null ? null : this.valueToDate(value);
			// it is "a" value but not a parseable value
			if ((value != null && (parsed == null || !parsed.getTime))
					// or it is not a valid date
					|| (parsed != null && parsed.getTime && isNaN(parsed.getTime()))) {
				messages.push({
					severity: "error",
					code: "type",
					title: "%{validation::This is not a valid date: {actual}}",
					values: {
						actual: value,
						expected: "date"
					},
					context: []
				});
			}
			else if (parsed != null && parsed.getTime && !isNaN(parsed.getTime()) && !this.isAvailable(parsed)) {
				messages.push({
					severity: "error",
					code: "allowed",
					title: "%{validation::This date is not allowed: {actual}}",
					priority: 1,
					variables: {
						actual: value					
					},
					context: []
				});
			}
			return messages;
		},
		validate: function() {
			var messages = this.$refs.text.validate();
			this.valid = !messages.length;
			return messages;
		},
		focus: function () {
			this.showPopup();
			if ( this.edit && !this.disabled ) {
				this.show = !this.show;
			} 
			else {
				this.show = false;
			}
		},
		showPopup: function() {
			if (this.popup) {
				var self = this;
				setTimeout(function() {
					self.show = self.edit && !self.disabled;
				}, this.popup);
			}
		},
		valueToDate: function(value) {
			if (this.parser) {
				return this.parser(value);
			}
			if (!this.localTime) {
				if (!this.includeHours) {
					// if we don't have hours, we want to use UTC
					value += "T00:00:00Z"
				}
				else if (!this.includeMinutes) {
					value += ":00:00Z"
				}
				else if (!this.includeSeconds) {
					value += ":00Z";
				}
			}
			if (value && value.match && value.match(/[0-9]{4}-[0-9]{2}-[0-9]{2}[\s]+[0-9]{2}:[0-9]{2}:[0-9]{2}.*$/)) {
				value = value.replace(/([0-9]{4}-[0-9]{2}-[0-9]{2})[\s]+([0-9]{2}:[0-9]{2}:[0-9]{2}.*)$/, "$1T$2");
			}
			return new Date(value);
		}
	},
	watch: {
		date: function(newValue) {
			if (!newValue) {
				if (this.value) {
					this.$emit("input", null);
					this.$emit("label", null);
				}
			}
			else if (this.secondsTimestamp) {
				if (!this.value || this.formatValue(this.value) != newValue) {
					newValue = this.valueToDate(newValue);
					this.$emit("input", newValue.getTime() / 1000, this.formatValue(newValue));
					this.$emit("label", this.formatValue(newValue));
				}
			}
			else if (this.timestamp) {
				if (!this.value || this.formatValue(this.value) != newValue) {
					newValue = this.valueToDate(newValue);
					this.$emit("input", newValue.getTime(), this.formatValue(newValue));
					this.$emit("label", this.formatValue(newValue));
				}
			}
			else if (this.stringify) {
				if (this.value != newValue) {
					newValue = this.formatValue(this.valueToDate(newValue));
					this.$emit("input", newValue, this.formatValue(newValue));
					this.$emit("label", this.formatValue(newValue));
				}
			}
			else {
				newValue = this.valueToDate(newValue);
				if (newValue && newValue.getTime) {
					var value = this.value;
					if ( typeof(value) == "string" ) {
						value = new Date(this.value);
					}
					if (!this.value || newValue.getTime() != value.getTime()) {
						this.lastParsed = newValue;
						this.$emit("input", newValue, this.formatValue(newValue));
						this.$emit("label", this.formatValue(newValue));
						this.show = false;
					}
				}
				// otherwise unset the value, at this point you are visually looking at something that is not a date
				// if we don't emit null, the old date will be retained (but invisible) making it for a weird interaction
				else {
					this.lastParsed = null;
					this.$emit("input", null);
					this.$emit("label", null);
				}
			}
		},
		value: function(newValue) {
			// during roundtripping is is possible that the date got serialized
			// for example the form engine will take a copy of the original dataset on persist
			// and this copy will contain a serialized date because JSON does not have a dedicated date datatype
			if (typeof(newValue) == "string" && newValue.match(/[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.*/) && this.lastParsed) {
				var parsed = new Date(newValue);
				if (parsed.getTime() == this.lastParsed.getTime()) {
					newValue = parsed;
				}
			}
			if (newValue instanceof Date || typeof(newValue) == "number") {
				var formatted = this.formatValue(newValue);
				// if we have parsed something in the past and it has now come back but for some reason it differs from the date itself, we might have a timezone issue
				if (this.lastParsed != null && this.lastParsed.getTime() == newValue.getTime() && formatted != this.date) {
					console.warn("Prevented a date loop potentially caused by a timezone difference", this.lastParsed, formatted, this.date);
				}
				else {
					this.date = formatted;
					// @2023-12-21: noticed that when you are updating the value (from the outside) with the exact same value that it already has (at least formatted), the label is reset
					// we emit this to enforce the label primarily
					this.$emit("input", newValue, this.formatValue(newValue));
				}
				// unset the last parsed, we had a successful roundtrip
				// someone might want to alter it externally
				this.lastParsed = null;
			}
			else {
				this.date = newValue;
			}
		},
		'default': function (newValue) {
			// if we have a default date and no value yet
			// or we have a value but it is no (longer) valid, we emit the default
			if ((newValue && !this.value) || (this.value && !this.isAvailable(this.value))) {
				this.$emit("input", newValue);
			}
		}
	}
});

Vue.component("n-form-date-picker", {
	template: "#n-form-date-picker",
	props: {
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		edit: {
			type: Boolean,
			required: false,
			default: true
		},
		required: {
			type: Boolean,
			required: false,
			default: null
		},
		name: {
			type: String,
			required: false
		},
		hide: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		placeholderYear: {
			type: String,
			required: false
		},
		placeholderMonth: {
			type: String,
			required: false
		},
		placeholderDay: {
			type: String,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		pattern: {
			type: String,
			required: false
		},
		patternComment: {
			type: String,
			required: false
		},
		minLength: {
			type: Number,
			required: false
		},
		maxLength: {
			type: Number,
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		validator: {
			type: Function,
			required: false
		},
		format: {
			type: String,
			required: false
		},
		minimum: {
			required: false
		},
		maximum: {
			required: false
		},
		allow: {
			type: Function,
			required: false
		},
		// a date or something that can be thrown at the Date constructor
		notBefore: {
			required: false
		},
		notAfter: {
			required: false
		},
		minimumOffset: {
			type: Number,
			required: false
		},
		maximumOffset: {
			type: Number,
			required: false
		},
		// whether you want a string or a date as object
		stringify: {
			type: Boolean,
			required: false,
			default: false
		},
		// the timeout is the timeout that is used when manually typing the date
		// make sure this is high enough, because once it times out, the system will try to parse whatever there is to a date
		// so if you just typed "1" and it immediately parses it, this becomes very annoying
		// also: selenium can't handle a timeout of 0 as it sends key by key, so the first key triggers a date generation and the other keys are just pasted after the date
		timeout: {
			type: Number,
			required: false,
			default: 600
		},
		default: {
			required: false
		},
		fields: {
			type: Array,
			required: false,
			default: function() { return ["year", "month", "day"]; }
		},
		// we can autoformat the result depending on the fields required
		// e.g. yyyy-MM or yyyy-MM-dd
		autoFormat: {
			type: Boolean,
			required: false,
			default: false
		},
		allowPartial: {
			type: Boolean,
			required: false,
			default: false
		},
		description: {
			type: String,
			required: false
		},
		filterValues: {
			type: Boolean,
			required: false,
			default: false
		},
		descriptionIcon: {
			type: String,
			required: false
		},
		descriptionType: {
			type: String,
			default: "after"
		},
		info: {
			type: String,
			required: false
		},
		after: {
			type: String,
			required: false
		},
		before: {
			type: String,
			required: false
		},
		suffix: {
			type: String,
			required: false
		},
		suffixIcon: {
			type: String,
			required: false
		}		
		
	},
	data: function() {
		return {
			result: {
				year: null,
				month: null,
				day: null
			},
			messages: [],
			valid: null
		}
	},
	created: function() {
		if (!this.value && this.default) {
			this.$emit("input", this.default);
		}
		if (this.value) {
			this.result.year = this.fields.indexOf("year") >= 0 ? this.value.getFullYear() : null;
			this.result.month = this.fields.indexOf("month") >= 0 ? this.value.getMonth() + 1 : null;
			this.result.day = this.fields.indexOf("day") >= 0 ? this.value.getDate() : null;
		}
	},
	computed: {
		self: function() {
			return this;
		},
		definition: function() {
			return nabu.utils.vue.form.definition(this);
		},
		mandatory: function() {
			return nabu.utils.vue.form.mandatory(this);
		},
		formattedDate: function() {
			var format = this.format;
			if (!format) {
				format = "dd MMMM yyyy"
			}
			return this.value == null ? null : this.$services.formatter.date(this.value, format);
		}
	},
	methods: {
		validate: function(soft) {
			this.messages.splice(0, this.messages.length);
			var messages = nabu.utils.schema.json.validate(this.definition, this.value, this.mandatory);
			for (var i = 0; i < messages.length; i++) {
				Object.defineProperty(messages[i], 'component', {
					value: this,
					enumerable: false
				});
			}
			if (this.validator != null) {
				var additional = this.validator(this.value);
				if (additional != null && additional.length) {
					for (var i = 0; i < additional.length; i++) {
						Object.defineProperty(additional[i], 'component', {
							value: this,
							enumerable: false
						});
						if (typeof(additional[i].context) == "undefined") {
							additional[i].context = [];
						}
						messages.push(additional[i]);
					}
				}
				else if (additional != null && additional.then) {
					messages.defer(additional);
				}
			}
			var hardMessages = messages.filter(function(x) { return !x.soft });
			// if we are doing a soft validation and all messages were soft, set valid to unknown
			if (soft && hardMessages.length == 0 && (messages.length > 0 || !valueToValidate) && this.valid == null) {
				this.valid = null;
				// remove local messages
				this.messages.splice(0);
			}
			else {
				this.valid = messages.length == 0;
				nabu.utils.arrays.merge(this.messages, nabu.utils.vue.form.localMessages(this, messages));
			}
			return messages;
		},
		getPlaceholder: function(field) {
			if (field == "year") {
				return this.placeholderYear;
			}
			else if (field == "month") {
				return this.placeholderMonth;
			}
			else if (field == "day") {
				return this.placeholderDay;
			}
			return null;
		},
		editable: function(field) {
			return field == "year"
				|| (field == "month" && (this.result.year != null || this.fields.indexOf("year") < 0))
				|| (field == "day" && (this.result.year != null || this.fields.indexOf("year") < 0) && (this.result.month != null || this.fields.indexOf("month") < 0));
		},
		listField: function(field, value) {
			var from = null;
			if (this.notBefore != null) {
				from = this.notBefore instanceof Date ? this.notBefore : new Date(this.notBefore);
			}
			else if (this.maximumOffset != null && this.maximumOffset <= 0) {
				from = new Date(new Date().getTime() + (this.maximumOffset * 1000 * 60 * 60 * 24));
			}
			else if (this.minimumOffset != null && this.minimumOffset > 0) {
				from = new Date(new Date().getTime() + (this.minimumOffset * 1000 * 60 * 60 * 24));
			}
			else {
				from = new Date("1900-01-01T00:00:00Z");
			}
			var to = null;
			if (this.notAfter != null) {
				to = this.notAfter instanceof Date ? this.notAfter : new Date(this.notAfter);
			}
			else if (this.maximumOffset != null && this.maximumOffset > 0) {
				to = new Date(new Date().getTime() + (this.maximumOffset * 1000 * 60 * 60 * 24));
			}
			else if (this.minimumOffset != null && this.minimumOffset <= 0) {
				to = new Date(new Date().getTime() + (this.minimumOffset * 1000 * 60 * 60 * 24));
			}
			else {
				to = new Date("2075-01-01T00:00:00Z");
			}
			var options = [];
			// at some point we might want to add labels (e.g. month formatting)
			if (field == "year") {
				for (var i = from.getFullYear(); i <= to.getFullYear(); i++) {
					if (value == null || !this.filterValues || this.formatField(field, i).toLowerCase().indexOf(value.toLowerCase()) >= 0) {
						options.push(i);
					}
				}
				options.reverse();
			}
			else if (field == "month") {
				for (var i = 1; i <= 12; i++) {
					if (this.result.year != null) {
						// we want the last of the month, and months start at 0, so i is already +1
						if (new Date(this.result.year, i, -1).getTime() < from.getTime()) {
							continue;
						}
						// check that the first of the month is still allowed by the to
						else if (new Date(this.result.year, i - 1, 1).getTime() > to.getTime()) {
							continue;
						}
					}
					if (value == null || !this.filterValues || this.formatField(field, i).toLowerCase().indexOf(value.toLowerCase()) >= 0) {
						options.push(i);
					}
				}
			}
			else if (field == "day") {
				for (var i = 1; i <= 31; i++) {
					if (this.result.year != null && this.result.month != null) {
						var date = new Date(this.result.year, this.result.month - 1, i);
						// that day does not exist in this month
						if (date.getMonth() != this.result.month - 1) {
							continue;
						}
						else if (date.getTime() < from.getTime()) {
							continue;
						}
						// check that the first of the month is still allowed by the to
						else if (date.getTime() > to.getTime()) {
							continue;
						}
					}
					if (value == null || !this.filterValues || this.formatField(field, i).toLowerCase().indexOf(value.toLowerCase()) >= 0) {
						options.push(i);
					}
				}
			}
			return options;
		},
		formatField: function(field, value) {
			if (value == null) {
				return value;
			}
			if (field == "year") {
				return "" + value;
			}
			else if (field == "month") {
				return nabu.utils.dates.months()[value - 1];
			}
			return "" + value;
		},
		updateField: function(field, value) {
			if (value == "") {
				value = null;
			}
			var self = this;
			this.result[field] = value;
			// validate the month and day
			if (field == "year") {
				if (this.result.month != null) {
					var options = this.listField("month");
					if (options.indexOf(this.result.month) < 0) {
						this.result.month = null;
						this.result.day = null;
					}
				}
				// always recalculate the suggestions
				// it's an array because the ref is defined in a for loop
				this.$refs.month[0].refilter();
				
				if (this.result.year != null && this.fields.indexOf("month") >= 0) {
					setTimeout(function() {
						self.$refs.month[0].$el.querySelector("input").focus();
					}, 1);
				}
			}
			else if (field == "month") {
				if (this.result.month != null && this.fields.indexOf("day") >= 0) {
					setTimeout(function() {
						self.$refs.day[0].$el.querySelector("input").focus();
					}, 1);
				}
			}
			if (field == "year" || field == "month") {
				if (this.result.day != null) {
					var options = this.listField("day");
					if (options.indexOf(this.result.day) < 0) {
						this.result.day = null;
					}
				}
				if (this.fields.indexOf("day") >= 0) {
					this.$refs.day[0].refilter();
				}
			}
			this.emitValue();
		},
		emitValue: function() {
			var format = "dateTime";
			// we want to avoid timezone issues
			var string = null;
			var hasAllFields = true;
			for (var i = 0; i < this.fields.length; i++) {
				if (this.result[this.fields[i]] == null) {
					hasAllFields = false;
					break;
				}
			}
			if (hasAllFields || this.allowPartial) {
				string = this.result.year == null ? new Date().getFullYear() : this.result.year;
				string += "-" + (this.result.month == null ? "01" : (this.result.month < 10 ? "0" : "") + this.result.month);
				string += "-" + (this.result.day == null ? "01" : (this.result.day < 10 ? "0" : "") + this.result.day);
				string +="T00:00:00Z";
			}
			// should also check if the value is the same but less critical
			if (string != null || this.value != null) {
				if (this.autoFormat) {
					var format = null;
					if (this.result.year) {
						format = "yyyy";
					}
					if (this.result.month) {
						format = "yyyy-MM";
					}
					if (this.result.day) {
						format = "yyyy-MM-dd";
					}
					if (format != null) {
						this.$emit("input", string == null ? null : this.$services.formatter.date(new Date(string), format));
					}
				}
				else {
					this.$emit("input", string == null ? null : new Date(string));
				}
			}
		}
	}
});


Vue.component("n-form-file", {
	props: {
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		// whether or not you are in edit mode
		edit: {
			type: Boolean,
			required: false,
			default: true
		},
		required: {
			type: Boolean,
			required: false,
			// explicitly set default value to null, otherwise vue will make it false which we can't distinguish from "not set"
			default: null
		},
		name: {
			type: String,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		// a json schema component stating the definition
		schema: {
			type: Object,
			required: false
		},
		info: {
			type: String,
			required: false
		},
		infoIcon: {
			type: String,
			required: false
		},
		prefix: {
			type: String,
			required: false
		},
		prefixIcon: {
			type: String,
			required: false
		},
		suffix: {
			type: String,
			required: false
		},
		suffixIcon: {
			type: String,
			required: false
		},
		before: {
			type: String,
			required: false
		},
		after: {
			type: String,
			required: false
		},
		allow: {
			type: Function,
			required: false
		},
		// if you want the value to be formatted before it is shown, set a formatter
		formatter: {
			type: Function,
			required: false
		},
		// this function is used on blur
		masker: {
			type: Function,
			required: false
		},
		// if you want the value to be parsed before it is emitted, set a parser
		parser: {
			type: Function,
			required: false
		},
		// you can set alternative text values for specific validation codes
		// send in for example {'required': 'This field is required'}
		// we support complex overrides as well where you can set {'required': { title: 'this field is required'}}
		// at this point the data will be merged
		// you can also set an array of objects [{code: 'required', title: 'this field is required'}]
		codes: {
			required: false
		},
		types: {
			type: Array,
			required: false
		},
		// amount of files allowed (default unlimited)
		amount: {
			required: false
		},
		// in bytes, you can explicitly pass in 0 to set to unlimited
		maxFileSize: {
			type: Number,
			required: false	
		},
		disabled: {
			type: Boolean,
			required: false,
			default: false
		},
		browseLabel: {
			type: String,
			required: false
		},
		dropLabel: {
			type: String,
			required: false
		},
		browseIcon: {
			type: String,
			required: false
		},
		deleteIcon: {
			type: String,
			required: false,
			default: "fa fa-times"			
		},
		restrictionMessage: {
			type: String,
			required: false
		},
		buttonClass: {
			required: false
		},
		visualizeFileNames: {
			type: Boolean,
			required: false
		},
		fileNameDeleteClass: {
			required: false
		},
		fileNameContainerClass: {
			required: false
		},
		fileNameClass: {
			required: false
		}
	},
	template: "#n-form-file",
	data: function() {
		return {
			messages: [],
			valid: null,
			timer: null,
			localValue: null,
			offsetX: 0,
			blurred: false,
			valueToCommit: null
		};
	},
	methods: {
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		}
	}
});
Vue.component("n-form-combo", {
	props: {
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		labels: {
			type: Array,
			required: false
		},
		initialLabel: {
			required: false
		},
		filter: {
			type: Function,
			required: false
		},
		// used to format the value into the input once selected from the dropdown
		formatter: {
			type: Function,
			required: false
		},
		// used to extract the actual value from the suggested items
		extracter: {
			type: Function,
			required: false
		},
		// the input field itself has to be plain text (the formatter)
		// however, in the dropdowns (and in the future multiselect?) we can use html
		prettyFormatter: {
			type: Function,
			required: false
		},
		// used to resolve an extracted value into a valid item usually returned by filter
		resolver: {
			type: Function,
			required: false
		},
		required: {
			type: Boolean,
			required: false,
			// explicitly set default value to null, otherwise vue will make it false which we can't distinguish from "not set"
			default: null
		},
		// a json schema component stating the definition
		schema: {
			type: Object,
			required: false
		},
		edit: {
			type: Boolean,
			required: false,
			default: true
		},
		items: {
			required: false
		},
		nillable: {
			type: Boolean,
			default: true
		},
		timeout: {
			type: Number,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		placeholderSelected: {
			type: String,
			required: false
		},
		autoclose: {
			type: Boolean,
			required: false,
			default: true
		},
		disabled: {
			type: Boolean,
			required: false
		},
		name: {
			type: String,
			required: false
		},
		autocomplete: {
			type: String,
			required: false
		},
		autoselectSingle: {
			type: Boolean,
			required: false
		},
		caseInsensitive: {
			type: Boolean,
			required: false,
			default: false
		},		
		descriptionIcon: {
			type: String,
			required: false
		},
		description: {
			type: String,
			required: false
		},
		descriptionType: {
			type: String,
			default: "after"
		},
		info: {
			type: String,
			required: false
		},
		infoIcon: {
			type: String,
			required: false
		},
		after: {
			type: String,
			required: false
		},
		before: {
			type: String,
			required: false
		},
		validator: {
			type: Function,
			required: false
		},
		allowTyping: {
			type: Boolean,
			default: true
		},
		// the text to show when there are no hits
		emptyValue: {
			type: String,
			required: false
		},
		// the text to show while the hits are being calculated
		calculatingValue: {
			type: String,
			required: false
		},
		// the text to show to reset the current choice (value must not be null)
		resetValue: {
			type: String,
			required: false
		},
		prefix: {
			type: String,
			required: false
		},
		prefixIcon: {
			type: String,
			required: false
		},
		suffix: {
			type: String,
			required: false
		},
		suffixIcon: {
			type: String,
			required: false
		},
		allowTypeMatch: {
			type: Boolean,
			required: false,
		},
		comboType: {
			type: String,
			default: "n-input-combo"
		},
		// the text to show to select all
		selectAllValue: {
			type: String,
			required: false
		},
		searchInDropdown: {
			type: Boolean,
			required: false
		},
		useCheckbox: {
			type: Boolean,
			default: false
		},
		showTags: {
			type: Boolean,
			default: false
		},
		// set to 0 to get unlimited
		maxAmountOfTags: {
			default: 3
		},
		showAmount: {
			type: Boolean,
			default: false
		},
		deleteTagIcon: {
			type: String,
			default: "times"
		},
		loadOnFocus: {
			type: Boolean,
			default: false
		}
	},
	template: "#n-form-combo",
	data: function() {
		return {
			valid: null,
			messages: [],
			valueLabel: null
		}
	},
	computed: {
		definition: function() {
			return nabu.utils.vue.form.definition(this);
		},
		mandatory: function() {
			return nabu.utils.vue.form.mandatory(this);
		}
	},
	methods: {
		refilter: function() {
			this.$refs.combo.refilter();
		},
		validate: function(soft) {
			this.messages.splice(0);
			var messages = nabu.utils.schema.json.validate(this.definition, this.value, this.mandatory);
			// if we have an error that the value is required but you did type something, you typed something invalid, let's reflect that in the message title
			var requiredMessage = messages.filter(function(x) { return x.code == "required" })[0];
			if (requiredMessage && this.$refs && this.$refs.combo && this.$refs.combo.content) {
				requiredMessage.title = "%{validation::The value you entered is invalid}";
				requiredMessage.actual = this.$refs.combo.content;
			}
			for (var i = 0; i < messages.length; i++) {
				Object.defineProperty(messages[i], 'component', {
					value: this,
					enumerable: false
				});
			}
			// allow for custom validation
			messages = nabu.utils.vue.form.validateCustom(messages, this.value, this.validator, this);
			
			var self = this;
			messages.then(function(validations) {
				var hardMessages = messages.filter(function(x) { return !x.soft });
				// if we are doing a soft validation and all messages were soft, set valid to unknown
				if (soft && hardMessages.length == 0 && (messages.length > 0 || self.value == null) && (self.valid == null || self.value == null)) {
					self.valid = null;
				}
				else {
					self.valid = messages.length == 0;
					self.messages.splice(0);
					nabu.utils.arrays.merge(self.messages, nabu.utils.vue.form.localMessages(self, messages));
				}
			});
			return messages;
		},
		updateValue: function(value, formatted, rawValue, selectedLabel) {
			this.$emit("input", value, formatted, rawValue, selectedLabel);
		},
		clear: function() {
			this.$refs.combo.clear();
		}
	},
	watch: {
		value: function() {
			this.messages.splice(0);
			this.valid = null;
		}
	}
});


Vue.component("n-form-section", {
	props: {
		name: {
			type: String,
			required: false
		},
		// a json schema component stating the definition
		schema: {
			type: Object,
			required: false
		},
		label: {
			type: String,
			required: false
		},
		// can be used to validate
		value: {
			required: false
		},
		validator: {
			type: Function,
			required: false
		},
		mode: {
			type: String,
			required: false
		}
	},
	data: function() {
		return {
			labels: []
		}
	},
	template: "#n-form-section",
	computed: {
		definition: function() {
			return nabu.utils.vue.form.definition(this);
		},
		mandatory: function() {
			return nabu.utils.vue.form.mandatory(this);
		}
	},
	methods: {
		validate: function(soft) {
			var messages = nabu.utils.vue.form.validateChildren(this, soft);
			if (this.validator) {
				var additional = this.validator(this.value);
				if (additional && additional.length) {
					for (var i = 0; i < additional.length; i++) {
						Object.defineProperty(additional[i], 'component', {
							value: this,
							enumerable: false
						});
						if (typeof(additional[i].context) == "undefined") {
							additional[i].context = [];
						}
						messages.push(additional[i]);
					}
				}
			}
			return messages;
		}
	},
	events: {
		'$vue.child.added': function(child) {
			if (child.label) {
				// we pass in the entire component because we are interested in the "hide" property it may have
				// if we simply pass in the hide, it doesn't work...
				this.labels.push({ 
					name: child.label,
					component: child
				});
			}
			else if (!this.labels.length && child.labels) {
				nabu.utils.arrays.merge(this.labels, child.labels);
			}
			else {
				this.labels.push(null);
			}
		}
	}
});

Vue.component("n-form-richtext", {
	props: {
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		edit: {
			type: Boolean,
			required: false,
			default: true
		},
		required: {
			type: Boolean,
			required: false,
			// explicitly set default value to null, otherwise vue will make it false which we can't distinguish from "not set"
			default: null
		},
		name: {
			type: String,
			required: false
		},
		// a json schema component stating the definition
		schema: {
			type: Object,
			required: false
		},
		pattern: {
			type: String,
			required: false
		},
		minLength: {
			type: Number,
			required: false
		},
		maxLength: {
			type: Number,
			required: false
		},
		timeout: {
			type: Number,
			required: false
		},
		cleanStyle: {
			type: Boolean,
			required: false
		},
		info: {
			type: String,
			required: false
		},
		suffix: {
			type: String,
			required: false
		},
		before: {
			type: String,
			required: false
		},
		after: {
			type: String,
			required: false
		},
		supportLinkType: {
			type: Boolean,
			required: false
		},
		supportBlocks: {
			type: Boolean,
			default: true
		},
		placeholder: {
			type: String,
			default: "Rich text"
		},
		showMenu: {
			type: Boolean,
			default: true
		},
		disabled: {
			type: Boolean,
			default: false
		}
	},
	template: "#n-form-richtext",
	data: function() {
		return {
			messages: [],
			valid: null,
			showBlock: false,
			showJustify: false,
			showDecoration: false,
			color: "#000000",
			// a copy of the value to prevent rerendering constantly but DO allow outside setting of the value
			localValue: null,
			internalSet: false
		};
	},
	computed: {
		definition: function() {
			return nabu.utils.vue.form.definition(this);
		},
		mandatory: function() {
			return nabu.utils.vue.form.mandatory(this);
		}
	},
	created: function() {
		// initialize as the same
		this.localValue = this.value;	
	},
	methods: {
		update: function($event) {
			var content = $event.target.innerHTML;
			if (content != this.value) {
				this.$emit("change", content);
				if (this.timer != null) {
					clearTimeout(this.timer);
					this.timer = null;
				}
				if (this.timeout) {
					var self = this;
					var self = this;
					this.timer = setTimeout(function() {
						self.internalSet = true;
						self.$emit("input", content);
					}, this.timeout);
				}
				else {
					this.internalSet = true;
					this.$emit("input", content);
				}
			}
		},
		justify: function(direction) {
			document.execCommand(direction, false, null)
		},
		insertTable: function() {
			document.execCommand("insertHTML", null, "<table cellspacing='0' cellpadding='0'><tr><td>" + window.getSelection() + "</td></tr></table>");
		},
		list: function() {
			document.execCommand("insertHTML", null, "<ul><li>" + window.getSelection() + "</li></ul>");
		},
		wrap: function(tag) {
			document.execCommand("insertHTML", null, "<" + tag + ">" + window.getSelection() + "</" + tag + ">");
		},
		bold: function() {
			document.execCommand("bold", false, null);
		},
		italic: function() {
			document.execCommand("italic", false, null);
		},
		underline: function() {
			document.execCommand("underline", false, null);
		},
		link: function() {
			var link = prompt("Link");
			if (link) {
				var type = null;
				if (this.supportLinkType) {
					type = prompt("Link Type (optional)");
				}
				var classes = prompt("Link classes");
				if (type) {
					document.execCommand("insertHTML", false, "<a class='" + classes + "' target='_blank' type='" + type + "' href='" + link + "' rel='noreferer noopener nofollow'>" + window.getSelection() + "</a>");
				}
				else {
					//document.execCommand("createLink", false, link);
					document.execCommand("insertHTML", false, "<a class='" + classes + "' target='_blank' href='" + link + "' rel='noreferer noopener nofollow'>" + window.getSelection() + "</a>");
				}
			}
		},
		paste: function(event) {
			var self = this;
			for (var i = 0; i < event.clipboardData.items.length; i++) {
				if (event.clipboardData.items[i].type.toLowerCase().match(/text\/.*/)) {
					event.clipboardData.items[i].getAsString(function(content) {
						var cleaned = nabu.utils.elements.clean(
							content,
							["p", "strong", "h1", "h2", "h3", "h4", "h5", "h6", "h7", "strong", "em", "b", "i", "u", "ul", "ol", "li", "br", "span", "div"],
							["head", "script", "style", "meta", "font"],
							null,
							self.cleanStyle ? ["style"] : null);
						document.execCommand("insertHTML", null, cleaned);
					});
					break;
				}
			}
			event.preventDefault();
		},
		tab: function(event) {
			document.execCommand("insertHTML", false, "&nbsp;&nbsp;&nbsp;&nbsp;");
			event.preventDefault();
		},
		indent: function() {
			document.execCommand("indent", false, null);
		},
		outdent: function() {
			document.execCommand("outdent", false, null);
		},
		clean: function() {
			document.execCommand("removeFormat", false, null);
		},
		validate: function() {
			var messages = nabu.utils.schema.json.validate(this.definition, this.value ? this.value.replace(/<[^>]+>/, "") : this.value, this.mandatory);
			for (var i = 0; i < messages.length; i++) {
				Object.defineProperty(messages[i], 'component', {
					value: this,
					enumerable: false
				});
			}
			this.valid = messages.length == 0;
			return messages;
		},
		applyColor: function() {
			document.execCommand("insertHTML", null, "<span style='color:" + this.color + "'>" + window.getSelection() + "</span>");
		}
	},
	watch: {
		value: function(newValue) {
			if (this.internalSet) {
				this.internalSet = false;
			}
			else {
				this.localValue = newValue;
			}
		}
	}
});

Vue.directive("html-once", {
	bind: function(element, binding) {
		element.innerHTML = binding.value;
	}
});
// @2025-06-11: weird issue where a rich text field starts empty, I type in "test", then (due to external forces) set the value to "null" but the rich text retains "test"
// if i switch the external value back to test, it still remains "test" and if i switch to null a second time, it DOES update to an empty value
// not sure why but that is but hence this directive
Vue.directive("html-basic", {
	bind: function(element, binding) {
		element.innerHTML = binding.value == null ? "" : binding.value;
	},
	update: function(element, binding) {
		element.innerHTML = binding.value == null ? "" : binding.value;
	}
});
Vue.component("n-form-checkbox", {
	props: {
		component: {
			type: String,
			default: "is-form-checkbox"
		},
		value: {
			required: true
		},
		item: {
			required: false
		},
		label: {
			type: String,
			required: false
		},
		// whether or not you are in edit mode
		edit: {
			type: Boolean,
			required: false,
			default: true
		},
		required: {
			type: Boolean,
			required: false,
			// explicitly set default value to null, otherwise vue will make it false which we can't distinguish from "not set"
			default: null
		},
		name: {
			type: String,
			required: false
		},
		// a json schema component stating the definition
		schema: {
			type: Object,
			required: false
		},
		hide: {
			type: Boolean,
			required: false,
			default: null
		},
		disabled: {
			type: Boolean,
			required: false
		},
		invert: {
			type: Boolean,
			required: false,
			default: false
		},
		validator: {
			type: Function,
			required: false
		},
		mustCheck: {
			type: Boolean,
			required: false,
			default: false
		},
		info: {
			type: String,
			required: false
		},
		infoIcon: {
			type: String,
			required: false
		},
		before: {
			type: String,
			required: false
		},
		after: {
			type: String,
			required: false
		},
		labelBefore: {
			type: Boolean,
			required: false
		},
		tabindex: {
			type: String
		}
	},
	template: "#n-form-checkbox",
	data: function() {
		return {
			messages: [],
			valid: null,
			calculatedValue: false
		};
	},
	created: function() {
		var booleanValue = this.getBooleanValue(this.value);
		this.calculatedValue = this.invertIfNecessary(booleanValue);
	},
	computed: {
		definition: function() {
			return nabu.utils.vue.form.definition(this);
		},
		mandatory: function() {
			return nabu.utils.vue.form.mandatory(this);
		}
	},
	methods: {
		getBooleanValue: function(newValue) {
			var booleanValue = false;
			// for arrays we want a separate path
			if (newValue == null) {
				booleanValue = false;
			}
			else if (newValue === "false") {
				booleanValue = false;
			}
			else if (newValue === "true") {
				booleanValue = true;
			}
			else if (newValue instanceof Array) {
				if (this.item instanceof Array) {
					booleanValue = true;
					for (var i = 0; i < this.item.length; i++) {
						if (newValue.indexOf(this.item[i]) < 0) {
							booleanValue = false;
							break;
						}
					}
				}
				else {
					booleanValue = newValue.indexOf(this.item) >= 0;
				}
			}
			else {
				booleanValue = newValue;
			}
			return booleanValue;
		},
		invertIfNecessary: function(value) {
			return this.invert ? !value : value;
		},
		validate: function() {
			// if the checkbox is set to mustCheck but the calculated value is null, false or undefined or anything but true, we imitate a null value to trigger the mandatory validation
			var messages = nabu.utils.schema.json.validate(this.definition, this.mustCheck && !this.calculatedValue ? null : (this.calculatedValue == null ? false : this.calculatedValue), this.mandatory || this.mustCheck);
			for (var i = 0; i < messages.length; i++) {
				Object.defineProperty(messages[i], 'component', {
					value: this,
					enumerable: false
				});
			}
			if (this.validator) {
				var additional = this.validator(this.value);
				if (additional && additional.length) {
					for (var i = 0; i < additional.length; i++) {
						Object.defineProperty(additional[i], 'component', {
							value: this,
							enumerable: false
						});
						if (typeof(additional[i].context) == "undefined") {
							additional[i].context = [];
						}
						messages.push(additional[i]);
					}
				}
			}
			this.valid = messages.length == 0;
			return messages;
		}, 
		toggleValue: function() {
			if (!this.disabled && this.edit) {
				if (this.value instanceof Array) {
					var self = this;
					var merge = function(item) {
						var index = self.value.indexOf(item);
						if (index >= 0) {
							self.value.splice(index, 1);
							self.$emit("remove", item);
						}
						else {
							self.value.push(item);
							self.$emit("add", item);
						}
					}
					// if the item itself is an array, we merge all
					if (this.item instanceof Array) {
						// we don't want to simply toggle every single entry, if you change the list of items, it will always be partially set and unset
						// this means we can never get a "full" match again
						// instead, we check what the current boolean situation is and try to invert it
						var current = this.getBooleanValue(this.value);
						this.item.forEach(function(x) {
							var index = self.value.indexOf(x);
							// if we are currently set to "true" (so everything is in there), we want to remove it
							if (current && index >= 0) {
								self.value.splice(index, 1);
								self.$emit("remove", x);
							}
							// if we are set to "false" and want to include everything, add it
							else if (!current && index < 0) {
								self.value.push(x);
								self.$emit("add", x);
							}
						});
					}
					else {
						merge(this.item);
					}
				}
				else {
					this.$emit("input", this.invertIfNecessary(!this.calculatedValue));
				}
			}
		},
		updateChecked: function(value) {
			if (this.$refs && this.$refs.input) {
				if (value) {
					this.$refs.input.setAttribute("checked", "true");
				}
				else {
					this.$refs.input.removeAttribute("checked");
				}
			}
		}
	},
	watch: {
		value: function(newValue) {
			var booleanValue = this.getBooleanValue(this.value);
			this.calculatedValue = this.invertIfNecessary(booleanValue);
			this.updateChecked(this.calculatedValue);
		}
	}
});

Vue.directive("checked", function(element, binding) {
	if ((binding.value instanceof Array && binding.length) || (!(binding.value instanceof Array) && binding.value)) {
		element.setAttribute("checked", "true");
	}
	else {
		element.removeAttribute("checked");
	}
});

Vue.component("n-form-checkbox-list", {
	template: "#n-form-checkbox-list",
	props: {
		value: {
			required: true
		},
		// whether or not you are in edit mode
		edit: {
			type: Boolean,
			required: false,
			default: true
		},
		required: {
			type: Boolean,
			required: false,
			// explicitly set default value to null, otherwise vue will make it false which we can't distinguish from "not set"
			default: null
		},
		label: {
			type: String,
			required: false
		},
		name: {
			type: String,
			required: false
		},
		// a json schema component stating the definition
		schema: {
			type: Object,
			required: false
		},
		hide: {
			type: Boolean,
			required: false,
			default: null
		},
		disabled: {
			type: Boolean,
			required: false
		},
		items: {
			type: Array,
			required: true,
			default: function() {
				return []
			}
		},
		filter: {
			type: Function
		},
		validator: {
			type: Function,
			required: false
		},
		// we have a list of items, this is the display label
		formatter: {
			type: Function,
			required: false
		},
		// we have a list of items, this is how we extract the value
		extracter: {
			type: Function,
			required: false
		},
		info: {
			type: String,
			required: false
		},
		after: {
			type: String,
			required: false
		},
		before: {
			type: String,
			required: false
		}		
	},
	computed: {
		definition: function() {
			return nabu.utils.vue.form.definition(this);
		},
		mandatory: function() {
			return nabu.utils.vue.form.mandatory(this);
		}
	},
	data: function() {
		return {
			messages: [],
			valid: null,
			actualValue: null,
			chosen: false,
			// corresponding labels
			labels: []
		};
	},
	created: function() {
		if (this.filter) {
			var self = this;
			var result = this.filter();
			if (result && result.then) {
				result.then(function(result) {
					self.items.splice(0);
					// check if it contains an array!
					if (result != null && !(result instanceof Array)) {
						Object.keys(result).forEach(function(key) {
							if (!(result instanceof Array)) {
								if (result[key] instanceof Array) {
									result = result[key];
								}
							}	
						});
					}
					if (result instanceof Array) {
						nabu.utils.arrays.merge(self.items, result);
					}
				});
			}
			else if (result instanceof Array) {
				nabu.utils.arrays.merge(self.items, result);
			}
		}
	},
	mounted: function() {
		// @2025-05-20: IF you have a value which is not an array, it is probably useful, convert it to array rather than tossing it
		if (this.value != null && !(this.value instanceof Array)) {
			this.$emit("input", [this.value]);
		}
		else if (!this.value || !(this.value instanceof Array)) {
			this.$emit("input", []);
		}
		// if we already have items, let's fill up the labels
		else if (this.value.length) {
			var self = this;
			this.value.forEach(function(x) {
				var index;
				if (!self.extracter) {
					index = self.items.indexOf(x);
				}
				else {
					self.items.forEach(function(item, i) {
						if (self.extracter(item) == x) {
							index = i;
						}
					});
				}
				self.labels.push(index >= 0 ? (self.formatter ? self.formatter(self.value[index]) : self.value[index]) : self.value[index]);
			})
		}
	},
	methods: {
		isChecked: function(item) {
			var value = this.extracter ? this.extracter(item) : item;
			return this.value && this.value.indexOf(value) >= 0;
		},
		toggle: function(item) {
			var value = this.extracter ? this.extracter(item) : item;
			var index = this.value.indexOf(value);
			if (index >= 0) {
				this.value.splice(index, 1);
				this.labels.splice(index, 1);
			}
			else {
				this.value.push(value);
				this.labels.push(this.formatter ? this.formatter(value ) : value);
			}
			//this.$emit("input", this.value, this.labels);
		},
		validate: function(soft) {
			this.messages.splice(0, this.messages.length);
			var messages = nabu.utils.schema.json.validate(this.definition, this.value, this.mandatory);
			
			var existingRequired = messages.filter(function(x) { return x.code == "required" })[0];
			if (existingRequired) {
				existingRequired.title = "%{validation::You must choose at least one option}";
			}
			else if (this.mandatory && this.value.length == 0) {
				messages.push({
					code: "required",
					severity: "error",
					soft: true,
					priority: 0,
					title: "%{validation::You must choose at least one option}"
				});
			}
			
			for (var i = 0; i < messages.length; i++) {
				Object.defineProperty(messages[i], 'component', {
					value: this,
					enumerable: false
				});
			}
			var hardMessages = messages.filter(function(x) { return !x.soft });
			// if we are doing a soft validation and all messages were soft, set valid to unknown
			if (soft && hardMessages.length == 0 && (messages.length > 0 || this.value == null) && (this.valid == null || this.value == null)) {
				this.valid = null;
				// remove local messages
				this.messages.splice(0);
			}
			else {
				this.valid = messages.length == 0;
				nabu.utils.arrays.merge(this.messages, nabu.utils.vue.form.localMessages(this, messages));
			}
			return messages;
		}
	}
});

Vue.component("n-form-text", {
	props: {
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		// whether or not you are in edit mode
		edit: {
			type: Boolean,
			required: false,
			default: true
		},
		required: {
			type: Boolean,
			required: false,
			// explicitly set default value to null, otherwise vue will make it false which we can't distinguish from "not set"
			default: null
		},
		name: {
			type: String,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		// a json schema component stating the definition
		schema: {
			type: Object,
			required: false
		},
		pattern: {
			type: String,
			required: false
		},
		patternComment: {
			type: String,
			required: false
		},
		minLength: {
			type: Number,
			required: false
		},
		maxLength: {
			type: Number,
			required: false
		},
		type: {
			type: String,
			required: false,
			default: "text"
		},
		hide: {
			type: Boolean,
			required: false,
			default: null
		},
		disabled: {
			type: Boolean,
			required: false
		},
		validator: {
			type: Function,
			required: false
		},
		unique: {
			type: Boolean,
			required: false
		},
		caseSensitive: {
			type: Boolean,
			required: false,
			default: true
		},
		timeout: {
			required: false
		},
		maximum: {
			type: Number,
			required: false
		},
		minimum: {
			type: Number,
			required: false
		},
		step: {
			type: Number,
			required: false
		},
		exclusiveMaximum: {
			type: Number,
			required: false
		},
		exclusiveMinimum: {
			type: Number,
			required: false
		},
		trim: {
			type: Boolean,
			required: false,
			default: false
		},
		mode: {
			type: String,
			required: false
		},
		autoSelect: {
			type: Boolean,
			required: false,
			default: false
		},
		autoScale: {
			type: Boolean,
			required: false,
			default: false
		},
		info: {
			type: String,
			required: false
		},
		infoIcon: {
			type: String,
			required: false
		},
		prefix: {
			type: String,
			required: false
		},
		prefixIcon: {
			type: String,
			required: false
		},
		suffix: {
			type: String,
			required: false
		},
		suffixIcon: {
			type: String,
			required: false
		},
		before: {
			type: String,
			required: false
		},
		after: {
			type: String,
			required: false
		},
		allow: {
			type: Function,
			required: false
		},
		// if you want the value to be formatted before it is shown, set a formatter
		formatter: {
			type: Function,
			required: false
		},
		// this function is used on blur
		masker: {
			type: Function,
			required: false
		},
		// if you want the value to be parsed before it is emitted, set a parser
		parser: {
			type: Function,
			required: false
		},
		// you can set alternative text values for specific validation codes
		// send in for example {'required': 'This field is required'}
		// we support complex overrides as well where you can set {'required': { title: 'this field is required'}}
		// at this point the data will be merged
		// you can also set an array of objects [{code: 'required', title: 'this field is required'}]
		codes: {
			required: false
		},
		showTooltip: {
			type: Boolean,
			required: false,
			default: true
		},
		autocomplete: {
			type: String,
			// for chrome, if we only set it to "off", we still get the auto suggestions popup that layers over everything....
			default: window.navigator.userAgent.indexOf("Chrome") >= 0 ? "nothing" : "off"
		},
		// you can show the customer spinners (for numbers only)
		// you need css to hide the default ones then
		showCustomSpinner: {
			type: Boolean,
			default: false
		},
		autofocus: {
			type: Boolean,
			default: false
		},
		// require the user to hit "enter" to commit the value
		commit: {
			type: Boolean,
			default: false
		},
		validateOnBlur: {
			type: Boolean,
			default: false
		}
	},
	template: "#n-form-text",
	data: function() {
		return {
			messages: [],
			valid: null,
			timer: null,
			localValue: null,
			offsetX: 0,
			blurred: false,
			valueToCommit: null
		};
	},
	created: function() {
		this.localValue = this.formatter && this.value != null ? this.formatter(this.value) : this.value;
		if (this.masker) {
			this.localValue = this.value != null ? this.masker(this.value) : this.value;
		}
	},
	ready: function() {
		if (this.type == "range") {
			this.calculateOffset(this.value);
		}
		if (this.autofocus && this.$refs.input) {
			this.$refs.input.focus();
			this.$refs.input.select();
		}
	},
	computed: {
		rows: function() {
			if (this.autoScale) {
				if (!this.value) {
					return 1;
				}
				else {
					return this.value.length - this.value.replace(/\n/g, "").length + 1;
				}
			}
			return null;
		},
		definition: function() {
			var definition = nabu.utils.vue.form.definition(this);
			if (this.type == "number") {
				definition.type = "number";
			}
			return definition;
		},
		rangeWidth: function () {
			if (this.minimum && this.maximum && this.exclusiveMinimum && this.exclusiveMaximum) {
				return (this.maximum - this.minimum) / (this.exclusiveMaximum - this.exclusiveMinimum)*100 + "%";	
			}
			else {
				return "100%";
			}
		},
		rangeLeftOffset: function () {
			if (this.minimum && this.maximum && this.exclusiveMinimum && this.exclusiveMaximum) {
				return (this.minimum - this.exclusiveMinimum) / (this.exclusiveMaximum - this.exclusiveMinimum)*100 + "%";	
			}
			else {
				return "0%";
			}
		},
		mandatory: function() {
			return nabu.utils.vue.form.mandatory(this);
		}
	},
	methods: {
		attemptSubmit: function() {
			var el = this.$el;
			while (el) {
				if (el.tagName && el.tagName.toLowerCase() == "form") {
					var button = el.querySelector("button[type='submit']");
					if (button) {
						button.click();
					}
					break;
				}
				else {
					el = el.parentNode;
				}
			}
		},
		mergeContent: function(content) {
			return this.$refs.input.value
				? this.$refs.input.value.substring(0, this.$refs.input.selectionStart) + content + 
					this.$refs.input.value.substring(this.$refs.input.selectionEnd)
				: content;
		},
		pasteHandler: function($event) {
			var clipboardData = clipboardData = $event.clipboardData || window.clipboardData;
			var content = clipboardData.getData('Text');
			if (this.allow) {
				var response = this.allow(null, this.mergeContent(content));
				// if you send back a string, it is assumed to be the complete string, not a rewrite of the new part
				if (typeof(response) == "string") {
					var current = this.$refs.input.selectionStart;
					this.$refs.input.value = response;
					this.$refs.input.selectionEnd = Math.min(current + 1, response.length);
					$event.preventDefault();
					$event.stopPropagation();
					this.updateValue(response);
				}
				// if we have any negative feedback, don't allow the paste
				else if ((response instanceof Array && response.length > 0) || !response) {
					$event.preventDefault();
					$event.stopPropagation();
				}
			}
		},
		checkKey: function($event) {
			if ($event.key == "Enter") {
				// ideally we want to actually run the commit value at this point...
				// but we can't seem to trigger an actual early run of the timer
				if (this.timer) {
					clearTimeout(this.timer);
					this.timer = null;
				}
				this.$emit("input", this.valueToCommit);
				this.$emit("commit");
			}
			if (this.allow && $event.key && !$event.ctrlKey && !$event.metaKey) {
				var result = this.allow($event.key, this.mergeContent($event.key));
				// you can send back an array of validation messages
				// this can't be asynchronous because we need to block the event _now_
				if (result instanceof Array) {
					if (result.length > 0) {
						$event.preventDefault();
						return false;
					}
				}
				// if we send back a string, we may have modified the end result
				else if (typeof(result) == "string") {
					var current = this.$refs.input.selectionStart;
					this.$refs.input.value = result;
					this.$refs.input.selectionEnd = Math.min(current + 1, result.length);
					//this.$refs.input.selectionStart = Math.min(current, result.length);
					$event.preventDefault();
					this.updateValue(result);
				}
				else if (!result) {
					$event.preventDefault();
					return false;
				}
			}
			return true;
		},
		focus: function($event) {
			this.blurred = false;
			this.$emit('focus', $event);
			if (this.autoSelect) {
				this.$refs.input.select();
			}
			if (this.masker) {
				this.localValue = this.formatter && this.value != null ? this.formatter(this.value) : this.value;
			}
		},
		blur: function (value) {
			this.blurred = true;
			this.localValue = this.masker && value != null ? this.masker(value) : value;
			this.$emit('blur');
			if (this.validateOnBlur) {
				this.validate(true);
			}
		},
		validate: function(soft) {
			// in some cases you block the update of the value if the validation fails, however this is a catch 22 if we use the value itself for validation
			if (this.masker) {
				var valueToValidate = this.value;
			}
			else {
				var valueToValidate = this.edit ? this.$refs.input.value : this.value;
				if (this.trim && valueToValidate && valueToValidate.trim) {
					valueToValidate = valueToValidate.trim();
				}
				if (valueToValidate == "") {
					valueToValidate = null;
				}
			}
			if (this.parser && valueToValidate != null) {
				valueToValidate = this.parser(valueToValidate);
			}
			// reset current messages
			this.messages.splice(0);
			// this performs all basic validation and enriches the messages array to support asynchronous
			var messages = nabu.utils.schema.json.validate(this.definition, valueToValidate, this.mandatory);
			// add context to the messages to we can link back to this component
			for (var i = 0; i < messages.length; i++) {
				// components are vue-based entities that have recursive links to each other, the validation messages again etc
				// we don't want to include them in the enumerable properties cause this would prevent them from ever being serialized
				// we want to keep all state serializable and validations can become part of the state
				Object.defineProperty(messages[i], 'component', {
					value: this,
					enumerable: false
				});
			}
			// allow for unique validation
			if (valueToValidate != null && this.unique && this.$group) {
				var count = 0;
				for (var i = 0; i < this.$group.length; i++) {
					// only count visible items
					if (this.$group[i].$el && this.$document.body.contains(this.$group[i].$el)) {
						if (this.$group[i].value == valueToValidate) {
							count++;
						}
						else if (!this.caseSensitive && this.$group[i].value && valueToValidate && this.$group[i].value.toLowerCase() == valueToValidate.toLowerCase()) {
							count++;
						}
					}
				}
				if (count > 1) {
					var message = {
						code: "unique",
						context: [],
						severity: "error",
						values: {
							expected: 1,
							actual: count,
							value: valueToValidate
						}
					};
					Object.defineProperty(message, 'component', {
						value: this,
						enumerable: false
					});
					messages.push(message);
				}
			}
			// allow for custom validation
			messages = nabu.utils.vue.form.validateCustom(messages, valueToValidate, this.validator, this);

			var self = this;
			messages.then(function(validations) {
				nabu.utils.vue.form.rewriteCodes(messages, self.codes);

				// we want to separate out the info & warning messages, they should not be blocking and can be displayed alongside actual errors
				// currently the informational & warning messages are only ever shown on the component itself, not at the form level
				// this is why we are removing them from the actual messages array, they do not follow the component setting for errors (currently)
				var informational = messages.filter(function(x) { return x.severity != "error" });
				if (informational.length) {
					informational.forEach(function(x) {
						messages.splice(messages.indexOf(x), 1);
					});
				}

				self.messages.splice(0);
				var hardMessages = messages.filter(function(x) { return !x.soft });
				// if we are doing a soft validation and all messages were soft, set valid to unknown
				if (soft && hardMessages.length == 0 && (messages.length > 0 || !valueToValidate) && self.valid == null) {
					self.valid = null;
				}
				else {
					self.valid = messages.length == 0;
					nabu.utils.arrays.merge(self.messages, nabu.utils.vue.form.localMessages(self, messages));
				}
				// make sure we emit the value we just validated. in case of validate on blur (or a short validate timeout) and a longer emit timeout
				// we might be validating values that are not persisted, we can then browse to the next page without persisting it at all
				// don't send out a belated update
				if (self.timer) {
					clearTimeout(self.timer);
					self.timer = null;
				}
				// the original value can be undefined or null or an empty string
				// the valueToValidate can be any one of those too (realistically likely an empty string as we are talking about text fields)
				// to make sure we only update if it is relevant, we add this if
				// otherwise we "update" from undefined to an empty string for example which whill (after the validate) trigger the watcher which immediately resets the validation errors
				if (!(self.value == null && !valueToValidate)) {
					self.valueToCommit = self.valueToValidate;
					self.$emit("input", valueToValidate);
				}
				// if we have any informational messages, we want to show them locally
				if (informational.length) {
					nabu.utils.arrays.merge(self.messages, informational);
				}
			});
			return messages;
		}, 
		calculateOffset: function(value) {
			if (!value) {
				this.$refs.tooltip.style.display = "none";
			}
			else if (this.$refs.input) {
				var parsed = parseFloat(value);
				var range = this.$refs.input;
				var ratio = (range.value - range.min) / (range.max - range.min);
				// we need to add a bit of a correction the further we go from the left
				// this correction is currently expressed as the thumbwidth for now (long story)
				// in the future we will probably expose this as an input parameter
				var thumbWidth = 40;
				this.$refs.tooltip.style.display = "block";
				this.$refs.tooltip.style.left = Math.floor((ratio * this.$refs.input.offsetWidth) - (thumbWidth * ratio)) + "px";
			}
		},
		triggerChange: function(event) {
			// IE does not fire input events for range, but it does trigger a change event
			if (this.type == "range" && navigator.userAgent && navigator.userAgent.toLowerCase().indexOf("rv:11.0") >= 0) {
				this.updateValue(event.target.value);
			}	
		},
		updateValue: function(value) {
			if (this.trim && typeof(value) != "undefined" && value != null) {
				value = value.trim();
			}
			// empty string means empty text field, we assume it is null then
			if (value == "") {
				value = null;
			}
			if (value != this.value) {
				if (this.timer) {
					clearTimeout(this.timer);
					this.timer = null;
				}
				// if we have a range, calculate the offset
				if (this.type == "range") {
					if (this.exclusiveMinimum != null && this.minimum != null && value < this.minimum) {
						value = this.minimum;
						this.localValue = this.formatter && this.value != null ? this.formatter(this.value) : this.value;
					}
					if (this.exclusiveMaximum != null && this.maximum != null && value > this.maximum) {
						value = this.maximum;
						this.localValue = this.formatter && this.value != null ? this.formatter(this.value) : this.value;
					}					
					this.calculateOffset(value);
				}
				var valueToEmit = this.parser && value != null ? this.parser(value) : value;
				if (valueToEmit == "") {
					valueToEmit = null;
				}
				// force the visual value to be the same
				this.localValue = this.formatter && valueToEmit != null ? this.formatter(valueToEmit) : valueToEmit;
				// always emit the change event, it is not subject to timeout
				this.$emit("change", valueToEmit);
				// we always set this because we want to preemptively send it in case of commit with timeout anyway
				this.valueToCommit = valueToEmit;
				if (!this.commit) {
					if (this.timeout) {
						var self = this;
						this.timer = setTimeout(function() {
							self.$emit("input", valueToEmit);
						}, this.timeout);
					}
					else {
						this.$emit("input", valueToEmit);
					}
				}
			}
		},
        increment: function () {
                if (this.type == "number") {
					this.$refs.input.stepUp();
					this.valueToCommit = this.$refs.input.value;
					this.$emit("input", this.$refs.input.value);
                }       
        },
        decrement: function () {
                if (this.type == "number") {
					this.$refs.input.stepDown();
					this.valueToCommit = this.$refs.input.value;
					this.$emit("input", this.$refs.input.value);
                }       
        }
	},
	watch: {
		// reset validity if the value is updated
		value: function(newValue) {
			this.valid = null;
			// remove local messages
			this.messages.splice(0);
			if (!this.blurred) {
				this.localValue = this.formatter && this.value != null ? this.formatter(this.value) : this.value;
			}
			else {
				this.localValue = this.masker && this.value != null ? this.masker(this.value) : this.value;
			}
			// if we have a range, calculate the offset, if we do it without the timeout, it is always one value too late :(
			if (this.type == "range") {
				var self = this;
				setTimeout(function() {
					self.calculateOffset(self.value);
				}, 1);
			}
		}
	}
});

HTMLTextAreaElement.prototype.insertAtCaret = function(text) {
	text = text || '';
	// IE
	if (document.selection) {
		this.focus();
		var sel = document.selection.createRange();
		sel.text = text;
	}
	else if (this.selectionStart || this.selectionStart === 0) {
		// Others
		var startPos = this.selectionStart;
		var endPos = this.selectionEnd;
		this.value = this.value.substring(0, startPos) + text
			+ this.value.substring(endPos, this.value.length);
		this.selectionStart = startPos + text.length;
		this.selectionEnd = startPos + text.length;
	}
	else {
		this.value += text;
	}
};

HTMLInputElement.prototype.insertAtCaret = function(text) {
	text = text || '';
	// IE
	if (document.selection) {
		this.focus();
		var sel = document.selection.createRange();
		sel.text = text;
	}
	else if (this.selectionStart || this.selectionStart === 0) {
		// Others
		var startPos = this.selectionStart;
		var endPos = this.selectionEnd;
		this.value = this.value.substring(0, startPos) + text
			+ this.value.substring(endPos, this.value.length);
		this.selectionStart = startPos + text.length;
		this.selectionEnd = startPos + text.length;
	}
	else {
		this.value += text;
	}
};
Vue.component("n-form-switch", {
	props: {
		value: {
			required: true
		},
		item: {
			required: false
		},
		label: {
			type: String,
			required: false
		},
		edit: {
			type: Boolean,
			required: false,
			default: true
		},
		disabled: {
			type: Boolean,
			required: false,
			default: false
		},
		invert: {
			type: Boolean,
			required: false,
			default: false
		},
		info: {
			type: String,
			required: false
		},
		infoIcon: {
			type: String,
			required: false
		},
		before: {
			type: String,
			required: false
		},
		after: {
			type: String,
			required: false
		}
	},
	template: "#n-form-switch",
	methods: {
		updateValue: function(newValue) {
			if (!this.disabled) {
				this.$emit("input", newValue);
			}
		},
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		}
	}
});

Vue.component("n-form-radio", {
	props: {
		value: {
			required: true
		},
		// whether or not you are in edit mode
		edit: {
			type: Boolean,
			required: false,
			default: true
		},
		required: {
			type: Boolean,
			required: false,
			// explicitly set default value to null, otherwise vue will make it false which we can't distinguish from "not set"
			default: null
		},
		label: {
			type: String,
			required: false
		},
		name: {
			type: String,
			required: false,
			// must always have a name to guarantee single selection within the group
			default: function() {
				return ("radio-" + Math.random()).replace("0\.", "");
			}
		},
		// a json schema component stating the definition
		schema: {
			type: Object,
			required: false
		},
		hide: {
			type: Boolean,
			required: false,
			default: null
		},
		disabled: {
			type: Boolean,
			required: false
		},
		disabler: {
			type: Function,
			required: false
		},
		items: {
			type: Array,
			required: true,
			default: function() {
				return []
			}
		},
		filter: {
			type: Function
		},
		validator: {
			type: Function,
			required: false
		},
		// we have a list of items, this is the display label
		formatter: {
			type: Function,
			required: false
		},
		// we have a list of items, this is how we extract the value
		extracter: {
			type: Function,
			required: false
		},
		infoIcon: {
			type: String,
			required: false
		},
		info: {
			type: String,
			required: false
		},
		after: {
			type: String,
			required: false
		},
		before: {
			type: String,
			required: false
		},
		mustChoose: {
			type: Boolean,
			required: false
		}		
	},
	template: "#n-form-radio",
	data: function() {
		return {
			messages: [],
			valid: null,
			actualValue: null,
			chosen: false
		};
	},
	created: function() {
		if (this.filter) {
			var self = this;
			var result = this.filter();
			if (result && result.then) {
				result.then(function(result) {
					self.items.splice(0);
					// check if it contains an array!
					if (result != null && !(result instanceof Array)) {
						Object.keys(result).forEach(function(key) {
							if (!(result instanceof Array)) {
								if (result[key] instanceof Array) {
									result = result[key];
								}
							}	
						});
					}
					if (result instanceof Array) {
						nabu.utils.arrays.merge(self.items, result);
						self.synchronizeValue();
					}
				});
			}
			else if (result instanceof Array) {
				nabu.utils.arrays.merge(self.items, result);
				self.synchronizeValue();
			}
		}
		else {
			this.synchronizeValue();
		}
	},
	computed: {
		definition: function() {
			return nabu.utils.vue.form.definition(this);
		},
		mandatory: function() {
			console.log("computed mandatory:", nabu.utils.vue.form.mandatory(this));
			return nabu.utils.vue.form.mandatory(this);
		}
	},
	methods: {
		isDisabled: function(item) {
			if (this.disabler) {
				return this.disabler(item);
			}
			else {
				return this.disabled;
			}
		},
		synchronizeValue: function() {
			// if we received an extracter, the current value is an extract from one of the items
			if (this.extracter && this.value) {
				var self = this;
				this.actualValue = this.items.filter(function(x) { return self.extracter(x) == self.value })[0];
			}
			else {
				this.actualValue = this.value;
			}
		},
		validate: function(soft) {
			this.messages.splice(0, this.messages.length);
			var messages = nabu.utils.schema.json.validate(this.definition, this.value, this.mandatory);
			
			var existingRequired = messages.filter(function(x) { return x.code == "required" })[0];
			if (existingRequired) {
				existingRequired.title = "%{validation::You must choose an option}";
			}
			else if (!this.chosen && this.mustChoose) {
				var message = {
					soft: false,
					severity: "error",
					code: "required",
					title: "%{validation::You must choose an option}",
					priority: 0,
					values: {
						actual: false,
						expected: true
					},
					context: []
				}
				Object.defineProperty(message, 'component', {
					value: this,
					enumerable: false
				});
				messages.push(message);				
			}
			// if we have an error that the value is required but you did type something, you typed something invalid, let's reflect that in the message title
			var requiredMessage = messages.filter(function(x) { return x.code == "required" })[0];
			if (requiredMessage && this.$refs && this.$refs.combo && this.$refs.combo.content) {
				requiredMessage.title = "%{validation::Please choose a value}";
				requiredMessage.actual = this.$refs.combo.content;
			}
			for (var i = 0; i < messages.length; i++) {
				Object.defineProperty(messages[i], 'component', {
					value: this,
					enumerable: false
				});
			}
			var hardMessages = messages.filter(function(x) { return !x.soft });
			// if we are doing a soft validation and all messages were soft, set valid to unknown
			if (soft && hardMessages.length == 0 && (messages.length > 0 || this.value == null) && (this.valid == null || this.value == null)) {
				this.valid = null;
				// remove local messages
				this.messages.splice(0);
			}
			else {
				this.valid = messages.length == 0;
				nabu.utils.arrays.merge(this.messages, nabu.utils.vue.form.localMessages(this, messages));
			}
			return messages;
		},		
		select: function(option) {
			if (!this.disabled && this.edit) {
				this.chosen = true;
				this.$emit("input", this.extracter ? this.extracter(option) : option, this.formatter ? this.formatter(option) : option);
				// we don't know if it's valid at this point
				this.valid = null;
				this.messages.splice(0);
			}
		}
	}
});

Vue.component("n-form-location", {
	props: {
		value: {
			required: false
		},
		label: {
			type: String,
			required: false
		},
		// whether or not you are in edit mode
		edit: {
			type: Boolean,
			required: false,
			default: true
		},
		required: {
			type: Boolean,
			required: false,
			// explicitly set default value to null, otherwise vue will make it false which we can't distinguish from "not set"
			default: null
		},
		name: {
			type: String,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		// a json schema component stating the definition
		schema: {
			type: Object,
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		validator: {
			type: Function,
			required: false
		},
		timeout: {
			type: Number,
			required: false
		},
		// the two letter code of the country
		countryRestriction: {
			type: String,
			required: false
		},
		allowEstablishments: {
			type: Boolean,
			required: false
		},
		allowCities: {
			type: Boolean,
			required: false
		},
		allowRegions: {
			type: Boolean,
			required: false
		},
		// allow for vague addresses
		allowVague: {
			type: Boolean,
			required: false
		},
		allowStreet: {
			type: Boolean,
			required: false
		},
		// latBottomLeft,longBottomLeft;latTopRight,longTopRight
		bounds: {
			type: String,
			required: false
		},
		// lat,long;radiusInMeters
		bias: {
			type: String,
			required: false
		},
		
		// the fields
		// geometry.location.lat
		latitude: {
			type: String,
			required: false
		},
		// geometry.location.long
		longitude: {
			type: String,
			required: false
		},
		// country
		country: {
			type: String,
			required: false
		},
		// countryCode (2 letter ISO)
		countryCode: {
			type: String,
			required: false
		},
		// political or locality
		city: {
			type: String,
			required: false
		},
		// administrative_area_level_2
		province: {
			type: String,
			required: false
		},
		// administrative_area_level_1
		region: {
			type: String,
			required: false
		},
		// route
		street: {
			type: String,
			required: false
		},
		streetIncludeNumber: {
			type: Boolean,
			required: false
		},
		// street_number
		streetNumber: {
			type: String,
			required: false
		},
		postCode: {
			type: String,
			required: false
		},
		formatted: {
			type: String,
			required: false
		}
		// street_address: down to an actual address
		// route: down to a street
	},
	template: "#n-form-location",
	data: function() {
		return {
			timer: null,
			place: null,
			sessionToken: null,
			resolvedType: null
		};
	},
	computed: {
		definition: function() {
			var definition = nabu.utils.vue.form.definition(this);
			if (this.type == "number") {
				definition.type = "number";
			}
			return definition;
		},
		mandatory: function() {
			return nabu.utils.vue.form.mandatory(this);
		}
	},
	created: function() {
		this.sessionToken = this.$services.geo.newSessionToken();
		
		// try to resolve an initial place
		var self = this;
		var geocoded = null;
		if (this.formatted && this.value[this.formatted]) {
			geocoded = this.$services.geo.geocode({
				address: this.value[this.formatted]
			});
		}
		else if (((this.country && this.value[this.country]) || (this.countryCode && this.value[this.countryCode])) && this.city && this.value[this.city]) {
			var address = "";
			if (this.country && this.value[this.country]) {
				address += this.value[this.country];
			}
			else if (this.countryCode && this.value[this.countryCode]) {
				address += this.value[this.countryCode];
			}
			if (this.city && this.value[this.city]) {
				address = this.value[this.city] + ", " + address;
			}
			if (this.street && this.value[this.street]) {
				var street = this.value[this.street];
				if (this.streetNumber && this.value[this.streetNumber]) {
					street += " " + this.value[this.streetNumber];
				}
				address = street + ", " + address;
			}
			geocoded = this.$services.geo.geocode({
				address: address
			});
		}
		else if (this.latitude && this.longitude && this.value[this.longitude] && this.value[this.latitude]) {
			geocoded = this.$services.geo.geocode({
				location: new google.maps.LatLng({ lat: parseFloat(this.value[this.latitude]), lng: parseFloat(this.value[this.longitude]) })
			});
		}
		if (geocoded != null) {
			geocoded.then(function(place) {
				if (place instanceof Array) {
					place = place[0];
				}
				place.description = place.formatted_address;
				self.place = place;
			});
		}
	},
	methods: {
		getPart: function(place, parts, short) {
			if (!(parts instanceof Array)) {
				parts = [parts];
			}
			var result = null;
			parts.forEach(function(part) {
				if (result == null) {
					result = place.address_components.filter(function(x) { return x.types.indexOf(part) >= 0})[0];
				}
			});
			return result ? (short ? result.short_name : result.long_name) : result;
		},
		validate: function(soft) {
			this.$refs.combo.messages.splice(0);
			var messages = nabu.utils.schema.json.validate(this.definition, this.resolvedType, this.mandatory);
			// only validate if we have resolved something, otherwise the required boolean will pick it up
			if (this.resolvedType) {
				if (!this.allowVague && this.resolvedType != "street_address") {
					messages.push({
						code: "vague",
						title: "%{validation::The address is not specific enough}",
						component: this,
						context: [],
						severity: "error",
						values: {
							expected: "street_address",
							actual: this.resolvedType
						}
					});
				}
			}
			var hardMessages = messages.filter(function(x) { return !x.soft });
			// if we are doing a soft validation and all messages were soft, set valid to unknown
			if (soft && hardMessages.length == 0 && messages.length > 0 && this.$refs.combo.valid == null) {
				this.$refs.combo.valid = null;
				// remove local messages
				this.messages.splice(0);
			}
			else {
				this.$refs.combo.valid = messages.length == 0;
				nabu.utils.arrays.merge(this.$refs.combo.messages, nabu.utils.vue.form.localMessages(this, messages));
			}
			return messages;
		},
		update: function(value) {
			if (this.$refs.combo) {
				this.$refs.combo.messages.splice(0);
				this.$refs.combo.valid = null;
			}
			var self = this;
			if (value && value.place_id) {
				var handler = function(place) {
					if (place instanceof Array) {
						place = place[0];
					}
					self.place = place;
					self.resolvedType = place.types[0];
					if (self.country) {
						self.value[self.country] = self.getPart(place, ["country"]);
					}
					if (self.countryCode) {
						self.value[self.countryCode] = self.getPart(place, ["country"], true);
					}
					if (self.province) {
						self.value[self.province] = self.getPart(place, ["administrative_area_level_2"]);
					}
					if (self.region) {
						self.value[self.region] = self.getPart(place, ["administrative_area_level_1"]);
					}
					if (self.city) {
						self.value[self.city] = self.getPart(place, ["sublocality", "locality"]);
					}
					if (self.postCode) {
						self.value[self.postCode] = self.getPart(place, ["postal_code"]);
					}
					if (self.street) {
						self.value[self.street] = self.getPart(place, ["route"]);
						if (self.streetIncludeNumber) {
							var number = self.getPart(place, "street_number");
							if (number != null && self.value[self.street] != null) {
								self.value[self.street] += " " + number;
							}
						}
					}
					if (self.streetNumber) {
						self.value[self.streetNumber] = self.getPart(place, ["street_number"]);
					}
					if (self.formatted) {
						self.value[self.formatted] = place.formatted_address;
					}
					if (self.latitude && place.geometry) {
						self.value[self.latitude] = place.geometry.location.lat instanceof Function ? place.geometry.location.lat() : place.geometry.location.lat;
					}
					if (self.longitude && place.geometry) {
						self.value[self.longitude] = place.geometry.location.lng instanceof Function ? place.geometry.location.lng() : place.geometry.location.lng;
					}
					self.$emit("label", self.formatPlace(place));
				};
				this.$services.geo.geocode({placeId: value.place_id}).then(handler, function() {
					if (value.description) {
						self.$services.geo.geocode({address: value.description }).then(handler);
					}
				});
			}
		},
		searchPlace: function(newValue) {
			if (newValue) {
				var promise = this.$services.q.defer();
				
				var parameters = {
					sessionToken: this.sessionToken
				};
				
				var restrictions = {};
				if (this.countryRestriction) {
					parameters.componentRestrictions = {
						country: this.countryRestriction.toUpperCase().split(",")
					}
				}
				var types = [];
				if (!this.allowVague) {
					types.push("address");
				}
				else {
					if (this.allowRegions) {
						types.push("regions");
					}
					if (this.allowCities) {
						types.push("cities");
					}
				}
				if (this.allowEstablishments) {
					types.push("establishment");
				}
				
				parameters.types = types;
				
				if (this.bias) {
					var parts = this.bias.split(";");
					var subparts = parts[0].split(",");
					parameters.location = new google.maps.LatLng({ lat: subparts[0], lng: subparts[1] })
					if (parts.length >= 2) {
						parameters.radius = parts[1];
					}
				}
				
				if (this.bounds) {
					var parts = this.bias.split(";");
					var subparts1 = parts[0].split(",");
					var subparts2 = parts[1].split(",");
					parameters.bounds = new google.maps.LatLngBounds(
						new google.maps.LatLng({ lat: subparts1[0], lng: subparts1[1] }),
						new google.maps.LatLng({ lat: subparts2[0], lng: subparts2[1] })
					);
				}
				
				return this.$services.geo.autocomplete(newValue, parameters);
			}
			else {
				return this.$services.q.resolve([]);
			}
		},
		formatPlace: function(place) {
			return place.formatted_address ? place.formatted_address : place.description;
		}
	}
});
Vue.component("n-form-address", {
	props: {
		value: {
			required: false
		},
		label: {
			type: String,
			required: false
		},
		// whether or not you are in edit mode
		edit: {
			type: Boolean,
			required: false,
			default: true
		},
		required: {
			type: Boolean,
			required: false,
			// explicitly set default value to null, otherwise vue will make it false which we can't distinguish from "not set"
			default: null
		},
		name: {
			type: String,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		// a json schema component stating the definition
		schemaResolver: {
			type: Function,
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		validator: {
			type: Function,
			required: false
		},
		timeout: {
			type: Number,
			required: false
		},
		// the two letter code of the country
		countryRestriction: {
			type: String,
			required: false
		},
		allowEstablishments: {
			type: Boolean,
			required: false
		},
		allowCities: {
			type: Boolean,
			required: false
		},
		allowRegions: {
			type: Boolean,
			required: false
		},
		// allow for vague addresses
		allowVague: {
			type: Boolean,
			required: false
		},
		allowStreet: {
			type: Boolean,
			required: false
		},
		// latBottomLeft,longBottomLeft;latTopRight,longTopRight
		bounds: {
			type: String,
			required: false
		},
		// lat,long;radiusInMeters
		bias: {
			type: String,
			required: false
		},
		
		// the fields
		// geometry.location.lat
		latitude: {
			type: String,
			required: false
		},
		// geometry.location.long
		longitude: {
			type: String,
			required: false
		},
		// country
		country: {
			type: String,
			required: false
		},
		// countryCode (2 letter ISO)
		countryCode: {
			type: String,
			required: false
		},
		countryLabel: {
			type: String,
			required: false
		},
		// political or locality
		city: {
			type: String,
			required: false
		},
		cityLabel: {
			type: String,
			required: false
		},
		// administrative_area_level_2
		province: {
			type: String,
			required: false
		},
		// administrative_area_level_1
		region: {
			type: String,
			required: false
		},
		// route
		street: {
			type: String,
			required: false
		},
		streetLabel: {
			type: String,
			required: false
		},
		// street_number
		streetNumber: {
			type: String,
			required: false
		},
		additional: {
			type: String,
			required: false
		},
		// street_number
		streetNumberLabel: {
			type: String,
			required: false
		},
		additionalLabel: {
			type: String,
			required: false
		},
		postCode: {
			type: String,
			required: false
		},
		postCodeLabel: {
			type: String,
			required: false
		},
		formatted: {
			type: String,
			required: false
		}
		// street_address: down to an actual address
		// route: down to a street
	},
	template: "#n-form-address",
	data: function() {
		return {
			timer: null,
			place: null,
			sessionToken: null,
			resolvedType: null,
			ready: false,
			postCodeFull: null
		};
	},
	computed: {
		definition: function() {
			var definition = nabu.utils.vue.form.definition(this);
			if (this.type == "number") {
				definition.type = "number";
			}
			return definition;
		},
		mandatory: function() {
			return nabu.utils.vue.form.mandatory(this);
		},
		countryField: function() {
			return this.country ? this.country : (this.countryCode ? '$country' : null);
		},
		formattedAddress: function() {
			var address = "";
			if (this.countryField && this.value[this.countryField]) {
				address += this.value[this.countryField];
			}
			else if (this.countryCode && this.value[this.countryCode]) {
				address += this.value[this.countryCode];
			}
			if (this.city && this.value[this.city] && this.postCode && this.value[this.postCode]) {
				if (address != "") {
					address = this.value[this.postCode] + " " + this.value[this.city] + ", " + address;
				}
				else {
					address = this.value[this.postCode] + " " + this.value[this.city]
				}
			}
			else if (this.city && this.value[this.city]) {
				if (address != "") {
					address = this.value[this.city] + ", " + address;
				}
				else {
					address = this.value[this.city];
				}
			}
			else if (!this.city && this.postCode && this.value[this.postCode]) {
				if (this.postCodeFull) {
					address = this.postCodeFull + (address ? ", " + address : "");
				}
				else {
					address = this.value[this.postCode] + ", " + address;
				}
			}
			if (this.street && this.value[this.street]) {
				var street = this.value[this.street];
				if (this.streetNumber && this.value[this.streetNumber]) {
					street += " " + this.value[this.streetNumber];
					if (this.additional && this.value[this.additional]) {
						street += " " + this.value[this.additional];
					}
				}
				address = street + ", " + address;
			}
			if (this.formatted) {
				Vue.set(this.value, this.formatted, address);
			}
			return address;
		},
		anyRequired: function() {
			if (this.schemaResolver) {
				if (this.country) {
					var result = this.schemaResolver(this.country);
					if (result && result.required) {
						return true;
					}
				}
				if (this.countryCode) {
					var result = this.schemaResolver(this.countryCode);
					if (result && result.required) {
						return true;
					}
				}
				if (this.city) {
					var result = this.schemaResolver(this.city);
					if (result && result.required) {
						return true;
					}
				}
				if (this.postCode) {
					var result = this.schemaResolver(this.postCode);
					if (result && result.required) {
						return true;
					}
				}
				if (this.province) {
					var result = this.schemaResolver(this.province);
					if (result && result.required) {
						return true;
					}
				}
				if (this.region) {
					var result = this.schemaResolver(this.region);
					if (result && result.required) {
						return true;
					}
				}
				if (this.street) {
					var result = this.schemaResolver(this.street);
					if (result && result.required) {
						return true;
					}
				}
				if (this.streetNumber) {
					var result = this.schemaResolver(this.streetNumber);
					if (result && result.required) {
						return true;
					}
				}
			}
			return false;
		}
	},
	created: function() {
		this.sessionToken = this.$services.geo.newSessionToken();
		
		// we need the full country name, even if you can't store it
		if (!this.country && this.countryCode) {
			// if you already have a value, we need to resolve it
			if (this.value[this.countryCode]) {
				var self = this;
				this.$services.geo.geocode({
					address: this.formattedAddress
				}).then(function(place) {
					if (place instanceof Array) {
						place = place[0];
					}
					Vue.set(self.value, self.countryField, self.getPart(place, ["country"]));
				});
			}
		}
	},
	ready: function() {
		// we can prefeed data, we don't want to trigger autocompletes on that
		this.ready = true;
	},
	methods: {
		getPart: function(place, parts, short) {
			if (!(parts instanceof Array)) {
				parts = [parts];
			}
			var result = null;
			parts.forEach(function(part) {
				if (result == null) {
					result = place.address_components.filter(function(x) { return x.types.indexOf(part) >= 0})[0];
				}
			});
			return result ? (short ? result.short_name : result.long_name) : result;
		},
		validate: function(soft) {
			var messages = nabu.utils.vue.form.validateChildren(this, soft);
			if (this.validator) {
				var additional = this.validator(this.value);
				if (additional && additional.length) {
					for (var i = 0; i < additional.length; i++) {
						Object.defineProperty(additional[i], 'component', {
							value: this,
							enumerable: false
						});
						if (typeof(additional[i].context) == "undefined") {
							additional[i].context = [];
						}
						messages.push(additional[i]);
					}
				}
			}
			return messages;
		},
		checkFullAddress: function() {
			// if we are interested in lat & long, we need to further resolve the address
			// this is only useful if we have a complete address
			var self = this;
			if (this.latitude || this.longitude || (this.countryCode && !this.value[this.countryCode])) {
				if ((self.country == null || self.value[self.country])
						&& (self.city == null || self.value[self.city])
						&& (self.postCode == null || self.value[self.postCode])
						&& (self.street == null || self.value[self.street])
						&& (self.streetNumber == null || self.value[self.streetNumber])) {
					this.$services.geo.geocode({
						address: this.formattedAddress
					}).then(function(place) {
						if (place instanceof Array) {
							place = place[0];
						}
						if (self.latitude && place.geometry) {
							self.value[self.latitude] = place.geometry.location.lat instanceof Function ? place.geometry.location.lat() : place.geometry.location.lat;
						}
						if (self.longitude && place.geometry) {
							self.value[self.longitude] = place.geometry.location.lng instanceof Function ? place.geometry.location.lng() : place.geometry.location.lng;
						}
						if (self.countryCode) {
							self.value[self.countryCode] = self.getPart(place, ["country"], true);
						}
					});
				}
			}
		},
		updateCountry: function(country, ignoreEmit) {
			this.updateCity(null, true);
			Vue.set(this.value, this.countryField, this.formatAutocomplete('country', country));
			
			if (this.countryCode) {
				Vue.set(this.value, this.countryCode, null);
				if (this.countryRestriction) {
					var parts = this.countryRestriction.split(/[\s]*,[\s]*/);
					if (parts.length == 1 && parts[0].trim().length != 0) {
						Vue.set(this.value, this.countryCode, parts[0].trim());
					}
				}
			}
			this.$emit("changed");
			
			var self = this;
			// likely disabled!
			Vue.nextTick(function() {
				if (country) {
					if (self.city) {
						self.$refs.city.$el.querySelector("input").focus();
					}
					else if (self.postCode) {
						self.$refs.postCode.$el.querySelector("input").focus();
					}
					else if (self.street) {
						self.$refs.street.$el.querySelector("input").focus();
					}
				}
			});
			this.checkFullAddress();
		},
		updateCity: function(city, ignoreEmit) {
			this.updatePostCode(null, true);
			Vue.set(this.value, this.city, this.formatAutocomplete('city', city));
			if (!ignoreEmit) {
				this.$emit("changed");
			}
			var self = this;
			Vue.nextTick(function() {
				if (city) {
					if (self.postCode) {
						self.$refs.postCode.$el.querySelector("input").focus();
					}
					else if (self.street) {
						self.$refs.street.$el.querySelector("input").focus();
					}
				}
			});
			this.checkFullAddress();
		},
		updatePostCode: function(postCode, ignoreEmit) {
			this.updateStreet(null, true);
			Vue.set(this.value, this.postCode, this.formatAutocomplete('postCode', postCode));
			if (!ignoreEmit) {
				this.$emit("changed");
			}
			var self = this;
			Vue.nextTick(function() {
				if (postCode) {
					if (self.street) {
						self.$refs.street.$el.querySelector("input").focus();
					}
				}
			});
			this.checkFullAddress();
		},
		updateStreet: function(street, ignoreEmit) {
			this.updateStreetNumber(null, true);
			Vue.set(this.value, this.street, this.formatAutocomplete('street', street));
			if (!ignoreEmit) {
				this.$emit("changed");
			}
			var self = this;
			Vue.nextTick(function() {
				if (street) {
					if (self.streetNumber) {
						self.$refs.streetNumber.$el.querySelector("input").focus();
					}
				}
			});
			this.checkFullAddress();
		},
		updateStreetNumber: function(streetNumber, ignoreEmit) {
			Vue.set(this.value, this.streetNumber, this.formatAutocomplete('streetNumber', streetNumber));
			if (!ignoreEmit) {
				this.$emit("changed");
			}
			this.checkFullAddress();
		},
		updateAdditional: function(additional, ignoreEmit) {
			Vue.set(this.value, this.additional, this.formatAutocomplete('additional', additional));
			if (!ignoreEmit) {
				this.$emit("changed");
			}
			this.checkFullAddress();
		},
		searchField: function(field, newValue) {
			// don't do searches for initial data, it is presumed correct from previous entry
			// if necessary, we can make this toggleable
			if (!this.ready) {
				return newValue ? [newValue] : [];
			}
			var promise = this.$services.q.defer();
			var address = "";
			var types = []
			if (field == "country") {
				types.push("(regions)");
			}
			else if (field == "city") {
				types.push("(cities)");
			}
			else if (field == "postCode") {
				types.push("(regions)");
			}
			else if (field == "street") {
				types.push("address");
			}
			else if (field == "streetNumber") {
				types.push("address");
			}
			// if we have a country field, that should always be filled in
			if (this.countryField) {
				address = field == "country" ? newValue : this.value[this.countryField];
			}
			else if (this.countryRestriction) {
				address = this.countryRestriction;
			}
			if (field != "country") {
				if (this.city && (field == "city" || this.value[this.city])) {
					var city = field == "city" ? newValue : this.value[this.city];
					if (field != "city" && this.postCode && (field == "postCode" || this.value[this.postCode])) {
						city = city + " " + (field == "postCode" ? newValue : this.value[this.postCode]);
					}
					address += ", " + city;
				}
				else if (!this.city && this.postCode && (field == "postCode" || this.value[this.postCode])) {
					address += ", " + (field == "postCode" ? newValue : this.value[this.postCode]);
				}
				if (field != "city" && field != "postCode") {
					if (this.street && (field == "street" || this.value[this.street])) {
						var street = field == "street" ? newValue : this.value[this.street];
						if (field != "street" && this.streetNumber && (field == "streetNumber" || this.value[this.streetNumber])) {
							street += " " + (field == "streetNumber" ? newValue : this.value[this.streetNumber]);
						}
						address += ", " + street;
					}
				}
			}
			var self = this;
			this.searchPlace(address, types).then(function(resolved) {
				promise.resolve(resolved.filter(function(place) {
					if (field == "country") {
						return place.types.indexOf(field) >= 0;
					}
					else if (field == "city") {
						return place.types.indexOf("locality") >= 0 || place.types.indexOf("city") >= 0 || place.types.indexOf("sublocality") >= 0;
					}
					else if (field == "postCode") {
						// we assume it contains _some_ number at least
						// otherwise you can get weird suggestions, for example we had country "frankrijk", city "nully", postcode suggestion "saint-cyr"
						// this is because we have to take locality & sublocality into account, otherwise we can't resolve the 2100 postcode for deurne (belgie)
						if (!self.formatAutocomplete("postCode", place).match(/.*[0-9]+.*/)) {
							return false;
						}
						return place.types.indexOf("postal_code") >= 0 || place.types.indexOf("locality") >= 0 || place.types.indexOf("sublocality") >= 0;
					}
					else if (field == "streetNumber") {
						return place.types.indexOf("address") >= 0;
					}
					return true;
				}));
			}, promise);
			return promise;
		},
		searchPlace: function(newValue, types) {
			if (newValue) {
				var promise = this.$services.q.defer();
				
				var parameters = {
					sessionToken: this.sessionToken
				};
				
				var restrictions = {};
				if (this.countryRestriction) {
					parameters.componentRestrictions = {
						country: this.countryRestriction.toUpperCase().split(",")
					}
				}
				parameters.types = types;
				
				if (this.bias) {
					var parts = this.bias.split(";");
					var subparts = parts[0].split(",");
					parameters.location = new google.maps.LatLng({ lat: subparts[0], lng: subparts[1] })
					if (parts.length >= 2) {
						parameters.radius = parts[1];
					}
				}
				
				if (this.bounds) {
					var parts = this.bias.split(";");
					var subparts1 = parts[0].split(",");
					var subparts2 = parts[1].split(",");
					parameters.bounds = new google.maps.LatLngBounds(
						new google.maps.LatLng({ lat: subparts1[0], lng: subparts1[1] }),
						new google.maps.LatLng({ lat: subparts2[0], lng: subparts2[1] })
					);
				}
				return this.$services.geo.autocomplete(newValue, parameters);
			}
			else {
				return this.$services.q.resolve([]);
			}
		},
		formatPlace: function(place) {
			return place.formatted_address ? place.formatted_address : place.description;
		},
		formatAutocomplete: function(field, place, offset) {
			if (!offset) {
				offset = 0;
			}
			if (!place) {
				return null;
			}
			else if (typeof(place) == "string") {
				return place;
			}
			var appendCity = false;
			if (field == "postCodeFull") {
				appendCity = true;
				field = "postCode";
			}
			var self = this;
			// they tend to repeat terms in random order (perhaps depending on the type?)
			var result = place.terms.filter(function(term) {
				var term = term.value;
				if (field == "country") {
					return true;
				}
				else if (field == "city") {
					return self.country == null || term != self.value[self.countryField];
				}
				else if (field == "postCode") {
					return (self.country == null || term != self.value[self.countryField])
						&& (self.city == null || term != self.value[self.city]);
				}
				else if (field == "street") {
					return (self.country == null || term != self.value[self.countryField])
						&& (self.city == null || term != self.value[self.city])
						&& (self.postCode == null || term != self.value[self.postCode]);
				}
				else if (field == "streetNumber") {
					return (self.country == null || term != self.value[self.countryField])
						&& (self.city == null || term != self.value[self.city])
						&& (self.postCode == null || term != self.value[self.postCode])
						&& (self.street == null || term != self.value[self.street]);
				}
			})[offset].value;
			// the postcode might return "Deurne, 2100"
			//var parts = place.structured_formatting.main_text.split(",");
			//var result = parts[parts.length - 1];
			// if we have a postcode but no city visible, let's add the city by default (in the future via config)
			if (appendCity && field == "postCode" && !this.city) {
				var city = this.formatAutocomplete("city", place, 1);
				if (city) {
					result += ", " + city;
					this.postCodeFull = result;
				}
			}
			return result;
		}
	}
});


Vue.component("n-form", {
	props: {
		// a json schema component stating the definition
		schema: {
			type: Object,
			required: false
		},
		mode: {
			type: String,
			required: false
		},
		// alternative code mappings for validations
		codes: {
			type: Object,
			required: false
		},
		// something that can be passed to :class
		contentClass: {
			required: false
		}
	},
	template: "#n-form",
	computed: {
		definition: function() {
			return nabu.utils.vue.form.definition(this);
		},
		mandatory: function() {
			return nabu.utils.vue.form.mandatory(this);
		}
	},
	methods: {
		validate: function(soft) {
			var messages = nabu.utils.vue.form.validateChildren(this, soft);
			var self = this;
			var map = function(validations) {
				if (self.codes) {
					validations.forEach(function(x) {
						if (x.code && self.codes[x.code]) {
							Vue.set(x, "title", self.codes[x.code]);
						}
					});
				}
			}
			map(messages);
			if (messages.then) {
				messages.then(function() {
					map(messages);
				})
			}
			return messages;
		}
	}
});

Vue.component("n-form-table", {
	props: {
		// a json schema component stating the definition
		schema: {
			type: Object,
			required: false
		},
		mode: {
			type: String,
			required: false
		}
	},
	template: "#n-form-table",
	data: function() {
		return {
			labels: [],
			hasContent: false
		}
	},
	computed: {
		definition: function() {
			return nabu.utils.vue.form.definition(this);
		},
		mandatory: function() {
			return nabu.utils.vue.form.mandatory(this);
		}
	},
	methods: {
		validate: function(soft) {
			return nabu.utils.vue.form.validateChildren(this, soft);
		}
	},
	events: {
		'$vue.child.added': function(child) {
			if (child.labels) {
				this.labels.splice(0, this.labels.length);
				nabu.utils.arrays.merge(this.labels, child.labels);
			}
			this.hasContent = !!this.labels.length;
		}
	}
});
if (!nabu) { var nabu = {}; }
if (!nabu.utils) { nabu.utils = {}; }
if (!nabu.utils.vue) { nabu.utils.vue = {}; }

nabu.utils.vue.form = {
	definition: function(component) {
		// take the original schema (if any)
		var schema = component.schema ? nabu.utils.objects.clone(component.schema) : null;
		// check if we can find the definition in the parent component
		if (!schema && component.name && component.$parent && component.$parent.definition && component.$parent.definition.properties) {
			schema = component.$parent.definition.properties[component.name];
		}
		if (!schema) {
			schema = {};
		}
		// bind in the additional keys
		var keys = ["minLength", "maxLength", "pattern", "patternComment", "maxItems", "minItems", "maximum", "minimum", "exclusiveMaximum", "exclusiveMinimum", "enum"];
		for (var i = 0; i < keys.length; i++) {
			if (component[keys[i]] != null) {
				schema[keys[i]] = component[keys[i]];
			}
		}
		return schema;
	},
	rewriteCodes: function(messages, codes) {
		if (codes instanceof Array) {
			var result = {};
			codes.forEach(function(x) {
				if (x.code) {
					result[x.code] = x;
				}
			});
			codes = result;
		}
		if (messages && messages.length && codes) {
			messages.forEach(function(x) {
				if (x.code) {
					// suppose you have a code "required" on a field "sessionSchedule[0].start"
					// by default we will translate the code "required" into "must exist" or something
					// however, in some cases you may want to have a more specific code for the start or for everything in sessionschedule
					// in that case, we use the context which is reverse sorted, so it would be "start, 0, sessionSchedule" in this example
					// we want to check for "sessionSchedule.start.required", then "sessionSchedule.required", only then "required"
					var codeToUse = null;
					if (x.context instanceof Array) {
						var contextToCheck = "";
						for (var i = x.context.length - 1; i >= 0; i--) {
							// cast to string and see if it is a number
							if (("" + x.context[i]).match(/^[0-9]+$/)) {
								continue;
							}
							if (contextToCheck != "") {
								contextToCheck += ".";
							}
							contextToCheck += x.context[i];
							// we only make it more specific as we go, so if get more specific matches, we use it
							if (codes[contextToCheck + "." + x.code]) {
								codeToUse = codes[contextToCheck + "." + x.code];
							}
						}
					}
					if (codeToUse == null) {
						codeToUse = codes[x.code];
					}
					if (codeToUse) {
						if (typeof(codeToUse) == "string") {
							x.title = codeToUse;
							x.title = nabu.utils.vue.form.replaceVariables(x.title, x);
						}
						else {
							Object.keys(codeToUse).forEach(function(key) {
								x[key] = codeToUse[key];
								x[key] = nabu.utils.vue.form.replaceVariables(x[key], x);
							});
						}
					}
				}
			});
		}
	},
	replaceVariables: function(template, variables) {
		if (variables) {
			Object.keys(variables).forEach(function(x) {
				template = template.replace(new RegExp("\\{[\\s]*" + x + "[\\s]*\\}", "g"), variables[x]);
			});
		}
		return template;
	},
	mandatory: function(component) {
		var required = component.required;
		if (required == null && component.name && component.$parent && component.$parent.definition) {
			required = component.$parent.definition.required && component.$parent.definition.required.indexOf(component.name) >= 0;
		}
		if (required == null && component.definition && component.definition.required) {
			required = true;
		}
		if (required == null) {
			required = false;
		}
		return required;
	},
	labels: function(component) {
		var labels = [];
		if (component.$children) {
			for (var i = 0; i < component.$children.length; i++) {
				if (component.$children[i].label) {
					labels.push(component.$children[i].label);
				}
			}
			// if there were no labels, ask the children
			if (!labels.length) {
				for (var i = 0; i < component.$children.length; i++) {
					if (component.$children[i].labels) {
						nabu.utils.arrays.merge(labels, component.$children[i].labels);
					}
					if (labels.length) {
						break;
					}
				}
			}
		}
		return labels.length ? labels : null;
	},
	mode: function(component) {
		// base it on html elements rather than $parent chains
		// the $parent chains are not always to be trusted to get to the right component
		var element = component.$el;
		while (element && element.getAttribute) {
			if (element.getAttribute("mode")) {
				return element.getAttribute("mode");
			}
			element = element.parentNode;
		}
		while (component) {
			if (component.mode) {
				return component.mode;
			}
			component = component.$parent;
		}
		return null;
	},
	localMessages: function(component, messages) {
		var localMessages = [];
		if (!messages || !messages.length) {
			return localMessages;
		}
		var mode = nabu.utils.vue.form.mode(component);
		messages.sort(function(a, b) {
			var priorityA = typeof(a.priority) != "undefined" ? a.priority : 0;
			var priorityB = typeof(b.priority) != "undefined" ? b.priority : 0;
			return priorityA - priorityB;
		});
		var handled = false;
		if (mode == "component") {
			localMessages.push(messages[0]);
			handled = true;
		}
		else if (component.mode != null) {
			var amount = parseInt(component.mode);
			if (amount == 0) {
				amount = messages.length;
			}
			else {
				amount = Math.min(amount, messages.length);
			}
			nabu.utils.arrays.merge(localMessages, messages.slice(0, amount));
			handled = true;
		}
		if (handled == true) {
			messages.forEach(function(x) { x.handled = true });
		}
		return localMessages;
	},
	validateChildren: function(component, soft) {
		var wrap = function(promise) {
			var newPromise = new nabu.utils.promise();
			promise.then(newPromise, newPromise);
			return newPromise;
		};
		var messages = nabu.utils.schema.addAsyncValidation([]);
		for (var i = 0; i < component.$children.length; i++) {
			if (component.$children[i].validate) {
				var childMessages = component.$children[i].validate(soft);
				if (component.$children[i].name) {
					for (var j = 0; j < childMessages.length; j++) {
						if (childMessages[j].context instanceof Array) {
							childMessages[j].context.push(component.$children[i].name);
						}
					}
				}
				nabu.utils.arrays.merge(messages, childMessages);
				if (childMessages && childMessages.then) {
					messages.defer(wrap(childMessages));
				}
			}
			// recurse over non-form components, they might be structural and secretly contain other form elements
			else {
				var childMessages = nabu.utils.vue.form.validateChildren(component.$children[i], soft);
				nabu.utils.arrays.merge(messages, childMessages);
				if (childMessages && childMessages.then) {
					messages.defer(wrap(childMessages));
				}
			}
		}
		return messages;
	},
	validateCustom: function(messages, valueToValidate, validator, context) {
		// allow for custom validation
		if (validator != null) {
			var additional = validator(valueToValidate);
			// we can send back asynchronous validations
			if (additional != null && additional.then) {
				messages.defer(additional);
			}
			// or an array of validations
			else if (additional != null && additional.length) {
				for (var i = 0; i < additional.length; i++) {
					Object.defineProperty(additional[i], 'component', {
						value: context,
						enumerable: false
					});
					if (typeof(additional[i].context) == "undefined") {
						additional[i].context = [];
					}
					messages.push(additional[i]);
				}
			}
		}
		return messages;
	}
}


if (!nabu) { var nabu = {}; }
if (!nabu.components) { nabu.components = {}; }

nabu.components.secret = Vue.component("n-secret", {
	props: {
		content: {
			type: String,
			required: true
		}
	},
	template: "#n-secret",
	data: function () {
		return {
			show: false
		}
	},
	computed: {
		secretContent: function() {
			return this.content.replace(/./g, "*");
		}
	}
});
// parameter: arbitraryStepSelection: can click on any step in the wizard to jump back to there
// state preservation is an external concern

if (!nabu) { var nabu = {}; }
if (!nabu.components) { nabu.components = {}; }

nabu.components.wizard = Vue.component("n-wizard", {
	props: {
		// each step should have:
		// - name: this will be the displayed name for the step
		// - content: the content to be shown, if it is a function it will be executed and the returned value will be shown
		steps: {
			type: Array,
			required: true
		},
		// an initial step (if any), otherwise the first step will be used
		initial: {
			type: Object,
			required: false
		},
		number: {
			type: Boolean,
			required: false
		},
		// whether or not the "next" should loop around to the first step
		loop: {
			type: Boolean,
			required: false
		},
		// whether or not the top buttons are interactive
		browse: {
			type: Boolean,
			required: false
		},
		loader: {
			type: Function,
			required: false
		}
	},
	template: "#n-wizard",
	data: function () {
		return {
			current: null
		}
	},
	ready: function() {
		this.current = this.initial ? this.initial : this.steps[0];
	},
	methods: {
		hasNext: function() {
			var index = this.steps.indexOf(this.current);
			if (index < this.steps.length - 1) {
				return !this.steps[index + 1].disabled;
			}
			return false;
		},
		hasPrevious: function() {
			var index = this.steps.indexOf(this.current);
			if (index > 0) {
				return !this.steps[index - 1].disabled;
			}
			return false;
		},
		next: function() {
			// it could be that for some reason your step is not in the list, could be you have a special first step
			// or that you updated the step list on the go
			// at this point this will be 0 so works out nicely
			var index = this.steps.indexOf(this.current) + 1;
			// if we went too far, go back
			if (index >= this.steps.length) {
				if (this.loop) {
					index = 0;
				}
				else {
					return this.current;
				}
			}
			this.current = this.steps[index];
			return this.current;
		},
		previous: function() {
			var index = this.steps.indexOf(this.current);
			// the current step was not in the steps, go to 0
			if (index < 0) {
				index = 0;
			}
			else {
				index--;
				if (index < 0) {
					if (this.loop) {
						index = this.steps.length - 1;
					}
					else {
						return this.current;
					}
				}
			}
			this.current = this.steps[index];
			return this.current;
		}
	},
	watch: {
		current: function(newValue) {
			if (newValue && newValue.content && this.$refs.container) {
				this.$render({
					target: this.$refs.container, 
					content: newValue.content,
					loader: this.loader
				});
			}
		}
	}
});
if (!nabu) { var nabu = {}; }
if (!nabu.components) { nabu.components = {}; }

nabu.components.collapsible = Vue.component("n-collapsible", {
	props: {
		title: {
			type: String,
			required: true
		},
		load: {
			type: Function,
			required: false
		},
		before: {
			type: String,
			required: false
		},
		after: {
			type: String,
			required: false
		},
		startOpen: {
			type: Boolean,
			required: false
		},
		onlyOneOpen: {
			type: Boolean,
			required: false
		},
		contentClass: {
			type: String,
			required: false
		}
	},
	template: "#n-collapsible",
	data: function () {
		return {
			show: false,
			loading: false,
			toggleable: true
		}
	},
	created: function() {
		if (this.startOpen) {
			this.show = true;
		}
	},
	methods: {
		toggle: function() {
			var self = this;
			var closeRest = function() {
				if (self.onlyOneOpen) {
					self.$parent.$children.forEach(function(child) {
						if (child.toggle && child.$el.classList.contains("is-collapsible"))	{
							if (child.show) {
								child.toggle();
							}
						}
					});
				}
			}
			if (this.toggleable) {
				if (!this.show) {
					if (this.load) {
						this.loading = true;
						var self = this;
						this.load().then(function() {
							closeRest();
							self.show = true;
							self.loading = false;
							self.$emit("show", self);
						}, function() {
							self.show = false;
							self.loading = false;
							self.$emit("hide", self);
						});
					}
					else {
						closeRest();
						this.show = true;
						this.$emit("show", this);
					}
				}
				else {
					this.show = false;
					this.$emit("hide", this);
				}
			}
		}
	}
});

Vue.component("n-menu-dropdown", {
	props: {
		actions: {
			types: Array,
			required: true
		}
	},
	template: "#n-menu-dropdown",
	data: function() {
		return {
			showing: []
		}
	},
	methods: {
		handle: function(action) {
			if (action.handler) {
				// we pass in the action again so you can add structural parameters to it
				action.handler(action);
			}
		},
		hide: function(action) {
			var index = this.showing.indexOf(action);
			if (index >= 0) {
				this.showing.splice(index, 1);
			}
		},
		show: function(action) {
			if (this.showing.indexOf(action) < 0) {
				this.showing.push(action);
			}
		}
	}
});
Vue.component("e-root", {
	props: {
		inlineAll: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	template: "<!--mailroot--><table class=\"body\"><tr><td class=\"float-center\" align=\"center\" valign=\"top\"><center><slot></slot></center></td></tr></table><!--/mailroot-->",
	ready: function() {
		/*var link = document.createElement("link");
		link.setAttribute("rel", "stylesheet");
		link.setAttribute("type", "text/css");
		link.setAttribute("href", "https://cdnjs.cloudflare.com/ajax/libs/foundation-emails/2.2.1/foundation-emails.css");
		document.head.appendChild(link);*/
		
		// the document.body is NOT up to date when the ready is run (presumably nexttick is called before dom update??)
		// this means if we inline right now, we will be inlining stale content
		//this.inlineCss();
		// instead we inline with a tiny timeout
		setTimeout(this.inlineCss,1);
		/*var self = this;
		setTimeout(function () {
			self.inlineCss();
		}, 100);
		*/
	},
	methods: {
		inlineCss: function() {
			// list of css properties is retrieved from the foundation css
			nabu.utils.elements.inlineCss(this.$el, true, this.inlineAll ? null : "email");
		}
	}
});

Vue.component("e-wrapper", {
	template: "<table class=\"wrapper\" align=\"center\"><tr><td class=\"wrapper-inner\"><slot></slot></td></tr></table>"
});

Vue.component("e-container", {
	template: "<table class=\"container\"><tbody><tr><td><slot></slot></td></tr></tbody></table>"
});

Vue.component("e-row", {
	template: "<table class=\"row\"><tbody><tr><slot></slot></tr></tbody></table>"
});

Vue.component("e-columns", {
	props: {
		small: {
			type: String,
			required: false
		},
		large: {
			type: String,
			required: false
		}
	},
	computed: {
		clazz: function() {
			var clazz = "";
			if (this.small) {
				clazz += " small-" + this.small;
			}
			if (this.large) {
				clazz += " large-" + this.large;
			}
			return clazz;
		}
	},
	template: "<th class=\"columns\" :class=\"clazz\"><table><tr><th><slot></slot></th><th class=\"expander\"></th></tr></table></th>"
});

Vue.component("e-button", {
	props: {
		href: {
			type: String,
			required: true
		}
	},
	template: "<table class=\"button\"><tr><td><table><tr><td><a :href=\"href\"><slot></slot></a></td></tr></table></td></tr></table>"
});

Vue.component("e-menu", {
	template: "<table class=\"menu\"><tr><td><table><tr><slot></slot></tr></table></td></tr></table>"
});

Vue.component("e-item", {
	props: {
		href: {
			type: String,
			required: true
		}
	},
	template: "<th class=\"menu-item\"><a :href=\"href\"><slot></slot></a></th>"
});

Vue.component("e-spacer", {
	template: "<table class=\"spacer\"><tbody><tr><td height=\"35px\" style=\"font-size:35px;line-height:35px;\">&#xA0;</td></tr></tbody></table>"
});

Vue.component("e-callout", {
	template: "<table class=\"callout\"><tr><th class=\"callout-inner\"><slot></slot></th><th class=\"expander\"></th></tr></table>"
});

Vue.component("n-button", {
	template: "#n-button",
	props: {
		icon: {
			type: String,
			required: false
		},
		text: {
			type: String,
			required: false
		},
		type: {
			type: String,
			required: false
		}
	}
});
Vue.component("n-windowing", {
	props: {
		value: {
			type: Number,
			required: false,
			default: 0
		},
		hasNext: {
			type: Boolean,
			required: false,
			default: false
		},
		load: {
			type: Function,
			required :false
		},
		// whether or not to perform an initial load
		initialize: {
			type: Boolean,
			required: false,
			default: true
		}
	},
	template: "#n-windowing",
	data: function() {
		return {
			loading: false,
			page: 0
		}
	},
	mounted: function() {
		this.page = this.value;
		if (this.load && this.initialize) {
			this.load(this.page);
		}
	},
	methods: {
		update: function(page) {
			if (this.load) {
				var self = this;
				self.loading = true;
				this.load(page).then(function() {
					self.$emit("input", page);
					self.page = page;
					self.loading = false;
				}, function() {
					self.loading = false;
				});
			}
			else {
				this.page = page;
			}
		},
		set: function(page) {
			this.page = page;
		}
	},
	watch: {
		value: function(newValue) {
			this.page = newValue;
		}
	}
});
Vue.component("n-sidebar", {
	template: "#n-sidebar",
	props: {
		popout: {
			type: Boolean,
			required: false,
			default: false
		},
		autocloseable: {
			type: Boolean,
			required: false,
			default: true
		},
		inline: {
			type: Boolean,
			required: false,
			default: false
		},
		position: {
			type: String,
			required: false,
			default: "right"
		}
	},
	ready: function() {
		this.closeOther();
		var position = this.position == "left" ? "left" : "right";
		if (this.popout) {
			this.$el.setAttribute("id", "n-sidebar-" + position + "-instance");
			this.parentNode = this.$el.parentNode;
			if (this.$root.$el != this.parentNode) {
				this.$root.$el.appendChild(this.$el);
			}
		}
		if (this.inline) {
			document.body.setAttribute("has-sidebar-" + position, "true");
		}
		this.$el.$$close = this.close;
	},
	beforeDestroy: function() {
		if (this.inline) {
			if (this.position == "left") {
				document.body.removeAttribute("has-sidebar-left");
			}
			else {
				document.body.removeAttribute("has-sidebar-right");
			}
		}
	},
	methods: {
		closeOther: function() {
			var position = this.position == "left" ? "left" : "right";
			// by default we just want one open, or they would pop over each other
			//var existing = document.querySelectorAll("#n-sidebar-" + position + "-instance");
			var existing = document.querySelectorAll(".n-sidebar." + position);
			var self = this;
			existing.forEach(function(x) {
				if (x != self.$el) {
					x.$$close();
				}
			});
		},
		close: function(explicit) {
			if (this.inline) {
				if (this.position == "left") {
					document.body.removeAttribute("has-sidebar-left");
				}
				else {
					document.body.removeAttribute("has-sidebar-right");
				}
			}
			if (this.popout) {
				if (this.parentNode && this.$el.parentNode != this.parentNode) {
					this.parentNode.appendChild(this.$el);
				}
			}
			this.$emit('close', {explicit: explicit});
		},
		autoClose: function() {
			if (this.autocloseable) {
				this.close();
			}
		}
	}
});

Vue.component("n-messages", {
	props: {
		messages: {
			type: Array,
			required: true
		}
	},
	template: "#n-messages",
	methods: {
		format: function(text, values, context) {
			if (context) {
				for (var i = 0; i < context.length; i++) {
					text = text.replace("{context[" + i + "]}", context[i]);
				}
			}
			if (values) {
				for (var key in values) {
					var value = values[key];
					if (this.$services && this.$services.formatter && this.$services.formatter.number) {
						if (typeof(value) == "string" && value.match && value.match(/^[0-9.]+/)) {
							value = Number(value);
						}
						if (value instanceof Number || typeof(value) == "number") {
							value = this.$services.formatter.number(value);
						}
					}
					text = text.replace("{" + key + "}", value);
				}
			}
			return text;
		},
		highlight: function(message) {
			if (message.component && message.component.$el) {
				message.component.$el.setAttribute("highlight", "true");
			}
		},
		unhighlight: function(message) {
			if (message.component && message.component.$el) {
				message.component.$el.removeAttribute("highlight");
			}
		}
	}
});

Vue.component("n-paging", {
	props: {
		value: {
			type: Number,
			required: false,
			default: 0
		},
		amount: {
			type: Number,
			required: false,
			default: 7
		},
		total: {
			type: Number,
			required: false,
			default: 1
		},
		load: {
			type: Function,
			required :false
		},
		arrows: {
			type: Boolean,
			required: false,
			default: false
		},
		// whether or not to perform an initial load
		initialize: {
			type: Boolean,
			required: false,
			default: true
		},
		buttonClasses: {
			type: Array,
			required: false
		},
		formClasses: {
			type: Array,
			required: false,
			default: function() {
				return "is-color-background is-spacing-large is-shadow-xsmall is-variant-vertical".split(" ");
			}
		},
		showEmpty: {
			type: Boolean,
			required: false
		}
	},
	template: "#n-paging",
	data: function() {
		return {
			loading: false,
			page: 0
		}
	},
	mounted: function() {
		this.page = this.value;
		if (this.load && this.initialize) {
			this.load(this.page);
		}
	},
	computed: {
		buttons: function() {
			var buttons = [];
			// we substract the current page and the inevitable first and last entries
			var surrounding = (this.amount - 2 - 1) / 2;
			if (this.page >= surrounding) {
				buttons.push(1);
				if (surrounding > 2 && this.page > surrounding) {
					buttons.push(2);
				}
				if (this.page >= surrounding + 1) {
					buttons.push(null);
				}
			}
			for (var i = Math.max(this.page - surrounding + 1, 0); i < Math.min(this.page + surrounding, this.total); i++) {
				buttons.push(i + 1);
			}
			if (this.page + surrounding < this.total) {
				if (this.page < this.total - surrounding - 1) {
					buttons.push(null);
				}
				if (surrounding > 2 && this.page < this.total - surrounding - 1) {
					buttons.push(this.total - 1);
				}
				buttons.push(this.total);
			}
			// at least push the first one if we want _something_
			if (buttons.length == 0 && this.showEmpty) {
				buttons.push(1);
			}
			return buttons;
		}
	},
	methods: {
		update: function(page) {
			this.$emit("input", page);
			if (this.load) {
				var self = this;
				self.loading = true;
				this.load(page).then(function() {
					self.page = page;
					self.loading = false;
				}, function() {
					self.loading = false;
				});
			}
			else {
				this.page = page;
			}
		},
		set: function(page) {
			this.page = page;
		},
		promptPage: function() {
			var self = this;
			this.$prompt(function() {
				var component = Vue.extend({ template: "#n-paging-prompt" });
				return new component({data: { page: null, formClasses: self.formClasses }});
			}).then(function(page) {
				page = parseInt(page) - 1;
				page = Math.max(0, page);
				page = Math.min(self.total, page);
				self.update(page);
			});
		}
	},
	watch: {
		value: function(newValue) {
			this.page = newValue;
		}
	}
});
Vue.component("n-info", {
	props: {
		autoClose: {
			type: Boolean,
			required: false,
			default: true
		},
		icon: {
			type: String,
			required: false,
			default: "info-circle"
		}
	},
	template: "#n-info",
	data: function() {
		return {
			showing: false
		}
	}
});
Vue.component("n-tags", {
	props: {
		tags: {
			type: Array,
			required: true
		},
		formatter: {
			type: Function,
			required: false
		},
		removable: {
			type: Boolean,
			required: false
		}
	},
	template: "#n-tags",
	methods: {
		remove: function(tag) {
			this.$emit("remove", this.tags.splice(this.tags.indexOf(tag), 1));
		},
		format: function(tag) {
			return this.formatter ? this.formatter(tag) : tag;
		}
	}
});
// need to import the following url: https://maps.googleapis.com/maps/api/js?key=<apikey>&libraries=places&callback=application.services.geo.initialize
Vue.service("geo", {
	data: function() {
		return {
			geocoder: null,
			autocompleter: null,
			placer: null
		}
	},
	methods: {
		initialize: function() {
			console.log("initializing geo");	
		},
		// must provide at least
		// - address: a string name to geocode
		// - location: a LatLng object
		// - placeId: a place id
		geocode: function(parameters) {
			if (!this.geocoder) {
				this.geocoder = new google.maps.Geocoder();
			}

			var promise = this.$services.q.defer();
			this.geocoder.geocode(parameters, function (results, status) {
				if (status === "OK") {
					promise.resolve(results);
				}
				else {
					promise.reject(status);
				}
			});
			return promise;
		},
		// the language is the one set in the browser, there seems to be no way to modify this language here
		// it is possible (but not validated) that you can set the language in the initial google script include as a query parameter
		autocomplete: function(input, parameters) {
			if (!this.autocompleter) {
				this.autocompleter = new google.maps.places.AutocompleteService();
			}
			if (!parameters) {
				parameters = {};
			}
			parameters.input = input;
			
			if (!parameters.sessionToken) {
				parameters.sessionToken = this.newSessionToken();
			}
			
			var promise = this.$services.q.defer();
			this.autocompleter.getPlacePredictions(parameters, function(results, status) {
				if (status === google.maps.places.PlacesServiceStatus.OK) {
					promise.resolve(results);
				}
				else {
					promise.reject(status);
				}
			});
			return promise;
		},
		newSessionToken: function() {
			return new google.maps.places.AutocompleteSessionToken();
		}
	}
});
window.addEventListener("load", function() {
	Vue.component("icon", {
		template: "<span class='is-icon fa' :class=\"'fa-' + name\"/>",
		props: {
			name: {
				type: String,
				required: true
			}
		}
	});
});
Vue.component("n-form-image-uploader-configure", {
	template: "#n-form-image-uploader-configure",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		},
		childComponents: {
			type: Object,
			required: false
		}
	}
});
Vue.component("n-form-image-uploader", {
	template: "#n-form-image-uploader",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		parentValue: {
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		edit: {
			type: Boolean,
			required: false
		},
		name: {
			type: String,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false,
			default: false
		},
		contentField: {
			type: String,
			default: "content"
		},
		nameField: {
			type: String,
			default: "contentName"
		},
		typeField: {
			type: String,
			default: "contentType"
		},
		childComponents: {
			type: Object,
			required: false
		}
	},
	data: function() {
		return {
			files: [],
			fileTypes: [],
			// the files that are being worked on
			working: [],
			messages: [],
			selectedImage: null,
			// this component supports both arrays and singular elements
			// this boolean keeps track of the type
			singular: false,
			valid: null
		}
	},
	computed: {
		remaining: function() {
			var maximum = this.field.maximum ? parseInt(this.field.maximum) : null;
			if (maximum == null) {
				return null;
			}
			return maximum - (this.files.length + this.storedAmount);
		},
		storedAmount: function() {
			if (this.field.binary) {
				return this.value != null ? 1 : 0;
			}
			else if (this.singular) {
				return this.value[this.contentField] != null ? 1 : 0;
			}
			else {
				return this.value.length;
			}
		}
	},
	created: function() {
		if (!this.field.hasOwnProperty("showLargeSelectedReadOnly")) {
			Vue.set(this.field, "showLargeSelectedReadOnly", true);
		}
		var self = this;
		if (this.field.binary) {
			this.singular = true;
		}
		else if (this.value instanceof Array) {
			this.singular = false;
		}
		else if (this.value != null) {
			this.singular = true;
		}
		else {
			// we try to automatically deduce whether we are dealing with an array or an object
			var arrays = this.$services.page.getAllArrays(this.page);
			if (arrays.indexOf(this.field.name) >= 0 || arrays.indexOf("page." + this.field.name) >= 0) {
				this.singular = false;
			}
			else {
				this.singular = true;
			}
		}
		if (!this.value) {
			this.$emit("input", this.singular ? (this.field.binary ? null : {}) : []);
			//this.$services.page.setValue(this.parentValue, this.field.name, this.singular ? {} : []);
		}
		else {
			this.processImages(this.value);
		}
		// by default this is only an image uploader
		if (!this.field.allowNonImages) {
			nabu.utils.arrays.merge(this.fileTypes, ["image/jpeg", "image/png", "image/svg+xml"]);
		}
	},
	methods: {
		getChildComponents: function() {
			return [{
				title: "Image Entry Wrapper",
				name: "image-entry-wrapper",
				component: "column"
			}, {
				title: "Image Hero Wrapper",
				name: "image-hero-wrapper",
				component: "column"
			}, {
				title: "Image Entry",
				name: "image-entry",
				component: "image"
			}, {
				title: "Image Hero",
				name: "image-hero",
				component: "image"
			}, {
				title: "Image Container",
				name: "image-container",
				component: "row"
			}, {
				title: "Image Title",
				name: "image-title",
				component: "h6"
			}, {
				title: "File Input",
				name: "file-input",
				component: "column"
			}, {
				title: "File Input Button",
				name: "file-input-button",
				component: "button"
			}, {
				title: "Remove Button",
				name: "file-delete-button",
				component: "button"
			}]
		},
		validate: function(soft) {
			var minimum = this.field.minimum ? parseInt(this.field.minimum) : null;
			var messages = [];
			if (minimum != null && this.files.length + this.storedAmount < minimum) {
				messages.push({
					severity: "error",
					code: "not-enough-files",
					title: "%{You need to add at least {minimum} image(s)}", 
					values: {
						minimum: minimum
					}
				});
			}
			this.valid = messages.length == 0;
			nabu.utils.arrays.merge(this.messages, nabu.utils.vue.form.localMessages(this, messages));
			return messages;
		},
		changed: function() {
			var self = this;
			this.messages.splice(0);
			this.valid = null;
			var maximum = this.field.maximum ? parseInt(this.field.maximum) : null;
			// only one allowed, remove the current one
			if ((this.field.binary || this.singular) && this.files.length == 1) {
				this.$emit("input", this.field.binary ? null : {});
				self.working.push(this.files[0]);
				self.resizeAndAdd(this.files[0]);
			}
			else if (maximum != null && this.files.length + this.storedAmount + this.working.length > maximum) {
				this.messages.push({
					severity: "info",
					code: "too-many-files",
					title: "%{You can only add {maximum} images}", 
					values: {
						maximum: maximum
					}
				});
			}
			else {
				this.files.forEach(function(file) {
					// not yet busy with it
					if (self.working.indexOf(file) < 0) {
						self.working.push(file);
						self.resizeAndAdd(file);
					}
				});
			}
			this.files.splice(0);
		},
		remove: function(index) {
			var self = this;
			if (this.singular) {
				// set everything to null
				self.value[self.nameField] = null;
				self.value[self.typeField] = null;
				self.value[self.contentField] = null;
				self.value["$url"] = null;
				this.selectedImage = null;
			}
			else {
				if (this.selectedImage == this.value[index]) {
					this.selectedImage = null;
				}
				this.value.splice(index, 1);
			}
			this.messages.splice(0);
			this.valid = null;
			this.$emit("changed");
		},
		getPlaceholder: function(file) {
			// TODO: if for example we don't have an image but a pdf we may want to show a clean pdf logo
			// however, for now, we just return the $url, knowing full well that it is not a valid image, but otherwise we have _nothing_ which is even worse
			return this.field.emptyImage ? this.field.emptyImage : file.$url;
		},
		resizeAndAdd: function(file) {
			var self = this;
			var reader = new FileReader();
			reader.onload = function(readerEvent) {
				var applyUrl = function(dataUrl) {
					var result = {};
					result["$url"] = dataUrl;
					result[self.contentField] = self.urlToBlob(dataUrl);
					result[self.nameField] = file.name;
					result[self.typeField] = file.type ? file.type : (self.field.allowNonImages ? "application/octet-stream" : "image/jpeg");
					if (self.field.binary) {
						// enrich blob with file data that is lost during resize
						result[self.contentField].name = file.name;
						result[self.contentField].type = file.type;
						result[self.contentField]["$url"] = dataUrl;
						// emit the blob itself
						self.$emit("input", result[self.contentField]);
					}
					else if (self.singular) {
						//nabu.utils.objects.merge(self.value, result);
						Object.keys(result).forEach(function(key) {
							Vue.set(self.value, key, result[key]);
						});
					}
					else {
						self.value.push(result);
					}
					if (self.selectedImage == null) {
						self.selectedImage = result;
					}
					// splice it from the arrays
					var index = self.working.indexOf(file);
					if (index >= 0) {
						self.working.splice(index, 1);
					}
					self.$emit("changed");
				}
				if (file.type.indexOf("image/") == 0) {
					var image = new Image();
					image.onload = function (imageEvent) {
						var canvas = document.createElement('canvas');
						var maxSize = self.field.maxResolution ? parseInt(self.field.maxResolution) : 1024;
						var width = image.width;
						var height = image.height;
						if (maxSize != null && maxSize > 0) {
							if (width >= height && width > maxSize) {
								var factor = maxSize / width;
								height *= factor;
								width = maxSize;
							}
							else if (height > width && height > maxSize) {
								var factor = maxSize / height;
								width *= factor;
								height = maxSize;
							}
						}
						canvas.width = width;
						canvas.height = height;
						canvas.getContext('2d').drawImage(image, 0, 0, width, height);
						// try to retrieve as the original format
						var dataUrl = canvas.toDataURL(file.type ? file.type : "image/jpeg");
						applyUrl(dataUrl);
					};
					image.src = readerEvent.target.result;
				}
				else {
					applyUrl(readerEvent.target.result);
				}
			};
			reader.readAsDataURL(file);
		},
		urlToBlob: function(dataURL) {
			var BASE64_MARKER = ';base64,';
			if (dataURL.indexOf(BASE64_MARKER) < 0) {
				var parts = dataURL.split(',');
				var contentType = parts[0].split(':')[1];
				var raw = parts[1];
				return new Blob([raw], {type: contentType});
			}
			else {
				var parts = dataURL.split(BASE64_MARKER);
				var contentType = parts[0].split(':')[1];
				return this.base64ToBlob(parts[1], contentType);
			}
		},
		base64ToBlob: function(base, contentType) {
			var raw = window.atob(base);
			var rawLength = raw.length;
			var uInt8Array = new Uint8Array(rawLength);
			for (var i = 0; i < rawLength; ++i) {
				uInt8Array[i] = raw.charCodeAt(i);
			}
			return new Blob([uInt8Array], {type: contentType});
		},
		processImages: function(imagesToProcess) {
			var self = this;
			if (!(imagesToProcess instanceof Array)) {
				imagesToProcess = [imagesToProcess];
			}
			imagesToProcess.forEach(function(image) {
				if (image.$url == null && self.field.binary && image instanceof Blob) {
					var reader = new FileReader();
					reader.onload = function(event) { 
						Vue.set(image, "$url", event.target.result);
					}
					reader.readAsDataURL(image);
					if (self.selectedImage == null) {
						self.selectedImage = image;
					}
				}
				// if our content is already base64 encoded, it is likely from the backend
				else if (image.$url == null && image[self.contentField] != null && typeof(image[self.contentField]) == "string") {
					image.$url = "data:" + image[self.typeField] + ";base64," + image[self.contentField];
					image[self.contentField] = self.base64ToBlob(image[self.contentField], image[self.typeField]);
					if (self.selectedImage == null) {
						self.selectedImage = image;
					}
				}
				else if (image.$url == null && image[self.contentField] != null && image[self.contentField] instanceof Blob) {
					var reader = new FileReader();
					reader.onload = function(event) { 
						Vue.set(image, "$url", event.target.result);
					}
					reader.readAsDataURL(image[self.contentField]);
					if (self.selectedImage == null) {
						self.selectedImage = image;
					}
				}
				else if (image.$url != null && self.selectedImage == null) {
					self.selectedImage = image;
				}
			});
		}
	}
});

window.addEventListener("load", function() {
	application.bootstrap(function($services) {
		nabu.page.provide("page-form-list-input", { 
			component: "n-form-image-uploader", 
			configure: "n-form-image-uploader-configure", 
			name: "image-uploader",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "n-form-image-uploader", 
			configure: "n-form-image-uploader-configure", 
			name: "image-uploader",
			namespace: "nabu.page"
		});
		$services.router.register({
			alias: "page-form-image-uploader",
			enter: function(parameters) {
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "n-form-image-uploader";
				cloneParameters.configurationComponent = "n-form-image-uploader-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "imageUploader",
			category: "Form",
			name: "Image uploader",
			description: "Uploads images and can resize them",
			icon: "page/core/images/image.svg"
		});
	});
});

// TODO: add support for calling operations
// TODO: add support for executing arbitrary javascript
// TODO: add support for resetting events (though this might be an action on the page itself?)

// TODO: de confirmation moet een eigen actie zijn!
// kan zijn dat je iets wilt doen, dan confirmatie voor een volgende actie


Vue.service("triggerable", {
	methods: {
		getActiveRoutes: function(target) {
			var routes = [];
			if (target.triggers) {
				target.triggers.forEach(function(trigger) {
					if (trigger.actions) {
						trigger.actions.forEach(function(action) {
							if (action.type == "route") {
								// must not be a rule
								if (action.route && action.route.indexOf("=") != 0) {
									routes.push(action.route);
								}
								if (action.activeRoutes) {
									nabu.utils.arrays.merge(routes, action.activeRoutes);
								}
							}
						})
					}
				})
			}
			return routes;
		},
		getInternalState: function(page, trigger, action, triggers, component) {
			var result = {};
			if (trigger.trigger && triggers && triggers[trigger.trigger]) {
				result[trigger.trigger] = triggers[trigger.trigger]; 
			}
			// we want to merge the internal triggers that the component exposes as internal state as well
			if (component && component.getTriggers) {
				var componentTriggers = component.getTriggers();
				if (componentTriggers) {
					nabu.utils.objects.merge(result, componentTriggers);
				}
			}
			// depending on where you are in the action chain, you may have additional state
			var pageInstance = this.$services.page.getPageInstance(page);
			var index = action ? trigger.actions.indexOf(action) : trigger.actions.length;
			for (var i = 0; i < index; i++) {
				var before = trigger.actions[i];
				// we have explicitly saved a local state
				if (before.type == 'action' && before.resultName && before.actionTarget && before.action) {
					result[before.resultName] = this.$services.page.getActionOutput(pageInstance, before.actionTarget, before.action);
				}
				else if (before.type == "operation" && before.operation && before.resultName) {
					result[before.resultName] = this.$services.page.getSwaggerOperationOutputDefinition(before.operation);
				}
			}
			return result;
		},
		// get all the error "types" that can be caused by a certain trigger
		getTriggerErrorTypes: function(page, target, forTrigger) {
			var result = [];
			if (target && target.triggers) {
				var pageInstance = this.$services.page.getPageInstance(page);
				var available = this.$services.page.getAvailableActions(pageInstance);
				target.triggers.forEach(function(trigger) {
					if (!forTrigger || trigger.trigger == forTrigger) {
						if (trigger.actions) {
							trigger.actions.forEach(function(action) {
								// if we actually call an action on another component, check the action definition to see if it can return custom error types
								if (action.type == "action") {
									var chosenAction = available.filter(function(x) {
										return x.name == action.action;
									})[0];
									if (chosenAction && chosenAction.errors && chosenAction.errors.length) {
										nabu.utils.arrays.merge(result, chosenAction.errors);
									}
									else if (result.indexOf(action.action) < 0) {
										result.push(action.action);
									}
								}
								else if (result.indexOf(action.type) < 0) {
									result.push(action.type);
								}
							})
						}
					}
				});
			}
			return result;
		},
		// get all the events that can occur from these triggers
		getEvents: function(page, target, component) {
			var result = {};
			var self = this;
			var pageInstance = this.$services.page.getPageInstance(page);
			if (target.triggers) {
				target.triggers.forEach(function(trigger) {
					var internalState = self.getInternalState(page, trigger, null, null, component);
					trigger.actions.forEach(function(action) {
						if (nabu.page.event.getName(action, "event") && nabu.page.event.getName(action, "event") != "$close") {
							if (action.eventContent) {
								result[nabu.page.event.getName(action, "event")] = internalState[action.eventContent];
							}
							else {
								var type = nabu.page.event.getType(action, "event", page);
								result[nabu.page.event.getName(action, "event")] = type;
							}
						}
					});
					// no content currently
					if (trigger.errorEvent) {
						result[trigger.errorEvent] = self.$services.swagger.resolve("#/definitions/StructuredErrorResponse");
					}
				});
			}
			return result;
		},
		// check if we can trigger on this one
		canTrigger: function(target, trigger) {
			// @2025-05-13
			// we've had issues with editing nested components where the parent have triggers (e.G. click) on the component which still trigger, preventing correct editing
			// let's try for a while by disabling all triggers
			return target.triggers && this.$services.page.editing == null ? target.triggers.filter(function(x) {
			//return target.triggers ? target.triggers.filter(function(x) {
				return x.trigger == trigger;
			}).length > 0 : false;
		},
		// you can untrigger, for example hover effect might stop once you have a mouseout
		// or the select event might stop once you reload the data and nothing is selected anymore
		// or the button click might stop once the button is removed completely
		// if no specific trigger is passed in (e.g. select), we untrigger everything, this can be handy for example on destroy
		untrigger: function(target, trigger, instance) {
			var self = this;
			// TODO: the name "triggers" is actually configurable
			var triggers = target.triggers ? target.triggers.filter(function(x) {
				return !trigger || x.trigger == trigger;
			}) : [];
			triggers.forEach(function(x, triggerIndex) {
				if (instance["$$triggerTimer" + triggerIndex]) {
					if (x.timeout) {
						clearTimeout(instance["$$triggerTimer" + triggerIndex]);
					}
					else if (x.interval) {
						clearInterval(instance["$$triggerTimer" + triggerIndex]);
					}
					instance["$$triggerTimer" + triggerIndex] = null;
				}
				if (instance["$$triggerPromise" + triggerIndex]) {
					instance["$$triggerPromise" + triggerIndex].reject();
					instance["$$triggerPromise" + triggerIndex] = null;
				}
				if (x.actions) {
					x.actions.forEach(function(action) {
						// we can untoggle the visibility
						if (action.type == "visibility" && action.closeableTarget) {
							if (action.allowUntrigger) {
								var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
								// if we were aiming for visibility, the untrigger is closing it again
								if (action.closeableAction == "visible") {
									Vue.set(pageInstance.closed, action.closeableTarget, "$any");
								}
								// and the other way around
								else if (action.closeableAction == "hidden") {
									Vue.set(pageInstance.closed, action.closeableTarget, null);
								}
								// otherwise, we just toggle
								// note that if (in the mean time) someone else played with the visibility, this might not have the desired effect
								else {
									// just toggle it
									Vue.set(pageInstance.closed, action.closeableTarget, pageInstance.closed[action.closeableTarget] == null ? "$any" : null);
								}
							}
						}
						// we can withdraw an event by setting it to null
						else if (action.type == "event" && nabu.page.event.getName(action, "event")) {
							if (action.allowUntrigger) {
								var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
								return pageInstance.emit(
									nabu.page.event.getName(action, "event"),
									null
								);
							}
						}
						else if (action.type == "variable" && action.allowUntrigger) {
							var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
							Object.keys(action.bindings).map(function(key) {
								if (action.bindings[key] != null && pageInstance.get(key + "$active") == true) {
									// we do a triple check, we "abuse" dynamic casting like 0 == false to explicitly set a different value that actually means the same...
									// for example for menu collapsible toggling
									if (pageInstance.get(key) === pageInstance.get(key + "$expected")) {
										var value = pageInstance.get(key + "$previous");
										pageInstance.set(key, value);
									}
									pageInstance.set(key + "$expected", null);
									pageInstance.set(key + "$previous", null);
									pageInstance.set(key + "$active", false);
								}
							});
						}
					});
				}	
			});
		},
		calculateUrl: function(action, instance, state, immediatelyRoute, anchor) {
			var self = this;
			var customValueFunction = function(path, literal) {
				// look up in local state so you can evaluate that
				var result = self.$services.page.getValue(state, path);
				// fallback to global value function!
				if (result == null) {
					result = instance.$value(path, literal);
				}
				return result;
			}
			var addServiceContext = function(route, parameters) {
				var resolvedRoute = self.$services.router.router.get(route);
				if (resolvedRoute && resolvedRoute.isPage) {
					var page = self.$services.page.pages.filter(function(x) {
						return x.content.name == route;
					})[0];
					if (page) {
						var serviceContextVariable = page.content.serviceContext;
						var pagePath = resolvedRoute.url;
						if (pagePath && serviceContextVariable && serviceContextVariable.indexOf("page.") == 0) {
							serviceContextVariable = serviceContextVariable.substring("page.".length);
							// we want to allow "easy" use of service contexts in pages in a situation where it doesn't matter
							// for example you design masterdata screens to be able to support service context
							// but you also want to plug them in easily in an application that doesn't care
							// if we are using a page variable that is derived from the path
							if (pagePath && pagePath.indexOf("{" + serviceContextVariable + "}") >= 0) {
								// and it does not have a value
								if (!parameters[serviceContextVariable]) {
									// use context of current page by default
									var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
									// set it to default, the swagger client knows that it should not send it in that case
									parameters[serviceContextVariable] = pageInstance.getServiceContext();
									if (!parameters[serviceContextVariable]) {
										parameters[serviceContextVariable] = "default";
									}
								}
							}
						}
					}
				}
			};
			if (action.type == "route" && (action.route || action.routeFormula)) {
				var route = action.routeAsFormula ? self.$services.page.eval(action.routeFormula, state, instance) : action.route;
				var parameters = action.routeFormulateParameters ? self.$services.page.eval(action.routeFormulateParameters, state, instance) : this.getBindings(action, instance, state);
				addServiceContext(route, parameters);
				if (immediatelyRoute) {
					self.$services.page.chosenRoute = route;
					return self.$services.router.route(route, parameters, anchor, action.mask);
				}
				else {
					return self.$services.router.template(route, parameters);
				}
			}
			else if (action.type == "route" && action.url) {
				return self.$services.page.interpret(action.url, instance, null, customValueFunction);
			}
		},
		getBindings: function(action, instance, state) {
			var self = this;
			var parameters = {};
			if (action.bindings) {
				var customValueFunction = function(path, literal) {
					// look up in local state so you can evaluate that
					var result = self.$services.page.getValue(state, path);
					// fallback to global value function!
					if (result == null) {
						result = instance.$value(path, literal);
					}
					return result;
				}
				var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
				Object.keys(action.bindings).map(function(key) {
					if (action.bindings[key] != null) {
						var value = null;
						
						// need to check if you want to access local state
						var index = action.bindings[key].indexOf(".");
						var resolved = false;
						if (index > 0) {
							var variableName = action.bindings[key].substring(0, index);
							// if we have it in state, that wins
							if (state && state.hasOwnProperty(variableName)) {
								value = self.$services.page.getValue(state, action.bindings[key]);
								resolved = true;
							}
						}
						if (!resolved) {
							value = self.$services.page.getBindingValue(pageInstance, action.bindings[key], instance, customValueFunction);
						}
						// @2024-05-22
						// if you have a fixed value set to null, we map it
						// it is not entirely clear why other null values are being ignored? might just need to allow null values here?
						var isFixed = action.bindings[key].indexOf("fixed.") == 0;
						if (value != null || isFixed) {
							// does not take into account "." separated field names which are received
							//parameters[key] = value;
							self.$services.page.setValue(parameters, key, value);
						}
					}
				});
			}
			return parameters;
		},
		// the target we want to trigger on (cell, row,..)
		// the name of the trigger (e.g. click)
		// any value we received for the trigger, for instance an action or event might have data attached to it
		// with properties you can tweak other behaviors
		trigger: function(target, trigger, value, instance, properties) {
			// we don't always call this handler (immediately), so we separate the logic
			var self = this;
			
			var customValueFunctionParent = function(path, literal) {
				// look up in local state so you can evaluate that
				var result = value == null ? null : self.$services.page.getValue(value, path);
				// fallback to global value function!
				if (result == null) {
					result = instance.$value(path, literal);
				}
				return result;
			}
			
			// TODO: the name "triggers" is actually configurable
			var triggers = target.triggers ? target.triggers.filter(function(x) {
				return x.trigger == trigger
					&& (!x.condition || self.$services.page.isCondition(x.condition, value, instance, customValueFunctionParent))
					&& (!x.triggerError || (value && value.errorType == x.triggerError));
			}) : [];
			
			var promises = triggers.map(function(x, triggerIndex) {
				var state = {};
				
				// the initial state
				state[trigger] = value;
				
				// TODO: don't pre-filter actions, but instead filter them as we go further into the pipeline
				// if we then pass in the "state" (rather than the value), we can evaluate to the local pipeline state
				
				var customValueFunction = function(path, literal) {
					// look up in local state so you can evaluate that
					var result = self.$services.page.getValue(state, path);
					if (result == null) {
						result = customValueFunctionParent(path, literal);
					}
					// fallback to global value function!
					if (result == null) {
						result = instance.$value(path, literal);
					}
					return result;
				}
				
				// executing during run!
				var actions = x.actions;
				/*
				var actions = x.actions.filter(function(y) {
					return !y.condition || self.$services.page.isCondition(y.condition, value, instance, customValueFunction);
				});
				*/
				
				// local state we have built up, we can get variables from there
				
				// when the trigger execution stops specifically because of a confirmation failure (rather than an actual error), we don't want to run the error routines but DO want to fail the trigger
				var confirmationError = false;
				
				// we start a new promise for the full trigger
				var triggerPromise = self.$services.q.defer();
				
				// actions can be immediately run or chained
				var runAction = function(index, lastPromise) {
					var action = actions[index];
					var getBindings = function() {
						return self.getBindings(action, instance, state);
/*						var parameters = {};
						var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
						Object.keys(action.bindings).map(function(key) {
							if (action.bindings[key] != null) {
								var value = null;
								
								// need to check if you want to access local state
								var index = action.bindings[key].indexOf(".");
								var resolved = false;
								if (index > 0) {
									var variableName = action.bindings[key].substring(0, index);
									// if we have it in state, that wins
									if (state.hasOwnProperty(variableName)) {
										value = self.$services.page.getValue(state, action.bindings[key]);
										resolved = true;
									}
								}
								if (!resolved) {
									value = self.$services.page.getBindingValue(pageInstance, action.bindings[key], instance, customValueFunction);
								}
								if (value != null) {
									// does not take into account "." separated field names which are received
									//parameters[key] = value;
									self.$services.page.setValue(parameters, key, value);
								}
							}
						});
						return parameters;*/
					}
					
					var addServiceContext = function(route, parameters) {
						var resolvedRoute = self.$services.router.router.get(route);
						if (resolvedRoute && resolvedRoute.isPage) {
							var page = self.$services.page.pages.filter(function(x) {
								return x.content.name == route;
							})[0];
							if (page) {
								var serviceContextVariable = page.content.serviceContext;
								var pagePath = resolvedRoute.url;
								if (pagePath && serviceContextVariable && serviceContextVariable.indexOf("page.") == 0) {
									serviceContextVariable = serviceContextVariable.substring("page.".length);
									// we want to allow "easy" use of service contexts in pages in a situation where it doesn't matter
									// for example you design masterdata screens to be able to support service context
									// but you also want to plug them in easily in an application that doesn't care
									// if we are using a page variable that is derived from the path
									if (pagePath && pagePath.indexOf("{" + serviceContextVariable + "}") >= 0) {
										// and it does not have a value
										if (!parameters[serviceContextVariable]) {
											// use context of current page by default
											var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
											// set it to default, the swagger client knows that it should not send it in that case
											parameters[serviceContextVariable] = pageInstance.getServiceContext();
											if (!parameters[serviceContextVariable]) {
												parameters[serviceContextVariable] = "default";
											}
										}
									}
								}
							}
						}
					};
					
					var handler = function() {
						if (action.condition && !self.$services.page.isCondition(action.condition, value, instance, customValueFunction)) {
							return;
						}
						// event-based
						if (action.type == "event" && nabu.page.event.getName(action, "event")) {
							var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
							return pageInstance.emit(
								nabu.page.event.getName(action, "event"),
								action.eventContent ? state[action.eventContent] : nabu.page.event.getInstance(action, "event", instance.page, instance)
							);
						}
						else if (action.type == "route") {
							var anchor = properties && properties.anchor ? properties.anchor : action.anchor;
							var url = self.calculateUrl(action, instance, state, !anchor, anchor);
							// if we get a promise back, it is actually routing
							if (url && url.then) {
								return url;
							}
							if (anchor == "$blank") {
								window.open(url);
							}
							// if we have no explicit anchor, in local
							else if (anchor == "$window" || !anchor) {
								window.location = url;
							}
						}
						// route based
						else if (false && action.type == "route" && (action.route || action.routeFormula)) {
							var route = action.routeAsFormula ? self.$services.page.eval(action.routeFormula, self.state, instance) : action.route;
							var anchor = properties && properties.anchor ? properties.anchor : action.anchor;
							// if we are using an anchor we are either rendering outside ($blank, $window etc) or in a very specific location which can likely not be reached on replay
							// so we don't store it
							if (!anchor) {
								self.$services.page.chosenRoute = route;
							}
							var parameters = getBindings();
							addServiceContext(route, parameters);
							if (anchor == "$blank") {
								window.open(self.$services.router.template(route, parameters));
							}
							else if (anchor == "$window") {
								window.location = self.$services.router.template(route, parameters);
							}
							else {
								return self.$services.router.route(route, parameters, anchor, action.mask);
							}
						}
						else if (false && action.type == "route" && action.url) {
							var url = self.$services.page.interpret(action.url, instance, null, customValueFunction);
							var anchor = properties && properties.anchor ? properties.anchor : action.anchor;
							if (anchor == "$blank") {
								window.open(url);
							}
							else {
								window.location = url;
							}
						}
						else if (action.type == "notification") {
							var notification = {};
							notification.duration = action.notificationDuration ? parseInt(action.notificationDuration) : null;
							notification.title = action.notificationTitle ? self.$services.page.translate(self.$services.page.interpret(action.notificationTitle, instance)) : null;
							notification.message = action.notificationMessage ? self.$services.page.translate(self.$services.page.interpret(action.notificationMessage, instance)) : null;
							notification.severity = action.notificationColor;
							notification.closeable = !!action.notificationCloseable;
							notification.icon = action.notificationIcon;
							self.$services.notifier.push(notification);
							return self.$services.q.resolve();
						}
						// we might want to run an action
						else if (action.type == "action" && action.action) {
							if (action.actionTarget) {
								var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
								var target = self.$services.page.getActionTarget(pageInstance, action.actionTarget);
								// at this point it is a renderer or a component
								if (target && target.runAction) {
									var runBefore = null;
									var runAfter = null;
									var runError = null;
									// if the target has triggers of its own, we need to check
									// a renderer uses a "target" which is either a cell or a row
									// a regular component uses a cell (normally never a row?)
									var targetConfiguration = target.target ? target.target : (target.cell ? target.cell : target.row);
									if (targetConfiguration && targetConfiguration.triggers) {
										runBefore = targetConfiguration.triggers.filter(function(x) {
											return x.trigger == action.action + ":before";
										});
										runAfter = targetConfiguration.triggers.filter(function(x) {
											return x.trigger == action.action + ":after";
										});
										runError = targetConfiguration.triggers.filter(function(x) {
											return x.trigger == action.action + ":error";
										});
									}
									var beforePromise = null;
									if (runBefore && runBefore.length) {
										beforePromise = self.$services.triggerable.trigger(targetConfiguration, action.action + ":before", null, target);
									}
									
									var runTargetAction = function() {
										var result = target.runAction(action.action, getBindings());
										var promise = self.$services.q.defer();
										if (result && result.then) {
											result.then(function(answer) {
												if (action.resultName) {
													state[action.resultName] = answer;
												}
												if (runAfter && runAfter.length) {
													self.$services.triggerable.trigger(targetConfiguration, action.action + ":after", answer, target).then(function() {
														promise.resolve(answer)
													}, promise);
												}
												else {
													promise.resolve(answer);
												}
											}, function(error) {
												if (runError && runError.length) {
													self.$services.triggerable.trigger(targetConfiguration, action.action + ":error", error, target).then(function() {
														promise.reject(error)
													}, promise);	
												}
												else {
													promise.reject(error);
												}
											});
										}
										else {
											promise.resolve();
										}
										return promise;
									}
									if (beforePromise) {
										var overallPromise = self.$services.q.defer();
										beforePromise.then(function() {
											runTargetAction().then(overallPromise, overallPromise);
										}, overallPromise);
										return overallPromise;
									}
									else {
										return runTargetAction();
									}
								}
							}
						}
						else if (action.type == "operation" && action.operation) {
							var operation = self.$services.swagger.operations[action.operation];
							var parameters = getBindings();
							try {
								var promise = self.$services.q.defer();
								if (!parameters["$serviceContext"]) {
									var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
									parameters["$serviceContext"] = pageInstance.getServiceContext();
								}
								var target = instance.cell ? instance.cell : instance.row;
								// anything that is not a get should be autologged for analysis
								if (target && operation.method && operation.method.toLowerCase() != "get") {
									self.$services.analysis.push({
										event: "operation",
										category: "trigger",
										component: target.analysisId ? target.analysisId : (target.alias ? target.alias + "-" : "") + target.id,
										context: action.operation,
										page: self.$services.page.getRootPage(self.$services.page.getPageInstance(instance.page, instance)).page.content.name
									});
								}
								self.$services.swagger.execute(action.operation, parameters).then(function(answer) {
									if (action.resultName) {
										state[action.resultName] = answer;
									}
									promise.resolve(answer);
								}, function(error) {
									// TODO: get the response code
									promise.reject({errorType: "operation", error: error});
								});
								return promise;
							}
							catch (exception) {
								console.error("Could not run operation: " + action.operation, exception);
								return self.$services.q.reject({action: "operation", exception: exception});
							}
						}
						else if (action.type == "variable") {
							if (action.bindings) {
								var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
								Object.keys(action.bindings).map(function(key) {
									if (action.bindings[key] != null) {
										var value = null;
										
										// need to check if you want to access local state
										var index = action.bindings[key].indexOf(".");
										var resolved = false;
										if (index > 0) {
											var variableName = action.bindings[key].substring(0, index);
											// if we have it in state, that wins
											if (state && state.hasOwnProperty(variableName)) {
												value = self.$services.page.getValue(state, action.bindings[key]);
												resolved = true;
											}
										}
										if (!resolved) {
											value = self.$services.page.getBindingValue(pageInstance, action.bindings[key], instance, customValueFunction);
										}
										if (value == null && action.defaultValue) {
											value = self.$services.page.eval(action.defaultValue, {}, self);
										}
										// if we have an untrigger ability, store the current value
										if (action.allowUntrigger) {
											// some events (like hover) are executed continuously, we only want to keep the previous value if it was inactive before
											if (pageInstance.get(key + "$active") != true) {
												pageInstance.set(key + "$active", true);
												pageInstance.set(key + "$previous", pageInstance.get(key));
												// we only reset to previous if the current still matches the expected
												// otherwise other logic has kicked in
												// we can add a "force" or whatever if necessary at some point
												pageInstance.set(key + "$expected", value);
											}
										}
										// does not take into account "." separated field names which are received
										//parameters[key] = value;
										pageInstance.set(key, value);
									}
								});
							}
							return self.$services.q.resolve();
						}
						else if (action.type == "download" && action.operation) {
							var parameters = getBindings();
							
							self.$services.analysis.push({
								event: "download",
								category: "trigger",
								component: (instance.alias ? instance.alias + "-" : "") + instance.analysisId ? instance.analysisId : instance.id,
								context: instance.page.content.name,
								path: instance.page.content.path,
								data: parameters
							});
							
							if (action.allowArbitraryDownload) {
								if (!parameters["$serviceContext"]) {
									var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
									parameters["$serviceContext"] = pageInstance.getServiceContext();
								}
								var types = [{name: 'excel', contentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'},{name: 'json', contentType: 'application/json'},{name: 'xml', contentType:'application/xml'},{name:'csv',contentType:'text/csv'}];
								var acceptContentType = null;
								if (action.downloadAs) {
									acceptContentType = types.filter(function(x) { return x.name == action.downloadAs })[0];
									if (acceptContentType) {
										acceptContentType = acceptContentType.contentType;
									}
								}
								parameters["$responseType"] = "blob";
								return self.$services.page.downloadService(action.operation, parameters, action.fileName, acceptContentType);
							}
							
							var startDownload = function(url) {
								var operation = self.$services.swagger.operations[action.operation];
								
								var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
								var serviceContext = pageInstance.getServiceContext();
								if (serviceContext) {
									url += (url.indexOf("?") >= 0 ? "&" : "?") + "$serviceContext=" + serviceContext;
								}
								
								if (operation.method == "get" && operation.produces && operation.produces.length && operation.produces[0] == "application/octet-stream") {
									if (action.anchor != "$window") {
										self.$services.page.download(url, function() {
											// download failed, but there is no equivalent for when it is successful, hard to put it in a promise
										});
									}
									else {
										window.location = self.$services.swagger.parameters(action.operation, parameters).url;
									}
								}
								else if (operation["x-downloadable"] == "true") {
									var contentType = null;
									if (action.downloadAs == "excel") {
										contentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
									}
									else if (action.downloadAs == "csv") {
										contentType = "text/csv";
									}
									else if (action.downloadAs == "json") {
										contentType = "application/json";
									}
									else if (action.downloadAs == "xml") {
										contentType = "application/xml";
									}
									var separator = url.indexOf("?") < 0 ? "?" : "&";
									if (contentType != null) {
										url += separator + "header:Accept=" + contentType;
										separator = "&";
									}
									url += separator + "header:Accept-Content-Disposition=attachment";
									if (action.fileName) {
										url += ";fileName=" + self.$services.page.interpret(action.fileName, instance);
									}
									if (action.anchor != "$window") {
										self.$services.page.download(url, function() {
											// nothing yet
										});
									}
									else {
										window.location = url;
									}
								}
							}
							// in the new setup, we use otp generation to create a link that is self-authorizing
							if (self.$services.user.downloadUrl) {
								return self.$services.user.downloadUrl(action.operation, parameters).then(function(url) {
									if (url) {
										startDownload(url);
									}
								});
							}
							else {
								startDownload(self.$services.swagger.parameters(action.operation, parameters).url);
								return self.$services.q.resolve();
							}
						}
						else if (action.type == "javascript" && action.javascript) {
							var script = action.javascript;
							// if we don't wrap it in a function, it might only execute the first line
							// when dealing with formatting or conditions that might be wanted
							// however, in this location we want to execute a full script, we are not assigning or conditioning
							if (script.trim().indexOf("function") != 0) {
								script = "function(){ " + script + "}";
							}
							//var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
							//var result = self.$services.page.eval(script, pageInstance.variables, instance);
							// console.log("executing", script, customValueFunction)
							var result = self.$services.page.eval(script, state, instance, customValueFunction);
							if (result && result.then) {
								return result;
							}
							else {
								return self.$services.q.resolve(result);
							}
						}
						else if (action.type == "function" && action.function) {
							var func = self.$services.page.getRunnableFunction(action.function);
							if (!func) {
								throw "Could not find function: " + action.function; 
							}
							var promise = self.$services.q.defer();
							try {
								var result = self.$services.page.runFunction(func, getBindings(), self, promise);
							}
							catch (exception) {
								console.error("Could not run function: " + action.function, exception);
								promise.reject(exception);
							}
							return promise;
						}
						else if (action.type == "confirmation" && action.confirmation) {
							var promise = self.$services.q.defer();
							self.$confirm({translator: self.$services.page.translate, message:self.$services.page.translate(self.$services.page.interpret(action.confirmation, instance))}).then(promise, function(error) {
								confirmationError = true;
								promise.reject(error);
							});
							return promise;
						}
						else if (action.type == "visibility" && action.closeableTarget) {
							var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
							// if we don't have this target in our own page but we are a fragment of a larger page, check the parent!
							// TODO: this might need to be a while loop for complex page setups with nested fragments...
							if (!pageInstance.closed.hasOwnProperty(action.closeableTarget) && pageInstance.fragmentParent) {
								pageInstance = pageInstance.fragmentParent;
							}
							// if we want to ensure visibility, we must wipe the "closed" state
							if (action.closeableAction == "visible") {
								Vue.set(pageInstance.closed, action.closeableTarget, null);
							}
							else if (action.closeableAction == "hidden") {
								Vue.set(pageInstance.closed, action.closeableTarget, "$any");
							}
							else {
								// just toggle it
								Vue.set(pageInstance.closed, action.closeableTarget, pageInstance.closed[action.closeableTarget] == null ? "$any" : null);
							}
							return self.$services.q.resolve();
						}
						else if (action.type == "scroll" && action.scrollTo) {
							var element = document.querySelector(action.scrollTo);
							if (element) {
								var properties = {};
								properties.behavior = action.scrollBehavior ? action.scrollBehavior : "smooth";
								properties.block = action.scrollBlock ? action.scrollBlock : "center";
								properties.inline = action.scrollInline ? action.scrollInline : "nearest";
								// TODO: make the block target configurable, center is "generally" acceptable
								element.scrollIntoView(properties);
								return self.$services.q.resolve(element);
							}
							else {
								return self.$services.q.reject();
							}
						}
					};
					
					if (!self.edit) {
						// @2023-11-29: there are some issues with this: if we have an action that does NOT return a promise
						// we fall back to the "last promise" but this seems to sometimes lead to double actions
						// for instance an example where we had a rest call, then a notification (without promise at that time) and an action to refresh a table
						// the refresh was called twice
						// by simply returning a success promise from the notification, the double call was solved
						// it is not entirely clear yet as to why so leaving this as is for now
						var runNext = function(promise) {
							// we finished!
							if (index == actions.length - 1) {
								// we want to keep repeating
								if (x.interval) {
									instance["$$triggerTimer" + triggerIndex] = setTimeout(function() {
										runAction(0);
									}, x.interval);
								}
								// if we passed in a promise, wait for it to finish
								else if (promise) {
									promise.then(triggerPromise, triggerPromise);
								}
								else {
									triggerPromise.resolve();
								}
							}
							else if (promise) {
								promise.then(function() {
									runAction(index + 1, promise);
								}, triggerPromise);
							}
							else {
								runAction(index + 1, promise);
							}
						};
						
						var result = handler();
						
						// we don't want to chain it, immediately execute
						if (!lastPromise || action.immediate) {
							// if we returned a promise, we want to keep in mind when running following actions
							if (result && result.then) {
								// if we have a lastpromise and we are in immediate mode, we are actually in parallel
								if (lastPromise && action.immediate) {
									lastPromise = self.$services.q.all([lastPromise, result]);
								}
								// otherwise we just want the current promise
								else {
									lastPromise = result;
								}
							}
							// if we don't have a promise, we just keep the last one
							// anyway, start the next one
							runNext(lastPromise);
						}
						else {
							runNext(result && result.then ? result : lastPromise);
						}
					}
				};
				
				// start at the beginning
				if (actions.length > 0) {

					// for both the timeout and interval, we want to capture the promise so we can reject it later					
					// there is already a global "untrigger" when something unloads, so it should be cleanly stopped
					if (x.timeout || x.interval) {
						instance["$$triggerPromise" + triggerIndex] = triggerPromise;
					}
					
					// if we want confirmation and you reject, we don't start
					// deprecated, confirmation is now part of the actions
					if (x.confirmation) {
						self.$confirm({message:self.$services.page.translate(self.$services.page.interpret(x.confirmation, instance))}).then(function() {
							runAction(0);
						}, triggerPromise);
					}
					// if we have a timeout, use it to delay the start
					// if we only have an interval, the first run is immediately
					// if we have a timeout and interval, we only start after that timeout
					else if (x.timeout) {
						instance["$$triggerTimer" + triggerIndex] = setTimeout(function() {
							runAction(0);
						}, x.timeout);
					}
					else {
						runAction(0);
					}
				}
				/*
				// if we have no actions but we do have an interval, we want to try again
				// it could very well be that it was simply conditions
				// TODO: there is currently no easy way to trigger it again apart from calling trigger() in full
				else if (x.interval) {
					instance["$$triggerPromise" + triggerIndex] = triggerPromise;
					instance["$$triggerTimer" + triggerIndex] = setTimeout(function() {
						runAction(0);
					}, x.timeout);
				}
				*/
				// nothing happened, resolve immediately
				else {
					triggerPromise.resolve();
				}
				
				return triggerPromise.then(function() {
					if (x.closeEvent) {
						instance.$emit("close");
					}
				}, function(error) {
					// deprecated and never used, can be removed
					if (x.errorEvent) {
						var pageInstance = self.$services.page.getPageInstance(self.page);
						pageInstance.emit(x.errorEvent, error ? error : {});
					}
					if (!confirmationError) {
						var errorName = x.trigger + ":error";
						if (x.errorTrigger) {
							errorName = x.errorTrigger;
						}
						self.trigger(target, errorName, error, instance);
					}
				});
			});
			
			return this.$services.q.all(promises);
		}
	}
});

Vue.component("page-triggerable-configure", {
	template: "#page-triggerable-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		// where we can store our triggers
		target: {
			type: Object,
			required: true
		},
		// the available triggers, the key is the name, the value is the data type
		// to be interesting you need at least one trigger
		triggers: {
			type: Object,
			required: true
		},
		// the name of the field within the target that we can store it
		name: {
			type: String,
			default: "triggers"
		},
		allowClosing: {
			type: Boolean,
			default: false
		}
	},
	created: function() {
		// normalize
		if (!this.target[this.name]) {
			Vue.set(this.target, this.name, []);
		}
	},
	computed: {
		actionTypes: function() {
			var types = [];
			types.push({
				title: "REST call",	// Call a REST operation in the backend
				name: "operation"
			});
			types.push({
				title: "Download data",	// Download data from the backend
				name: "download"
			})
			types.push({
				title: "Run action", // Call an action on another component
				name: "action"
			});
			types.push({
				title: "Run function",	// Call a function
				name: "function"
			});
			types.push({
				title: "Show / hide",	// Change visibility of cell or row
				name: "visibility"
			});
			types.push({
				title: "Send event",	// Send an event to the entire page
				name: "event"
			});
			types.push({
				title: "Send notification",	// Show a notification to the user
				name: "notification"
			});
			types.push({
				title: "Redirect",	// Redirect the user to another page
				name: "route"
			});
			types.push({
				title: "Scroll",		// Scroll to a particular position in the page
				name: "scroll"
			});
			/*
			types.push({
				title: "Reset other events",
				name: "reset"
			});
			*/
			types.push({
				title: "Ask confirmation",	// Ask for confirmation
				name: "confirmation"
			});
			types.push({
				title: "Set variable",
				name: "variable"
			});
			types.push({
				title: "Execute javascript",
				name: "javascript"
			});
			return types;
		}
	},
	methods: {
		getTriggerErrorTypes: function(trigger, value) {
			var triggerName = trigger ? trigger.trigger : null;
			// if we are subscribing to an error, check there
			if (triggerName) {
				triggerName = triggerName.replace(/:error$/, "");
			}
			var result = this.$services.triggerable.getTriggerErrorTypes(this.page, this.target, triggerName);
			if (result.length && value) {
				result = result.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
			}
			return result;
		},
		finalizedTrigger: function(trigger) {
			return trigger.actions && trigger.actions.filter(function(x) {
				return x.type == "route";
			}).length > 0;
		},
		getAvailableColors: function(value) {
			var variants = [];
			this.$services.page.getArisComponentHierarchy("alert").forEach(function(component) {
				if (component.dimensions) {
					component.dimensions.forEach(function(x) {
						if (x.name == "color") {
							x.options.forEach(function(opt) {
								if (variants.indexOf(opt) < 0) {
									variants.push(opt);
								}
							})
						}
					})
				}
				/*
				if (component.variants != null) {
					component.variants.forEach(function(variant) {
						if (variants.indexOf(variant.name) < 0) {
							variants.push(variant.name);
						}
					});
				}
				*/
			});
			if (value != null) {
				variants = variants.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			variants.sort();
			return variants;
		},
		getAnchors: function(value) {
			var result = ["$blank", "$window"];
			document.body.querySelectorAll("[anchor]").forEach(function(element) {
				result.push(element.getAttribute("anchor"));
			})
			result.sort();
			if (value) {
				result = result.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			return result;
		},
		actionUp: function(trigger, action) {
			var index = trigger.actions.indexOf(action);	
			if (index > 0) {
				trigger.actions.splice(index, 1);
				trigger.actions.splice(index - 1, 0, action);
			}
		},
		actionDown: function(trigger, action) {
			var index = trigger.actions.indexOf(action);	
			if (index < trigger.actions.length - 1) {
				trigger.actions.splice(index, 1);
				trigger.actions.splice(index + 1, 0, action);
			}
		},
		getAvailableParameters: function(trigger, action) {
			var result = {};
			nabu.utils.objects.merge(result, this.$services.page.getAllAvailableParameters(this.page));
			nabu.utils.objects.merge(result, this.$services.triggerable.getInternalState(this.page, trigger, action, this.triggers));
			return result;
		},
		addAction: function(target) {
			var action = {
				// the event to send
				event: null,
				// redirect to url
				url: null,
				// call an action on another object
				action: null,
				actionTarget: null,
				// emit an event once an action is done
				actionEvent: null,
				// route to redirect to
				route: null,
				// whether or not to mask
				mask: null,
				// the anchor to route in
				anchor: null,
				// other active routes
				activeRoutes: [],
				// possible bindings
				bindings: {}
			};
			target.actions.push(action);
		},
		addTrigger: function() {
			var trigger = {
				actions: []
			};
			var triggerNames = this.getTriggerNames();
			// if there is only one trigger, we start on that
			if (triggerNames.length == 1) {
				trigger.trigger = triggerNames[0];
			}
			this.target[this.name].push(trigger);
		},
		// get available trigger names
		getTriggerNames: function(value) {
			var result = Object.keys(this.triggers);
			if (value) {
				result = result.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0});
			}
			if (this.target.triggers) {
				this.target.triggers.forEach(function(trigger) {
					var name = null;
					if (trigger.errorTrigger) {
						name = trigger.errorTrigger;
					}
					else if (trigger.trigger) {
						name = trigger.trigger + ":error";
					}
					if (name != null && result.indexOf(name) < 0) {
						result.push(name);
					}
				});
			}
			result.sort();
			return result;
		}	
	}
});
Vue.component("n-form-ace", {
	template: "<div class='is-form-ace'>"
		+ "	<div class='is-label-wrapper is-row is-spacing-gap-small' v-if='label'><label class='is-label'><span class='is-label-content' v-html='label'></span><n-info v-if='$slots[\"default\"]'><slot></slot></n-info></label><button @click='magnify' class='is-button is-size-xsmall is-variant-ghost'><icon name='search'/></button></div>"
		+ "	<div class='is-content-before' v-if='before' v-html='before'></div>"
		+ "	<div class='is-content-wrapper'>"
		+ "		<n-ace :mode='mode' :timeout='timeout' :value='value' v-bubble:input ref='ace' :placeholder='placeholder'/>"
		+ "	</div>"
		+ "	<n-messages :messages='messages' v-if='messages && messages.length'/>"
		+ "	<div class='is-content-after' v-if='after' v-html='after'></div>"
		+ "</div>",
	props: {
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		mode: {
			type: String,
			required: false,
			default: "javascript"
		},
		timeout: {
			type: Number,
			required: false,
			default: 300
		},
		before: {
			type: String,
			required: false
		},
		after: {
			type: String,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		template: {
			type: Boolean,
			required: false
		}
	},
	data: function() {
		return {
			messages: []
		}
	},
	methods: {
		validate: function(soft) {
			return [];
		}, 
		magnify: function() {
			var self = this;
			this.$prompt(function() {
				var component = Vue.component("big-ace");
				var instance = new component({propsData: {value: self.value, mode: self.mode }});
				instance.$on("input", function(value) {
					self.$emit("input", value);
					// visually update the value
					self.$refs.ace.editor.setValue(value);
				})
				return instance;
			});
		}
	}
});
Vue.component("n-ace", {
	template: "<div class='n-ace'></div>",
	props: {
		value: {
			required: true
		},
		mode: {
			type: String,
			required: false,
			default: "scss"
		},
		timeout: {
			type: Number,
			required: false,
			default: 300
		},
		placeholder: {
			type: String,
			required: false
		}
	},
	data: function() {
		return {
			editor: null,
			timer: null
		}
	},
	ready: function() {
		ace.require("ace/ext/language_tools");
		this.editor = ace.edit(this.$el);
		this.editor.setOptions({
			enableBasicAutocompletion: true,
			enableSnippets: true,
			enableLiveAutocompletion: true,
			useSoftTabs: false,
			showInvisibles: false,
			scrollPastEnd: false,
			enableEmmet: false,
			// default scroll speed is _very_ fast for some reason
			scrollSpeed: 0.5,
			tabSize: 4,
			placeholder: this.placeholder
		});
		//this.editor.setTheme("ace/theme/monokai");
		var self = this;
		this.editor.getSession().on('change', function() {
			if (self.timer) {
				clearTimeout(self.timer);
				self.timer = null;
			}
			self.$emit("change", self.editor.getSession().getValue());
			if (self.timeout) {
				self.timer = setTimeout(function() {
					self.$emit("input", self.editor.getSession().getValue());
				}, self.timeout);
			}
			else {
				self.$emit("input", value);
			}
		});
		if (this.value) {
			// the -1 moves cursor to the start, if we use 1 it moves to the end
			this.editor.setValue(this.value, -1);
		}
		this.setMode(this.mode);
	},
	methods: {
		setMode: function(mode) {
			this.editor.getSession().setMode("ace/mode/" + mode);
		},
		insert: function(text) {
			this.editor.insert(text);
		}
	},
	watch: {
		mode: function(newValue) {
			this.editor.getSession().setMode("ace/mode/" + mode);
		}
	}
});
Vue.component("big-ace", {
	template: "#big-ace",
	props: {
		value: {
			required: false
		},
		mode: {
			type: String,
			required: false,
			default: "javascript"
		}
	},
	created: function() {
		console.log("created with", this.value, this.mode);
	},
	methods: {
		close: function() {
			this.$resolve();
		}
	}
})
Vue.component("data-pipeline-mixin", {
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	created: function() {
		this.watchArray();
		if (this.loadData) {
			this.loadData();
		}
	},
	methods: {
		watchArray: function() {
			if (this.cell.state.array) {
				var self = this;
				this.$services.data.watchArray({
					instance: this,
					handler: function() {
						self.loadData();
					}
				});
			}
		}
	}
})

Vue.component("data-configure", {
	template: "#data-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		// the target (cell or row)
		target: {
			type: Object,
			required: true
		},
		// whether or not we are in edit mode (we can do things slightly different)
		edit: {
			type: Boolean,
			required: false
		}
	},
	created: function() {
		if (!this.target.bindings) {
			Vue.set(this.target, "bindings", {});
		}
		if (!this.target.defaultOrderBy) {
			Vue.set(this.target, "defaultOrderBy", []);
		}
		if (!this.target.type) {
			if (this.target.operation) {
				Vue.set(this.target, "type", "operation");
			}
			else if (this.target.array) {
				Vue.set(this.target, "type", "array");
			}
		}
	},
	computed: {
		operationParameters: function() {
			var result = [];
			if (this.target.operation) {
				// could be an invalid operation?
				if (this.$services.swagger.operations[this.target.operation]) {
					var parameters = this.$services.swagger.operations[this.target.operation].parameters;
					if (parameters) {
						nabu.utils.arrays.merge(result, parameters.map(function(x) { return x.name }));
					}
					result.push("$serviceContext");
				}
			}
			return result;
		}
	},
	methods: {
		getRepeatTypes: function(value) {
			var types = [];
			types.push({
				name: "operation",
				title: "The return value of a REST call"
			});
			types.push({
				name: "array",
				title: "The values available in an array"
			});
			nabu.utils.arrays.merge(types, nabu.page.providers("page-repeat"));
			if (value) {
				types = types.filter(function(x) {
					return (x.name && x.name.toLowerCase().indexOf(value.toLowerCase()) >= 0)
						|| (x.title && x.title.toLowerCase().indexOf(value.toLowerCase()) >= 0)
				})
			}
			return types;
		},
		getRepeatConfigurator: function() {
			var self = this;
			if (this.target.type && this.target.type != "operation" && this.target.type != "array") {
				var type = nabu.page.providers("page-repeat").filter(function(x) {
					return x.name == self.target.type;
				})[0];
				return type ? type.configurator : null;
			}	
		},
		getOrderByFields: function() {
			var result = [];
			if (this.target && this.target.operation) {
				var operation = this.$services.swagger.operation(this.target.operation);	
				var self = this;
				if (operation && operation.parameters) {
					var orderBy = operation.parameters.filter(function(x) {
						return x.name == "orderBy";
					})[0];
					// if we have an order by field, we can order by all the outputs (by default)
					if (orderBy && operation.responses["200"] && operation.responses["200"].schema) {
						var definition = self.$services.swagger.resolve(operation.responses["200"].schema);
						var arrays = self.$services.page.getArrays(definition);
						if (arrays.length > 0) {
							var childDefinition = self.$services.page.getChildDefinition(definition, arrays[0]);
							if (childDefinition && childDefinition.items && childDefinition.items.properties) {
								nabu.utils.arrays.merge(result, Object.keys(childDefinition.items.properties));
							}
						}
					}
				}
			}
			return result;
		}
	}
});

Vue.component("data-pipeline-configure", {
	template: "#data-pipeline-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		// the target (cell or row)
		target: {
			type: Object,
			required: true
		},
		// whether or not we are in edit mode (we can do things slightly different)
		edit: {
			type: Boolean,
			required: false
		},
		removable: {
			type: Boolean,
			default: true
		},
		pipeline: {
			type: Object,
			required: true
		}
	},
	data: function() {
		return {
			
		}
	}
});

Vue.component("data-pipelines-configure", {
	template: "#data-pipelines-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		// the target (cell or row)
		target: {
			type: Object,
			required: true
		},
		// whether or not we are in edit mode (we can do things slightly different)
		edit: {
			type: Boolean,
			required: false
		},
		allowed: {
			type: Number
		},
		initializer: {
			type: Function
		}
	},
	created: function() {
		if (!this.target.pipelines) {
			Vue.set(this.target, "pipelines", []);
		}
		if (this.allowed == 1 && this.target.pipelines.length == 0) {
			this.addPipeline();
		}
	},
	data: function() {
		return {
			
		}
	},
	methods: {
		addPipeline: function() {
			var pipeline = {};
			if (this.initializer) {
				this.initializer(pipeline);
			}
			this.target.pipelines.push(pipeline);
		}
	}
});
Vue.component("page-event-value", {
	template: "#page-event-value",
	props: {
		container: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		title: {
			type: String,
			required: false,
			default: "Event"
		},
		name: {
			type: String,
			required: false,
			default: "genericEvent"
		},
		inline: {
			type: Boolean,
			required: false
		},
		nameModifiable: {
			type: Boolean,
			default: true
		},
		// string list of keys
		keys: {
			type: Array,
			required: false
		},
		allowFields: {
			type: Boolean,
			default: true
		}
	},
	created: function() {
		// built in some (minor) backwards compatibility
		if (typeof(this.container[this.name]) == "string") {
			Vue.set(this.container, this.name, {
				eventFields: [{name: "value", isFixed: false, fixedValue: null, stateValue: null}],
				name: this.container[this.name]
			});
		}
		else if (!this.container[this.name]) {
			Vue.set(this.container, this.name, {
				eventFields: [],
				name: null
			});
		}
		else if (!this.container[this.name].eventFields) {
			Vue.set(this.container[this.name], "eventFields", []);
		}
	},
	methods: {
		addEventField: function(target) {
			if (!target.eventFields) {
				Vue.set(target, "eventFields", []);
			}
			target.eventFields.push({name:null,fixedValue:null,isFixed:false,stateValue:null});
		}
	}
});

if (!nabu) { var nabu = {}; }
if (!nabu.page) { nabu.page = {}; }
if (!nabu.page.event) { nabu.page.event = {}; }

nabu.page.event = {
	getType: function(container, name, page) {
		var result = {};
		if (container[name] && container[name].eventFields) {
			var parameters = page ? application.services.page.getAllAvailableParameters(page) : {};
			container[name].eventFields.forEach(function(x) {
				result[x.name] = !x.isFixed && parameters ? application.services.page.getChildDefinition({properties:parameters}, x.stateValue) : {
					type: "string"
				};
			});
		}
		return {properties:result};
	},
	getName: function(container, name) {
		return container[name] ? (typeof(container[name]) == "string" ? container[name] : container[name].name) : null;	
	},
	getInstance: function(container, name, page, component) {
		var pageInstance = application.services.page.getPageInstance(page, component);
		var result = {};
		// backwards compatibility
		if (typeof(container[name]) == "string") {
			// backwards compatibility with page click events
			if (name == "clickEvent") {
				if (container.hasFixedClickValue && container.clickEventValue) {
					result.value = container.clickEventValue;
				}
				else if (container.clickEventValue) {
					result.value = application.services.page.getBindingValue(pageInstance, container.clickEventValue);
				}
			}
			// actions backwards compatibility
			else if (container.hasFixedState && container.eventFixedState) {
				result.value = application.services.page.interpret(container.eventFixedState, component);
			}
			// actions backwards compatibility
			else if (container.eventState) {
				result.value = pageInstance.get(container.eventState);
			}
		}
		else if (container[name] && container[name].eventFields) {
			container[name].eventFields.forEach(function(x) {
				if (x.isFixed) {
					result[x.name] = application.services.page.interpret(x.fixedValue, component);
				}
				else {
					result[x.name] = application.services.page.getBindingValue(pageInstance, x.stateValue);
				}
			});
		}
		return result;
	}
}
Vue.component("n-form-page", {
	template: "#n-form-page",
	props: {
		value:  {
			required: true
		},
		timeout: {
			type: Number,
			required: false,
			default: 600
		}
	},
	data: function() {
		return {
			page: null,
			timer: null
		}
	},
	created: function() {
		var counter = this.$services.page.counter++;
		this.page = {
			name: "dynamic-page-" + counter,
			counter: counter,
			content: this.$services.page.normalize(typeof(this.value) == "string" ? JSON.parse(this.value) : {})
		};
	},
	methods: {
		update: function() {
			var content = JSON.stringify(this.page.content);
			if (content != this.value) {
				this.$emit("input", content);
			}
		},
		validate: function() {
			return [];
		}
	},
	watch: {
		page: {
			handler: function(newValue) {
				if (this.timer) {
					clearTimeout(this.timer);
					this.timer = null;
				}
				this.timer = setTimeout(this.update, this.timeout);
			},
			deep: true
		}
	}
});
Vue.component("n-page-mapper", {
	template: "#n-page-mapper2",
	props: {
		// every key is a new source to map from and contains the definitions of the fields we can map in there
		from: {
			type: Object,
			required: true
		},
		// contains the definitions of the fields we can map to
		to: {
			required: true
		},
		// the resulting bindings are in here
		value: {
			type: Object,
			required: true
		},
		plain: {
			type: Boolean,
			default: false
		},
		allowComputed: {
			type: Boolean,
			default: true
		},
		watchForChanges: {
			type: Boolean,
			default: false
		},
		dropUnused: {
			type: Boolean,
			default: false
		},
		allowRecursiveMapping: {
			type: Boolean,
			default: false
		}
	},
	computed: {
		// for the label dropdown
		sources: function() {
			var sources = Object.keys(this.from);
			// allow fixed values
			sources.push("fixed");
			if (!this.plain) {
				if (this.$services.page.functions.length > 0) {
					sources.push("$function");
				}
				// allow enumerations
				nabu.utils.arrays.merge(sources, nabu.page.providers("page-enumerate").map(function(x) {
					return x.name;
				}).filter(function(x) { return sources.indexOf(x) < 0 }));
			}
			sources.sort();
			return sources;
		},
		unmappedFields: function() {
			var self = this;
			return this.fieldsToMap.filter(function(x) {
				return self.mappedFields.indexOf(x) < 0;
			});
		}
	},
	data: function() {
		return {
			fieldsToMap: [],
			// adding field?
			adding: false,
			fieldToAdd: null,
			fieldToMapRecursively: null,
			fieldMode: null,
			mappedFields: [],
			labelChoice: false
		}
	},
	created: function() {
		this.calculateFieldsToMap();
	},
	methods: {
		calculateFieldsToMap: function() {
			this.fieldsToMap.splice(0);
			this.mappedFields.splice(0);
			
			if (this.to instanceof Array) {
				nabu.utils.arrays.merge(this.fieldsToMap, this.to);
			}
			else if (this.to) {
				nabu.utils.arrays.merge(this.fieldsToMap, this.$services.page.getSimpleKeysFor(this.to, true, true));
			}
			
			var self = this;
			this.fieldsToMap.forEach(function(x) {
				if (self.value[x] != null) {
					self.mappedFields.push(x);
				}
			});
			if (this.dropUnused) {
				Object.keys(this.value).forEach(function(key) {
					if (self.fieldsToMap.indexOf(key) < 0) {
						delete self.value[key];
					}
				})
			}
		},
		removeField: function(field) {
			this.setValue(field, null, null);
			var index = this.mappedFields.indexOf(field);
			if (index >= 0) {
				this.mappedFields.splice(index, 1);
			}
		},
		resetField: function() {
			this.adding = false; 
			this.fieldToAdd = null; 
			this.fieldMode = null;
		},
		addField: function() {
			if (this.fieldToAdd) {
				this.mappedFields.push(this.fieldToAdd);
				if (this.fieldMode == "fixed") {
					this.value[this.fieldToAdd] = "fixed.";
				}
			}
			this.resetField();
		},
		mapRecursively: function() {
			
		},
		allFieldsFrom: function(value) {
			var fields = this.$services.page.getSimpleKeysFor({properties:this.from}, true, true);
			if (value) {
				fields = fields.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			return fields;
		},
		// get the possible field names for this label
		fieldsFrom: function(value, label, fields) {
			if (label == "$function") {
				//var functions = this.$services.page.functions.map(function(x) { return x.id });
				// can not use async functions as mappers (for now?)
				var functions = this.$services.page.listFunctionDefinitions()
					//.filter(function(x) { return !x.async })
					.map(function(x) { return x.id });
				if (value) {
					functions = functions.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase() >= 0 )});
				}
				return functions;
			}
			if (label == "fixed") {
				return value ? [value] : [];
			}
			var provider = nabu.page.providers("page-enumerate").filter(function(x) { return x.name == label })[0];
			if (provider) {
				var enumerations = provider.enumerate();
				if (provider.label) {
					enumerations = enumerations.map(function(x) { return x[provider.label ]});
				}
				return enumerations;
			}
			// in some cases the root definition is an array (e.g. batch selection event from a table)
			// at that point, we want the fields within, the getSimpleKeys does not support this well atm
			var def = this.from[label];
			if (def.type == "array" && def.items) {
				def = def.items;
			}
			var fields = this.$services.page.getSimpleKeysFor(def, true, true);
			if (value) {
				fields = fields.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			fields.push("$all");
			return fields;
		},
		getUnmappedField: function(value) {
			return this.unmappedFields.filter(function(x) {
				return !value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
			});
		},
		getFunctionInput: function(id) {
			var transformer = this.$services.page.functions.filter(function(x) { return x.id == id })[0];
			var parameters = {};
			var self = this;
			if (transformer) {
				transformer.inputs.map(function(x) {
					parameters[x.name] = self.$services.page.getResolvedPageParameterType(x.type);
				});
			}
			return {properties:parameters};
		},
		getFunctionOutput: function(id, value) {
			var transformer = this.$services.page.functions.filter(function(x) { return x.id == id })[0];
			var parameters = {};
			var self = this;
			if (transformer) {
				transformer.outputs.map(function(x) {
					parameters[x.name] = self.$services.page.getResolvedPageParameterType(x.type);
				});
			}
			return this.$services.page.getSimpleKeysFor({properties:parameters}, true, true);
		},
		setValue: function(field, newValue, label) {
			// when you are not using label-driven choice, split it
			if (label == null && !this.labelChoice && newValue != null) {
				var index = newValue.indexOf(".");
				if (index >= 0) {
					label = newValue.substring(0, index);
					newValue = newValue.substring(index + 1);
				}
			}
			if (false && label == "fixed" && newValue) {
				this.value[field] = {
					label: label,
					value: newValue
				};
			}
			else if (label == "$function" && newValue) {
				var def = this.$services.page.getFunctionDefinition(newValue);
				Vue.set(this.value, field, {
					label: label,
					value: newValue,
					bindings: {},
					lambda: def && def.async ? true : false,
					lambdable: false,
					output: null
				});
				this.value[field].lambdable = def && !def.async;
			}
			else if (this.fieldMode == "mapRecursive" && label != "fixed") {
				var self = this;
				this.getUnmappedField().forEach(function(x) {
					// if it is a child 
					if (x == "$all" || x.indexOf(field + ".") == 0) {
						var xname = x.replace(/^.*\.([^.]+)$/, "$1");
						self.fieldsFrom(null, label).forEach(function(y) {
							if (newValue == "$all" || y.indexOf(newValue + ".") == 0) {
								var yname = y.replace(/^.*\.([^.]+)$/, "$1");
								if (xname == yname) {
									Vue.set(self.value, x, label + "." + y);
									self.mappedFields.push(x);
								}
							}
						})
					}
				});
				this.resetField();
			}
			// can set the full label in non label choice mode
			else if (label == null && !this.labelChoice) {
				Vue.set(this.value, field, newValue);
			}
			else {
				Vue.set(this.value, field, label && (newValue || label == "fixed") ? label + '.' + (newValue ? newValue : "") : null);
			}
		},
		getBindingsFor: function(field) {
			if (this.value[field] && this.value[field].bindings) {
				return this.value[field].bindings;
			}
			return null;
		},
		getObjectFor: function(field) {
			return this.value[field];
		},
		isFixedValue: function(field) {
			var value = this.value[field];
			return value != null && value.indexOf("fixed.") == 0;
		},
		getValueFor: function(field) {
			if (this.value[field] && this.value[field].value) {
				return this.value[field].value;
			}
			if (!this.labelChoice) {
				if (this.value[field] && this.value[field].indexOf("fixed.") == 0) {
					return this.value[field].substring("fixed.".length);
				}
				else {
					return this.value[field];
				}
			}
			else {
				return this.value[field]
					? this.value[field].substring(this.value[field].indexOf(".") + 1)
					: null;
			}
		},
		isComputedValue: function(field) {
			if (!this.allowComputed) {
				return false;
			}
			var value = this.getValueFor(field);
			return value && value.indexOf("=") == 0;
		},
		switchComputed: function(field) {
			var value = this.getValueFor(field);
			// go to non-computed
			if (value && value.indexOf("=") == 0) {
				value = value.substring(1);
			}
			else {
				value = "=" + value;
			}
			console.log("switching computed", field, this.getValueFor(field), value);
			this.setValue(field, value, 'fixed');
		},
		getLabelFor: function(field) {
			// if we have an object
			if (this.value[field] && this.value[field].label) {
				return this.value[field].label;
			}
			return this.value[field]
				? this.value[field].split(".")[0]
				: (this.sources.indexOf("fixed") >= 0 ? "fixed" : null);
		},
		isLambdable: function(field) {
			return this.value[field] && this.value[field].lambdable;
		}
	},
	watch: {
		to: function() {
			if (this.watchForChanges) {
				this.calculateFieldsToMap();
			}
		},
		value: {
			deep: true,
			handler: function() {
				this.$emit("changed");
			}
		}
	}
});

nabu.services.VueService(Vue.extend({
	methods: {
		round: function(number, amountOfDecimals) {
			var multiplier = Math.pow(10, amountOfDecimals);
			return Math.round(number * multiplier) / multiplier;
		},
		format: function(value, properties, page, cell, record, component) {
			if (!properties.format) {
				return value;
			}
			else if (properties.format == "checkbox") {
				return "<n-form-checkbox :value='value' />";
			}
			else if (value == null || typeof(value) == "undefined") {
				return null;
			}
			// formatting is optional
			else if (!properties.format || properties.format == "text") {
				return value;
			}
			else if (properties.format == "html") {
				return properties.html ? properties.html : value;
			}
			else if (properties.format == "link") {
				return "<a target='_blank' class='is-button is-variant-link is-spacing-none' ref='noopener noreferrer nofollow' href='" + value + "'>" + value.replace(/http[s]*:\/\/([^/]+).*/, "$1") + "</a>";
			}
			else if (properties.format == "date") {
				if (value && properties.isTimestamp) {
					value = new Date(value);
				}
				else if (value && properties.isSecondsTimestamp) {
					value = new Date(1000 * value);
				}
				return this.date(value, properties.dateFormat);
			}
			// backwards compatibility
			else if (properties.format == "dateTime") {
				return this.date(value, "dateTime");
			}
			else if (properties.format == "number") {
				return this.number(value, properties.amountOfDecimals, properties.retainTrailing);
			}
			else if (properties.format == "masterdata") {
				var serviceContext = null;
				if (component && component.page) {
					var pageInstance = this.$services.page.getPageInstance(component.page, component);
					serviceContext = pageInstance == null ? null : pageInstance.getServiceContext();
				}
				// we take the default field (title) which should be translated!
				return this.masterdata(value, serviceContext);
			}
			else if (properties.format == "javascript") {
				return this.javascript(value, properties.javascript, properties.state, properties.$value);
			}
			// otherwise we are using a provider
			else {
				var result = nabu.page.providers("page-format").filter(function(x) { return x.name == properties.format })[0]
					.format(value, properties, page, cell, record, component);
				return result;
			}
		},
		javascript: function(value, code, state, $value) {
			var $services = this.$services;
			if (code instanceof Function) {
				return code(value);
			}
			else {
				var result = (new Function('with(this) { return ' + code + ' }')).call({
					value: value,
					$value: $value,
					state: state,
					$services: this.$services
				});
				//var result = eval(code);
				if (result instanceof Function) {
					result = result.bind(this);
					result = result(value);
				}
				return result;
			}
		},
		date: function(date, format) {
			if (date instanceof Array) {
				var self = this;
				return date.map(function(single) {
					return self.date(single, format);
				});
			}
			else {
				if (!date) {
					return null;
				}
				else if (typeof(date) == "string") {
					date = new Date(date);
				}
				if (!format || format == "date") {
					format = "yyyy-MM-dd";
				}
				else if (format == "dateTime") {
					format = "yyyy-MM-ddTHH:mm:ss.SSS";
				}
				else if (format == "locale-date" && date.toLocaleDateString) {
					return date.toLocaleDateString();
				}
				else if (format == "locale-time" && date.toLocaleTimeString) {
					return date.toLocaleTimeString();
				}
				else if (format.indexOf("locale-time-") == 0) {
					format = format.substring("locale-time-".length);
					var parameters = {};
					var amountOfHours = format.length - format.replace(/h/g, "").length;
					if (amountOfHours == 1) {
						parameters.hour = "numeric";
					}
					else if (amountOfHours >= 2) {
						parameters.hour = amountOfHours + "-digit";
					}
					var amountOfMinutes = format.length - format.replace(/m/g, "").length;
					if (amountOfMinutes == 1) {
						parameters.minute = "numeric";
					}
					else if (amountOfMinutes >= 2) {
						parameters.minute = amountOfMinutes + "-digit";
					}
					var amountOfSeconds = format.length - format.replace(/s/g, "").length;
					if (amountOfSeconds == 1) {
						parameters.second = "numeric";
					}
					else if (amountOfSeconds >= 2) {
						parameters.second = amountOfSeconds + "-digit";
					}
					return new Date().toLocaleTimeString([], parameters);
				}
				else if (format == "locale" && date.toLocaleString) {
					return date.toLocaleString();
				}
				
				format = format.replace(/yyyy/g, date.getFullYear());
				format = format.replace(/yy/g, ("" + date.getFullYear()).substring(2, 4));
				format = format.replace(/dd/g, (date.getDate() < 10 ? "0" : "") + date.getDate());
				format = format.replace(/d/g, date.getDate());
				format = format.replace(/HH/g, (date.getHours() < 10 ? "0" : "") + date.getHours());
				format = format.replace(/H/g, date.getHours());
				format = format.replace(/mm/g, (date.getMinutes() < 10 ? "0" : "") + date.getMinutes());
				format = format.replace(/m/g, date.getMinutes());
				format = format.replace(/ss/g, (date.getSeconds() < 10 ? "0" : "") + date.getSeconds());
				format = format.replace(/s/g, date.getSeconds());
				format = format.replace(/[S]+/g, date.getMilliseconds());
				// we get an offset in minutes
				format = format.replace(/[X]+/g, Math.floor(date.getTimezoneOffset() / 60) + ":" + date.getTimezoneOffset() % 60);
				// do months last as they can introduce named months which might conflict with expressions in the above
				// e.g. "Sep" could trigger the millisecond replacement
				// replacing a month with "May" could trigger the single "M" replacement though
				// so first we replace the capital M with something that should never conflict
				if (nabu.utils.dates.days) {
					format = format.replace(/E/g, "#");
				}
				format = format.replace(/M/g, "=");
				format = format.replace(/====/g, this.$services.page.translate(nabu.utils.dates.months()[date.getMonth()]));
				format = format.replace(/===/g, this.$services.page.translate(nabu.utils.dates.months()[date.getMonth()]).substring(0, 3));
				format = format.replace(/==/g, (date.getMonth() < 9 ? "0" : "") + (date.getMonth() + 1));
				format = format.replace(/=/g, date.getMonth() + 1);
				
				// this was added later, hence the defensive check for projects that don't have this yet
				if (nabu.utils.dates.days) {
					format = format.replace(/####/g, this.$services.page.translate(nabu.utils.dates.days()[nabu.utils.dates.dayOfWeek(date)]));
					format = format.replace(/###/g, this.$services.page.translate(nabu.utils.dates.days()[nabu.utils.dates.dayOfWeek(date)]).substring(0, 3));   
				}
				format = format.replace(/##/g, (nabu.utils.dates.dayOfWeek(date) < 9 ? "0" : "") + (nabu.utils.dates.dayOfWeek(date) + 1));
				format = format.replace(/#/g, nabu.utils.dates.dayOfWeek(date) + 1);
				return format;
			}
		},
		masterdata: function(id, serviceContext) {
			if (!id) {
				return "";
			}
			var entry = this.$services.masterdata.entry(id);
			if (entry) {
				return entry.title ? entry.title : entry.name;
			}
			var category = this.$services.masterdata.category(id);
			if (category) {
				return category.title ? category.title : category.name;
			}
			return this.$services.masterdata.resolve(id, null, serviceContext);
		},
		number: function(input, amountOfDecimals, retainTrailing) {
			amountOfDecimals = amountOfDecimals == null ? 2 : parseInt(amountOfDecimals);
			if (typeof(input) != "number") {
				input = parseFloat(input);
			}
            var options = {};
            // we used to use toFixed, but it does do rounding, it just cuts off
            options.minimumFractionDigits = retainTrailing ? amountOfDecimals : 0;
            options.maximumFractionDigits = amountOfDecimals;
            return Number(input).toLocaleString(this.$services.page.getLocale(), options);
		},
		conventionize: function(value) {
			// we currently assume from lower camelcase to word
			return value.substring(0, 1).toUpperCase() + value.substring(1).replace(/([A-Z]+)/g, " $1");
		}
	}
}), { name: "nabu.page.services.Formatter" });
nabu.services.VueService(Vue.extend({
	data: function() {
		return {
			resolved: {},
			resolvers: {}
		}
	},
	created: function() {
		var self = this;
		this.resolver = nabu.utils.misc.BatchResolver(
			// resolver
			function(ids) { return self.$services.swagger.execute("nabu.cms.core.manage.node.rest.node.resolve", {ids:ids}) },
			// cacher
			function(key, value) { if (value) self.merge(key, value); return self.resolved[key] },
			// generator
			function(key) { Vue.set(self.resolved, key, {}); return self.resolved[key]; },
			// mapper
			function(result) { return result.id }
		);
	},
	methods: {
		// the ids is the input field we can use to input the ids to be searched
		// the id is the field in the returned values that can be used to extract the id again
		getResolver: function(operation, ids, id, operationProperties) {
			var additional = operationProperties ? JSON.stringify(operationProperties) : "";
			if (!this.resolvers[operation + "." + ids + additional]) {
				var self = this;
				Vue.set(this.resolved, operation + "." + ids + additional, {});
				var resolved = this.resolved[operation + "." + ids + additional];
				this.resolvers[operation + "." + ids + additional] = nabu.utils.misc.BatchResolver(
					// resolver
					function(idList) {
						var properties = {};
						if (operationProperties) {
							nabu.utils.objects.merge(properties, operationProperties);
						}
						properties[ids] = idList;
						return self.$services.swagger.execute(operation, properties);
					},
					// cacher
					function(key, value) { if (value) self.merge(resolved, key, value); return resolved[key] },
					// generator
					function(key) { Vue.set(resolved, key, {}); return resolved[key]; },
					// mapper
					function(result) { return result[id] }
				);
			}
			return this.resolvers[operation + "." + ids + additional];
		},
		resolve: function(operation, ids, id, value, operationProperties) {
			var additional = operationProperties ? JSON.stringify(operationProperties) : "";
			// without this, it goes into an infinite resolving loop
			// only if we use the merge() function, if we simply set the full value it doesn't
			if (this.resolved[operation + "." + ids + additional] && this.resolved[operation + "." + ids + additional][value]) {
				return this.resolved[operation + "." + ids + additional][value];
			}
			return this.getResolver(operation, ids, id, operationProperties)(value);
		},
		merge: function(resolved, key, value) {
			var self = this;
			if (!resolved[key]) {
				Vue.set(resolved, key, {});
			}
			Object.keys(value).map(function(childKey) {
				Vue.set(resolved[key], childKey, value[childKey]);	
			});
		}
	}
}), { name: "nabu.page.services.PageResolver" });
nabu.services.VueService(Vue.extend({
	data: function() {
		return {
			timer: null,
			width: 0,
			height: 0
		}
	},
	created: function() {
		var self = this;
		this.update();
		window.addEventListener("resize", function(event) {
			if (this.timer) {
				window.clearTimeout(this.timer);
			}
			// recalculate everything in 100ms
			this.timer = setTimeout(function() { self.update() }, 100);
		});
	},
	methods: {
		update: function() {
			// https://stackoverflow.com/questions/1248081/get-the-browser-viewport-dimensions-with-javascript
			this.width = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
			this.height = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
		}
	}
}), { name: "nabu.page.services.Resizer" });
Vue.service("aris", {
	methods: {
		getAmountOfAppliedOptions: function(container, component) {
			var self = this;
			var modifiers = this.getAvailableModifiers(container, component);
			var activeModifiers = Object.keys(modifiers).filter(function(key) {
				return self.isActiveModifier(container, component, key);
			}).length;
			var dimensions = this.getAvailableDimensions(component);
			var activeOptions = 0;
			dimensions.forEach(function(x) {
				activeOptions += x.options.filter(function(y) {
					return self.isActiveOption(container, component, x, y.name);
				}).length;
			});
			return activeOptions + activeModifiers;
		},
		isActiveModifier: function(container, childComponent, modifier) {
			return container.components[childComponent.name].modifiers.indexOf(modifier) >= 0;
		},
		getAvailableDimensions: function(childComponent) {
			var hierarchy = this.$services.page.getArisComponentHierarchy(childComponent.component);
			var dimensions = [];
			hierarchy.forEach(function(component) {
				if (component.dimensions) {
					component.dimensions.forEach(function(x) {
						var current = dimensions.filter(function(y) { return y.name == x.name })[0];
						if (!current) {
							current = {name: x.name };
							dimensions.push(current);
						}
						if (!current.options) {
							current.options = [];
						}
						// a dimension can exist across multiple components (being more specific in a certain extension)
						if (!current.components) {
							current.components = [];
						}
						current.components.push(component.name);
						// only add options that we don't know about yet
						if (current.options.length > 0) {
							x.options.forEach(function(y) {
								var option = current.options.filter(function(z) { return z.name == y.name })[0];
								if (option == null) {
									current.options.push(JSON.parse(JSON.stringify(y)));
								}
								// append the body so we see the full effect
								else if (option.body.indexOf(y.body) < 0) {
									option.body += "\n" + y.body;
								}
							});
						}
						else {
							nabu.utils.arrays.merge(current.options, x.options);
						}
					})
				}
			});
			// sort the dimensions alphabetically
			dimensions.sort(function(a, b) { return a.name.localeCompare(b.name) });
			return dimensions;
		},
		getAvailableModifiers: function(container, childComponent) {
			var current = container.components[childComponent.name].variant;
			var available = {};
			this.getAvailableVariants(childComponent).filter(function(x) {
				return x.name == "default" || x.name == current;
			}).forEach(function(x) { 
				if (x.modifiers) {
					x.modifiers.forEach(function(y) {
						if (available[y] == null) {
							available[y] = [];
						}
						available[y].push({
							variant: x.name,
							component: x.component
						});
					})
				} 
			});
			return available;
		},
		isActiveOption: function(container, childComponent, dimension, option) {
			return container.components[childComponent.name].options.indexOf(dimension.name + "_" + option) >= 0;
		},
		getAvailableVariants: function(childComponent) {
			var variants = [];
			this.$services.page.getArisComponentHierarchy(childComponent.component).forEach(function(component) {
				if (component.variants != null) {
					component.variants.forEach(function(variant) {
						var clone = JSON.parse(JSON.stringify(variant));
						clone.component = component.name;
						variants.push(clone);
					});
				}
			});
			return variants;
		},
		listActiveOptions: function(container, childComponent, dimension) {
			if (!container || !container.components[childComponent.name]) {
				return [];
			}
			var active = container.components[childComponent.name].options.filter(function(x) {
				return x.indexOf(dimension.name + "_") == 0;
			}).map(function(x) {
				return x.substring((dimension.name + "_").length);
			});
			return active == null ? [] : active;
		},
		listActiveModifiers: function(container, childComponent) {
			var active = container && container.components[childComponent.name] ? container.components[childComponent.name].modifiers : null;
			return active == null ? [] : active;
		},
		listActive: function(container, childComponent) {
			var active = [];
			var self = this;
			nabu.utils.arrays.merge(active, this.listActiveModifiers(container, childComponent).map(function(x) {
				return {
					name: x,
					dimension: "modifier"
				}
			}));
			this.getAvailableDimensions(childComponent).forEach(function(dimension) {
				nabu.utils.arrays.merge(active, self.listActiveOptions(container, childComponent, dimension).map(function(x) {
					return {
						name: x,
						dimension: dimension.name
					}
				}));
			});
			return active.map(function(x) {
				return {
					name: x.name,
					dimension: x.dimension,
					condition: container.components[childComponent.name].conditions[x.dimension + '_' + x.name]
				}
			});
		}
	}
});
// TODO the page.content.properties don't seem to serve a function currently
// i _think_ the idea was to use it as <meta> tags in the header when the page is routed

if (!nabu) { var nabu = {} };
if (!nabu.page) { nabu.page = {}}

nabu.page.provide = function(spec, implementation) {
	if (!nabu.page.state) {
		nabu.page.state = { providers: [] }
	}
	if (!nabu.page.state.providers[spec]) {
		nabu.page.state.providers[spec] = [];
	}
	nabu.page.state.providers[spec].push(implementation);
}

nabu.page.providers = function(spec) {
	return nabu.page.state && nabu.page.state.providers[spec] ? nabu.page.state.providers[spec] : [];
}

nabu.page.instances = {};

nabu.services.VueService(Vue.extend({
	services: ["swagger", "user", "cookies"],
	data: function() {
		return {
			// the active tab on a page, we want to be able to add additional tabs and keep the last active for the duration of the editing session
			// we want the component configuration by default
			// other options are: container (cell/row), styling (aris), triggers
			activeSubTab: "component",
			// by default we assume a single configuration tab, but more complex components might have more
			availableSubTabs: [],
			showBreadcrumbs: true,
			showRawTranslations: false,
			
			// you can globally activate views
			activeViews: [],
			chosenRoute: null,
			mouseX: 0,
			mouseY: 0,
			counter: 1,
			title: null,
			theme: null,
			restrictToTheme: true,
			home: null,
			homeUser: null,
			pages: [],
			loading: true,
			// application properties
			properties: [],
			environment: null,
			environmentProperties: [],
			// the devices for this application
			devices: [],
			// application styles
			styles: [],
			// templates available for use
			templates: [],
			// full page templates that are available for use
			pageTemplates: [],
			// functions
			functions: [],
			// custom content
			contents: [],
			// any imports
			imports: [],
			applicationState: [],
			translations: [],
			lastCompiled: null,
			customStyle: null,
			cssStep: null,
			editable: false,
			testable: false,
			wantEdit: false,
			copiedRow: null,
			copiedCell: null,
			useEval: false,
			cssLastModified: null,
			cssError: null,
			functionError: null,
			disableReload: true,
			validations: [],
			googleSiteVerification: null,
			// the page we are editing?
			editing: null,
			dragItems: [],
			variables: {},
			geoRefusalTimeout: null,
			location: null,
			showConsole: false,
			// pages can report stuff to show in the console (mostly events)
			reports: [],
			// features that are enabled (necessary for runtime stuff)
			enabledFeatures: [],
			// when testing, you can check the available features and toggle them (either on or off)
			availableFeatures: [],
			toggledFeatures: [],
			// user specific settings
			users: [],
			// the drag/drop doesn't work very well in javafx webview?
			dragTypes: [],
			inspectContent: null,
			consoleTab: null,
			branding: {},
			// the current branding can be a combination of core branding and localized branding
			currentBranding: {},
			defaultLocale: null,
			copiedType: null,
			copiedContent: null,
			rendering: 0,
			// we start off false to mitigate initial faulty stable detection
			stable: false,
			stableTimer: null,
			// we actually start with true, we are assuming you have a v-if bound to this boolean
			// we don't want the cookie banner to temporarily visually appear until we can establish whether or not you accepted them
			// due to the loading strategy this should not occur but still...
			hasAcceptedCookies: true,
			// functions that are run whenever cookie settings change
			cookieHooks: [],
			// you can set a cookie provider, the key is the name of the cookie provider, the value is an array of regexes (or names) of the cookies that belong to this provider
			cookieProviders: {},
			// whether or not to use aris
			useAris: true,
			aris: null,
			// you can copy styling for later pasting
			copiedStyling: null,
			notificationStyle: "success-outline",
			// promise results from conditionals
			conditionalResults: {}
		}
	},
	activate: function(done) {
		// intercept all cookie actions
		this.interceptCookies();
		// make sure we fix the cookie stuff, this uses the cookies services
		// we do this periodically to catch evil scripts!
		this.synchronizeCookies(true);
		
		// check if we have already accepted the cookies
		this.calculateAcceptedCookies();
		
		var self = this;
		// non-reactive
		this.pageCounter = 0;
		//document.title = "Loading...";
		window.addEventListener("paste", function(event) {
			if (self.canEdit()) {
				var data = event.clipboardData.getData("text/plain");
				if (data) {
					try {
						var parsed = JSON.parse(data);
						if (parsed && parsed.type == "page-row") {
							self.copiedRow = parsed.content;
							self.copiedCell = null;
						}
						else if (parsed && parsed.type == "page-cell") {
							self.copiedCell = parsed.content;
							self.copiedRow = null;
						}
						else if (parsed.type && parsed.content) {
							self.copiedType = parsed.type;
							self.copiedContent = parsed.content;
						}
					}
					catch (exception) {
						// ignore
					}
				}
			}
		});
		window.addEventListener("keydown", function(event) {
			//192 in firefox and 222 in chrome?
			if (self.canEdit() && (event.code == "Backquote" || event.which == 121)) {
				self.showConsole = !self.showConsole;
			}
		});
		this.isServerRendering = navigator.userAgent.match(/Nabu-Renderer/);
		this.$services.swagger.offlineHandler = function() {
			// if you have permission to still view the application while offline (e.g. tester), you shouldn't end up here anyway
			// so we don't check the canTest()!
			setTimeout(function() {
				self.$services.router.route("offline", null, null, true);
			}, 1);
		}
		// any cookies you have provided that are not set to auto accept will be added to the cookie providers
		nabu.page.providers("page-cookies").filter(function(x) { return x.name && !x.accept }).forEach(function(x) {
			var group = x.group ? x.group : x.name;
			var name = x.name;
			if (!self.cookieProviders[group]) {
				Vue.set(self.cookieProviders, group, []);
			}
			if (self.cookieProviders[group].indexOf(x.name) < 0) {
				self.cookieProviders[group].push(x.name);
			}
		});
		
		this.activate(done, true);
	},
	clear: function(done) {
		Object.keys(nabu.page.instances).forEach(function(key) {
			nabu.page.instances[key].emit("$clear", {});	
		});
		this.activate(done ? done : function() {}, false);
	},
	computed: {
		enumerators: function() {
			var providers = {};
			nabu.page.providers("page-enumerate").map(function(x) {
				providers[x.name] = x;
			});
			return providers;
		},
		isSsr: function() {
			return navigator.userAgent.match(/Nabu-Renderer/);
		}
	},
	created: function() {
		var self = this;
		document.addEventListener("keydown", function(event) {
			if (event.ctrlKey && event.altKey && event.keyCode == 88) {
				if (self.canEdit()) {
					self.wantEdit = !self.wantEdit;
				}
				else {
					self.$services.router.route("login", null, null, true);
				}
				event.preventDefault();
			}
			else if (self.canEdit()) {
				if (event.key && event.key.toLowerCase() == "f1") {
					if (self.activeViews.indexOf("conditions") < 0) {
						self.activeViews.push("conditions");
					}
					event.stopPropagation();
					event.preventDefault();
				}
				else if (event.key && event.key.toLowerCase() == "f2") {
					if (self.activeViews.indexOf("styling") < 0) {
						self.activeViews.push("styling");
					}
					event.stopPropagation();
					event.preventDefault();
				}
			}
		});
		document.addEventListener("keyup", function(event) {
			if (self.canEdit()) {
				if (event.key && event.key.toLowerCase() == "f1") {
					var index = self.activeViews.indexOf("conditions");
					if (index >= 0) {
						self.activeViews.splice(index, 1);
					}
				}
				else if (event.key && event.key.toLowerCase() == "f2") {
					var index = self.activeViews.indexOf("styling");
					if (index >= 0) {
						self.activeViews.splice(index, 1);
					}
				}
			}
		});
	},
	methods: {
		// cleanup internal variables like $position etc
		cleanup: function(data) {
			var self = this;
			if (data instanceof Array) {
				data.forEach(this.cleanup);
			}
			else if (this.isObject(data)) {
				Object.keys(data).forEach(function(key) {
					if (key.indexOf("$") == 0) {
						delete data[key];
					}
					else {
						self.cleanup(data[key]);
					}
				});
			}
			return data;
		},
		nullify: function(data) {
			var self = this;
			if (data instanceof Array) {
				data.forEach(this.nullify);
			}
			else {
				Object.keys(data).forEach(function(key) {
					if (data[key] != null && self.$services.page.isObject(data[key])) {
						data[key] = self.nullify(data[key]);
					}
					// TODO: if we have an array of complex objects, we need to nullify every one of them, if the result is null for a one, we need to remove it from the array
					if (data[key] instanceof Array && data[key].length == 0) {
						delete data[key];
					}
					if (data[key] == null) {
						delete data[key];
					}
				});
				if (Object.keys(data).length == 0) {
					return null;
				}
			}
			return data;
		},
		getPrettyNameForTypography: function(target) {
			if (target.state && target.state.content) {
				var content = target.state.content.trim();
				// if the content is a pure variable (e.g. for basic table layouts), we don't want the curlies
				if (content.substring(0, 1) == "{") {
					content = content.substring(1);
				}
				if (content.substring(content.length - 1) == "}") {
					content = content.substring(0, content.length - 1);
				}
				// if we don't have spaces, we camel case it (e.g. in the variable example)
				//if (content.indexOf(" ") < 0) {
					content = this.prettify(content);
				//}
				return content;
			}
		},
		isThemeCompliant: function(entry) {
			if (this.theme != null && this.restrictToTheme) {
				return entry.theme == this.theme;
			}
			return true;
		},
		isActiveView: function(view) {
			return this.activeViews.indexOf(view) >= 0;
		},
		// the handler will be called with the resulting component instance once it is done rendering
		renderComponent: function(page, cell, currentInstance, routeAlias, bindings, handler, customValueFunction) {
			var properties = {};
			if (bindings) {
				var self = this;
				var pageInstance = this.$services.page.getPageInstance(page, currentInstance);
				Object.keys(bindings).forEach(function(key) {
					var binding = bindings[key];
					if (binding != null) {
						var value = customValueFunction ? customValueFunction(binding) : self.$services.page.getBindingValue(pageInstance, binding, self);
						if (value != null) {
							self.$services.page.setValue(properties, key, value);
						}
					}
				});
			}
			var target = document.createElement("div");
			this.$services.router.route(routeAlias, properties, target, true).then(handler);
		},
		isPartOfTemplate: function(target) {
			return target.templateReferenceId && !target.templateVersion;
		},
		getTemplateRoot: function(page, target, highest) {
			var path = this.getTargetPath(page.content, target.id);	
			// for nested templates you can wonder whether you want to highest (nearest the root) or lowest (nearest the target)
			// if we want the "highest" root, we want the one m
			if (!highest) {
				path.reverse();
			}
			return path.filter(function(x) {
				return x.templateReferenceId && x.templateVersion;
			})[0];
		},
		getBindings: function(bindings, instance, state) {
			var self = this;
			var parameters = {};
			var pageInstance = self.$services.page.getPageInstance(instance.page, instance);
			Object.keys(bindings).map(function(key) {
				if (bindings[key] != null) {
					var value = null;
					
					// need to check if you want to access local state
					var index = bindings[key].indexOf(".");
					var resolved = false;
					if (index > 0) {
						var variableName = bindings[key].substring(0, index);
						// if we have it in state, that wins
						if (state && state.hasOwnProperty(variableName)) {
							value = self.$services.page.getValue(state, bindings[key]);
							resolved = true;
						}
					}
					if (!resolved) {
						value = self.$services.page.getBindingValue(pageInstance, bindings[key], instance);
					}
					if (value != null) {
						self.$services.page.setValue(parameters, key, value);
					}
				}
			});
			return parameters;
		},
		updateToLatestTemplate: function(target, recursive) {
			var self = this;
			if (target.templateReferenceId) {
				var self = this;
				var latest = this.templates.filter(function(x) {
					return x.id == target.templateReferenceId;
				})[0];
				var instance = JSON.parse(latest.content).content;
				var getOriginal = function(instance, id) {
					if (instance.id == id) {
						return instance;
					}
					else if (instance.cells) {
						return instance.cells.reduce(function(all, x) {
							return all == null ? getOriginal(x, id) : all;
						}, null);
					}
					else if (instance.rows) {
						return instance.rows.reduce(function(all, x) {
							return all == null ? getOriginal(x, id) : all;
						}, null);
					}
				}
				var recursiveUpdate = function(x) {
					var original = getOriginal(instance, x.templateFragmentId);
					if (original && original.aris) {
						Vue.set(x, "aris", original.aris);
						self.$services.page.setRerender(x.aris);
					}
					if (x.cells) {
						x.cells.forEach(recursiveUpdate);
					}
					if (x.rows){
						x.rows.forEach(recursiveUpdate);
					}
				}
				recursiveUpdate(target);
				target.templateVersion = latest.templateVersion;
			}
			// we also recurse into templates, that means if a template is part of a larger template and not updated in the overall template, it might still be updated here
			// but on the flipside, if you just nest natural templates (the more likely usecase), you want all of them to be updated
			if (recursive) {
				if (target.cells) {
					target.cells.forEach(function(x) {
						self.updateToLatestTemplate(x, true);
					});
				}
				if (target.rows) {
					target.rows.forEach(function(x) {
						self.updateToLatestTemplate(x, true);
					});
				}
			}
		},
		watchField: function(pageInstance, field, handler) {
			if (field.indexOf("page.") == 0) {
				field = field.substring("page.".length);
			}
			var self = this;
			var unwatch = null;
			var current = pageInstance.get(field);
			handler(current);
			var parentField = field;
			while (current == null && parentField.indexOf(".") >= 0) {
				var index = parentField.lastIndexOf(".");
				if (index > 0) {
					parentField = parentField.substring(0, index);
					current = pageInstance.get(parentField);
				}
			}
			// if it doesn't exist yet, keep an eye on the page state
			// we tried to be more specific and watch direct parents but this _somehow_ failed
			if (current == null) {
				unwatch = pageInstance.$watch("variables", function(newValue) {
					var result = pageInstance.get("page." + field);
					if (result != null) {
						handler(result);
					}
					unwatch();
					self.watchField(pageInstance, field, handler);
				}, {deep: true});
			}
			// we are not watching the field, but rather a parent
			else if (parentField != field) {
				unwatch = pageInstance.$watch("variables." + parentField, function(newValue) {
					var result = pageInstance.get("page." + field);
					if (result != null) {
						handler(result);
					}
					// always unwatch and restart, not sure how it evolves
					unwatch();
					self.watchField(pageInstance, field, handler);
				}, {deep: true});
			}
			else {
				var watchKey = "variables." + field;
				unwatch = pageInstance.$watch(watchKey, function(newValue) {
					handler(newValue);
					unwatch();
					// may have unset to null, changed to a different array,...
					self.watchField(pageInstance, field, handler);
				}, {deep: true});
			}
			// return a function to stop watching
			return function() {
				if (unwatch != null) {
					unwatch();
				}
			}
		}, 
		getSwaggerOperationInputDefinition: function(operationId) {
			var result = {properties: {}};
			var self = this;
			if (operationId) {
				var operation = this.$services.swagger.operations[operationId];
				if (operation && operation.parameters) {
					var self = this;
					operation.parameters.forEach(function(key) {
						if (key.schema) {
							result.properties[key.name] = self.$services.swagger.resolve(key.schema);
						}
						else {
							result.properties[key.name] = key;
						}
					});
				}
				result.properties["$serviceContext"] = {
					type: "string"
				}
			}
			return result;
		},
		getSwaggerOperationOutputDefinition: function(operationId) {
			var self = this;
			var result = {};
			if (operationId != null) {
				var operation = this.$services.swagger.operations[operationId];
				if (operation && operation.responses["200"]) {
					var response = operation.responses["200"];
					var schema = null;
					if (response && response.schema) {
						schema = this.$services.swagger.resolve(response.schema);
						if (schema) {
							result = schema;
						}
					}
				}
			}
			return result;
		},
		listCloseableItems: function(page, value, includeEventBased) {
			var result = [];
			var search = function(container) {
				if (container.closeable) {
					result.push(container);
				}
				else if (container.on && includeEventBased) {
					result.push(container);
				}
				if (container.cells) {
					container.cells.forEach(search);
				}
				if (container.rows) {
					container.rows.forEach(search);
				}
			}	
			search(page.content);
			if (value) {
				var pageInstance = this.getPageInstance(page);
				var self = this;
				result = result.filter(function(x) {
					return self.formatPageItem(pageInstance, x).toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
			}
			return result;
		},
		isCloseable: function(target) {
			// it is closeable when you have an event-driven opening (old school)
			// or if you set show toggle!
			// or when you specifically set that it can be closed
			// or when it is rendered somewhere else than the page
			return target.on || target.closeable || (target.target != 'page' && target.target != null);	
		},
		// calculate all the available actions in a page
		getAvailableActions: function(pageInstance, value) {
			var self = this;
			// we care about the available actions, not the input/output etc yet
			// if two actions are named the same but have different input/output, it doesn't matter at this point
			// in the next phase, you select an actual target
			// at that point we have the exact definition of the action
			var available = {};
			pageInstance.getActions().forEach(function(action) {
				available[action.name] = action;
			});
			this.getSingularComponents(pageInstance).forEach(function(component) {
				self.getActions(component, null, pageInstance).forEach(function(action) {
					available[action.name] = action;
				});
			});
			// we also need to check for renderers
			this.getAvailableRenderers(pageInstance.page).forEach(function(target) {
				var renderer = self.getRenderer(target.renderer);
				self.getActions(renderer, target, pageInstance).forEach(function(action) {
					available[action.name] = action;
				});	
			});
			var result = Object.values(available);
			result.sort(function(a, b) {
				return a.name.localeCompare(b.name);
			});
			if (value) {
				result = result.filter(function(x) {
					return x.name.toLowerCase().indexOf(value.toLowerCase()) >= 0
						|| (x.title && x.title.toLowerCase().indexOf(value.toLowerCase()) >= 0);
				})
			}
			return result;
		},
		// get all SINGULAR components
		// components might be registered multiple times (e.g. alias_ and instance_)
		// multiple components might be registered to the same cell (through older means like arbitrary, repeat,...)
		getSingularComponents: function(pageInstance) {
			var components = [];
			Object.keys(pageInstance.components).forEach(function(key) {
				if (key instanceof Number || key.match(/^[0-9]+$/)) {
					if (pageInstance.components[key] && (!(pageInstance.components[key] instanceof Array))) {
						components.push(pageInstance.components[key]);
					}
				}	
			});
			return components;
		},
		// once we've chosen an action, we want to list all the targets that support this
		// we always want a target cell or row
		// this is for a number of reasons:
		// - we want to streamline with renderers
		// - cells and rows always have an identity and metadata like name etc, components might not
		// this provides a better listing
		// in the new way of doing things, normal cells should only every have a single component
		// page arbitrary is (hopefully) deprecated and the old repeat is gone as well
		getActionTargets: function(pageInstance, action, value) {
			var targets = [];
			pageInstance.getActions().forEach(function(x) {
				if (x.name == action) {
					targets.push({
						name: pageInstance.page.name,
						id: "$page",
						runAction: pageInstance.runAction
					});
				}
			})
			var self = this;
			this.getSingularComponents(pageInstance).forEach(function(component) {
				var hasAction = self.getActions(component, null, pageInstance).filter(function(x) {
					return x.name == action;
				}).length > 0;
				if (hasAction) {
					targets.push(component.$$cell ? component.$$cell : component.target);
				}
			});
			// we also need to check for renderers
			// no longer necessary, they are included in the above loop (if they are rendered!)
			/*
			this.getAvailableRenderers(pageInstance.page).forEach(function(target) {
				var renderer = self.getRenderer(target.renderer);
				var hasAction = self.getActions(renderer, target, pageInstance).filter(function(x) {
					return x.name == action;
				}).length > 0;
				if (hasAction) {
					targets.push(target);
				}
			});
			*/
			if (value) {
				targets = targets.filter(function(x) {
					return x.name && x.name.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				})
			}
			return targets;
		},
		// we want to look for all components that implement a particular specification
		getSpecificationTargets: function(pageInstance, specification) {
			var targets = [];
			var self = this;
			this.getSingularComponents(pageInstance).forEach(function(component) {
				if (component.getSpecifications && component.getSpecifications().indexOf(specification) >= 0) {
					targets.push(component.$$cell);
				}
			});
			this.getAvailableRenderers(pageInstance.page).forEach(function(target) {
				var renderer = self.getRenderer(target.renderer);
				if (renderer.getSpecifications && renderer.getSpecifications(target).indexOf(specification) >= 0) {
					targets.push(target);
				}
			});
			return targets;
		},
		// the action target is _always_ the id, but it might be a cell, a row or a component within a cell
		// can't combine cell renderers with cell content for now, there is only one id
		// though we do keep an additional reference under instance_<id> to the actual content...
		getActionTarget: function(pageInstance, actionTarget) {
			if (actionTarget == "$page") {
				var interestingPageInstance = pageInstance;
				while (interestingPageInstance.fragmentParent) {
					interestingPageInstance = interestingPageInstance.fragmentParent;
				}
				return interestingPageInstance;
			}
			var target = pageInstance.components[actionTarget];
			if (!target && pageInstance.fragmentParent) {
				target = this.getActionTarget(pageInstance.fragmentParent, actionTarget);
			}
			return target;
		},
		getActionOutput: function(pageInstance, actionTarget, action) {
			var target = this.getActionTarget(pageInstance, actionTarget);
			if (target) {
				var result = this.getActions(target, null, pageInstance).filter(function(x) {
					return x.name == action;
				})[0];
				if (result && result.output && Object.keys(result.output).length > 0) {
					return result.output;
				}
			}
			return null;
		},
		getActionInput: function(pageInstance, actionTarget, action) {
			var target = this.getActionTarget(pageInstance, actionTarget);
			if (target) {
				var result = this.getActions(target, null, pageInstance).filter(function(x) {
					return x.name == action;
				})[0];
				if (result && result.input && Object.keys(result.input).length > 0) {
					return result.input;
				}
			}
			return null;
		},
		// combine all the actions a component supports (including specifications)
		getState: function(component) {
			var state = {};
			if (component.getSpecifications) {
				var specifications = component.getSpecifications();
				var implemented = nabu.page.providers("page-specification").filter(function(x) {
					return specifications.indexOf(x.name) >= 0;
				});
				implemented.forEach(function(x) {
					if (x.state) {
						nabu.utils.objects.merge(state, x.state);
					}
				});
			}
			if (component.getState) {
				nabu.utils.objects.merge(state, component.getState());
			}
		},
		// combine all the actions a component supports (including specifications)
		getActions: function(component, target, pageInstance) {
			var actions = [];
			if (component.getActions) {
				nabu.utils.arrays.merge(actions, component.getActions(target, pageInstance, this.$services));
			}
			if (component.getSpecifications) {
				var specifications = component.getSpecifications(target);
				var implemented = nabu.page.providers("page-specification").filter(function(x) {
					return specifications.indexOf(x.name) >= 0;
				});
				implemented.forEach(function(x) {
					if (x.actions) {
						nabu.utils.arrays.merge(actions, x.actions);
					}
				});
			}
			// we also want to scan renderers
			if (component.target || component.cell || component.row) {
				var rendererTarget = component.target ? component.target : (component.cell ? component.cell : component.row);
				if (rendererTarget && rendererTarget.renderer) {
					var renderer = this.getRenderer(rendererTarget.renderer);
					if (renderer && renderer.getActions) {
						nabu.utils.arrays.merge(actions, renderer.getActions(rendererTarget, pageInstance, this.$services));
					}
					if (renderer && renderer.getSpecifications) {
						var specifications = renderer.getSpecifications(rendererTarget);
						var implemented = nabu.page.providers("page-specification").filter(function(x) {
							return specifications.indexOf(x.name) >= 0;
						});
						implemented.forEach(function(x) {
							if (x.actions) {
								nabu.utils.arrays.merge(actions, x.actions);
							}
						});
					}
				}
			}
			return actions;
		},
		getRenderers: function(type) {
			return nabu.page.providers("page-renderer").filter(function(x) { return x.type == null || x.type == type || (x.type instanceof Array && x.type.indexOf(type) >= 0) });
		},
		getRenderer: function(name) {
			return nabu.page.providers("page-renderer").filter(function(x) { return x.name == name })[0];
		},
		getRendererConfiguration: function(name) {
			var renderer = nabu.page.providers("page-renderer").filter(function(x) { return x.name == name })[0];
			return renderer ? renderer.configuration : null
		},
		// we often need to query the renderer state definition while determining the page state definition
		// this can lead to recursive lookups, so instead, we pass the page state definition to the renderer, it should not try to calculate it on its own
		// this _will_ lead to infinite loops
		getRendererState: function(name, target, page, pageParameters) {
			var renderer = nabu.page.providers("page-renderer").filter(function(x) { return x.name == name })[0];
			var state = renderer && renderer.getState ? renderer.getState(target, page, pageParameters, this.$services) : null;	
			if (!state) {
				state = {properties:{}};
			}
			else if (!state.properties) {
				state.properties = {};
			}
			if (renderer.getSpecifications) {
				var specifications = renderer.getSpecifications(target);
				var implemented = nabu.page.providers("page-specification").filter(function(x) {
					return specifications.indexOf(x.name) >= 0;
				});
				implemented.forEach(function(x) {
					if (x.state) {
						nabu.utils.objects.merge(state.properties, x.state);
					}
				});
			}
			return state;
		},
		// do the reverse from input binding: apply the renderer state to the pageInstance
		applyRendererParameters: function(pageInstance, target, state, dumbMerge) {
			console.log("applying parameters", target, state, dumbMerge);
			if (target && target.rendererBindings) {
				var self = this;
				// note that we also explicitly set null values to allow you to unset
				Object.keys(target.rendererBindings).forEach(function(key) {
					if (target.rendererBindings[key] != null) {
						var merged = false;
						// basic merging works when you are doing field-level bindings
						// but suppose you have an update form and map an entire record to it
						// the record you map is from an update that was triggered by a button in a table
						// if you just merge back the full record into the event, it will still not modify the record in the original table
						// but if we merge it one-deep, we will do a by-reference merge into the necessary objects
						if (!dumbMerge) {
							var existing = pageInstance.get(target.rendererBindings[key]);
							if (existing && self.isObject(existing)) {
								self.mergeObject(existing, self.$services.page.getValue(state, key));
								merged = true;
							}
						}
						if (!merged) {
							pageInstance.set(target.rendererBindings[key], self.$services.page.getValue(state, key));
						}
					}
				});
			}
		},
		calculateAcceptedCookies: function() {
			this.hasAcceptedCookies = !!this.$services.cookies.get("cookie-settings");	
		},
		getAllowedCookies: function() {
			// these technical cookies are always allowed
			// JSESSIONID allows for server-side sessions
			// language allows the user to choose a language, even if not logged in at the time of choosing
			// the device cookie allows for remembering existing user, validating new devices, notifying the user if a new device is used...
			// the realm cookie (in combination with te device cookie) actually holds the secret to remembering users
			// the cookie settings allow to store additional whitelisted cookies
			var allowedCookies = ["JSESSION", "language", "Device-moduleWeb", "Realm-moduleWeb", "cookie-settings", "geolocation-refused"];
			// check if we have already whitelisted cookies
			var cookieSettings = this.getCookieSettings();
			// each allowed cookie setting is either a name of a cookie, a regex of a cookie or the name of a provider that _has_ regexes
			// the provider is simply to bundle the regexes etc into a readable and reusable name
			var self = this;
			cookieSettings.forEach(function(x) {
				allowedCookies.push(x);
				if (self.cookieProviders[x] instanceof Array) {
					nabu.utils.arrays.merge(allowedCookies, self.cookieProviders[x]);
				}
			});
			// you can whitelist cookies this way without specific user acceptance (e.g. they are technical)
			nabu.page.providers("page-cookies").filter(function(x) { return x.name && x.accept }).forEach(function(x) {
				allowedCookies.push(x.name);
			});
			return allowedCookies;
		},
		getCookieSettings: function() {
			var allowedCookies = [];
			var cookieSettings = this.$services.cookies.get("cookie-settings");
			if (cookieSettings) {
				try {
					nabu.utils.arrays.merge(allowedCookies, JSON.parse(cookieSettings));
				}
				catch (exception) {
					// ignore, someone messed with it?
				}
			}
			return allowedCookies;
		},
		// check if a component is in fact a page
		isPage: function(component) {
			return component && component.$options && component.$options.template && (component.$options.template == "#nabu-page" || component.$options.template == "#nabu-page-optimized");
		},
		pasteItem: function(item) {
			var content = null;
			if (this.isCopied(item)) {
				content = this.copiedContent;
				this.copiedContent = null;
				this.copiedType = null;
			}	
			return content;
		},
		// whether or not this type of item is in the "clipboard"
		isCopied: function(item) {
			return this.copiedType == item;
		},
		// copy it to the clipboard
		copyItem: function(item, content, clone) {
			// if not specified, we set to true
			if (clone == null) {
				clone = true;
			}
			nabu.utils.objects.copy({
				type: item,
				content: content
			});
			this.copiedType = item;
			this.copiedContent = clone ? JSON.parse(JSON.stringify(content)) : content;
		},
		suggestDevices: function(value) {
			var devices = this.devices.map(function(x) { return x.name }); 
			if (value && value.match(/[0-9]+/)) { 
				devices.unshift(value) 
			}
			return devices;
		},
		device: function(operator, name) {
			if (name == null) {
				name = operator.replace(/.*?([\w]+).*?/, "$1").trim();
				operator = operator.replace(/([^\w]+)?.*/, "$1").trim();
			}
			return this.isDevice([{operator: operator, name: name}]);
		},
		isDevice: function(devices) {
			var actual = this.$services.resizer.width;
			for (var i = 0; i < devices.length; i++) {
				if (devices[i].operator && devices[i].name) {
					var operator = devices[i].operator;
					var width = 0;
					if (devices[i].name.match(/[0-9]+/)) {
						width = parseInt(devices[i].name);
					}
					else {
						var device = this.devices.filter(function(x) { return x.name == devices[i].name })[0];
						if (device && device.width) {
							width = parseInt(device.width);
						}
						else if (device && !device.width && device.name == "wide") {
							width = 2560;
						}
						// the default devices!
						else if (device && !device.width && device.name == "desktop") {
							width = 1280;
						}
						else if (device && !device.width && device.name == "tablet") {
							width = 960;
						}
						else if (device && !device.width && device.name == "phone") {
							width = 512;
						}
					}
					// infinitely big, so matches any query requesting larger
					if (width == 0) {
						if (operator != ">" && operator != ">=") {
							return false;
						}
					}
					else if (operator == "<" && actual >= width) {
						return false;
					}
					else if (operator == "<=" && actual > width) {
						return false;
					}
					else if (operator == ">" && actual <= width) {
						return false;
					}
					else if (operator == ">=" && actual < width) {
						return false;
					}
					else if (operator == "==" && actual != width) {
						return false;
					}
				}
			}
			return true;
		},
		getLocale: function() {
			// does the user have an explicitly chosen locale?
			// TODO
			if (this.defaultLocale) {
				return this.defaultLocale;
			}
			else if (navigator.language) {
				return navigator.language;
			}
			// IE
			else if (navigator.userLanguage) {
				return navigator.userLanguage;
			}
			// also IE
			else if (navigator.browserLanguage) {
				return navigator.browserLanguage;
			}
			// default
			else {
				return "en-US";
			}
		},
		mergeObject: function(into, from) {
			var keys = [];
			Object.keys(from).forEach(function(key) {
				if (into[key] instanceof Array && from[key] instanceof Array) {
					into[key].splice(0);
					nabu.utils.arrays.merge(into[key], from[key]);
				}
				else {
					Vue.set(into, key, from[key]);
				}
				keys.push(key);
			});
			// delete the current keys
			Object.keys(into).forEach(function(key) {
				if (keys.indexOf(key) < 0) {
					into[key] = null;
					delete into[key];
				}
			});
		},
		showContent: function(content) {
			this.inspectContent = content;
			this.consoleTab = "inspect";
			this.showConsole = true;
		},
		downloadService: function(operation, parameters, fileName, acceptContentType) {
			var self = this;
			var promise = this.$services.q.defer();
			parameters["$$rawMapper"] = function(response, raw) {
				if (raw.responseType == "blob") {
					response = raw.response;
				}
				else if (raw.responseType == "arraybuffer") {
					response = new Blob(raw.response);
				}
				else if (raw.responseText != null) {
					//response = nabu.utils.binary.blob(raw.responseText, raw.getResponseHeader("Content-Type"));
					response = new Blob([raw.responseText], { type: raw.getResponseHeader("Content-Type")});
				}
				return response;
			};
			if (acceptContentType) {
				parameters["$accept"] = acceptContentType;
			}
			this.$services.swagger.execute(operation, parameters).then(function(result) {
				self.downloadBlob(result, fileName).then(promise, promise);
			}, promise);
			return promise;
		},
		downloadBlob: function(blob, fileName) {
			var promise = this.$services.q.defer();
			var reader = new FileReader();
			reader.readAsDataURL(blob);
			reader.onload = function() {
				var url = reader.result;
				var tag = document.createElement("a");
				document.body.appendChild(tag);
				tag.setAttribute("download", fileName ? fileName : (blob.name ? blob.name : ""));
				tag.setAttribute("href", url);
				tag.click();
				document.body.removeChild(tag);
				promise.resolve();
			};
			return promise;
		},
		download: function(url, errorHandler, successHandler) {
			// use iframes to better handle problems when they occur (e.g. a 500)
			var iframe = iframe = document.createElement('iframe');
			iframe.setAttribute("class", "hiddenDownloader");
			iframe.style.visibility = 'hidden';
			iframe.style.width = "0px";
			iframe.style.height = "0px";
			iframe.style.display = 'none';
			// firefox only triggers this in case we get an error document back
			// chrome always triggers this, even _before_ the download is complete, if we remove the iframe at that point from the DOM, the download fails
			// so we leave the iframe in the DOM at this point
			// we have very few ways to check if the downloaded was successful or not, but we can try to inspect the body of the iframe (its from the same origin) and determine based on the content there
			iframe.onload = function(event) {
				var iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
				// no body or an empty body means it loaded ok!
				if (iframeDocument && (!iframeDocument.body || iframeDocument.body.innerHTML == "")) {
					console.log("File downloaded correctly", url);
					// probably not working as intended!
					if (successHandler) {
						successHandler(url);
					}
				}
				else {
					console.log("file download failed", url);
					if (errorHandler) {
						errorHandler(url);
					}
				}
			}
			// this is never triggered in any browser :(
			iframe.onerror = function(event) {
				console.log("failed!", event);
			}
			document.body.appendChild(iframe);
			if (this.$services.language != null && this.$services.language.current != null) {
				if (url.indexOf("?") <= 0) {
					url += "?language=" + this.$services.language.current;
				}
				else {
					url += "&language=" + this.$services.language.current;
				}
			}
			iframe.src = url;
		},
		// category is a general category of reports, for example we can have "analysis" reports or "event" reports or...
		// the source is where it comes from, this is usually a page, but it could also be a service like the router, swagger,...
		// the type is the general type of the report, for example a click event
		// the name is the specific name of this report, for example a specific event
		// properties can be anything
		report: function(category, source, type, name, properties) {
			if (this.canEdit()) {
				this.reports.unshift({
					category: category,
					source: source,
					type: type,
					name: name,
					timestamp: new Date(),
					properties: properties
				});
				this.limitReports();
			}
		},
		limitReports: function() {
			// if the console is hidden, we want to keep some recent entries but not everything
			if (this.reports.length >= 20 && !this.showConsole) {
				this.reports.splice(20);
			}
		},
		// the additional allows you to easily pass in additional css classes
		getIconHtml: function(icon, additionalCss) {
			var providers = nabu.page.providers("page-icon");
			providers.sort(function(a, b) {
				return a.priority - b.priority;	
			});
			var provider = providers[0];
			return provider.html(icon, additionalCss);
		},
		getNameColor: function(name) {
			var saturation = 80;
			var lightness = 40;
			var hash = 0;
			for (var i = 0; i < name.length; i++) {
				hash = name.charCodeAt(i) + ((hash << 5) - hash);
			}
			var hue = hash % 360;
			return 'hsl('+ hue +', '+ saturation +'%, '+ lightness +'%)';
		},
		closeRight: function() {
			var right = document.querySelector("#n-sidebar-right-instance");
			if (right && right.__vue__ && right.__vue__.close) {
				right.__vue__.close();
			}
			else if (right && right.$$close) {
				right.$$close();
			}
		},
		clearAllDrag: function() {
			this.clearDrag();
			console.log("-----------> clearing drag");
			this.dragTypes.splice(0);
		},
		clearDrag: function() {
			this.dragItems.splice(0).forEach(function(x) {
				x.classList.remove("is-hover-bottom", "is-hover-top", "is-hovering", "is-hover-left", "is-hover-right");
			});
		},
		// this should work both in regular browers and javafx webview where the drag events are more or less messed up
		setDragData: function(e, type, value) {
			if (e && e.dataTransfer && e.dataTransfer.setData) {
				event.dataTransfer.setData(type, value);
			}
			this.dragTypes.push({type: type, value: value});
		},
		hasDragData: function(event, type) {
			if (type == "operation" && event && event.dataTransfer && event.dataTransfer.data && event.dataTransfer.data.service) {
				return true;
			}
			return (event && event.dataTransfer && event.dataTransfer.types && event.dataTransfer.types.indexOf(type) >= 0)
				|| this.dragTypes.filter(function(x) { return x.type == type }).length > 0;
		},
		getDragData: function(event, type) {
			var value = event && event.dataTransfer && event.dataTransfer.getData ? event.dataTransfer.getData(type) : null;
			if (!value && type == "operation" && event && event.dataTransfer && event.dataTransfer.data && event.dataTransfer.data.service) {
				value = event.dataTransfer.data.service;
			}
			if (!value) {
				value = this.dragTypes.filter(function(x) { return x.type == type })[0];
				if (value) {
					value = value.value;
				}
			}
			return value;
		},
		pushDragItem: function(item) {
			this.clearDrag();
			this.dragItems.push(item);
		},
		parseValue: function(value) {
			if (value == null || value == "null") {
				 return null;
			}
			else if (value === "true") {
				return true;
			}
			else if (value === "false") {
				return false;
			}
			else if (value.match instanceof Function && value.match(/^[0-9]+$/)) {
				return parseInt(value);
			}
			else if (value.match instanceof Function && value.match(/^[0-9.]+$/)) {
				return parseFloat(value);
			}
			return value;
		},
		isClickable: function(element) {
			if (element.classList && element.classList.contains("clickable")) {
				return true;
			}
			else if (element.classList && element.classList.contains("unclickable")) {
				return false;
			}
			else if (element.parentNode) {
				return this.isClickable(element.parentNode);
			}
			else {
				return true;
			}
		},
		getAvailableTypes: function(value) {
			var types = ['string', 'boolean', 'number', 'integer'];
			nabu.utils.arrays.merge(types, Object.keys(this.$services.swagger.swagger.definitions));
			if (value) {
				types = types.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			return types;
		},
		getContent: function(page, key) {
			// if we are in development mode and no explicit language choice is made, don't show the contents, you want the json values
			if (true && (!this.$services.language || !this.$services.language.cookieValue)) {
				return null;
			}
			return this.contents.filter(function(x) {
				// if it is a different page we are not interested
				if (page && x.page != page) {
					return false;
				}
				// if we want a global content, don't take a page content
				else if (!page && x.page) {
					return false;
				}
				else {
					return x.key == key;
				}
			})[0];
		},
		formatFieldsLight: function(value, fields) {
			for (var i = 0; i < fields.length; i++) {
				
			}
		},
		// format a row or cell for human consumption
		formatPageItem: function(pageInstance, target) {
			var component = target.id != null ? pageInstance.getComponentForCell(target.id) : null; 
			// if you explicitly gave it a name, use that
			if (target.name) {
				return target.name;
			}
			// if we can somehow calculate a name for this specific instance, it would be better than other alternatives
			else if (target.id && component != null && component.getPrettyName != null && component.getPrettyName(target) != null) {
				return component.getPrettyName(target);
			}
			// if you have routed content, use a prettified version of the alias
			else if (target.alias) {
				return this.prettifyRouteAlias(target.alias);
			}
			// if you have a renderer, use that
			else if (target.renderer && this.getRenderer(target.renderer)) {
				return this.getRenderer(target.renderer).title;
			}
			// if all else fails, we use the id
			return "" + target.id;
		},
		getRootPage: function(pageInstance) {
			while (pageInstance && pageInstance.fragmentParent) {
				pageInstance = pageInstance.fragmentParent;
			}
			return pageInstance;
		},
		getPageType: function(page, target) {
			// this surfaced as a bottleneck taking up 20% of overhead in certain repeats
			// so instead we cache the value to prevent recalculation
			// the cache is reset when we exit edit mode
			if (!this.calculatedPageTypes) {
				this.calculatedPageTypes = {};
			}
			if (!this.calculatedPageTypes[page.content.name]) {
				this.calculatedPageTypes[page.content.name] = {};
			}
			if (this.calculatedPageTypes[page.content.name]["target-" + target.id] && !this.editing) {
				return this.calculatedPageTypes[page.content.name]["target-" + target.id];
			}
			var self = this;
			var pageType = null;
			var pageInstance = this.getRootPage(this.getPageInstance(page));
			var path = this.$services.page.getTargetPath(pageInstance.page.content, target.id);
			// we check if there is a renderer in the path to this target
			// if so, that renderer can modify how we render the content
//			var path = this.$services.page.getTargetPath(page.content, target.id);
			path.reverse();
			path.forEach(function(x) {
				if (x.renderer && !pageType) {
					var renderer = self.getRenderer(x.renderer);
					if (renderer && renderer.getPageType) {
						pageType = renderer.getPageType(x);
					}
				}
			});
			// fallback to something set on the page (e.g. the repeat does this!)
			if (pageType == null) {
				pageType = page.content.pageType;
			}
			var provider = pageType == null ? null : nabu.page.providers("page-type").filter(function(x) {
				return x.name == pageType;
			})[0];
			var result = {
				pageType: pageType,
				path: path,
				provider: provider
			};	
			if (!this.editing) {
				this.calculatedPageTypes[page.content.name]["target-" + target.id] = result;
				return this.calculatedPageTypes[page.content.name]["target-" + target.id];
			}
			else {
				return result;
			}
		},
		getCellComponents: function(page, cell) {
			var components = [];
			// we _do_ want the default cell component at this point
			// the renderer might expose only additional targets
			// and the styling is always set anyway on the cell itself
			
			var pageType = this.getPageType(page, cell);
			if (pageType && pageType.provider && pageType.provider.cellComponent instanceof Function) {
				var component = pageType.provider.cellComponent(cell, pageType.path, page);
				if (component) {
					components.push({
						title: "Cell",
						name: component,
						component: component
					});
				}
			}
			if (components.length == 0) {
				components.push({
					title: "Cell",
					name: "page-column",
					component: "page-column",
					defaultVariant: "page-column" + (cell.alias ? "-" + cell.alias : "")
				});
			}
			if (cell.renderer) {
				var renderer = this.getRenderer(cell.renderer);	
				if (renderer && renderer.getChildComponents) {
					nabu.utils.arrays.merge(components, renderer.getChildComponents(cell));
				}
			}
			var pageInstance = this.getPageInstance(page);
			var component = pageInstance.getComponentForCell(cell.id);
			if (component != null) {
				if (component.getChildComponents) {
					nabu.utils.arrays.merge(components, component.getChildComponents());
				}
				else {
					var self = this;
					if (component && component.configurator) {
						var configurator = Vue.component(component.configurator());
						configurator = new configurator({propsData: {
							page: self.page,
							cell: cell
						}});
						// destroy cleanly
						configurator.$destroy();
						if (configurator.getChildComponents) {
							nabu.utils.arrays.merge(components, configurator.getChildComponents());
						}
					}
				}
				/*
				We temporarily had the idea to allow full custom styling for separate states but it is disabled for now
				if (component.getPotentialStates) {
					var additional = [];
					component.getPotentialStates().forEach(function(state) {
						components.forEach(function(component) {
							additional.push({
								title: component.title + " (" + state + ")",
								name: component.name + "--" + state,
								component: component.component
							});
						})
					});
					nabu.utils.arrays.merge(components, additional);
				}
				*/
			}
			return components;
		},
		getRowComponents: function(page, row) {
			var components = [];
			
			var pageType = this.getPageType(page, row);
			if (pageType && pageType.provider && pageType.provider.rowComponent instanceof Function) {
				var component = pageType.provider.rowComponent(row, pageType.path, page);
				if (component) {
					components.push({
						title: "Row",
						name: component,
						component: component
					});
				}
			}
			if (components.length == 0) {
				// push the row itself
				components.push({
					title: "Row",
					name: "page-row",
					component: "page-row"
				});
			}
			if (row.renderer) {
				var renderer = this.getRenderer(row.renderer);	
				if (renderer && renderer.getChildComponents) {
					nabu.utils.arrays.merge(components, renderer.getChildComponents(row));
				}
			}
			return components;
		},
		slowNormalizeAris: function(page, container, type) {
			var self = this;
			// sometimes we need to wait until it is all rendered (like when switching alias)
			// not sure why, but waiting twice seems to work for now....
			Vue.nextTick(function() {
				Vue.nextTick(function() {
					self.normalizeAris(page, container, type);
				});
			});
		},
		setRerender: function(cell) {
			if (cell && !cell.hasOwnProperty("rerender")) {
				Object.defineProperty(cell, "rerender", {
					value: true,
					enumerable: false,
					writable: true
				});
			}
			else if (cell) {
				cell.rerender = true;
			}
		},
		normalizeAris: function(page, container, type, components) {
			if (this.useAris) {
				if (container.aris == null) {
					Vue.set(container, "aris", {
						components: {}
					});
				}
				if (components == null && (type == null || type == "row" || type == "cell")) {
					components = type == "row" ? this.getRowComponents(page, container) : this.getCellComponents(page, container);
				}
				components.forEach(function(x) {
					if (container.aris.components[x.name] == null) {
						Vue.set(container.aris.components, x.name, {
							variant: null,
							// applied modifiers (by name)
							modifiers: [],
							// applied options, this is written as "dimension_option"
							options: [],
							// for each modifier and option you can set a condition
							// the key is the name of the modifier or option, the value is the condition
							conditions: {}
						});
					}
					// added later
					if (container.aris.components[x.name].conditions == null) {
						Vue.set(container.aris.components[x.name], "conditions", {});
					}
					if (x.defaultVariant) {
						Vue.set(container.aris.components[x.name], "defaultVariant", x.defaultVariant);
					}
				});
				// set this explicitly, in some cases the watcher is not triggered
				this.setRerender(container.aris);
			}
			return true;
		},
		
		calculateArisComponents: function(container, specific, instance) {
			var childComponents = {};
			var self = this;
			if (container && container.components) {
				// removed repeated key-based access for tiny optimization
				var containerComponents = container.components;
				Object.keys(containerComponents).forEach(function(key) {
					// removed repeated key-based access for tiny optimization
					var containerComponent = containerComponents[key];
					childComponents[key] = {
						classes: []
					};
					if (containerComponent.variant != null) {
						// you can explicitly set it to default to override the other default
						// however, we don't need to include that in the css classes
						if (containerComponent.variant != "default") {
							childComponents[key].classes.push("is-variant-" + containerComponent.variant);
						}
					}
					else if (containerComponent.defaultVariant != null) {
						childComponents[key].classes.push("is-variant-" + containerComponent.defaultVariant);
					}
					// we can have specific subvariants, for example for cells which have an alias
					else if (specific) {
						childComponents[key].classes.push("is-variant-" + key + "-" + specific);
					}
					// we always add the default now, you can always actively choose another variant to start from (the default for instance)
					else {
						childComponents[key].classes.push("is-variant-" + key);
					}
					if (containerComponent.options != null && containerComponent.options.length > 0) {
						containerComponent.options.forEach(function(option) {
							var add = true;
							if (containerComponent.conditions && containerComponent.conditions[option] != null) {
								add = self.isCondition(containerComponent.conditions[option], {}, instance);
							}
							if (add) {
								childComponents[key].classes.push("is-" + option.replace("_", "-"));
							}
						});
					}
					if (containerComponent.modifiers != null && containerComponent.modifiers.length > 0) {
						containerComponent.modifiers.forEach(function(modifier) {
							var add = true;
							if (containerComponent.conditions && containerComponent.conditions[modifier] != null) {
								add = self.isCondition(containerComponent.conditions[modifier], {}, instance);
							}
							if (add) {
								childComponents[key].classes.push("is-" + modifier);
							}
						});
					}
					// if no classes are set, set the default name as variant so themes can target this
	//				if (childComponents[key].classes.length == 0) {
	//					childComponents[key].classes.push("is-variant-" + key);
	//				}
				});
			}
			return childComponents;
		},
		// this returns all the parent components as well
		getArisComponentHierarchy: function(component) {
			var components = this.getArisComponents();
			var hierarchy = [];
			var last = components[component];
			while (last) {
				hierarchy.push(last);
				last = last.extends ? components[last.extends] : null;
			}
			return hierarchy;
		},
		// we hide this behind a function so we can refactor the layout later
		getArisComponents: function() {
			return this.aris;
		},
		activate: function(done, initial) {
			var self = this;
		
			var injectJavascript = function() {
				var promise = self.$services.q.defer();
			
				if (navigator.userAgent.indexOf("Trident") >= 0) {
					promise.resolve();
				}
				else {
					// inject some javascript stuff if we are in edit mode
					//self.inject("https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.js");
					// inject ace editor
					// check out https://cdnjs.com/libraries/ace/
					// if it fails, we ignore it and set editing to false
					// too many whitelist issues getting this from CDN, let's just ship it
					/*
					self.inject("https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.3/ace.js", function() {
						self.inject("https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.3/mode-scss.js");
						self.inject("https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.3/mode-javascript.js");
						self.inject("https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.3/mode-html.js");
						self.inject("https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.3/ext-language_tools.js");
						self.inject("https://cdnjs.cloudflare.com/ajax/libs/ace/1.3.3/ext-whitespace.js");
						promise.resolve();
						// inject sass compiler (no longer used)
						self.inject("https://cdnjs.cloudflare.com/ajax/libs/sass.js/0.10.9/sass.js", function() {
							self.inject("https://cdnjs.cloudflare.com/ajax/libs/sass.js/0.10.9/sass.worker.js", function() {
								promise.resolve();
							});
						});
					}, function() {
						self.editable = false;
						promise.resolve();
					});
					*/
					self.inject("/resources/cdn/ace/1.3.3/ace.js", function() {
						self.inject("/resources/cdn/ace/1.3.3/mode-scss.js");
						self.inject("/resources/cdn/ace/1.3.3/mode-javascript.js");
						self.inject("/resources/cdn/ace/1.3.3/mode-html.js");
						self.inject("/resources/cdn/ace/1.3.3/ext-language_tools.js");
						self.inject("/resources/cdn/ace/1.3.3/ext-whitespace.js");
						promise.resolve();
						// inject sass compiler
						/*self.inject("https://cdnjs.cloudflare.com/ajax/libs/sass.js/0.10.9/sass.js", function() {
							self.inject("https://cdnjs.cloudflare.com/ajax/libs/sass.js/0.10.9/sass.worker.js", function() {
								promise.resolve();
							});
						});*/
					}, function() {
						self.editable = false;
						promise.resolve();
					});
				}
				return promise;
			}
	
			self.$services.swagger.execute("nabu.web.page.core.v2.rest.configuration.get").then(function(configuration) {
				self.editable = configuration.editable;
				self.testable = configuration.testable;
				self.pages.splice(0, self.pages.length);
				self.properties.splice(0, self.properties.length);
				self.environmentProperties.splice(0);
				self.devices.splice(0, self.devices.length);
				self.contents.splice(0);
				self.translations.splice(0);
				self.enabledFeatures.splice(0);
				self.availableFeatures.splice(0);
				self.toggledFeatures.splice(0);
				self.users.splice(0);
				self.defaultLocale = configuration.defaultLocale;
				self.environment = configuration.environment;
				if (configuration.branding) {
					Vue.set(self, "branding", configuration.branding);
				}
				else {
					Vue.set(self, "branding", {});
				}
				if (configuration.pages) {
					nabu.utils.arrays.merge(self.pages, configuration.pages);
					self.loadPages(self.pages);
					self.loadFormatters(self.pages);
				}
				if (configuration.properties) {
					nabu.utils.arrays.merge(self.properties, configuration.properties);
				}
				if (configuration.environmentProperties) {
					nabu.utils.arrays.merge(self.environmentProperties, configuration.environmentProperties);
				}
				if (configuration.devices) {
					nabu.utils.arrays.merge(self.devices, configuration.devices);
				}
				self.ensureDevices();
				if (configuration.title) {
					self.title = configuration.title;
				}
				if (configuration.theme) {
					self.theme = configuration.theme;
				}
				if (configuration.home) {
					self.home = configuration.home;
				}
				if (configuration.homeUser) {
					self.homeUser = configuration.homeUser;
				}
				if (configuration.users) {
					nabu.utils.arrays.merge(self.users, configuration.users);
				}
				if (configuration.contents) {
					nabu.utils.arrays.merge(self.contents, configuration.contents);
				}
				if (configuration.translations) {
					var decode = function(value) {
						return value.replace(/\\n/g, "\n")
							.replace(/\\"/g, '"');
					}
					nabu.utils.arrays.merge(self.translations, configuration.translations.map(function(x) {
						// configurations are picked up directly from JSON files which have encoded properties
						// so if you were to type a linefeed into a json file, it would become \n, get picked up as such and appear in the translation
						// however, we can't match an encoded \n with an actual linefeed character
						// so we decode it here, currently it is a whitelist of encoded properties
						if (x && x.translation && x.name) {
							x.name = decode(x.name);
							// we assume the user copied the encoded characters
							x.translation = decode(x.translation);
						}
						return x;
					}));
				}
				if (configuration.imports) {
					nabu.utils.arrays.merge(self.imports, configuration.imports);
				}
				if (configuration.state) {
					nabu.utils.arrays.merge(self.applicationState, configuration.state);
				}
				if (configuration.googleSiteVerification) {
					self.googleSiteVerification = configuration.googleSiteVerification;
				}
				if (configuration.geoRefusalTimeout != null) {
					self.geoRefusalTimeout = configuration.geoRefusalTimeout;
				}
				if (self.home || self.homeUser) {
					self.registerHome(self.home, self.homeUser);
				}
				if (configuration.enabledFeatures) {
					nabu.utils.arrays.merge(self.enabledFeatures, configuration.enabledFeatures);
				}
				if (self.geoRefusalTimeout != null && navigator.geolocation) {
					var refused = self.$services.cookies.get("geolocation-refused");
					if (!refused) {
						navigator.geolocation.getCurrentPosition(
							function (position) {
								Vue.set(self, "location", position.coords);
								// update if necessary
								var watchId = navigator.geolocation.watchPosition(function(position) {
									Vue.set(self, "location", position.coords);
								});
								// could cancel the watchid at a later point?
								// navigator.geolocation.clearWatch(watchId);
							},
						// the user may not have given permission?
						function(error) {
							// if the user denied it, set a cookie to remember this for a while
							if (error.code == error.PERMISSION_DENIED && self.geoRefusalTimeout) {
								self.$services.cookies.set("geolocation-refused", "true", self.geoRefusalTimeout);
							}
						});
					}
				}
				if (self.googleSiteVerification) {
					var meta = document.createElement("meta");
					meta.setAttribute("name", "google-site-verification");
					meta.setAttribute("content", self.googleSiteVerification);
					document.head.appendChild(meta);
				}
				// don't do imports for server rendering, they should not be critical to the page and might not be parseable
				if (!navigator.userAgent.match(/Nabu-Renderer/)) {
					self.imports.forEach(function(x) {
						if (x.type == 'javascript') {
							self.inject(self.interpret(x.link), function() {}, function() {}, x.async);
						}
					});
				}
				var promises = [];
				if (self.canEdit()) {
					self.injectEditIcon();
					var editorPromises = [];
					if (self.useAris) {
						editorPromises.push(nabu.utils.ajax({url: "/api/otr/page/aris-definitions"}).then(function(response) {
							self.aris = {};
							JSON.parse(response.responseText).forEach(function(component) {
								self.aris[component.name] = component;
							});
						}));
					}
					editorPromises.push(injectJavascript());
					editorPromises.push(self.$services.swagger.execute("nabu.web.page.core.v2.rest.templates.list").then(function(list) {
						if (list && list.templates) {
							list.templates.forEach(function(template) {
								try {
									var content = JSON.parse(template.content);
									if (content.type == "page") {
										self.pageTemplates.push(template);
									}
									// multiple pages combined!
									else if (content.type == "pages") {
										self.pageTemplates.push(template);
									}
									else {
										self.templates.push(template);
									}
								}
								catch (exception) {
									console.error("Can not parse JSON", exception, template.content);
								}
							});
							//nabu.utils.arrays.merge(self.templates, list.templates);
						}
					}));
					// we probably don't want to wait for these, they should only be relevant once you are actually editing etc which is not _right_ away
					if (false) {
						nabu.utils.arrays.merge(promises, editorPromises);
					}
					self.scanPagesForTemplates();
				}
				else {
					self.removeEditIcon();
				}
				if (self.canTest()) {
					// this call can take long (lots of I/O to be done)
					// so we don't include it in the blocking promises array
					// loading this does not change the application, it simply gives the tester more options in case he specifically wants to test features (which is very rare)
					self.$services.swagger.execute("nabu.web.page.core.v2.rest.feature.get").then(function(features) {
						if (features) {
							if (features.enabled) {
								nabu.utils.arrays.merge(self.availableFeatures,
									features.enabled.map(function(x) { x.enabled = true; return x }));
								// not all enabled features might be in enabledFeatures, as that only looks at web application features, not broader ones
								features.enabled.forEach(function(x) {
									if (self.enabledFeatures.indexOf(x.name) < 0) {
										self.enabledFeatures.push(x.name);
									}
								});
							}
							if (features.disabled) {
								nabu.utils.arrays.merge(self.availableFeatures,
									features.disabled.map(function(x) { x.enabled = false; return x }));
							}
						}
					});
				}
				if (self.applicationState) {
					self.applicationState.forEach(function(state) {
						if (state.name) {
							promises.push(self.$services.swagger.execute(state.operation).then(function(result) {
								Vue.set(self.variables, state.name, result);
							}));
						}
					});
				}
				self.$services.q.all(promises).then(function() {
					Vue.nextTick(function() {
						self.loading = false;
					});
					if (self.canEdit()) {
						// start reloading the css at fixed intervals to pull in any relevant changes
						setTimeout(self.reloadCss, 10000);
					}
					done();
				}, function(error) {
					var route = "error";
					error.forEach(function(x) {
						if (x && (x.status == 503 || x.status == 502)) {
							route = "offline";
						}
					});
					Vue.nextTick(function(e) {
						self.loading = false;
						// route to error once the services are done initializing
						setTimeout(function() {
							self.$services.router.route(route, null, null, route == "offline");
						}, 1);
					});
					if (self.canEdit()) {
						// start reloading the css at fixed intervals to pull in any relevant changes
						setTimeout(self.reloadCss, 10000);
					}
					done();
				});
			});
		},
		removeEditIcon: function() {
			var icon = document.getElementById("page-edit-icon");
			if (icon) {
				icon.parentNode.removeChild(icon);
			}
		},
		injectEditIcon: function() {
			var div = document.createElement("div");
			div.setAttribute("id", "page-edit-icon");
			div.setAttribute("class", "is-column has-tooltip");
			div.setAttribute("style", "position: fixed; bottom: 1rem; left: 1rem; z-index: 10000;");
			var button = document.createElement("button");
			div.appendChild(button);
			//button.setAttribute("class", "is-button is-border-radius-xxlarge is-variant-warning");
			button.setAttribute("style", "padding: 0.7rem; border-radius: 50px; background-color: #fff; border: solid 1px #666; cursor: pointer")
			button.innerHTML = "<img src='" + application.configuration.root + "resources/images/helper/edit.svg' style='width: 1rem' />";
			document.body.appendChild(div);
			var self = this;
			
			var tooltip = document.createElement("span");
			tooltip.setAttribute("class", "is-tooltip is-wrap-none");
			tooltip.innerHTML = "Show rendered pages <span class='shortkey is-badge'>" + (navigator.platform.toLowerCase().indexOf("mac") >= 0 ? "CMD" : "CTRL") + "+ALT+X</span>";
			div.appendChild(tooltip);
			
			var pages = document.createElement("div");
			pages.setAttribute("style", "position: absolute; bottom: 100%; left: 0;");
			//pages.style.display = "none";
			div.appendChild(pages);
			var showPages = function() {
				div.removeChild(tooltip);
				nabu.utils.elements.clear(pages);
				var button = document.createElement("button");
				button.setAttribute("style", "background-color: #333; color: #fff; white-space:nowrap; border: none; padding: 0.7rem; border: solid 1px #333; margin-bottom: 0.3rem; border-radius: 10px; cursor: pointer; display: flex;");
				button.innerHTML = "View all pages";
				pages.appendChild(button);
				button.onclick = function() {
					self.$services.router.route("pages");
				};
				var availablePages = [];
				Object.keys(nabu.page.instances).forEach(function(key) {
					var page = nabu.page.instances[key].page;
					if (!page.content.readOnly && availablePages.indexOf(page) < 0) {
						availablePages.push(page);
					}
				});
				availablePages.sort(function(a, b) {
					return a.content.name.localeCompare(b.content.name);
				});
				availablePages.forEach(function(x) {
					var button = document.createElement("button");
					button.setAttribute("style", "background-color: #fff; border: none; white-space: nowrap; padding: 0.7rem; border: solid 1px #666; margin-bottom: 0.3rem; border-radius: 10px; cursor: pointer; display: flex; column-gap: 0.7rem; align-items: center");
					var span = document.createElement("span");
					span.innerHTML = x.content.label ? x.content.label : x.content.name;
					button.appendChild(span);
					var img = document.createElement("img");
					img.setAttribute("src", application.configuration.root + "resources/images/helper/search.svg");
					img.setAttribute("style", "width: 0.7rem");
					img.setAttribute("title", "Inspect state");
					button.appendChild(img);
					img.onclick = function(event) {
						var reported = [];
						Object.keys(nabu.page.instances).forEach(function(key) {
							if (x == nabu.page.instances[key].page && reported.indexOf(nabu.page.instances[key]) < 0) {
								reported.push(nabu.page.instances[key]);
								console.log("Page: " + x.content.name, nabu.page.instances[key].variables, nabu.page.instances[key]);
							}
						});
						event.stopPropagation();
					}
					pages.appendChild(button);
					// we just edit the first instance of the page we find
					button.onclick = function(event) {
						var found = false;
						Object.keys(nabu.page.instances).forEach(function(key) {
							if (!found && x == nabu.page.instances[key].page) {
								found = true;
								nabu.page.instances[key].goIntoEdit();
							}
						});
					}
				})
			}
			button.onclick = function(event) {
				if (pages.firstChild) {
					div.appendChild(tooltip);
					nabu.utils.elements.clear(pages);	
				}
				else {
					showPages();
					event.stopPropagation();
				}
			};
			// make sure it closes when you click somewhere
			document.addEventListener("click", function() {
				if (pages.firstChild) {
					div.appendChild(tooltip);
					nabu.utils.elements.clear(pages);
				}
			});
			// add the same shortkey as before to open it
			document.addEventListener("keydown", function(event) {
				if ((event.ctrlKey || event.metaKey) && event.altKey && event.keyCode == 88) {
					if (self.canEdit()) {
						if (pages.firstChild) {
							div.appendChild(tooltip);
							nabu.utils.elements.clear(pages);	
						}
						else {
							showPages();
						}
					}
					else {
						self.$services.router.route("login", null, null, true);
					}
				}
			});
		},
		// we can do inline templates in pages
		scanPagesForTemplates: function() {
			var self = this;
			this.pages.forEach(function(page) {
				// the marker to even start checking
				if (page.content.hasTemplates) {
					var check = function(target) {
						if (target.rows) {
							target.rows.forEach(function(x) {
								if (x.isTemplate) {
									if (x.templateStable) {
										var existing = self.templates.filter(function(y) {
											return y.id == x.templateId;
										})[0];
										if (existing) {
											self.templates.splice(self.templates.indexOf(existing), 1);
										}
										self.templates.push({
											id: x.templateId,
											version: x.release,
											type: "row",
											templateVersion: x.templateVersion,
											category: x.templateCategory ? x.templateCategory : page.content.name,
											name: x.templateTitle,
											description: x.templateDescription,
											icon: x.templateIcon ? x.templateIcon : "align-justify",
											content: JSON.stringify({
												type: "page-row",
												content: x.templateStable
											})
										})
									}
								}
								// only recursively check if we are not already in a template
								else if (x.cells) {
									check(x);
								}
							});
						}
						if (target.cells) {
							target.cells.forEach(function(x) {
								if (x.isTemplate) {
									if (x.templateStable) {
										var existing = self.templates.filter(function(y) {
											return y.id == x.templateId;
										})[0];
										if (existing) {
											self.templates.splice(self.templates.indexOf(existing), 1);
										}
										self.templates.push({
											id: x.templateId,
											version: x.release,
											type: "cell",
											templateVersion: x.templateVersion,
											category: x.templateCategory ? x.templateCategory : page.content.name,
											name: x.templateTitle,
											description: x.templateDescription,
											icon: x.templateIcon ? x.templateIcon : "align-justify",
											content: JSON.stringify({
												type: "page-cell",
												content: x.templateStable
											})
										})
									}
								}
								else if (x.rows) {
									check(x);
								}
							});
						}
					}
					check(page.content);
				}
			})
		},
		ensureDevices: function() {
			var self = this;
			var ensure = function(name, width) {
				var device = self.devices.filter(function(x) { return x.name == name})[0];
				if (device == null) {
					self.devices.push({
						name: name,
						width: width
					});
				}
				else if (device.width == null) {
					device.width = width;
				}
			}
			// we don't _need_ to set the device widths, we need to make sure the devices exist so you can choose them
			// the placeholder in the edit screen visualizes the default without hard saving it to your application
			// the default itself is set in the breakpoint injector
			ensure("phone", null); // 512
			ensure("tablet", null);	// 960
			ensure("desktop", null); // 1280
			ensure("wide", null); // 2560
		},
		getApplicationStateNames: function(value) {
			var values = this.applicationState.filter(function(x) { return !!x.name }).map(function(x) {
				return x.name;
			});
			if (value) {
				values = values.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				})
			}
			return values;
		},
		reloadState: function(name) {
			var state = this.applicationState.filter(function(x) {
				return x.name == name;
			})[0];
			if (state && state.operation) {
				var self = this;
				return this.$services.swagger.execute(state.operation).then(function(result) {
					Vue.set(self.variables, state.name, result);
				});
			}
			else {
				return this.$services.q.reject();
			}
		},
		renumber: function(page, entity, mapping) {
			var initial = false;
			if (!mapping) {
				mapping = {};
				initial = true;
			}
			var self = this;
			if (entity.id) {
				var oldId = entity.id;
				entity.id = page.content.counter++;
				mapping[oldId] = entity.id;
			}
			if (entity.rows) {
				entity.rows.map(function(row) {
					self.renumber(page, row, mapping);
				});
			}
			if (entity.cells) {
				entity.cells.map(function(cell) {
					self.renumber(page, cell, mapping);
				});
			}
			if (initial) {
				var renumberInternally = function(target) {
					if (target.renderer) {
						var renumberProvider = nabu.page.providers("page-renumberer").filter(function(x) {
							return x.renderer == target.renderer;
						})[0];
						if (renumberProvider) {
							renumberProvider.renumber(target, mapping);
						}
					}
					if (target.alias) {
						var renumberProvider = nabu.page.providers("page-renumberer").filter(function(x) {
							return x.component == target.alias;
						})[0];
						if (renumberProvider) {
							renumberProvider.renumber(target, mapping);
						}
					}
					if (target.cells) {
						target.cells.forEach(renumberInternally);
					}
					if (target.rows) {
						target.rows.forEach(renumberInternally);
					}
				}
				renumberInternally(entity, mapping);
				return entity;
			}
			else {
				return mapping;
			}
		},
		getGlobalEvents: function() {
			var events = {};
			this.pages.map(function(page) {
				if (page.content.globalEvents) {
					page.content.globalEvents.map(function(event) {
						var globalName = event.globalName ? event.globalName : event.localName;
						if (globalName != null) {
							if (events[globalName] == null) {
								var properties = event.properties;
								// if we have an instance of it, we can resolve the definition "realtime"
								// for some reason this definition is sometimes wrong. it is also not in sync with the definition in json which (while outdated) is what we would expect
								// we disable this for now as the usecases are too limited to draw any conclusions
								//if (nabu.page.instances[page.content.name]) {
								//	properties = nabu.page.instances[page.content.name].getEvents()[event.localName];
								//}
								events[globalName] = properties == null ? {properties:{}} : properties;
							}
						}
					});
				}
			});
			return events;
		},
		// push global events to all pages
		emit: function(event, data, source) {
			var instances = [];
			// make sure we don't emit it again to the source page
			if (source != null) {
				instances.push(source);
			}
			Object.keys(nabu.page.instances).map(function(key) {
				var instance = nabu.page.instances[key];
				if (instances.indexOf(instance) < 0) {
					if (instance.page.content.globalEventSubscriptions) {
						var globalEvent = instance.page.content.globalEventSubscriptions.filter(function(x) {
							return x.globalName == event;
						})[0];
						if (globalEvent) {
							instance.emit(globalEvent.localName != null ? globalEvent.localName : event, data);
						}
					}
					instances.push(instance);
				}
			});
		},
		getCurrentInstance: function(component) {
			var page = null;
			while (!page && component) {
				if (component.page) {
					page = component.page;
				}
				else {
					component = component.$parent;
				}
			}
			return page ? this.getPageInstance(page, component) : null;
		},
		getPageInstanceByName: function(pageName, component) {
			var page = this.pages.filter(function(x) {
				return x.content.name == pageName;
			})[0];
			return page ? this.getPageInstance(page, component) : null;
		},
		getParentInstance: function(pageInstance) {
			var instance = pageInstance;
			while (instance && instance.$parent) {
				instance = instance.$parent;
				if (instance.page && instance.page != pageInstance.page) {
					return this.getPageInstance(instance.page, instance);
				}
			}
			return null;
		},
		getParentPageInstance: function(page, component) {
			var currentInstance = this.getPageInstance(page, component);
			var parentInstance = null;
			// let's check through the parents
			while (!parentInstance && currentInstance && currentInstance.$parent) {
				currentInstance = currentInstance.$parent;
				if (currentInstance.page) {
					parentInstance = this.getPageInstance(currentInstance.page, currentInstance);
				}
			}
			return parentInstance;
		},
		getDraggables: function() {
			var result = {};
			var self = this;
			Object.keys(nabu.page.instances).forEach(function(key) {
				var draggables = nabu.page.instances[key].getDraggables();
				Object.keys(draggables).forEach(function(draggable) {
					result[draggable] = draggables[draggable];
				});
			});
			return result;
		},
		getDraggableKeys: function(value) {
			return Object.keys(this.getDraggables(value)).filter(function(x) {
				return !value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
			});
		},
		getPageInstance: function(page, component) {
			var pageInstance = null;
			if (component && component.pageInstanceId != null) {
				pageInstance = nabu.page.instances[page.name + "." + component.pageInstanceId];
			}
			else if (component && component.$parent) {
				var parent = component.$parent;
				while (parent != null && parent.pageInstanceId == null) {
					parent = parent.$parent;
				}
				if (parent && parent.pageInstanceId != null) {
					pageInstance = nabu.page.instances[page.name + "." + parent.pageInstanceId];	
				}
			}
			if (!pageInstance && component && component.$root && component.$root.pageInstanceId != null) {
				pageInstance = nabu.page.instances[page.name + "." + component.$root.pageInstanceId];
			}
			return pageInstance ? pageInstance : nabu.page.instances[typeof(page) == "string" ? page : page.name];
		},
		setPageInstance: function(page, instance) {
			nabu.page.instances[page.name] = instance;
			if (instance.pageInstanceId != null) {
				nabu.page.instances[page.name + "." + instance.pageInstanceId] = instance;	
			}
		},
		destroyPageInstance: function(page, instance) {
			if (instance.pageInstanceId != null) {
				delete nabu.page.instances[page.name + "." + instance.pageInstanceId];
			}
			if (nabu.page.instances[page.name] == instance) {
				delete nabu.page.instances[page.name];
			}
		},
		// this may no longer be in use, there was a call from the page instance to this which reverted to the page instance, this has been optimized away
		// it is not clear if anyone else is using it atm, so it now points to the page method call
		destroy: function(component) {
			if (component.page && component.cell) {
				var pageInstance = this.$services.page.getPageInstance(component.page, component);
				//Vue.delete(pageInstance.components, component.cell.id, null);
				pageInstance.destroyComponent(component, component.cell);
			}
		},
		reloadSwagger: function() {
			if (!this.disableReload) {
				return this.$services.swagger.$clear();
			}
		},
		reloadCss: function() {
			this.reloadSwagger();
			var self = this;
			if (!self.disableReload) {
				nabu.utils.ajax({url:"/api/otr/page/css-modified"}).then(function(response) {
					if (response.responseText != null && !self.disableReload) {
						var date = new Date(response.responseText);
						if (!self.cssLastModified) {
							self.cssLastModified = date;
						}
						else if (date.getTime() > self.cssLastModified.getTime()) {
							// actually reload
							var links = document.head.getElementsByTagName("link");
							for (var i = 0; i < links.length; i++) {
								var original = links[i].getAttribute("original");
								if (!original) {
									original = links[i].href;
									links[i].setAttribute("original", original);
								}
								links[i].setAttribute("href", original + "&loadTime=" + date.getTime());
							}
							self.cssLastModified = date;
						}
					}
					setTimeout(self.reloadCss, 5000);
				});
			}
			else {
				setTimeout(self.reloadCss, 5000);
			}
		},
		getFunctionDefinition: function(id) {
			return this.listFunctionDefinitions().filter(function(x) { return x.id == id })[0];
		},
		getRunnableFunction: function(id) {
			var parts = id.split(".");
			var target = window;
			for (var i = 0; i < parts.length - 1; i++) {
				if (!target[parts[i]]) {
					target = null;
					break;
				}
				target = target[parts[i]];
			}
			var func = target == null ? null : target[parts[parts.length - 1]];	
			// if we didn't find a custom function, check provided ones
			if (!func) {
				var result = nabu.page.providers("page-function").filter(function(x) {
					return x.id == id;
				})[0];
				if (result) {
					func = result.implementation;
				}
			}
			return func;
		},
		runFunction: function(func, input, context, promise) {
			var definition = null;
			if (typeof(func) == "string") {
				definition = this.getFunctionDefinition(func);
				var id = func;
				func = this.getRunnableFunction(id);
				if (!func) {
					throw "Could not find function: " + id;
				}
			}
			var resolve = function(result) {
				if (promise) {
					promise.resolve(result);
				}
			};
			var reject = function(result) {
				if (result.responseText) {
					result = JSON.parse(result.responseText);
				}
				if (promise) {
					promise.reject(result);
				}
			};
			try {
				var returnValue = func(input, this.$services, context && context.$value ? context.$value : function() {}, resolve, reject);
				// if not async, call the done yourself
				if (definition && !definition.async) {
					resolve(returnValue);
				}
				return returnValue == null ? promise : returnValue;
			}
			catch (exception) {
				reject(exception);
				throw exception;
			}
		},
		getBindingValue: function(pageInstance, bindingValue, context, customValueFunction) {
			var self = this;
			if (bindingValue && bindingValue.label) {
				if (bindingValue.label == "fixed") {
					return bindingValue.value;
				}
				else if (bindingValue.label == "$function") {
					/*
					var parts = bindingValue.value.split(".");
					var target = window;
					for (var i = 0; i < parts.length - 1; i++) {
						if (!target[parts[i]]) {
							throw "Could not find function: " + bindingValue.value;
						}
						target = target[parts[i]];
					}
					var func = target[parts[parts.length - 1]];
					*/
					
					var func = this.getRunnableFunction(bindingValue.value);
					if (!func) {
							throw "Could not find function: " + bindingValue.value;
					}
					if (bindingValue.lambda) {
						return function() {
							var def = self.getFunctionDefinition(bindingValue.value);
							var input = {};
							// we map the bindings we have a value for
							if (bindingValue.bindings) {
								Object.keys(bindingValue.bindings).forEach(function(key) {
									if (bindingValue.bindings[key]) {
										var value = self.getBindingValue(pageInstance, bindingValue.bindings[key], context);
										self.setValue(input, key, value);
									}
								});
							}
							if (def.inputs) {
								var tmp = arguments;
								var counter = 0;
								def.inputs.forEach(function(x, i) {
									if (!bindingValue.bindings[x.name]) {
										input[x.name] = tmp[counter++];
									}
								});
							}
							if (def.async) {
								var promise = self.$services.q.defer();
								var promiseToReturn = promise;
								if (bindingValue.output) {
									promiseToReturn = self.$services.q.defer();
									promise.then(function(result) {
										promiseToReturn.resolve(result ? result[bindingValue.output] : result);
									}, promise);
								}
								self.runFunction(func, input, context, promise);
								return promiseToReturn;
							}
							else {
								var output = self.runFunction(func, input, context);
								if (bindingValue.output) {
									output = output[bindingValue.output];
								}
								return output;
							}
						}
					}
					var input = {};
					var self = this;
					if (bindingValue.bindings) {
						Object.keys(bindingValue.bindings).forEach(function(key) {
							if (bindingValue.bindings[key]) {
								var value = self.getBindingValue(pageInstance, bindingValue.bindings[key], context);
								self.setValue(input, key, value);
							}
						});
					}
					//var result = func(input, this.$services);
					var result = this.runFunction(func, input, context);
					if (bindingValue.output) {
						return this.getValue(result, bindingValue.output);
					}
					else {
						return result;
					}
				}
			}
			
			if (bindingValue == null) {
				return null;
			}
			var enumerators = this.enumerators;
			// allow for fixed values
			// for the longest time we did not use the value function here
			// the default value function itself also actually uses the getBindingValue so we need to be careful here
			// however the default value does not pass in a value function, so the iteration stops there
			// the primary usecase is that some contexts have more information (like the repeat, triggers,...) regarding certain state
			// when we want to bind that state, it might not work otherwise
			var value = bindingValue.indexOf("fixed") == 0 ? this.translate(bindingValue.substring("fixed.".length)) : (customValueFunction ? customValueFunction(bindingValue) : (pageInstance ? pageInstance.get(bindingValue) : null));
			// if we have a fixed value that starts with a "=", interpret it
			if (bindingValue.indexOf("fixed.=") == 0) {
				value = this.interpret(value, pageInstance, null, customValueFunction);
			}
			var key = bindingValue.split(".")[0];
			// allow for enumerated values, if there is a provider with that name, check it
			if (!value && enumerators[key]) {
				var label = bindingValue.substring(key.length + 1);
				var enumeration = enumerators[key].enumerate().filter(function(x) {
					return enumerators[key].label ? x[enumerators[key].label] == label : x == label;
				})[0];
				if (enumeration != null && typeof(enumeration) != "undefined") {
					value = enumerators[key].value ? enumeration[enumerators[key].value] : enumeration;
				}
			}
			// let's check parent contexts
			if (value == null && context != null) {
				while (context) {
					if (context.getCellValue) {
						var localResult = context.getCellValue(bindingValue);
						if (localResult != null) {
							value = localResult;
							break;
						}
					}
					context = context.$parent;
				}
			}
			// if the page is a fragment of another page, check that parent one
			if (value == null && pageInstance && pageInstance.fragmentParent) {
				value = this.getBindingValue(pageInstance.fragmentParent, bindingValue, context);
			}
			return value;
		},
		translateErrorCode: function(value, defaultValue) {
			// if you have a standardized translator service available
			if (this.$services.translator && this.$services.translator.translate) {
				return this.$services.translator.translate("%" + "{" + value + "}", defaultValue ? defaultValue : this.$services.translator.translate("%" + "{An error has occurred while trying to complete your action}"));
			}
			else {
				var translations = !value ? [] : this.translations.filter(function(x) {
					// this is not actually a translation, fall back to defaults
					if (x.translation == x.name) {
						return false;
					}
					if (value.toLowerCase() == x.name.toLowerCase()) {
						return true;
					}
					else {
						// if we try to cast something to a regex that is not meant as a regex, it may error out
						// we don't care at that point, just ignore it
						// the backend already allows for generalization through regex, not sure if this is necessary in the translations
						// might also require for example that a * is present before actually attempting this?
						try {
							return value.match(new RegExp(x.name.replace(/\*/g, ".*")));
						}
						catch (exception) {
							// not a regex!
						}
					}
					return false;
				});
				var translation = null;
				if (translations.length > 1) {
					translations.forEach(function(x) {
						if (translation == null || translation.name.length < x.name.length)	 {
							translation = x;
						}
					});
				}
				else if (translations.length == 1) {
					translation = translations[0];
				}
				return translation && translation.translation 
					? translation.translation 
					: (defaultValue ? defaultValue : "An error has occurred while trying to complete your action");
			}
		},
		translate: function(value, component) {
			if (this.showRawTranslations) {
				return value;
			}
			// if you have a standardized translator service available
			if (this.$services.translator && this.$services.translator.translate) {
				return this.$services.translator.translate(value);
			}
			// otherwise we do best effort local translations, but that requires that someone pushed translations to this
			// in v1, page builder was itself responsible for loading translations but that is no longer the case
			if (value && value.indexOf) {
				while (value.indexOf("%" + "{") >= 0) {
					var start = value.indexOf("%" + "{");
					var depth = 1;
					var end = -1;
					for (var j = start + 2; j < value.length; j++) {
						if (value.charAt(j) == "{") {
							depth++;
						}
						else if (value.charAt(j) == "}") {
							depth--;
							if (depth == 0) {
								end = j;
								break;
							}
						}
					}
					// no end tag
					if (end < 0) {
						break;
					}
					var available = value.substring(start + 2, end);
					var parts = available.split("::");
					var translation = this.translations.filter(function(x) {
						return ((parts.length == 1 && x.context == null)
								|| (parts.length == 2 && x.context == parts[0]))
							&& (x.name == (parts.length == 1 ? parts[0] : parts[1]));
					})[0];
					value = value.substring(0, start) + (translation && translation.translation ? translation.translation : (parts.length == 1 ? parts[0] : parts[1])) + value.substring(end + 1);
				}
			}
			return value;
		},
		interpret: function(value, component, state, customValueFunction) {
			if (typeof(value) == "string" && value.length > 0 && value.substring(0, 1) == "=") {
				value = value.substring(1);
				var result = null;
				if (state) {
					result = this.eval(value, state, component, customValueFunction);
				}
				else if (component) {
					var stateOwner = component;
					while (!stateOwner.localState && stateOwner.$parent) {
						stateOwner = stateOwner.$parent;
					}
					if (stateOwner && stateOwner.localState) {
						result = this.eval(value, stateOwner.localState, component, customValueFunction);
					}
					if (result == null && stateOwner && stateOwner.state) {
						result = this.eval(value, stateOwner.state, component, customValueFunction);
					}
					if (result == null && component.page) {
						var pageInstance = this.getPageInstance(component.page, component);
						// the whole "state" thing is deprecated, there is only page state
						//result = this.getBindingValue(pageInstance, value);
						result = this.eval(value, pageInstance.variables, component, customValueFunction);
					}
				}
				else {
					result = this.eval(value, {}, component, customValueFunction);
				}
				value = result;
			}
			if (typeof(value) == "string") {
				var changed = true;
				while (changed) {
					changed = false;
					var index = value.indexOf("{{");
					if (index >= 0) {
						var end = value.indexOf("}}", index);
						if (end >= index) {
							var rule = value.substring(index + 2, end);
							var result = null;
							if (state) {
								result = this.eval(rule, state, component, customValueFunction);
							}
							else if (component) {
								var stateOwner = component;
								while (!stateOwner.localState && stateOwner.$parent) {
									stateOwner = stateOwner.$parent;
								}
								if (stateOwner && stateOwner.localState) {
									result = this.eval(rule, stateOwner.localState, component, customValueFunction);
								}
								if (result == null && stateOwner && stateOwner.state) {
									result = this.eval(rule, stateOwner.state, component, customValueFunction);
								}
								if (result == null && component.page) {
									var pageInstance = this.getPageInstance(component.page, component);
									result = this.getBindingValue(pageInstance, rule);
								}
							}
							// when loading variables in the initial things like api keys in imports
							// there is no component yet
							// you can basically only use application level variables then
							else if (rule.trim().indexOf("application.") == 0) {
								var variable = rule.trim().substring("application.".length);
								variable = this.properties.filter(function(x) { return x.key == variable })[0];
								result = variable ? variable.value : null;
							}
							value = value.substring(0, index) + (result == null ? "" : result) + value.substring(end + 2);
							changed = true;
						}
					}
				}
			}
			return value;
		},
		getValue: function(data, field) {
			if (field) {
				if (data && data.hasOwnProperty(field)) {
					return data[field];
				}
				var parts = field.split(".");
				var value = data;
				parts.forEach(function(part) {
					// skip $all, you just want the entire value
					if (value && part != "$all") {
						value = value[part];
					}
				});
				return value;
			}
			return null;
		},
		setValue: function(data, field, value) {
			var tmp = data;
			var parts = field.split(".");
			for (var i = 0; i < parts.length - 1; i++) {
				if (parts[i] == "$all") {
					continue;
				}
				if (!tmp[parts[i]]) {
					// if it does not exist and we are trying to set null, leave it
					if (value == null) {
						return;
					}
					Vue.set(tmp, parts[i], {});
				}
				tmp = tmp[parts[i]];
			}
			Vue.set(tmp, parts[parts.length - 1], value);
		},
		getInputBindings: function(operation) {
			var self = this;
			var bindings = {};
			if (typeof(operation) == "string") {
				operation = this.$services.swagger.operations[operation];
			}
			if (operation && operation.parameters) {
				var self = this;
				operation.parameters.map(function(parameter) {
					if (parameter.in == "body") {
						var type = self.$services.swagger.resolve(parameter);
						if (type.schema.properties) {
							Object.keys(type.schema.properties).map(function(key) {
								// 1-level recursion (currently)
								// always add the element itself if it is a list (need to be able to add/remove it)
								if (type.schema.properties[key].type != "object") {
									var newKey = "body." + key;
									bindings[newKey] = null;
								}
								if (type.schema.properties[key].type == "object" || type.schema.properties[key].type == "array") {
									var properties = type.schema.properties[key].type == "array" ? type.schema.properties[key].items.properties : type.schema.properties[key].properties;
									Object.keys(properties).map(function(key2) {
										var newKey = "body." + key + "." + key2;
										bindings[newKey] = null;	
									});
								}
							});
						}
					}
					else {
						bindings[parameter.name] = null;
					}
				});
			}
			return bindings;
		},
		filterOperations: function(value, accept) {
			return this.getOperations(accept).filter(function(x) {
				return !value || x.id.toLowerCase().indexOf(value.toLowerCase()) >= 0;
			});
		},
		getOperations: function(accept) {
			var result = [];
			var operations = this.$services.swagger.operations;
			Object.keys(operations).map(function(operationId) {
				var shouldAccept = accept == null
					|| (accept instanceof Function && accept(operations[operationId]))
					|| (accept.toLowerCase && operationId.toLowerCase().indexOf(accept.toLowerCase()) >= 0);
				if (shouldAccept) {
					result.push(operations[operationId]);
				}
			});
			result.sort(function(a, b) {
				return a.id.localeCompare(b.id);
			});
			return result;
		},
		// operations allowed in a trigger are both get and modify, but not downloads
		getTriggerOperations: function(value) {
			return this.getOperations(function(operation) {
				return operation && (!operation.produces || !operation.produces.length || operation.produces.indexOf("application/octet-stream") < 0)
					&& (!value || operation.id.toLowerCase().indexOf(value.toLowerCase()) >= 0);
			});
		},
		// operations that can be used to update state in the backend
		getModifyOperations: function(value) {
			// must not be a get
			return this.getOperations(function(operation) {
				return operation && operation.method != "get"
					&& (!value || operation.id.toLowerCase().indexOf(value.toLowerCase()) >= 0);
			});
		},
		// operations where you can download a binary blob
		// download operations can also download records in csv format etc
		getBinaryOperations: function(value) {
			return this.getOperations(function(operation) {
				var binaryDownload = operation && operation.method == "get" && operation.produces && operation.produces.length && operation.produces[0] == "application/octet-stream"
					&& (!value || operation.id.toLowerCase().indexOf(value.toLowerCase()) >= 0);
				return binaryDownload;
			});			
		},
		// operations where you can download data
		getDownloadOperations: function(value) {
			return this.getOperations(function(operation) {
				var binaryDownload = operation && operation.method == "get" && operation.produces && operation.produces.length && operation.produces[0] == "application/octet-stream";
				var regularDownload = operation && operation["x-downloadable"] == "true";
				return (binaryDownload || regularDownload) && (!value || operation.id.toLowerCase().indexOf(value.toLowerCase()) >= 0);
			});
		},
		getUploadOperations: function(value) {
			return this.getOperations(function(operation) {
				var binaryUpload = operation && operation.method != "get" && operation.consumes && operation.consumes.length && operation.consumes[0] == "application/octet-stream";
				return binaryUpload && (!value || operation.id.toLowerCase().indexOf(value.toLowerCase()) >= 0);
			});
		},
		// operations where you can retrieve state (e.g. for initial state) from the backend
		getStateOperations: function(value) {
			var self = this;
			return Object.keys(this.$services.swagger.operations).filter(function(operationId) {
				if (value && operationId.toLowerCase().indexOf(value.toLowerCase()) < 0) {
					return false;
				}
				var operation = self.$services.swagger.operations[operationId];
				// must be a get
				return operation.method.toLowerCase() == "get"
					// and contain the name fragment (if any)
					&& (!name || operation.id.toLowerCase().indexOf(name.toLowerCase()) >= 0)
					// must have _a_ response
					&& operation.responses["200"];
			});
		},
		// all operations that return an array of some sort
		getArrayOperations: function(value) {
			var self = this;
			return this.getOperations(function(operation) {
				// must be a get
				var isAllowed = operation.method.toLowerCase() == "get"
					// and contain the name fragment (if any)
					&& (!name || operation.id.toLowerCase().indexOf(name.toLowerCase()) >= 0)
					// must have _a_ response
					&& operation.responses["200"];
				// we also need at least _a_ complex array in the results
				if (isAllowed && operation.responses["200"] != null && operation.responses["200"].schema != null) {
					var schema = operation.responses["200"].schema;
					if (!schema["$ref"]) {
						isAllowed = false;
					}
					else {
						var definition = self.$services.swagger.resolve(schema["$ref"]);
						isAllowed = self.$services.page.getArrays(definition).length > 0;
					}
				}
				if (isAllowed && value) {
					isAllowed = operation.id.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				}
				return isAllowed;
			});
		},
		getPageVariables: function(page, value) {
			var variables = this.getSimpleKeysFor({properties:this.getAllAvailableParameters(page, null, true)});
			if (value) {
				variables = variables.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
			}
			return variables;
		},
		getSimpleClasses: function(value) {
			var classes = ["primary", "secondary", "info", "success", "warning", "danger", "inline"];
			if (value) {
				classes = classes.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
			}
			// the class itself is allowed
			if (classes.indexOf(value) < 0) {
				classes.push(value);
			}
			return classes;
		},
		getDynamicVariables: function(styleVariables, state, instance) {
			if (!styleVariables) {
				return [];
			}
			var self = this;
			return styleVariables.filter(function(style) {
				return !style.condition || self.isCondition(style.condition, state, instance);
			}).map(function(style) {
				return {
					name: style.name,
					value: self.$services.page.interpret(style.rule, instance, state)
				};
			});
		},
		getDynamicClasses: function(styles, state, instance) {
			if (!styles) {
				return [];
			}
			var self = this;
			return styles.filter(function(style) {
				return self.isCondition(style.condition, state, instance);
			}).map(function(style) {
				return self.$services.page.interpret(style.class, instance, state);
			});
		},
		getRestrictedParameters: function() {
			// component is mostly for page-arbitrary
			return ["page", "cell", "edit", "component", "parameters", "localState"];
		},
		getPageParameterValues: function(page, pageInstance) {
			// copy things like query parameters & path parameters
			var result = pageInstance.variables ? nabu.utils.objects.clone(pageInstance.variables) : {};
			// copy internal parameters as well
			if (pageInstance.parameters) {
				//var parameters = this.getPageParameters(page).properties;
/*				Object.keys(parameters).forEach(function(key) {
					if (pageInstance.parameters[key] != null) {
						result[key] = pageInstance.parameters[key];
					}
				});*/
				var restricted = this.getRestrictedParameters();
				Object.keys(pageInstance.parameters).filter(function(x) { return restricted.indexOf(x) < 0 }).forEach(function(key) {
					// runtime values in variables take precedence over static input parameters!
					if (pageInstance.parameters[key] != null && !result.hasOwnProperty(key)) {
						result[key] = pageInstance.parameters[key];
					}
				});
			}
			return result;
		},
		isCondition: function(condition, state, instance, customValueFunction, defaultValue) {
			if (!condition) {
				return true;
			}
			try {
				var result = this.eval(condition, state, instance, customValueFunction);
				// if we get a promise, return false initially, update to true if possible
				if (result && result.then) {
					var instanceId = instance.conditionId;
					if (!instanceId) {
						instance.conditionId = crypto.randomUUID();
					}
					var key = instanceId + "::" + condition;
					if (!this.conditionalResults.hasOwnProperty(key)) {
						Vue.set(this.conditionalResults, key, defaultValue == null ? false : defaultValue);
					}
					var self = this;
					result.then(function(result) {
						// if you have no result, we assume (because resolve instead of reject) that it was successful
						// you can also pass in an explicit value that is cast to boolean to determine whether or not it was successful
						// we don't update it if it stays the same to prevent update loops (boolean changes, triggers rerender, boolean is updated again even though the same, rerender etc)
						var booleanValue = result == null || !!result;
						if (booleanValue !== self.conditionalResults[key]) {
							Vue.set(self.conditionalResults, key, booleanValue);
						}
					});
					return this.conditionalResults[key];
				}
				return !!result;
			}
			catch (exception) {
				console.error("Could not evaluate condition", condition, exception);
				return false;
			}
		},
		// you can pass in a schema that has to be enriched
		getSchemaFromObject: function(object, schema) {
			var self = this;
			if (schema == null) {
				schema = {};
			}
			if (typeof(object) === "string" || object instanceof String) {
				schema.type = "string";
			}
			else if (object instanceof Date) {
				schema.type = "string";
				schema.format = "date-time";
			}
			else if (typeof(object) === "number" || object instanceof Number) {
				schema.type = "int64";
			}
			else if (typeof(object) === "boolean" || object instanceof Boolean) {
				schema.type = "boolean";
			}
			// we have an array of items, we merge the definitions from each instance in case they don't all have the same fields
			else if (object instanceof Array) {
				var items = {};
				object.forEach(function(instance) {
					self.getSchemaFromObject(instance, items);	
				});
				schema.type = "array";
				schema.items = items;
			}
			// we assume it's an object
			else {
				schema.type = "object";
				schema.properties = {};
				if (object != null) {
					Object.keys(object).forEach(function(key) {
						schema.properties[key] = self.getSchemaFromObject(object[key]);
					});
				}
			}
			return schema;
		},
		getPageState: function(pageInstance) {
			var state = {};
			// inherit state from above
			if (pageInstance.localState) {
				Object.keys(pageInstance.localState).map(function(key) {
					state[key] = pageInstance.localState[key];
				})
			}
			Object.keys(pageInstance.variables).map(function(key) {
				if (typeof(state[key]) == "undefined") {
					state[key] = pageInstance.variables[key];
				}
			});
			var parameters = pageInstance.parameters ? nabu.utils.objects.clone(pageInstance.parameters) : {};
			Object.keys(parameters).forEach(function(key) {
				var page = {};
				if (parameters[key] != null) {
					page[key] = parameters[key];
				}
				state.page = page;
			});
			// aliased components win, even if their state is null (it has to be predictable)
			// subsumed by variables
/*			Object.keys(pageInstance.components).forEach(function(x) {
				if (x.indexOf("alias_") == 0) {
					var component = pageInstance.components[x];
					state[x.substring("alias_".length)] = component.getState ? component.getState() : null;
				}	
			});*/
			return state;
		},
		hasFeature: function(feature, leadin) {
			// we mostly use this to circumvent compilation optimization
			if (!leading) {
				leadin = "@";
			}
			// remove syntax if applicable
			feature = feature.replace(leadin + "{", "");
			feature = feature.replace("}", "");
			return this.enabledFeatures.indexOf(feature) >= 0;
		},
		evalInContext: function(context, js) {
			if ((!js.match(/^[\s]*function\b.*/)) && (!js.match(/^[\s]*return[\s]+.*/))) {
				js = "return " + js;
			}
			var value;
			try {
				// for statements
				value = (new Function('with(this) { ' + js + ' }')).call(context);
			}
			catch (e) {
				// do nothing
			}
			// during minification the variable "context" is renamed to something else
			// that means the eval always fails at it expects a context variable to be available
			//value = (new Function('with(this) { ' + js + ' }')).call(context);
			//try {
				// for expressions
				//value = eval('with(context) { ' + js + ' }');
			//	value = (new Function('with(this) { ' + js + ' }')).call(context);
			//}
			//catch (e) {
				/*if (e instanceof SyntaxError) {
					try {
						// for statements
						value = (new Function('with(this) { ' + js + ' }')).call(context);
					}
					catch (e) {
						// do nothing
					}
				}*/
			//}
			return value;	
		},
		eval: function(condition, state, instance, customValueFunction, skipFunctionExecution) {
			if (!condition) {
				return null;
			}
			// compilation optimization
			var leadin = condition ? "@" : "@@";
			
			// the vast majority of conditions will not have feature based logic, this optimizes away a loop and regexes
			if (condition.indexOf(leadin) >= 0) {
				// replace all the enabled features with true
				this.enabledFeatures.forEach(function(x) {
					// avoid the regex matcher!
					condition = condition.replace(leadin + "{" + x + "}", "true");
				});
				// replace all the disabled features with false
				condition = condition.replace(/@\{[^}]+\}/gm, "false");
			}
			
			// for a long time, state was meant to incorporate local state from repeats etc, but the use of local state is being reduced, partly because it is not reactive (for anything that is _not_ local) and memory
			// instead we tend to use data-card etc for actual repeats so it does not appear to be necessary anymore?
			// anyway, because of that local state, we often put the data (e.G. for a table) in "record", so you needed to type state.record.myField (to prevent unintentional naming collissions)
			// however, not always, in forms it was directly the form field, for example "state.myField".
			// this made it hard to predict when you needed record and when you didn't, resulting in a lot of trial and error
			// so now, if we see state.record, we will expand the data onto state itself
			// this remains backwards compatible (state.record.myField will keep working) but more predictable going forward (use state.myField)
			if (state) {
				
			}
			
			if (this.useEval) {
				try {
					var result = eval(condition);
				}
				catch (exception) {
					console.warn("Could not evaluate", condition, exception);
					return false;
				}
				if (result instanceof Function) {
					result = result(state);
				}
				return result;
			}
			else {
				try {
					var resultFunction = Function('"use strict";return (function(state, $services, $value, $is, application, value) { return ' + condition + ' })')();
					// by default it is bound to "undefined"
					resultFunction = resultFunction.bind(this);
					var result = resultFunction(state, this.$services, customValueFunction ? customValueFunction : (instance ? instance.$value : function() { throw "No value function" }), instance ? instance.$is : function() { "No is function" }, application, state && state.value ? state.value : state);
					if (result instanceof Function) {
						// by default it is bound to "undefined"
						result = result.bind(this);
						if (!skipFunctionExecution) {
							result = result(state);
						}
					}
				}
				catch (exception) {
					console.error("Could not evaluate", condition, exception);
					return null;
				}
				return result;
			}
			return null;
		},
		classes: function(clazz, value) {
			var result = [];
			var sheets = document.styleSheets;
			for (var l = 0; l < sheets.length; l++) {
				try {
					var rules = sheets.item(l).rules || sheets.item(l).cssRules;
					for (var i = 0; i < rules.length; i++) {
						var rule = rules.item(i);
						if (rule.selectorText) {
							if (rule.selectorText.match(new RegExp(".*\\." + clazz + "\\.([\\w-]+)\\b.*", "g"))) {
								var match = rule.selectorText.replace(new RegExp(".*\\." + clazz + "\\.([\\w-]+)\\b.*", "g"), "$1");
								if (result.indexOf(match) < 0) {
									result.push(match);
								}
							}
						}
					}
				}
				catch (exception) {
					// ignore
				}
			}
			if (value) {
				result = result.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
				// allow the (partial) value itself
				if (result.indexOf(value) < 0) {
					result.push(value);	
				}
			}
			return result;
		},
		getSimpleKeysFor: function(definition, includeComplex, includeArrays, keys, path) {
			var self = this;
			var sort = false;
			if (!keys) {
				keys = [];
				sort = true;
			}
			if (definition && definition.properties) {
				Object.keys(definition.properties).map(function(key) {
					// arrays can not be chosen, you need to bind them first
					// simple arrays are always allowed currently
					if (definition.properties[key] && (definition.properties[key].type != "array" || includeArrays || (definition.properties[key].items && !definition.properties[key].items.properties))) {
						var childPath = (path ? path + "." : "") + key;
						var isArray = definition.properties[key].type == "array";
						var isComplex = !!definition.properties[key].properties;
						// if we have an array, it can be a complex array
						if (!isComplex && definition.properties[key].items) {
							isComplex = !!definition.properties[key].items.properties;
						}
						if (includeComplex || !isComplex) {
							keys.push(childPath);
						}
						// if it is complex, recurse
						if (isComplex) {
							if (isArray) {
								// not sure if the ternary is needed, "definition.properties[key].items" should be correct for complex types
								// but for backwards compatibility i don't want to mess it up
								self.getSimpleKeysFor(definition.properties[key].items.properties ? definition.properties[key].items : {properties:definition.properties[key].items}, includeComplex, includeArrays, keys, childPath);
							}
							else {
								self.getSimpleKeysFor(definition.properties[key], includeComplex, includeArrays, keys, childPath);
							}
						}
					}
				});
			}
			if (sort) {
				keys.sort();
			}
			return keys;
		},
		saveConfiguration: function() {
			var self = this;
			return this.$services.swagger.execute("nabu.web.page.core.v2.rest.configuration.update", {
				body: {
					title: this.title,
					theme: this.theme,
					home: this.home,
					homeUser: this.homeUser,
					users: this.users,
					properties: self.properties,
					environmentProperties: self.environmentProperties,
					devices: self.devices,
					imports: self.imports,
					state: self.applicationState,
					googleSiteVerification: self.googleSiteVerification,
					geoRefusalTimeout: self.geoRefusalTimeout,
					defaultLocale: self.defaultLocale,
					branding: self.branding
				}
			});
		},
		listFunctionDefinitions: function() {
			var result = [];
			nabu.utils.arrays.merge(result, this.functions);
			nabu.utils.arrays.merge(result, nabu.page.providers("page-function"));
			return result;
		},
		listFunctions: function(value) {
			var result = this.listFunctionDefinitions().map(function(x) { return x.id });
			return result.filter(function(x) {
				return !value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
			});
		},
		getFunctionInput: function(id, value) {
			var transformer = this.$services.page.functions.filter(function(x) { return x.id == id })[0];
			if (!transformer) {
				transformer = nabu.page.providers("page-function").filter(function(x) { return x.id == id })[0];
			}
			var parameters = {};
			var self = this;
			if (transformer && transformer.inputs) {
				transformer.inputs.map(function(x) {
					parameters[x.name] = self.$services.page.getResolvedPageParameterType(x.type, null, x.isArray);
					if (!parameters[x.name].required && x.required) {
						parameters[x.name].required = x.required;
					}
				});
			}
			return {properties:parameters};
		},
		hasFunctionOutput: function(id) {
			var output = this.getFunctionOutputFull(id);
			return Object.keys(output.properties).length > 0;
		},
		// really poor naming decisions lead to this...
		getFunctionOutputFull: function(id, value) {
			var transformer = this.$services.page.functions.filter(function(x) { return x.id == id })[0];
			if (!transformer) {
				transformer = nabu.page.providers("page-function").filter(function(x) { return x.id == id })[0];
			}
			var parameters = {};
			var self = this;
			if (transformer && transformer.outputs) {
				transformer.outputs.map(function(x) {
					parameters[x.name] = self.$services.page.getResolvedPageParameterType(x.type, null, x.isArray);
				});
			}
			return {properties:parameters};
		},
		getFunctionOutput: function(id, value) {
			return this.$services.page.getSimpleKeysFor(this.getFunctionOutputFull(id, value), true, true);
		},
		inject: function(link, callback, failure, async) {
			// only inject it once!
			var existing = document.head.querySelector('script[src="' + link + '"]');
			if (existing) {
				if (callback) {
					callback();
				}
			}
			else {
				var script = document.createElement("script");
				script.setAttribute("src", link);
				script.setAttribute("type", "text/javascript");
				if (async) {
					script.setAttribute("async", "true");
				}
				
				if (callback) {
					// IE (not 11)
					if (script.readyState){  
						script.onreadystatechange = function() {
							if (script.readyState == "loaded" || script.readyState == "complete") {
								script.onreadystatechange = null;
								callback();
							}
						};
					}
					// IE 11?
					else if (script.attachEvent) {
						script.attachEvent("onload", function() {
							callback();
						});
						if (failure) {
							script.attachEvent("onerror", function() {
								failure();
							});
						}
					}
					else if (script.addEventListener) {
						script.addEventListener("load", function() {
							callback();
						});
						if (failure) {
							script.addEventListener("error", function() {
								failure();
							});
						}
					}
					// rest
					else { 
						script.onload = function() {
							callback();
						};
					}
				}
				document.head.appendChild(script);
			}
		},
		canEdit: function() {
			return !this.isServerRendering && this.editable;	
		},
		canTest: function() {
			return this.canEdit() || (!this.isServerRendering && this.testable);
		},
		pathParameters: function(url) {
			if (!url) {
				return [];
			}
			var variables = url.match(/\{[\s]*[^}:]+[\s]*(:[\s]*([^}]+)[\s]*|)\}/g);
			return !variables ? [] : variables.map(function(variable) {
				return variable.substring(1, variable.length - 1).replace(/:.*$/, "");
			});
		},
		alias: function(page) {
			return page.name;
		},
		rename: function(page, name) {
			var newName = this.dashify(name);
			// if we actually renamed it...
			if (newName != page.name) {
				newName = this.uniquifyPageName(newName);
				var oldName = page.name;
				page.name = newName;
				page.content.label = name;
				var self = this;
				return this.update(page).then(function() {
					self.removeByName(oldName);
				});
			}
			// you update the label, but it amounts to the same name
			else if (newName == page.name && name != page.content.label) {
				page.content.label = name;
				return this.update(page);
			}
		},
		remove: function(page) {
			var self = this;
			this.removeByName(page.name).then(function() {
				self.pages.splice(self.pages.indexOf(page), 1);
			});
		},
		removeByName: function(name) {
			return this.$services.swagger.execute("nabu.web.page.core.v2.rest.page.delete", {name: name});
		},
		uniquifyPageName: function(pageName) {
			var existing = this.pages.map(function(x) {
				return x.name;
			});
			var tryName = pageName;
			var counter = 1;
			while (existing.indexOf(tryName) >= 0) {
				tryName = pageName + counter;
			}
			return tryName;
		},
		create: function(name, category) {
			var newName = this.uniquifyPageName(this.dashify(name));
			
			var content = this.normalize({
				label: name
			});
			if (category) {
				content.category = category;
			}
			// we automatically add page path, it is usually in sync
			// especially now that we add a default skeleton, this makes it easier
			content.path = "/" + this.dashify(name);
			return this.update({
				name: newName,
				content: content
			});
		},
		update: function(page) {
			var self = this;
			if (!page.content) {
				page.content = self.normalize({});
			}
			page.content.name = page.name;
			
			// we need to calculate aliased components so we know all aliases that exist BEFORE the components are mounted
			// the problem is that we can't dictate the order of mounting, and aliases only become known once they are mounted
			// at that point, already mounted modules may depend on it
			
			
			//page.marshalled = JSON.stringify(page.content, null, "\t");
			page.marshalled = JSON.stringify(page.content);
			return this.$services.swagger.execute("nabu.web.page.core.v2.rest.page.update", { body: page }).then(function() {
				// add it to the pages if it isn't there yet (e.g. create)
				var index = self.pages.indexOf(page);
				// re-add to trigger a reregister (if necessary)
				if (index >= 0) {
					self.pages.splice(index, 1, page);
				}
				else {
					self.pages.push(page);
				}
			});
		},
		findMain: function(rowHolder) {
			if (rowHolder.rows && rowHolder.rows.length) {
				for (var i = 0; i < rowHolder.rows.length; i++) {
					if (rowHolder.rows[i].customId == "main") {
						return rowHolder.rows[i];
					}
					if (rowHolder.rows[i].cells && rowHolder.rows[i].cells.length) {
						for (var j = 0; j < rowHolder.rows[i].cells.length; j++) {
							var cell = rowHolder.rows[i].cells[j];
							if (cell.customId == "main") {
								return cell;
							}
							else if (cell.rows) {
								var main = this.findMain(cell);
								if (main) {
									return main;
								}
							}
						}
					}
				}
			}
			return null;
		},
		filterRoutes: function(value) {
			if (value != null && value.substring(0, 1) == "=") {
				return [value];
			}
			var routes = this.$services.router.list().filter(function(x) {
				return x.alias && (!value || x.alias.toLowerCase().indexOf(value.toLowerCase()) >= 0);
			});
			routes.sort(function(a, b) {
				return a.alias.localeCompare(b.alias);
			});
			return routes.map(function(x) { return x.alias });
		},
		loadFormatters: function(pages) {
			if (!(pages instanceof Array)) {
				pages = [pages];
			}
			var self = this;
			pages.forEach(function(page) {
				if (page.content.formatters && page.content.formatters.length) {
					page.content.formatters.forEach(function(formatter) {
						if (formatter.name && formatter.script) {
							nabu.page.provide("page-format", {
								format: function(value, fragment, page, cell, record, component) {
									var $value = component ? component.$value : null;
									if (!$value) {
										var pageInstance = self.getPageInstance(page);
										$value = pageInstance ? pageInstance.$value : function(value) { return null };
									}
									var result = (new Function('with(this) { return ' + formatter.script + ' }')).call({
										value: value,
										$value: $value,
										state: {value:value},
										$services: self.$services
									});
									//var result = eval(code);
									if (result instanceof Function) {
										result = result.bind(this);
										result = result(value);
									}
									return result;
								},
								// in the future we can expose these parameters in the page itself
								skipCompile: true,
								html: true,
								// and add a configuration if necessary
								//configure: "page-format-resolver",
								name: formatter.name,
								namespace: "nabu.page.custom"
							});
						}
					});
				}
			});
		},
		loadPages: function(pages) {
			var self = this;
			pages.map(function(page) {
				if (!page.content) {
					Vue.set(page, "content", self.normalize(page.marshalled ? JSON.parse(page.marshalled) : {}));
				}
				
				var parameters = {};
				if (page.content.parameters) {
					page.content.parameters.filter(function(x) { return !x.private }).forEach(function(x) {
						parameters[x.name] = self.getResolvedPageParameterType(x.type, null, x.isArray);
						// currently we do not want to allow you to map different parts
						if (parameters[x.name].properties) {
							parameters[x.name].properties = {};
						}
					})
				}
				
				var pagePath = page.content.path;
				if (pagePath && pagePath.indexOf("/") != 0) {
					pagePath = "/" + pagePath;
				}
				// allow for translatable urls
				// may not work during translation redirects!!
				if (pagePath) {
					pagePath = self.translate(pagePath);
				}
				var route = {
					alias: self.alias(page),
					url: page.content.initial ? "/.*" : pagePath,
					query: page.content.query ? page.content.query : [],
					name: page.content.label ? page.content.label : page.content.name,
					category: page.content.category,
					//parameters: page.content.parameters ? page.content.parameters.map(function(x) { return x.name }) : [],
					parameters: parameters,
					enter: function(parameters, mask) {
						var serviceContextVariable = page.content.serviceContext;
						if (serviceContextVariable && serviceContextVariable.indexOf("page.") == 0) {
							serviceContextVariable = serviceContextVariable.substring("page.".length);
							// we want to allow "easy" use of service contexts in pages in a situation where it doesn't matter
							// for example you design masterdata screens to be able to support service context
							// but you also want to plug them in easily in an application that doesn't care
							// if we are using a page variable that is derived from the path
							if (pagePath && pagePath.indexOf("{" + serviceContextVariable + "}") >= 0) {
								// and it does not have a value
								if (!parameters[serviceContextVariable]) {
									// set it to default, the swagger client knows that it should not send it in that case
									parameters[serviceContextVariable] = "default";
								}
							}
						}
						if (page.content.initial) {
							var found = !!self.findMain(page.content);
							// check that there is a row/cell with the default anchor, if not, insert it
/*							for (var i = 0; i < page.content.rows.length; i++) {
								if (page.content.rows[i].customId == "main") {
									found = true;
									break;
								}
							}*/
							// we push a row so we can route _something_
							// otherwise everything might break!
							if (!found) {
								page.content.rows.push({
									id: 0,
									customId: "main",
									cells: [],
									class: null
								});
							}
						}
						else if (page.content.path) {
							// break out
							setTimeout(function() {
								self.$services.analysis.push({
									event: "browse",
									category: "page",
									component: page.content.name,
									path: page.content.path,
									data: parameters
								});
							}, 1);
						}
						// we update the og:url meta tag to make sure we can share this page
						var url = "";
						// We only put absolute uris in the og:url meta tag
						if (url && page.content.path) {
							// the router returns a path with the server.root() in it
							var absoluteUrl = url + self.$services.router.router.templateUrl(page.content.path, parameters, page.content.query);
							self.updateUrl(absoluteUrl);
						}
						return new nabu.page.views.Page({propsData: {page: page, parameters: parameters, stopRerender: parameters ? parameters.stopRerender : false, pageInstanceId: self.pageCounter++, masked: mask }});
					},
					// ability to recognize page routes
					isPage: true,
					initial: page.content.initial,
					roles: page.content.roles != null && page.content.roles.length > 0 ? page.content.roles : null,
					slow: !page.content.initial && page.content.slow,
					parent: page.content.pageParent,
					defaultAnchor: page.content.defaultAnchor,
					// additional properties set on the page
					properties: page.content.properties ? page.content.properties : []
				};
				
				self.$services.router.unregister(self.alias(page));
				self.$services.router.register(route);
			});
		},
		normalize: function(content) {
			// the rows with content
			if (!content.rows) {
				content.rows = [];
			}
			if (!content.path) {
				content.path = null;
			}
			// a counter that serves as id generator
			if (!content.counter) {
				content.counter = 1;
			}
			// contains the definition of the variables (usually just a name)
			// does _not_ contain the value, this is a runtime thing
			if (!content.variables) {
				content.variables = [];
			}
			// definition of the query parameters
			if (!content.query) {
				content.query = [];
			}
			// actions linked to an event
			if (!content.actions) {
				content.actions = [];
			}
			// css class
			if (!content.class) {
				content.class = null;
			}
			if (!content.initial) {
				content.initial = false;
			}
			if (!content.menuX) {
				content.menuX = 0;
			}
			if (!content.menuY) {
				content.menuY = 0;
			}
			if (!content.states) {
				content.states = [];
			}
			if (!content.category) {
				content.category = null;
			}
			if (!content.slow) {
				content.slow = false;
			}
			return content;
		},
		getParentRoutes: function(newValue, not) {
			var routes = this.$services.router.list().filter(function(x) { return !!x.alias && !!x.defaultAnchor }).map(function(x) { return x.alias });
			if (newValue) {
				routes = routes.filter(function(x) { return x.toLowerCase().indexOf(newValue.toLowerCase()) >= 0 });
			}
			if (not) {
				routes = routes.filter(function(x) { return not.indexOf(x) < 0 });
			}
			routes.sort();
			return routes;
		},
		prettifyRouteAlias: function(alias) {
			var routes = this.$services.router.list();
			var route = routes.filter(function(x) { return x.alias == alias })[0];
			if (route && route.name) {
				var sameName = routes.filter(function(x) { return x.name == route.name });
				if (sameName.length >= 2) {
					return route.name + (route.category ? " (" + route.category + ")" : "");
				}
				else {
					return route.name;
				}
			}
			return alias;
		},
		getNamedRoutes: function(newValue) {
			var routes = this.$services.router.list().filter(function(x) { return !!x.alias && !!x.name && (!newValue || x.name.toLowerCase().indexOf(newValue.toLowerCase()) >= 0) });
			routes.sort(function(a, b) {
				return a.name.localeCompare(b.name);
			});
			return routes;
		},
		getPageRoutes: function(newValue) {
			// allow rules
			if (newValue && newValue.indexOf("=") == 0) {
				return [{
					alias: newValue, 
					name: "Calculated route"
				}];
			}
			var routes = this.$services.router.list().filter(function(x) { return x.isPage });
			// originally we couldn't route to skeletons, it is "normally" not done
			// however, a subskeleton needed a default routing because it did routing dynamically based on initial state
			//var routes = this.$services.router.list().filter(function(x) { return x.isPage && !x.defaultAnchor });
			routes.sort(function(a, b) {
				return a.name.localeCompare(b.name);
			});
			if (newValue) {
				routes = routes.filter(function(a) {
					return a.name.toLowerCase().indexOf(newValue.toLowerCase()) >= 0
						|| (a.label && a.label.toLowerCase().indexOf(newValue.toLowerCase()) >= 0);
				});
			}
			return routes;
		},
		// routes that can be embedded
		getEmbeddableRoutes: function(newValue) {
			return this.getRoutes(newValue, true);
		},
		getRoutes: function(newValue, embeddedOnly) {
			var routes = this.$services.router.list().filter(function(x) { return !!x.alias });
			if (embeddedOnly) {
				routes = routes.filter(function(x) {
					// if it's a page, it must NOT have a parent
					// this can trigger some weird rerendering issues
					// alternative is that masking is further applied on parent rerouting, but it is weird to embed a page with a parent
					// you can split this up into a utility page and a wrapper that makes it bookmarkable with a parent
					return !x.isPage || !x.parent;
				});
			}
			routes = routes.map(function(x) { return x.alias });
			if (newValue) {
				routes = routes.filter(function(x) { return x.toLowerCase().indexOf(newValue.toLowerCase()) >= 0 });
			}
			routes.sort();
			return routes;
		},
		// TODO: if the route is a page, we want to have more detailed information about the page parameters
		// for example if you have a complex internal variable in the page with definition etc, the route parameters will only state that there is _a_ variable, not the actual definition
		// either we enrich routes with this information already present when loading pages or we have a better way to go from the route to the actual page so we can use getPageParameters
		getRouteParameters: function(route) {
			var result = {
				properties: {}
			};
			if (!route) {
				return result;
			}
			if (route.parent) {
				var parentRoute = this.$services.router.get(route.parent);
				if (parentRoute) {
					var parentResult = this.getRouteParameters(parentRoute);
					if (parentResult && parentResult.properties) {
						nabu.utils.objects.merge(result.properties, parentResult.properties);
					}
				}
			}
			if (route.url) {
				this.pathParameters(route.url).map(function(key) {
					result.properties[key] = {
						type: "string"
					}
				});
			}
			if (route.query) {
				route.query.map(function(key) {
					// the key could already be a complex definition (though unlikely)
					result.properties[key] = typeof(key) == "string" ? {type: "string"} : key;
				});
			}
			// we assume a parameters object that has the json-esque definitions
			if (route.parameters) {
				nabu.utils.objects.merge(result.properties, route.parameters);
			}
			return result;
		},
		getArrays: function(definition, path, arrays) {
			if (!arrays) {
				arrays = [];
			}
			if (definition && definition.properties) {
				var keys = Object.keys(definition.properties);
				for (var i = 0; i < keys.length; i++) {
					var property = definition.properties[keys[i]];
					// we've had properties like "body" that were "undefined"
					if (property != null) {
						var childPath = (path ? path + "." : "") + keys[i];
						if (property.type == "array") {
							arrays.push(childPath);
						}
						else if (property.properties) {
							this.getArrays(property, childPath, arrays);
						}
					}
				}
			}
			// the definition itself could be an array, the path is likely null at that point though...
			else if (definition && definition.type == "array") {
				arrays.push(path);
			}
			return arrays;
		},
		// this simply returns all available parameters, regardless of whether you listen on it or not
		// currently not cell specific, so does not take into account repeats
		getAllAvailableParameters: function(page, context) {
			var result = {};

			var self = this;
			if (!context) {
				context = self;
			}
			var pageInstance = self.$services.page.getPageInstance(page, context);
			
			var provided = this.getProvidedParameters();
			Object.keys(provided.properties).map(function(key) {
				result[key] = provided.properties[key];	
			});
			
			var application = this.getApplicationParameters();
			if (Object.keys(application.properties).length) {
				result.application = application;
			}

			// if you inherit from another page, we add that as well
			if (page.content.pageParent) {
				var parentPage = this.pages.filter(function(x) {
					return x.content.name == page.content.pageParent;
				})[0];
				if (parentPage != null) {
					result.parent = {properties:this.getAllAvailableParameters(parentPage)};
				}
			}
			// if not defined explicitly, we might still have a parent in this context?
			else {
				var parentInstance = self.$services.page.getParentPageInstance(page, context);
				if (parentInstance && parentInstance.page) {
					result["parent"] = {properties:this.getAllAvailableParameters(parentInstance.page)};
				}
			}
			
			this.normalizeParentScope(result);
			
			// and the page itself
			// we exclude the dynamic because we add it below
			result.page = this.getPageParameters(page, true);
			
			// the available state
			page.content.states.map(function(state) {
				var operation = null;
				if (state.inherited) {
					operation = self.applicationState.filter(function(x) { return x.name == state.applicationName }).map(function(x) { return x.operation })[0];
				}
				else {
					operation = state.operation;
				}
				if (operation && self.$services.swagger.operation(operation) && self.$services.swagger.operation(operation).responses && self.$services.swagger.operation(operation).responses["200"]) {
					result[state.name] = self.$services.swagger.resolve(self.$services.swagger.operation(operation).responses["200"]).schema;
				}
			});
			
			// the available computed
			if (page.content.computed) {
				page.content.computed.map(function(state) {
					if (state.name && state.bindings && state.bindings[state.name] && state.bindings[state.name].label == "$function") {
						var output = self.getFunctionOutputFull(state.bindings[state.name].value);
						if (state.bindings && state.bindings[state.name].output) {
							output = output.properties[state.bindings[state.name].output];
						}
						result[state.name] = output;
					}
				});
			}
			
			// and map all events
			var available = pageInstance.getEvents();
			Object.keys(available).map(function(key) {
				result[key] = available[key];
			});
			
			nabu.page.providers("page-enumerate").forEach(function(x) {
				if (x.enumerate && x.label) {
					var tmp = {};
					var entries = x.enumerate();
					if (entries) {
						entries.forEach(function(y) {
							tmp[y[x.label]] = {
								type: "string"
							};
						});
						result[x.name] = {properties:tmp};
					}
				}
			});
			
			var scanRows = function(rows) {
				rows.forEach(function(row) {
					if (row.cells) {
						row.cells.forEach(function(cell) {
							if (cell.alias && cell.contentRuntimeAlias) {
								result[cell.contentRuntimeAlias] = self.getRouteParameters(self.$services.router.get(cell.alias));
							}
							if (cell.rows && cell.rows.length) {
								scanRows(cell.rows);
							}
						})
					}
				})
			}
			if (page.content.rows) {
				scanRows(page.content.rows);
			}
			
			this.enrichWithRuntimeAliasDefinitions(result, pageInstance);
			
			return result;
		},
		enrichWithRuntimeAliasDefinitions: function(result, pageInstance) {
			// and map all the aliased components
			Object.keys(pageInstance.components).forEach(function(x) {
				if (x.indexOf("alias_") == 0) {
					var name = x.substring("alias_".length);
					var component = pageInstance.components[x];
					if (component.getState) {
						var definition = component.getState();
						if (definition) {
							result[name] = definition;
						}
					}
				}
			});	
			var self = this;
			this.getAvailableRenderers(pageInstance.page).forEach(function(target) {
				if (target.runtimeAlias) {
					var state = self.getRendererState(target.renderer, target, pageInstance.page, result);
					if (state) {
						result[target.runtimeAlias] = state;
					}
				}
			});
		},
		// get the renderers in a page
		getAvailableRenderers: function(page) {
			var renderers = [];
			var self = this;
			// we also want to find all aliased rows and cells
			var checkRows = function(rows) {
				rows.forEach(function(row) {
					if (row.renderer) {
						renderers.push(row);
					}
					if (row.cells) {
						row.cells.forEach(function(cell) {
							if (cell.renderer) {
								renderers.push(cell);
							}
							if (cell.rows) {
								checkRows(cell.rows);
							}
						})
					}
				})
			}
			if (page && page.content && page.content.rows) {
				checkRows(page.content.rows);
			}
			return renderers;
		},
		getAllAvailableKeys: function(page, includeComplex, value) {
			var keys = [];
			var self = this;
			var parameters = this.getAllAvailableParameters(page);
			Object.keys(parameters).map(function(key) {
				// not the page itself? this is mostly for eventing purposes, for other purposes it might be interesting to keep it
				if (includeComplex && key != "page") {
					keys.push(key);
				}
				// if we want complex, we also want arrays (this was added later and backwards compatible etc etc)
				nabu.utils.arrays.merge(keys, self.getSimpleKeysFor(parameters[key], includeComplex, includeComplex).filter(function(x) { return x != null}).map(function(x) {
					return key + "." + x;
				}));
			});
			if (value) {
				keys = keys.filter(function(x) {
					return x && x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
			}
			return keys;
		},
		getAvailableKeys: function(page, cell, includeAllEvents) {
			var keys = [];
			var self = this;
			var parameters = this.getAvailableParameters(page, cell, includeAllEvents);
			Object.keys(parameters).map(function(key) {
				nabu.utils.arrays.merge(keys, self.getSimpleKeysFor(parameters[key]).map(function(x) {
					return key + "." + x;
				}));
			});
			return keys;
		},
		getAvailableParameters: function(page, cell, includeAllEvents) {
			var result = {};

			var self = this;
			var pageInstance = self.$services.page.getPageInstance(page, self);
			
			// the available events
			var available = pageInstance.getEvents();
			if (includeAllEvents) {
				Object.keys(available).map(function(key) {
					result[key] = available[key];
				});
			}
			
			var provided = this.getProvidedParameters();
			Object.keys(provided.properties).map(function(key) {
				result[key] = provided.properties[key];	
			});
			
			var application = this.getApplicationParameters();
			if (Object.keys(application.properties).length) {
				result.application = application;
			}
			
			// if you inherit from another page, we add that as well
			if (page.content.pageParent) {
				var parentPage = this.pages.filter(function(x) {
					return x.content.name == page.content.pageParent;
				})[0];
				if (parentPage != null) {
					//result.parent = this.getPageParameters(parentPage);
					result["parent"] = {properties:this.getAvailableParameters(parentPage, null, includeAllEvents)};
				}
			}
			// if not defined explicitly, we might still have a parent in this context?
			else {
				var parentInstance = self.$services.page.getParentPageInstance(page, self);
				if (parentInstance && parentInstance.page) {
					// it is a fragment parent, the data belongs in the same scope
					if (parentInstance == pageInstance.$props.fragmentParent) {
						nabu.utils.objects.merge(result, this.getAvailableParameters(parentInstance.page, null, includeAllEvents));
					}
					else {
						//result["parent"] = this.getPageParameters(parentInstance.page);
						result["parent"] = {properties:this.getAvailableParameters(parentInstance.page, null, includeAllEvents)};
					}
				}
			}
			
			this.normalizeParentScope(result);
			
			// and the page itself
			result.page = this.getPageParameters(page);

			// the available state, page state overrides page parameters & application parameters if relevant
			page.content.states.map(function(state) {
				var operation = null;
				if (state.inherited) {
					operation = self.applicationState.filter(function(x) { return x.name == state.applicationName }).map(function(x) { return x.operation })[0];
				}
				else {
					operation = state.operation;
				}
				if (operation) {
					operation = self.$services.swagger.operation(operation);
					if (operation && operation.responses && operation.responses["200"]) {
						result[state.name] = self.$services.swagger.resolve(operation.responses["200"]).schema;
					}
				}
			});
			
			// the available computed
			if (page.content.computed) {
				page.content.computed.map(function(state) {
					if (state.name && state.bindings && state.bindings[state.name] && state.bindings[state.name].label == "$function") {
						var output = self.getFunctionOutputFull(state.bindings[state.name].value);
						if (state.bindings && state.bindings[state.name].output) {
							output = output.properties[state.bindings[state.name].output];
						}
						result[state.name] = output;
					}
				});
			}
			
			var scanRows = function(rows) {
				rows.forEach(function(row) {
					if (row.cells) {
						row.cells.forEach(function(cell) {
							if (cell.alias && cell.contentRuntimeAlias) {
								result[cell.contentRuntimeAlias] = self.getRouteParameters(self.$services.router.get(cell.alias));
							}
							if (cell.rows && cell.rows.length) {
								scanRows(cell.rows);
							}
						})
					}
				})
			}
			if (page.content.rows) {
				scanRows(page.content.rows);
			}
			
			this.enrichWithRuntimeAliasDefinitions(result, pageInstance);
			
			// cell specific stuff overwrites everything else
			if (cell) {
				var targetPath = this.getTargetPath(page.content, cell.id);
				if (targetPath && targetPath.length) {
					targetPath.map(function(part) {
						if (part.on) {
							result[part.on] = available[part.on];
						}
						if (part.instances) {
							Object.keys(part.instances).map(function(key) {
								var array = part.instances[key];
								if (array) {
									var variable = array.substring(0, array.indexOf("."));
									var rest = array.substring(array.indexOf(".") + 1);
									if (result[variable]) {
										result[key] = self.getChildDefinition(result[variable], rest).items;
									}
								}
							})
						}
						if (part.cellState) {
							Object.keys(part.cellState).map(function(key) {
								result[key] = part.cellState[key];
							});
						}
					});
				}
			}

			return result;	
		},
		getTarget: function(rowContainer, id, parent) {
			if (rowContainer.rows) {
				for (var i = 0; i < rowContainer.rows.length; i++) {
					if (rowContainer.rows[i].id == id) {
						return parent ? rowContainer : rowContainer.rows[i];
					}
					if (rowContainer.rows[i].cells) {
						for (var j = 0; j < rowContainer.rows[i].cells.length; j++) {
							if (rowContainer.rows[i].cells[j].id == id) {
								return parent ? rowContainer.rows[i] : rowContainer.rows[i].cells[j];
							}
							var has = this.getTarget(rowContainer.rows[i].cells[j], id, parent);
							if (has) {
								return has;
							}
						}
					}
				}
			}
			return null;
		},
		suggestField: function(page, value) {
			var fields = [];
			var parameters = this.getAvailableParameters(page, null, true);
			nabu.utils.arrays.merge(fields, this.getSimpleKeysFor({properties:parameters}, true, true));
			fields.sort();
			if (value) {
				fields = fields.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
			}
			return fields;
		},
		suggestArray: function(page, value) {
			return this.getAllArrays(page).filter(function(x) {
				return !value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0
			});
		},
		getAllArrays: function(page, targetId) {
			var self = this;
			var arrays = [];
			// get all the arrays available in the page itself
			// TODO: filter events that you are not registered on?
			var parameters = this.getAvailableParameters(page, null, true);
			Object.keys(parameters).map(function(key) {
				nabu.utils.arrays.merge(arrays, self.getArrays(parameters[key]).map(function(x) { return x == null ? key : key + "." + x }));
			});
			// @2024-06-11: only in v1?
			if (targetId != null && false) {
				// get all arrays available in parent rows/cells
				var path = this.getTargetPath(page.content, targetId);
				if (path.length) {
					path.map(function(entry) {
						if (entry.instances) {
							Object.keys(entry.instances).map(function(key) {
								var mapping = entry.instances[key];
								if (mapping) {
									var index = mapping.indexOf(".");
									var variable = mapping.substring(0, index);
									var path = mapping.substring(index + 1);
									var definition = self.getChildDefinition(parameters[variable], path);
									nabu.utils.arrays.merge(arrays, self.getArrays(definition.items).map(function(x) { return key + "." + x }));
								}
							});
						}
					});
				}
			}
			return arrays;
		},
		getChildDefinition: function(definition, path, parts, index) {
			if (!parts) {
				parts = path.split(".");
				index = 0;
			}
			var properties = definition == null ? null : (definition.type == "array" ? definition.items.properties : definition.properties);
			if (properties) {
				var child = properties[parts[index]];
				if (index == parts.length - 1) {
					return child;
				}
				else {
					return this.getChildDefinition(child, path, parts, index + 1);
				}
			}
			return null;
		},
		cloneByReference: function(object) {
			var self = this;
			var result;
			if (object instanceof Array) {
				result = [];
				object.forEach(function(x) {
					result.push(self.cloneByReference(x));
				});
			}
			else if (self.isObject(object)) {
				result = {};
				Object.keys(object).forEach(function(key) {
					result[key] = self.cloneByReference(object[key]);
				});
			}
			else {
				result = object;
			}
			return result;
		},
		smartClone: function(object) {
			if (object == null) {
				return null;
			}
			var self = this;
			// when we clone things like blob and files, they break, so we do it slightly smarter
			var cloned = JSON.parse(JSON.stringify(object));
			var scanForSpecials = function(original, cloned) {
				if (original instanceof Blob || original instanceof File) {
					return original;
				}
				else if (original instanceof Date) {
					return new Date(original.getTime());
				}
				else if (original instanceof Array) {
					original.forEach(function(y, index) {
						cloned[index] = scanForSpecials(y, cloned[index]);
					})
				}
				else if (self.isObject(original)) {
					Object.keys(original).forEach(function(x) {	
						cloned[x] = scanForSpecials(original[x], cloned[x]);	
					});
				}
				return cloned;
				// this logic assumes you already have an object which is not necessarily the case
				// sometimes we smart clone whatever data you are binding
				/*
				Object.keys(original).forEach(function(x) {
					if (original[x] instanceof Blob || original[x] instanceof File) {
						// should be immutable
						cloned[x] = original[x];
					}
					else if (original[x] instanceof Date) {
						cloned[x] = new Date(original[x].getTime());
					}
					if (original[x] instanceof Array) {
						original[x].forEach(function(y, index) {
							if (self.isObject(y)) {
								scanForSpecials(y, cloned[x][index]);
							}
						});
					}
					else if (self.isObject(original[x])) {
						scanForSpecials(original[x], cloned[x]);
					}
				});
				*/
			};
			return scanForSpecials(object, cloned);
			//return cloned;
		},
		explode: function(into, from, path) {
			var self = this;
			Object.keys(from).forEach(function(key) {
				if (key != null) {
					var value = from[key];
					if (value != null) {
						var childPath = path ? path + "." + key : key;
						// if we explode the arrays as well, they are added like myarray.0.myitem etc
						// in the form engine this can make it hard to manipulate lists as a list item
						// because the arrays are exploded but the form list items work directly on the actual arrays
						// when remerging, the array items are overwritten by the exploded version
						if (self.isObject(value) && !(value instanceof Array)) {
							if (!value._isVue) {
								self.explode(into, value, childPath);
							}
						}
						// only set root values if we have a path?
						else if (path != null) {
							Vue.set(into, childPath, from[key]);
						}
					}
				}	
			});
		},
		isObject: function(object) {
			return object != null 
				&& Object(object) === object 
				&& !(object instanceof Date)
				&& !(object instanceof File)
				&& !(object instanceof Blob);
		},
		isPublicPageParameter: function(page, name) {
			if (page && page.content && page.content.path) {
				if (this.pathParameters(page.content.path).indexOf(name) >= 0) {
					return true;
				}
			}
			if (page && page.content && page.content.query) {
				if (page.content.query.indexOf(name) >= 0) {
					return true;
				}
			}
			return false;
		},
		filterPageStartupParameters: function(page, value) {
			var result = this.getPageStartupParameters(page);	
			var keys = this.getSimpleKeysFor({properties: result}, true);
			return value ? keys.filter(function(x) {
				return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
			}) : keys;
		},
		// for example for initial state, we were using "getPageParameters" which only lists parameters available in the page itself (which is what we want)
		// it should not, for instance, include events (which can not have triggered yet in initial state) nor runtime aliases from renderers (again, not yet available)
		// but we DO need the parent state at that point
		// the getAllAvailableParameters is too broad, it takes all the not-yet-available data into account
		getPageStartupParameters: function(page) {
			var self = this;
			var result = {page: this.getPageParameters(page, true)};
			// if you inherit from another page, we add that as well
			if (page.content.pageParent) {
				var parentPage = this.pages.filter(function(x) {
					return x.content.name == page.content.pageParent;
				})[0];
				if (parentPage != null) {
					result.parent = this.getPageParameters(parentPage);
				}
			}
			// if not defined explicitly, we might still have a parent in this context?
			else {
				var parentInstance = self.$services.page.getParentPageInstance(page);
				if (parentInstance && parentInstance.page) {
					result.parent = this.getPageParameters(parentInstance.page);
				}
			}
			return result;
		},
		// we squash parent scopes into a single scope, so it doesn't matter how many parents you have
		// by specifying the exact parent, the result would be too fragile depending on a very specific layout
		// this does mean if your parent has a variable with the same name as your grandparent, you can not access the grandparent variable
		normalizeParentScope: function(result) {
			// normalize parent scope
			if (result && result.parent && result.parent.properties && result.parent.properties.parent) {
				var parentParent = result.parent.properties.parent;
				delete result.parent.properties.parent;
				var newParent = {};
				nabu.utils.objects.merge(newParent, parentParent);
				// if you redefine the variable in this page, it will be overridden
				nabu.utils.objects.merge(newParent, result.parent);
				result.parent = newParent;
			}
		},
		// TODO: we don't want to be able to edit stuff like events
		// but components can add their own state to the page
		// for that reason, we do need the page instance, to get (in turn) the aliased components with their own state
		// we can't guarantee that the components will be there at runtime (due to conditions)
		// but at you need to be able to bind to these things
		// for instance the page-level form fields use this service to deduce which fields they can write to
		getPageParameters: function(page, excludeRuntime, excludePrivate) {
			var parameters = {
				properties: {}
			};
			if (page.content.path) {
				this.pathParameters(page.content.path).map(function(x) {
					parameters.properties[x] = {
						type: "string"
					}
				})
			}
			if (page.content.query) {
				page.content.query.map(function(x) {
					parameters.properties[x] = {
						type: "string"
					}
				});
			}
			
			var self = this;
			if (page.content.states) {
				page.content.states.forEach(function(x) {
					var operation = null;
					if (x.inherited) {
						operation = self.applicationState.filter(function(y) { return y.name == x.applicationName }).map(function(y) { return y.operation })[0];
					}
					else {
						operation = x.operation;
					}
					if (x.name && operation) {
						operation = self.$services.swagger.operation(operation);
						if (operation && operation.responses && operation.responses["200"]) {
							var schema = operation.responses["200"].schema;
							if (schema && schema.$ref) {
								var definition = self.getResolvedPageParameterType(schema.$ref, null, x.isArray);
								if (definition) {
									parameters.properties[x.name] = definition;
								}
							}
						}
					}
				});
			}
			
			var pageInstance = this.getPageInstance(page);
			// you can set parameters much like swagger input parameters
			// that means you can set a name
			// you can also set a default value and other stuff
			if (page.content.parameters) {
				var self = this;
				page.content.parameters.filter(function(x) { return !excludePrivate || !x.private }).forEach(function(x) {
					/*if (x.type == null || ['string', 'boolean', 'number', 'integer'].indexOf(x.type) >= 0) {
						parameters.properties[x.name] = {
							type: x.type == null ? "string" : x.type
						}
					}
					else {
						parameters.properties[x.name] = self.$services.swagger.resolve(self.$services.swagger.definition(x.type))
					}*/
					var currentValue = null;
					if (x.template) {
						currentValue = self.eval(x.template);
					}
					else {
						currentValue = pageInstance ? pageInstance.get(x.name) : null;
					}
					if (x.useDefinition && x.definition) {
						parameters.properties[x.name] = JSON.parse(x.definition);	
					}
					else {
						parameters.properties[x.name] = self.getResolvedPageParameterType(x.type, currentValue, x.isArray);
					}
				});
			}
			
//			parameters = {properties:{page: { properties: parameters.properties}}};
			
			if (pageInstance && !excludeRuntime) {
				this.enrichWithRuntimeAliasDefinitions(parameters.properties, pageInstance);
			}
			
			return parameters;
		},
		// not used atm
		getTranslatableParameters: function(part, translations) {
			if (translations == null) {
				translations = [];
			}
			var self = this;
			if (part.$translations) {
				part.$translations.forEach(function(translation) {
					if (part[translation]) {
						translations.push({
							key: translation,
							value: part[translation]
						});
					}
				});
			}
			Object.keys(part).forEach(function(key) {
				if (key != "$translations" && (!part.$translations || part.$translations.indexOf(key) < 0)) {
					if (typeof(part[key]) == "object") {
						self.getTranslatableParameters(part[key], translations);
					}
					else if (part[key] instanceof Array) {
						part[key].forEach(function(single) {
							if (typeof(single) == "object") {		
								self.getTranslatableParameters(single, translations);
							}
						})
					}
				}
			})
			return translations;
		},
		notify: function(severity, message) {
			this.validations.push({
				severity: severity,
				message: message,
				title: message
			});
		},
		guessNameFromOperation: function(operation) {
			var parts = operation.split(".");
			var reserved = ["create", "read", "update", "delete", "list", "get", "rest", "crud", "services"];
			for (var i = parts.length - 1; i >= 0; i--) {
				if (reserved.indexOf(parts[i]) < 0) {
					return parts[i];
				}
			}
			return null;
		},
		getResolvedPageParameterType: function(type, instance, isArray) {
			var result;
			if (type == null && instance != null) {
				result = this.getSchemaFromObject(instance);
			}
			else if (type == null || ['string', 'boolean', 'number', 'integer'].indexOf(type) >= 0) {
				result = {type:type == null ? "string" : type};
			}
			else {
				try {
					result = this.$services.swagger.resolve(this.$services.swagger.definition(type));
				}
				catch (exception) {
					console.error("Could not resolve type: " + type);
					return {type: "string"};
				}
			}
			if (result && isArray) {
				result = {
					type: "array",
					items: result
				}
			}
			return result;
		},
		getApplicationProperties: function() {
			var properties = {};
			this.properties.map(function(property) {
				properties[property.key] = property.value;
			});
			this.environmentProperties.map(function(property) {
				properties[property.key] = property.value;
			});
			return properties;
		},
		// @2022-10-26: deprecated because its weird (still need to check if its actually used anywhere)
		getApplicationParameters: function() {
			var parameters = {
				properties: {}
			};
			// and you can set parameters at the web application level that are accessible to any page
			this.properties.map(function(property) {
				parameters.properties[property.key] = property;
			});
			this.environmentProperties.map(function(property) {
				parameters.properties[property.key] = property;
			});
			return parameters;
		},
		getProvidedParameters: function() {
			var parameters = {
				properties: {}
			};
			nabu.page.providers("page-bindings").map(function(provider) {
				var result = provider();
				if (result && result.definition) {
					Object.keys(result.definition).map(function(key) {
						parameters.properties[key] = result.definition[key];	
					});
				}
			});
			return parameters;
		},
		// retrieves the path of rows/cells to get to the targetId, this can be used to resolve instances for example
		getTargetPath: function(rowContainer, targetId, recursive) {
			// when we explode for example cells in a loop, the id is further finetuned, for example the original cell might have id "2", the exploded will have "2-1", "2-2" etc to guarantee in-document uniqueness
			if (typeof(targetId) == "string" && targetId.indexOf("-") > 0) {
				targetId = targetId.substring(0, targetId.indexOf("-"));
			}
			var reverse = false;
			if (!recursive) {
				recursive = true;
				// we manage the complete path at this level, reverse when everything is done as the path contains everything in the reverse order
				reverse = true;
			}
			var self = this;
			var path = null;
			if (rowContainer.rows) {
				for (var i = 0; i < rowContainer.rows.length; i++) {
					path = [];
					var row = rowContainer.rows[i];
					if (row.id == targetId) {
						path.push(row);
					}
					else {
						for (var j = 0; j < row.cells.length; j++) {
							var cell = row.cells[j];
							if (cell.id == targetId) {
								path.push(cell);
								path.push(row);
							}
							else if (cell.rows) {
								var subPath = self.getTargetPath(cell, targetId, recursive);
								if (subPath && subPath.length) {
									nabu.utils.arrays.merge(path, subPath);
									path.push(cell);
									path.push(row);
								}
							}
							if (path.length) {
								break;
							}
						}
					}
					if (path.length) {
						break;
					}
				}
			}
			if (path && reverse) {
				path.reverse();
			}
			return path;
		},
		getSwaggerParametersAsKeys: function(operation) {
			var self = this;
			var keys = [];
			if (operation) {
				if (typeof(operation) == "string") {
					operation = this.$services.swagger.operations[operation];
				}
				operation.parameters.map(function(parameter) {
					if (parameter.in == "body") {
						var type = self.$services.swagger.resolve(parameter);
						if (type.schema.properties) {
							nabu.utils.arrays.merge(keys, self.getSimpleKeysFor(type.schema, true, true).map(function(x) { return "body." + x }));
						}
					}
					else {
						keys.push(parameter.name);
					}
				});
			}
			return keys;
		},
		registerHome: function(home, homeUser) {
			// the previous dynamic home route
			var previousDynamicHome = this.$services.router.router.list().filter(function(x) { return x.alias == "home" && !x.isPage })[0];
			if (previousDynamicHome) {
				this.$services.router.unregister(previousDynamicHome);
			}
			var self = this;
			// check if there is a page-based home, we need to still support that
			var originalHomeRoute = this.$services.router.router.list().filter(function(x) { return x.alias == "home" && x.isPage })[0];
			this.$services.router.register({
				alias: "home",
				enter: function(parameters) {
					// the timeout disconnects the reroute from the current flow
					// otherwise weird things happen
					setTimeout(function() {
						var applicableUser = self.users.filter(function(x) {
							var hasAnyRole = false;
							if (x.roles) {
								x.roles.forEach(function(role) {
									if (role == "$guest" && !self.$services.user.loggedIn) {
										hasAnyRole = true;
									}	
									else if (role == "$user" && self.$services.user.loggedIn) {
										hasAnyRole = true;
									}
									else if (self.$services.user.hasRole && self.$services.user.hasRole(role)) {
										hasAnyRole = true;
									}
								});
							}
							return hasAnyRole;
						})[0];
						if (applicableUser && applicableUser.home) {
							if (applicableUser.home == "home" && originalHomeRoute) {
								originalHomeRoute.enter(parameters);
							}
							else {
								self.$services.router.route(applicableUser.home, parameters);
							}
						}
						else if (homeUser && self.$services.user.loggedIn) {
							if (homeUser == "home" && originalHomeRoute) {
								originalHomeRoute.enter(parameters);
							}
							else {
								self.$services.router.route(homeUser, parameters);
							}
						}
						else if (home) {
							if (home == "home" && originalHomeRoute) {
								originalHomeRoute.enter(parameters);
							}
							else {
								self.$services.router.route(home, parameters);
							}
						}
						else {
							self.$services.router.route("login", parameters, null, true);
						}
					}, 1)
				},
				url: "/",
				priority: 1
			});
		},
		// unused?
		dropOperationInto: function (operation, cell, failIfMissing) {
			var self = this;
			if (this.$services.swagger.operations[operation]) {
				console.log("Dropping", operation);
			}
			else if (!failIfMissing) {
				this.reloadSwagger().then(function() {
					self.dropOperationInto(operation, cell, true);
				});
			}
		},
		updateUrl: function(url) {
			var element = document.head.querySelector("meta[property='og:url']");
			var insert = true;
			if (element) {
				if (element.getAttribute("content") != url) {
					element.parentNode.removeChild(element);
				}
				else {
					insert = false;
				}
			}
			if (insert && url) {
				element = document.createElement("meta");
				element.setAttribute("property", "og:url");
				element.setAttribute("content", url);
				document.head.appendChild(element);
			}
		},
		// update the branding parameters depending on the page
		updateBranding: function(branding, pageInstance) {
			var self = this;
			
			if (branding && pageInstance) {
				var resolvedBranding = {};
				Object.keys(branding).forEach(function(key) {
					resolvedBranding[key] = self.interpret(branding[key], pageInstance, pageInstance.variables, pageInstance.$value);
				})
				branding = resolvedBranding;
			}
			
			var fields = ["favicon", "title", "siteName", "description", "image", "imageAlt", "facebookAppId", "twitterUserName"];
			// the current branding takes the specific branding and (if absent) the default branding
			fields.forEach(function(field) {
				self.currentBranding[field] = branding[field] ? branding[field] : self.branding[field];
				// an exception for title...
				if (!self.currentBranding[field] && field == "title" && self.title) {
					self.currentBranding[field] = self.title;
				}
			})
			var og = ["title", "description", "image", "siteName"];
			
			fields.forEach(function(field) {
				if (field == "favicon") {
					// updating favicon
					var element = document.head.querySelector("link[rel='icon']");
					var insertFavicon = true;
					if (element) {
						if (element.getAttribute("href") != self.currentBranding[field]) {
							element.parentNode.removeChild(element);
						}
						else {
							insertFavicon = false;
						}
					}
					if (insertFavicon && self.currentBranding[field]) {
						element = document.createElement("link");
						element.setAttribute("rel", "icon");
						element.setAttribute("type", "image/png");
						element.setAttribute("href", self.currentBranding[field]);
						document.head.appendChild(element);
					}
				}
				else if (og.indexOf(field) >= 0) {
					var element = document.head.querySelector("meta[property='og:" + field + "']");
					var insert = true;
					if (element) {
						if (element.getAttribute("content") != self.currentBranding[field]) {
							element.parentNode.removeChild(element);
						}
						else {
							insert = false;
						}
					}
					if (insert && self.currentBranding[field]) {
						element = document.createElement("meta");
						element.setAttribute("property", "og:" + field);
						element.setAttribute("content", self.currentBranding[field]);
						document.head.appendChild(element);
					}
					if (field == "title" && self.currentBranding[field] != null) {
						document.title = self.templateTitle();
					}
				}
				else if (field == "imageAlt") {
					var element = document.head.querySelector("meta[name='twitter:image:alt']");
					var insert = true;
					if (element) {
						if (element.getAttribute("content") != self.currentBranding[field]) {
							element.parentNode.removeChild(element);
						}
						else {
							insert = false;
						}
					}
					if (insert && self.currentBranding[field]) {
						element = document.createElement("meta");
						element.setAttribute("name", "twitter:image:alt");
						element.setAttribute("content", self.currentBranding[field]);
						document.head.appendChild(element);
					}
				}
				// TODO: the others are not reactive yet, they are generally not updated per page...
			});
		},
		templateTitle: function(page) {
			var environment = this.getEnvironment();
			var template = this.title;
			if (page && page.content.title) {
				template = page.content.title;
			}
			else if (this.currentBranding && this.currentBranding.title) {
				template = this.currentBranding.title;
			}
			else if (this.branding && this.branding.title) {
				template = this.branding.title;
			}
			if (template) {
				var defaultTitle = template.match(/.*\{title\|([^}]+)\}.*/) ? template.replace(/.*\{title\|([^}]+)\}.*/, "$1") : "Unnamed";
				template = template.replace("{environment}", environment);
				if (page) {
					template = template.replace(/\{title[^}]*}/, page.content.label);
					template = template.replace("{category}", page.content.category);
				}
				else {
					template = template.replace(/\{title[^}]*}/, defaultTitle);
				}
				return this.$services.page.translate(this.$services.page.interpret(template, this));
			}
		},
		getEnvironment: function() {
			var environment = this.environment;
			// we assume stuff like "bebat-dev" etc, we are generally interested in the last bit
			var parts = environment.split("-");
			// the last part
			environment = parts[parts.length - 1].toUpperCase();
			return environment;
		},
		dashify: function(content) {
			if (content == null) {
				return null;
			}
			return this.underscorify(content).replace(/_/g, "-");
		},
		underscorify: function(content) {
			if (content == null) {
				return null;
			}
			return content.replace(/[^\w]+/g, "_").replace(/([A-Z]+)/g, "_$1").replace(/^_/, "").replace(/_$/, "")
				.replace(/[_]+/g, "_").toLowerCase();
		},
		prettify: function(text) {
			if (text == null) {
				return null;
			}
			text = this.underscorify(text);
			var result = null;
			text.split(/_/).forEach(function(x) {
				if (!result) {
					result = "";
				}
				else {
					result += " ";
				}
				if (x.length > 0) {
					result += x.substring(0, 1).toUpperCase() + x.substring(1);
				}
			});
			return result;
		},
		camelify: function(content) {
			if (content == null) {
				return null;
			}
			// first we do underscores, it is easiest
			// if we start or end with an underscore, remove it
			content = this.underscorify(content);
			var parts = content.split("_")
			var result = null;
			for (var i = 0; i < parts.length; i++) {
				if (result == null) {
					result = parts[i];
				}
				else {
					result += parts[i].substring(0, 1).toUpperCase() + parts[i].substring(1);
				}
			}
			return result;
		},
		normalizeCell: function(cell) {
			if (cell.rows == null) {
				cell.rows = [];
			}
			if (cell.bindings == null) {
				cell.bindings = {};
			}
			if (cell.devices == null) {
				cell.devices = [];
			}
			if (cell.id == null) {
				cell.id = -1;
			}
			cell.rows.forEach(this.normalizeRow);
			return cell;
		},
		normalizeRow: function(row) {
			if (row.cells == null) {
				row.cells = [];
			}
			if (row.id == null) {
				row.id = -1;
			}
			row.cells.forEach(this.normalizeCell);
			return row;
		},
		unsetCookie: function(cookie) {
			var index = cookie.indexOf('=');
			var name = index >= 0 ? cookie.substring(0, index) : cookie;
			var path = null;
			if (cookie.indexOf("path") >= 0) {
				path = cookie.replace(/[\n]+/, " ").replace(/.*;[\s]*path[\s]*=[\s]*([^;]+).*/, "$1");
				if (path == cookie) {
					path = null;
				}
			}
			if (path == null) {
				path = "/";
			}
			var expires = "";
			var days = -365;
			var value = "cleared"; 
			var domain = null;
			if (cookie.indexOf("domain") >= 0) {
				domain = cookie.replace(/[\n]+/, " ").replace(/.*;[\s]*domain[\s]*=[\s]*([^;]+).*/, "$1");
				if (domain == cookie) {
					domain = null;
				}
			}
			var date = new Date();
			date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
			expires = "; expires=" + date.toUTCString();
			var fullCookie = name + "=" + value + expires + "; path=" + path
				+ (domain ? ";domain=" + domain : "");
			// pre and post intercept
			if (document.originalCookie != null) {
				document.originalCookie = fullCookie;
			}
			else {
				document.cookie = fullCookie;
			}
			// it seems setting with domain "null" does not unset cookies at for example ".sub.domain.com"
			// we do a second round with the actual domain, this seems to work to remove those as well
			if (domain == null) {
				domain = "${environment('host')}";
			}
			var fullCookie = name + "=" + value + expires + "; path=" + path
				+ (domain ? ";domain=" + domain : "");
			if (document.originalCookie != null) {
				document.originalCookie = fullCookie;
			}
			else {
				document.cookie = fullCookie;
			}
		},
		// check if the name is allowed
		isAllowedCookie: function(name) {
			var allowedCookies = this.getAllowedCookies();
			if (allowedCookies.indexOf(name) >= 0) {
				return true;
			}
			for (var i = 0; i < allowedCookies.length; i++) {
				if (name.match(new RegExp(allowedCookies[i]))) {
					return true;
				}
			}
			return false;
		},
		// list all the cookies you want to accept, as an array
		acceptCookies: function(cookies) {
			if (!cookies) {
				cookies = [];
			}
			else if (!(cookies instanceof Array)) {
				cookies = [cookies];
			}
			// remember _100_ years!
			this.$services.cookies.set("cookie-settings", JSON.stringify(cookies), 365*100);
			this.calculateAcceptedCookies();
			// synchronize immediately
			this.synchronizeCookies();
			this.cookieHooks.forEach(function(x) { x(cookies) });
		},
		// you can add functions that are run everytime the cookie settings change
		addCookieHook: function(func) {
			this.cookieHooks.push(func);
			// immediately trigger in case you accepted in a previous instance
			func(this.getAllowedCookies());
		},
		interceptCookies: function() {
			var self = this;
			// now we write an intercept so any new cookies being written can not violate this
			var originalCookie = "originalCookie";
			if (!this.isSsr) {
				// we redirect document.cookie to document.originalCookie
				Object.defineProperty(
					Document.prototype, 
					originalCookie, 
					Object.getOwnPropertyDescriptor(Document.prototype, 'cookie')
				);
				// we redefine document.cookie
				Object.defineProperty(Document.prototype, 'cookie', {
					enumerable: true,
					configurable: true,
					get: function() {
						return this[originalCookie];
					},
					set: function(value) {
						// we check if the cookie is allowed
						var index = value.indexOf('=');
						if (index >= 0) {
							var cookieName = value.substring(0, index);
							// if it's allowed, we let it pass
							if (self.isAllowedCookie(cookieName)) {
								this[originalCookie] = value;
							}
							else {
								console.log("Blocking cookie", cookieName);
								self.unsetCookie(value);
							}
						}
					}
				});
			}
		},
		synchronizeCookies: function(repeat) {
			var self = this;
			// first up: remove any cookies that should not be there
			// the problem is load order, we can't fully guarantee to intercept all cookie setting, because that would require the javascript to be run before any includes are resolved
			// because this is hard to guarantee, we simply remove the cookies later on if it is relevant
			var cookies = document.cookie.split(/[\s]*;[\s]*/);
			for (var i = 0; i < cookies.length; i++) {
				var index = cookies[i].indexOf('=');
				if (index >= 0) {
					var name = cookies[i].substring(0, index);
					if (!self.isAllowedCookie(name)) {
						console.log("Removing cookie", name);
						self.unsetCookie(cookies[i]);
					}
				}
			}
			if (repeat) {
				// repeat periodically
				setTimeout(function() {
					self.synchronizeCookies(repeat)
				}, 30000);
			}
		}
	},
	watch: {
		environment: function(newValue, oldValue) {
			if (oldValue && document.body) {
				document.body.classList.remove("environment-" + oldValue);
			}
			if (newValue) {
				// TODO: update class
				var updateEnvironmentClass = function() {
					if (document.body) {
						document.body.classList.add("environment-" + newValue);
					}
					else {
						setTimeout(updateEnvironmentClass, 100);
					}
				}
				updateEnvironmentClass();
			}
		},
		editing: function(newValue) {
			// reset the calculated page types
			if (!newValue) {
				this.calculatedPageTypes = {};
			}
		},
		rendering: function(newValue) {
			if (newValue > 0) {
				if (this.stableTimer) {
					clearTimeout(this.stableTimer);
					this.stableTimer = null;
				}
				this.stable = false;
			}
			else {
				var self = this;
				this.stableTimer = setTimeout(function() {
					self.stable = true;
				}, 100);
			}
		},
		stable: function(newValue) {
			console.log("rendering stable", newValue);	
		},
		// push the location to the swagger client
		location: function(newValue) {
			this.$services.swagger.geoPosition = newValue;
		},
		pages: function(newValue) {
			if (!this.loading) {
				this.loadPages(newValue);
			}
		},
		title: function(newValue) {
			document.title = newValue;
		},
		home: function(newValue) {
			if (newValue && !this.loading) {
				this.registerHome(newValue, this.homeUser);
			}
		},
		homeUser: function(newValue) {
			if (newValue && !this.loading) {
				this.registerHome(this.home, newValue);
			}
		},
		showConsole: function(newValue) {
			if (this.canTest()) {
				// remove from DOM
				var element = document.querySelector("#nabu-console-instance");
				if (element) {
					element.parentNode.removeChild(element);
				}
				// render a console in the DOM
				if (newValue) {
					var div = document.createElement("div");
					div.setAttribute("id", "nabu-console-instance");
					document.body.appendChild(div);
					this.$services.router.route("nabu-console", { initialTab: "features" }, div);
					//this.$services.router.route("nabu-console", { initialTab: this.consoleTab }, div);
					document.body.classList.add("has-nabu-console");
					this.consoleTab = null;
				}
				else {
					document.body.classList.remove("has-nabu-console");
					this.limitReports();
				}
			}
		},
		branding: {
			deep: true,
			handler: function(newValue) {
				var self = this;
				Vue.nextTick(function() {
					self.updateBranding(self.branding);
				})
			}
		}
	}
}), { name: "nabu.page.services.Page" });


document.addEventListener("mousemove", function(event) {
	if (application && application.services && application.services.page) {
		application.services.page.mouseX = event.pageX;
		application.services.page.mouseY = event.pageY;
		application.services.page.mouseXPassive = event.pageX;
		application.services.page.mouseYPassive = event.pageY;
	}
});


var clearTemplates = function() {
	var scripts = document.head.getElementsByTagName("script");
	for (var i = scripts.length - 1; i >= 0; i--) {
		scripts[i].parentNode.removeChild(scripts[i]);
	}
}
/**
 * Providers should optionally have these handlers:
 * - start: when the session is first started
 * - stop: when the session is stopped
 * - reauthenticate: when the authentication for the user changes
 * - push(data): an array of data structures, there are a few "reserved" fields
 * 		- event: the event name, for actions this is the actual action name you configured, the most specific
 * 		- type: the event type (e.g. browse, action-trigger (usually by clicking)), we could for example add an "action-validate" in case it triggers validations
 * 		- category: the category of types it belongs to, e.g. everything you can do with an "page action" is in the category "action", e.g. click & hover
 * 		- group: the category this event belongs to (e.g. the page category, or a manually grouped set of buttons)
 * 
 * 
 * Example:
 * 	- event: which button you clicked (e.g. finalize-order)
 *  - type: you clicked a button (button-click)
 * 	- category: you did something with a button (button)
 * 	- group: if you want to combine multiple buttons into a custom grouping for reporting reasons
 */
Vue.service("analysis", {
	// if we wait on the page, we know the user is already loaded as well
	services: ["page"],
	data: function() {
		return {
			provider: null,
			id: 1,
			mobile: application && application.configuration && application && application.configuration.mobile != null ? application && application.configuration.mobile : navigator.userAgent.toLowerCase().indexOf("mobi") >= 0,
			language: application && application.configuration ? application.configuration.language : null,
			timezone: null,
			locale: null
		}
	},
	activate: function(done) {
		this.start();
		if (Intl && Intl.DateTimeFormat	&& Intl.DateTimeFormat().resolvedOptions) {
			this.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
			this.locale = Intl.DateTimeFormat().resolvedOptions().locale;
		}
		done();
	},
	methods: {
		apply: function(x) {
			nabu.page.providers("page-analysis").forEach(x);
		},
		start: function() {
			this.apply(function(x) {
				if (x.start) {
					x.start();
				}
			});
		},
		stop: function() {
			this.apply(function(x) {
				if (x.stop) {
					x.stop();
				}
			});
		},
		// type: the type of event (e.g. page-action, click,...)
		// name: the specific event, e.g. a specific button
		push: function(data) {
			var self = this;
			// enrich with environmental information
			data.meta = {
				mobile: this.mobile,
				browserLanguage: navigator.language,
				created: new Date().toISOString(),
				url: window.location.href,
				userAgent: navigator.userAgent
			};
			if (document.referrer) {
				data.meta.referrer = document.referrer;
			}
			if (this.language) {
				data.meta.userLanguage = this.language;
			}
			if (this.timezone) {
				data.meta.timezone = this.timezone;
			}
			if (this.locale) {
				data.meta.locale = this.locale;
			}
			data.eventId = this.id++;
			// we add the location if we have it
			if (this.$services.page.location) {
				data.location = this.$services.page.location;
			}
			this.apply(function(x) {
				if (x.push) {
					x.push(data);
				}
			});
			this.$services.page.report("analysis", data.source ? data.source : (data.pageName ? data.pageName : "$anonymous"), data.type, data.event, data);
		}
	},
	// if we upgrade the user credentials, a clear is triggered
	clear: function(done) {
		this.apply(function(x) {
			if (x.reauthenticate) {
				x.reauthenticate();
			}
		});
		done();
	}
});

// stop the session when unloading
// for chrome
window.addEventListener("beforeunload", function(event) {
	if (application.services && application.services.analysis) {
		application.services.analysis.stop();
	}
});

// for not-chrome
window.addEventListener("unload", function(event) {
	if (application.services && application.services.analysis) {
		application.services.analysis.stop();
	}
});

/*
A notification has a standard layout:

- name: the name of the notification (if any), it can be used to perform some action (like close all notifications with name 'something')
- event: the name of the event (if any) that caused the notification to be sent out, unlikely to be useful
- duration: how long should the notification be visible? if explicitly set to 0, it will stay open until the user closes it (this assumes closeable is turned on...)
- title (optional)
- message (required)
- severity
- closeable (is there an x to close early?)
- icon (is there an icon to show?)
- actions []: array of actions you can perform, each action has:
	- component: if the name of a component is specified, that is rendered with the data of the notification as v-bind parameters (this allows you to fully freestyle)
			if not specified, the action is assumed to be a button
	- class: the class to be applied to the component / button
	- click: what should happen on click? (generic handler)
	- route: you can set a route where the user fill be redirected to if they click it (in lieu of the generic handler)
	- the route will be passed the data from the notification to best match the input parameters
		-> you can craft custom events to get the data just right if needed
- data
	-> a notification is triggered by an event, the data object contains whatever data is in the event
	-> this data is passed 


page builder extensions:
- condition: an additional condition when the event should trigger
- on: the event to trigger on
*/
Vue.service("notifier", {
	methods: {
		activeProviders: function() {
			// IE does not have this
			var priority = Number.MIN_SAFE_INTEGER ?  Number.MIN_SAFE_INTEGER : -1000000;	
			// there can only be one notifier active, based on priority
			return nabu.page.providers("page-notifier").sort(function(a, b) {
				if (a.priority == null) {
					a.priority = 0;
				}
				if (b.priority == null) {
					b.priority = 0;
				}
				// highest first!
				return b.priority - a.priority;
			}).filter(function(x) {
				// if we have the same priority or higher than the current one, we assume it is ok to add
				if (x.priority >= priority) {
					priority = x.priority;
					return true;
				}
				return false;
			});
		},
		apply: function(x) {
			this.activeProviders().forEach(x);
		},
		push: function(notification) {
			// if data is missing (e.g. no duration, no closeable etc), the implementation can choose what the default behavior should be
			// if we rectified the data here, the implementation would never know the original request
			this.apply(function(x) {
				x.push(notification);
			});
		}
	}
});
// the data service combines reusable functionality for loading data arrays in the frontend
// as well as a reusable configuration component that can capture all the necessary information

// basic data operations are only concerned with retrieving series data from the page state or the backend
// this series can be paged if needed and we can jump to different pages etc

// pipelines build on basic data but add in streaming updates/creates/deletes and can do meta calculations on the data to reduce it to a point value or expand it into a matrix
// note that pipelines can be windowed at the start, but the window should not change when streaming is active. streaming updates do not work well with paged window switching.
// we currently recognize 3 types of pipeline data
// - series (basically an array of data, this can be streamingly updated)
// - point: a single conclusion based on a series, for example the maximum, minimum, sum,...
// - matrix: a dynamic series of series calculated on top of a series. For instance a group by

// especially for matrices we can opt to "normalize" them so every entry in the matrix contains an equal amount of entries
// this does require a normalization key to be present in the data, this can be offset either against a predefined series of labels or a calculated sum total of all the labels in the original series
// we can also normalize a basic series vs an expected list of labels if needed

Vue.component("data-mixin", {
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	created: function() {
		this.loadData();
		this.watchAll();
		Vue.set(this.state, "filter", this.filter);
		Vue.set(this.state, "records", this.records);
		Vue.set(this.state, "selected", this.selected);
	},
	data: function() {
		return {
			loadPromise: null,
			subscriptions: [],
			records: [],
			selected: [],
			paging: {},
			state: {},
			filter: {},
			loadTimer: null
		}
	},
	methods: {
		clear: function() {
			this.records.splice(0);
		},
		loadDataAsync: function() {
			if (this.loadTimer) {
				clearTimeout(this.loadTimer);
				this.loadTimer = null;
			}
			this.loadTimer = setTimeout(this.loadData, 100);
		},
		loadData: function() {
			var self = this;
			self.clear();
			// abort the previous promise if it still ongoing
			if (this.loadPromise && this.loadPromise.abort) {
				this.loadPromise.abort();
			}
			this.loadPromise = this.$services.data.load({
				instance: this,
				limit: 0,
				handler: function(results, page) {
					self.clear();
					// HOOK
					if (self.postProcess) {
						results = self.postProcess(results);
					}
					nabu.utils.arrays.merge(self.records, results);
				}
			});
		},
		select: function(record, append) {
			if (!append) {
				this.selected.splice(0);
			}
			if (record instanceof Array) {
				nabu.utils.arrays.merge(this.selected, record);
			}
			else if (record) {
				this.selected.push(record);
			}
		},
		unsubscribe: function() {
			this.$services.data.unwatchAll(this.subscriptions);
		},
		watchAll: function() {
			this.unsubscribe();
			var self = this;
			nabu.utils.arrays.merge(this.subscriptions, this.$services.data.watchAll({
				instance: this,
				target: this.cell.state,
				handler: function() {
					Vue.set(self, "data", null);
					self.loadDataAsync();
					self.watchAll();
				}
			}));
		},
		getRuntimeAlias: function () {
			return this.cell.state.runtimeAlias;
		},
		getRuntimeState: function () {
			return this.state;
		},
		getState: function () {
			return {
				properties: {
					filter: this.$services.data.getInputParameters(this.cell.state.operation),
					records: {
						type: "array",
						items: {
							type: "object",
							properties: this.$services.data.getDataDefinition({instance: this})
						}
					},
					selected: {
						type: "array",
						items: {
							type: "object",
							properties: this.$services.data.getDataDefinition({instance: this})
						}
					}
				}
			};
		},
	},
	beforeDestroy: function() {
		this.unsubscribe();
	}
})

Vue.service("data", {
	services: ["swagger"],
	methods: {
		// TODO: we want to add other sources of operations
		// like functions, page-builder-managed services (which perform CRUD and contain state)
		getOperations: function() {
			return this.getSwaggerOperations();	
		},
		getDataOperations: function(name) {
			return this.getSwaggerDataOperations(name);
		},
		execute: function(operationId, parameters) {
			// TODO: differentiate between services, functions...
			return this.$services.swagger.execute(operationId, parameters);	
		},
		getSwaggerOperations: function(accept) {
			var result = [];
			var operations = this.$services.swagger.operations;
			Object.keys(operations).map(function(operationId) {
				if (accept(operations[operationId])) {
					result.push(operations[operationId]);
				}
			});
			result.sort(function(a, b) {
				return a.id.localeCompare(b.id);
			});
			return result;
		},
		getSwaggerDataOperations: function(name) {
			var self = this;
			return this.getSwaggerOperations(function(operation) {
				// must be a get
				var isAllowed = operation.method.toLowerCase() == "get"
					// and contain the name fragment (if any)
					&& (!name || operation.id.toLowerCase().indexOf(name.toLowerCase()) >= 0)
					// must have _a_ response
					&& operation.responses["200"];
				// we also need at least _a_ complex array in the results
				if (isAllowed && operation.responses["200"] != null && operation.responses["200"].schema != null) {
					var schema = operation.responses["200"].schema;
					var definition = self.$services.swagger.definition(schema["$ref"]);
					isAllowed = false;
					if (definition.properties) {
						Object.keys(definition.properties).map(function(field) {
							if (definition.properties[field].type == "array") {
								isAllowed = true;
							}
						});
					}
				}
				return isAllowed;
			});
		},
		getDefinition: function(operationId) {
			var properties = {};
			var operation = this.$services.swagger.operations[operationId];
			if (operation && operation.responses["200"]) {
				var definition = this.$services.swagger.resolve(operation.responses["200"].schema);
				if (definition.properties) {
					var self = this;
					Object.keys(definition.properties).map(function(field) {
						if (definition.properties[field].type == "array") {
							var items = definition.properties[field].items;
							if (items.properties) {
								nabu.utils.objects.merge(properties, items.properties);
							}
						}
					});
				}
			}
			/*else if (this.cell.state.array) {
				var available = this.$services.page.getAvailableParameters(this.page, this.cell);
				var variable = this.cell.state.array.substring(0, this.cell.state.array.indexOf("."));
				var rest = this.cell.state.array.substring(this.cell.state.array.indexOf(".") + 1);
				if (available[variable]) {
					var childDefinition = this.$services.page.getChildDefinition(available[variable], rest);
					if (childDefinition) {
						nabu.utils.objects.merge(properties, childDefinition.items.properties);
					}
				}
			}*/
			return properties;
		},
		getInputParameters: function(operationId) {
			var result = {
				properties: {}
			};
			var self = this;
			var operation = this.$services.swagger.operations[operationId];
			if (operation && operation.parameters) {
				var blacklist = ["limit", "offset", "orderBy", "connectionId"];
				var parameters = operation.parameters.filter(function(x) {
					return blacklist.indexOf(x.name) < 0;
				}).map(function(x) {
					result.properties[x.name] = self.$services.swagger.resolve(x);
				})
			}
			return result;
		},
		
		
		
		
		
		
		
		// input can contain:
		// instance: the instance of your component is expected to contain the regular "page" etc parameters
		// target: the target is where your state is stored (by default this is either cell.state or target)
		// filter: you can pass in an object that represents in the input parameters (e.g. query parameters)
		// 		for instance for the repeat this should be the "this.state.filter"
		// orderBy: you can pass in a string array of order by statements
		// 		for the repeat this should be "this.state.order.by"
		// serviceContext: manipulate the service context
		// page: the page number to load
		// handler: the data handler that will receive the new data
		// we will return a promise for the "main" data result, but in the future there will be multiple handlers (added/modified/deleted through streaming)
		// so the handler logic is also available
		normalizeInput: function(input) {
			var self = this;
			// the input can be a vnode in and off itself
			var instance = input.$vnode ? input : input.instance;
			// don't use other variables directly from the instance
			if (input.$vnode) {
				input = {};
			}
			var target = input.target ? input.target : (instance && instance.cell ? instance.cell.state : instance.target);
			var operation = input.operation ? input.operation : (target ? target.operation : null);
			var array = input.array ? input.array : (target ? target.array : null);
			var bindings = input.bindings ? input.bindings : (target ? target.bindings : null);
			// if you have a filter object on your instance itself (e.g. for data components), we use that
			var filter = input.filter ? input.filter : (instance && instance.filter ? instance.filter : (instance && instance.state ? instance.state.filter : null));
			var orderBy = input.orderBy ? input.orderBy : (instance && instance.state && instance.state.order ? instance.state.order.by : (target ? target.defaultOrderBy : null));
			if (orderBy != null) {
				if (!(orderBy instanceof Array)) {
					orderBy = [orderBy];
				}
				orderBy = orderBy.map(function(single) {
					// if it is an object, we assume the standard layout with "name" and "direction"
					if (self.$services.page.isObject(single)) {
						return single.name + (single.direction ? " " + single.direction : "");
					}
					// otherwise we assume already serialized order by
					else {
						return single;
					}
				});
			}
			var page = input.page ? input.page : (instance ? instance.page : null);
			var pageInstance = input.pageInstance ? input.pageInstance : (page ? this.$services.page.getPageInstance(page, instance) : null);
			var limit = input.limit;
			// a script to modify the data
			var script = input.script ? input.script : (target ? target.script : null);
			// a template of what the output of the script would be, for type generation
			var template = input.template ? input.template : (target ? target.template : null);
			return {
				handler: input.handler,
				target: target,
				operation: operation,
				array: array,
				bindings: bindings,
				filter: filter,
				orderBy: orderBy,
				pageInstance: pageInstance,
				limit: limit,
				script: script,
				page: page,
				serviceContext: input.serviceContext,
				template: template,
				pageNumber: input.pageNumber
			}
		},
		// get the array output field for a given operation
		getArrayOutputField: function(operationId) {
			var operation = this.$services.swagger.operations[operationId];
			if (operation && operation.responses && operation.responses["200"] && operation.responses["200"].schema) {
				var properties = {};
				var definition = this.$services.swagger.resolve(operation.responses["200"].schema);
				var arrays = this.$services.page.getArrays(definition);
				if (arrays.length > 0) {
					var childDefinition = this.$services.page.getChildDefinition(definition, arrays[0]);
					if (childDefinition && childDefinition.items && childDefinition.items.properties) {
						properties[arrays[0]] = childDefinition.items.properties;
					}
				}
				return properties;
			}
		},
		getDataDefinition: function(input) {
			input = this.normalizeInput(input);
			if (input.operation) {
				var operation = this.$services.swagger.operations[input.operation];
				if (operation && operation.responses && operation.responses["200"] && operation.responses["200"].schema) {
					var properties = {};
					var definition = this.$services.swagger.resolve(operation.responses["200"].schema);
					var arrays = this.$services.page.getArrays(definition);
					if (arrays.length > 0) {
						var childDefinition = this.$services.page.getChildDefinition(definition, arrays[0]);
						if (childDefinition && childDefinition.items && childDefinition.items.properties) {
							nabu.utils.objects.merge(properties, childDefinition.items.properties);
						}
					}
					if (definition.properties) {
						Object.keys(definition.properties).map(function(field) {
							if (definition.properties[field].type == "array") {
								var items = definition.properties[field].items;
								if (items.properties) {
									nabu.utils.objects.merge(properties, items.properties);
								}
							}
						});
					}
					return properties;
				}
				else {
					console.warn("Could not resolve data for operation", input.operation);
					return {};
				}
			}
			else if (input.array) {
				var parameters = this.$services.page.getAvailableParameters(input.pageInstance.page, null, true);
				
				var arrayName = input.array;
				var definition = this.$services.page.getChildDefinition({properties:parameters}, arrayName);
				if (!definition && arrayName.indexOf("page.") == 0) {
					definition = this.$services.page.getChildDefinition({properties:parameters}, arrayName.substring("page.".length));
				}
				if (!definition && arrayName.indexOf("parent.") == 0) {
					var parentPage = this.$services.page.pages.filter(function(x) {
						return x.content.name == input.pageInstance.page.content.pageParent;
					})[0];
					if (parentPage) {
						var parentParameters = this.$services.page.getAvailableParameters(parentPage, null, true);
						definition = this.$services.page.getChildDefinition({properties:parentParameters}, arrayName.substring("parent.".length));	
						if (definition == null && arrayName.indexOf("parent.page.") == 0) {
							definition = this.$services.page.getChildDefinition({properties:parentParameters}, arrayName.substring("parent.page.".length));	
						}
					}
				}
				if (definition && definition.items && definition.items.properties) {
					return definition.items.properties;
				}
				else {
					console.warn("Could not resolve data for array", input.array);
					return {};
				}
			}
			// check generation script
			else if (input.script) {
				// TODO: derive from template!
			}
		},
		filterFields: function(input, value) {
			var definition = this.getDataDefinition(input);
			var keys = this.$services.page.getSimpleKeysFor({properties:definition}, true, true);
			if (value) {
				keys = keys.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
			}
			return keys;
		},
		// the extracter function can just return a value from the data point
		// or you can do some calculation before returning it, for example a date might have millisecond precision but you want to group by minute
		// the extracter should return an object with two fields:
		// - value: the value we will use for label matching
		// - description: the prettified description to show the user (if it comes up), for example with date formatting
		// if the description does not exist, the value is used
		calculateLabelSeries(series, extracter) {
			var labels = [];
			var capturedValues = [];
			series.forEach(function(entry) {
				var extracted = extracter(entry);
				if (capturedValues.indexOf(extracted.value) < 0) {
					capturedValues.push(extracted.value);
					labels.push(extracted);
				}
			});
			return labels;
		},
		getDataType: function(input) {
			input = this.normalizeInput(input);
			if (input.target && input.target.template) {
				var templated = this.$services.page.eval(input.target.template);
				if (templated instanceof Array) {
					if (templated.length) {
						var instance = templated[0];
						return instance instanceof Array ? "matrix" : "series";
					}
				}
				else {
					return "point";
				}
			}
			return "series";
		},
		// we can generate a time series from a certain date until a certain with a given interval
		// each result can have an "extracter" to get the actual data from the timestamp (e.g. generalized to minute, day,..)
		// and a formatter which extracts a value for human consumption
		getTimeSeries: function(from, until, increment, extracter, formatter) {
			var series = [];
			while (from.getTime() < until.getTime()) {
				var value = extracter(from);
				var description = formatter ? formatter(from) : value;
				series.push({
					value: value,
					description: description
				});
				from = new Date(from.getTime() + increment);
			}
			return series;
		},
		// when a series is normalized against a set of labels, we might conclude that a single label has multiple entries
		// we can use the combiner to combine them into a new data point (e.g. sum them)
		// the default combiner will just return the "last" one
		normalizeSeries(series, extracter, labels, combiner) {
			if (!combiner) {
				combiner = function(matching) { return matching[matching.length - 1]; };
			}
			var result = [];
			var hashed = {};
			series.forEach(function(entry) {
				var extracted = extracter(entry);
				if (hashed[extracted.value] == null) {
					hashed[extracted.value] = [];
				}
				hashed[extracted.value].push(entry);
			});
			labels.forEach(function(label) {
				var matching = hashed[label.value];
				// no matches were found, insert an empty value
				if (matching == null) {
					result.push(null);
				}
				else if (matching.length == 1) {
					result.push(matching[0]);
				}
				else {
					result.push(combiner(matching));
				}
			});
			return result;
		},
		normalizeMatrix(matrix, extracter, labels, combiner) {
			var result = [];
			var self = this;
			matrix.forEach(function(row) {
				result.push(self.normalizeSeries(row, extracter, labels, combiner));
			});
			return result;
		},
		// when creating a matrix from a series, the extracter determines which dynamic series it ends up in
		createMatrix: function(series, extracter) {
			return Object.values(this.group(series, extracter));
		},
		group: function(series, extracter) {
			var hashed = {};
			series.forEach(function(entry) {
				var extracted = extracter(entry);
				var value = extracted.value ? extracted.value : extracted;
				if (hashed[value] == null) {
					hashed[value] = [];
				}
				hashed[value].push(entry);
			})
			return hashed;
		},
		load: function(input) {
			var self = this;
			
			input = this.normalizeInput(input);
			
			var transform = function(data) {
				if (input.script) {
					var result = (new Function('with(this) { return ' + input.script + ' }')).call({
						value: data,
						$value: input.instance.$value,
						state: {data:data},
						$services: self.$services
					});
					//var result = eval(code);
					if (result instanceof Function) {
						result = result.bind(this);
						result = result(value);
					}
					return result;
				}
				else {
					return data;
				}
			}
			
			var promise = this.$services.q.defer();
			
			var handler = function(results, paging, error) {
				results = transform(results);
				if (input.handler) {
					input.handler(results, paging, error);
				}
				if (error) {
					promise.reject(error);
				}
				else {
					promise.resolve({
						records: results,
						paging: paging
					})
				}
			}
			
			// we want to call an operation
			if (input.operation) {
				var parameters = {};
				var self = this;
				if (input.bindings) {
					Object.keys(input.bindings).map(function(name) {
						if (input.bindings[name]) {
							var value = self.$services.page.getBindingValue(input.pageInstance, input.bindings[name], self);
							if (value != null && typeof(value) != "undefined") {
								parameters[name] = value;
							}
						}
					});
				}
				// some components (e.g. repeat) will keep a local value for the filter input parameters
				// this wins from anything bound to the input
				if (input.filter) {
					Object.keys(input.filter).forEach(function(key) {
						// someone might still attempt to write to record?
						// by default the state has no keys
						// any key available is explicitly written by the user, so even a null value is an active decision
						if (key != "record") {
							parameters[key] = input.filter[key];
						}
					});
				}
				if (input.orderBy && input.orderBy.length) {
					parameters["orderBy"] = input.orderBy;
				}
				// if we want to load a certain page, we need a limit
				if (parameters.limit == null) {
					parameters.limit = input.limit != null ? input.limit : 10;
				}
				// limit 0 means no limit
				if (parameters.limit == 0) {
					parameters.limit = null;
				}
				parameters.offset = parameters.limit * (input.pageNumber ? input.pageNumber : 0);
				if (input.serviceContext) {
					parameters["$serviceContext"] = input.serviceContext;
				}
				if (!parameters["$serviceContext"]) {
					parameters["$serviceContext"] = input.pageInstance.getServiceContext();
				}
				this.$services.swagger.execute(input.operation, parameters).then(function(list) {
					if (list) {
						var arrayFound = false;
						var array = null;
						var paging = null;
						var arrayField = Object.keys(self.getArrayOutputField(input.operation))[0];
						var findArray = function(root) {
							array = root[arrayField];
							if (array == null) {
								array = [];
							}
							arrayFound = true;
						}
						findArray(list);
						
						var pageFound = false;
						var findPage = function(root) {
							Object.keys(root).forEach(function(field) {
								// check if we have an object that has the necessary information
								if (typeof(root[field]) === "object" && root[field] != null && !pageFound) {
									// these are the two fields we use and map, check if they exist
									if (root[field].current != null && root[field].total != null) {
										paging = root[field];
										pageFound = true;
									}
									// recurse
									if (!pageFound) {
										findPage(root[field]);
									}
								}
							});
						}
						findPage(list);
						
						handler(array == null ? [] : array, paging == null ? {} : paging);
					}
					else {
						handler([], {});
					}
				}, function(error) {
					handler([], {}, error);
				})
			}
			else if (input.array) {
				var result = input.pageInstance.get(input.array);
				handler(result ? result : [], {});
			}
			else if (input.type) {
				var provider = nabu.page.providers("page-repeat").filter(function(provider) {
					return provider.name == input.type;
				})[0];
				if (provider && provider.loadData) {
					var state = {
						records: []
					}
					var result = provider.loadData(input.target, state, {}, false);
					if (result.then) {
						result.then(function() {
							promise.resolve(state.records);
						}, promise);
					}
					else {
						promise.resolve(state.records);
					}
				}
			}
			return promise;
		},
		uniquify: function(records) {
			var self = this;
			var position = 0;
			// make sure we have the highest before we start
			// if for example we pass in an array from outside, it might already have a position
			records.forEach(function(record) {
				if (record.hasOwnProperty("$position") && record.$position >= position) {
					position = record.$position + 1;
				}
			});
			records.forEach(function(record) {
				if (!record.hasOwnProperty("$position") && typeof(record) != "string" && !(record instanceof String)) {
					record["$position"] = position++;
				}
			});
		},
		unwatchAll: function(watchers) {
			if (watchers) {
				watchers.forEach(function(watcher) {
					if (watcher instanceof Function) {
						watcher();
					}
					else if (watcher instanceof Array) {
						watcher.forEach(function(child) {
							if (child instanceof Function) {
								child();
							}
						});
					}
				});
			}
		},
		watchAll: function(input) {
			var self = this;
			input = this.normalizeInput(input);
			
			var watchers = [];
			// if the target has multiple pipelines, watch them all
			if (input.target.pipelines) {
				nabu.utils.arrays.merge(watchers, input.target.pipelines.map(function(pipeline) {
					var cloned = {};
					nabu.utils.objects.merge(cloned, input);
					cloned.target = pipeline;
					return self.watchAll(cloned);
				}));
			}
			else {
				// watch the data array if that is needed
				watchers.push(this.watchArray(input));
				
				// if we have an operation, we might have bound input values, we want to watch those as well
				if (input.bindings) {
					Object.keys(input.bindings).map(function(name) {
						if (input.bindings[name]) {
							var binding = input.bindings[name];
							if (binding.indexOf("parent.") == 0) {
								// TODO: watch in parent
							}
							else {
								if (binding.indexOf("page.") == 0) {
									binding = binding.substring("page.".length);
								}
								console.log("watching", binding, input.pageInstance.variables, input.handler);
								watchers.push(input.pageInstance.$watch("variables." + binding, input.handler, {deep: true}));
							}
						}
					});
				}				
			}
			return watchers;
		},
		watchArray: function(input) {
			var self = this;
			
			input = this.normalizeInput(input);

			var targetArray = input.array;
			
			var self = this;
			var current = input.pageInstance.get(targetArray);
			var unwatch = null;
			// if it doesn't exist yet, keep an eye on the page state
			// we tried to be more specific and watch direct parents but this _somehow_ failed
			if (current == null) {
				var unwatch = input.pageInstance.$watch("variables", function(newValue) {
					var result = input.pageInstance.get(targetArray);
					if (result != null) {
						input.handler();
						unwatch();
						unwatch = self.watchArray(input);
					}
				}, {deep: true});
			}
			else {
				var stringified = JSON.stringify(current);
				if (targetArray.indexOf("page.") == 0) {
					targetArray = targetArray.substring("page.".length);
				}
				var watchKey = "variables." + targetArray;
				var unwatch = input.pageInstance.$watch(watchKey, function(newValue) {
					if (JSON.stringify(input.pageInstance.get(targetArray)) != stringified) {
						input.handler();
						unwatch();
						// may have unset to null, changed to a different array,...
						unwatch = self.watchArray(input);
					}
				}, {deep: true});
			}
			return function() {
				if (unwatch) {
					unwatch();
				}
			};
		}
	}
});
Vue.service("image", {
	services: ["q"],
	methods: {
		// can pass in a file or blob, the blob should have annotated metadata similar to file like "type"
		// https://developer.mozilla.org/en-US/docs/Web/API/FileReader
		resize: function(file, maxWidth, maxHeight) {
			var self = this;
			var reader = new FileReader();
			var promise = this.$services.q.defer();
			reader.onload = function(readerEvent) {
				var applyUrl = function(dataUrl) {
					var result = {};
					result.url = dataUrl;
					result.file = self.urlToBlob(dataUrl);
					result.file.name = file.name;
					// this is not allowed in minified mode
					// it "should" be the same given the code
					// if there is ever a problem with the type not matching, we can pass it along to urlToBlob and use the file type over the internal type
					//result.file.type = file.type;
					result.name = file.name;
					result.type = file.type ? file.type : "application/octet-stream";
					promise.resolve(result);
				}
				// if we have an image
				if (file.type && file.type.indexOf("image/") == 0) {
					var image = new Image();
					image.onload = function (imageEvent) {
						var canvas = document.createElement('canvas');
						var width = image.width;
						var height = image.height;
						var factor = 1;
						if (maxWidth != null && width > maxWidth) {
							factor = maxWidth / width;
						}
						if (maxHeight != null && height > maxHeight) {
							factor = Math.min(factor, maxHeight / height);
						}
						width *= factor;
						height *= factor;
						canvas.width = width;
						canvas.height = height;
						canvas.getContext('2d').drawImage(image, 0, 0, width, height);
						// try to retrieve as the original format
						var dataUrl = canvas.toDataURL(file.type ? file.type : "image/jpeg");
						applyUrl(dataUrl);
					};
					image.src = readerEvent.target.result;
				}
				else {
					applyUrl(readerEvent.target.result);
				}
			};
			reader.readAsDataURL(file);
			return promise;
		},
		urlToBlob: function(dataURL) {
			var BASE64_MARKER = ';base64,';
			if (dataURL.indexOf(BASE64_MARKER) < 0) {
				var parts = dataURL.split(',');
				var contentType = parts[0].split(':')[1];
				var raw = parts[1];
				return new Blob([raw], {type: contentType});
			}
			else {
				var parts = dataURL.split(BASE64_MARKER);
				var contentType = parts[0].split(':')[1];
				return this.base64ToBlob(parts[1], contentType);
			}
		},
		base64ToBlob: function(base, contentType) {
			var raw = window.atob(base);
			var rawLength = raw.length;
			var uInt8Array = new Uint8Array(rawLength);
			for (var i = 0; i < rawLength; ++i) {
				uInt8Array[i] = raw.charCodeAt(i);
			}
			return new Blob([uInt8Array], {type: contentType});
		},
	}	
});
window.addEventListener("load", function() {
	if (nabu && nabu.page && nabu.page.provide) {
		nabu.page.provide("page-structure", { 
			category: "Layouts",
			name: "Three Columns",
			description: "A simple layout with three columns",
			icon: "page/core/layouts/three-columns.png",
			content: {"type":"page-row","content":{"id":11,"cells":[{"id":14,"rows":[{"id":13,"cells":[],"class":null,"customId":null,"instances":{},"condition":null,"direction":"vertical","align":null,"on":null,"collapsed":false,"name":"Column Contents"}],"alias":null,"bindings":{},"name":"Column 1","state":{},"target":"page","on":null,"class":null,"customId":null,"width":1,"height":null,"instances":{},"condition":null,"devices":[],"clickEvent":{"eventFields":[],"name":null}},{"id":12,"rows":[{"id":16,"cells":[],"class":null,"customId":null,"instances":{},"condition":null,"direction":"vertical","align":null,"on":null,"collapsed":false,"name":"Column Contents"}],"alias":null,"bindings":{},"name":"Column 2","state":{},"target":"page","on":null,"class":null,"customId":null,"width":1,"height":null,"instances":{},"condition":null,"devices":[],"clickEvent":null},{"id":15,"rows":[{"id":17,"cells":[],"class":null,"customId":null,"instances":{},"condition":null,"direction":"vertical","align":null,"on":null,"collapsed":false,"name":"Column Contents"}],"alias":null,"bindings":{},"name":"Column 3","state":{},"target":"page","on":null,"class":null,"customId":null,"width":1,"height":null,"instances":{},"condition":null,"devices":[],"clickEvent":{"eventFields":[],"name":null}}],"class":null,"customId":null,"instances":{},"condition":null,"direction":null,"align":null,"on":null,"collapsed":false,"name":"Columns"}}
		});
	}
});
/*
There are a number of challenges to attachment uploading:
- the visualization (especially when uploading multiple) is often very application dependent so should not be encapsulated in the component
- often file uploads are part of a larger form which means there is an overarching json that you are trying to build. attachments _can_ be base64 encoded in the json but this often balloons the size unnecessarily
- when using "update" forms, you definitely don't want to ship json base64 back and forth
- uploads tend to take a while, so you need some visual feedback for the user and you need to make sure the user does not click "submit" before it is done
- images tend to be oversized because of the high resolution of cameras, we generally need to resize this
- it is usually better (though not always) to immediately start uploading when the user selects a file rather than waiting for the full form to be submitted because of the upload duration
	- however, the user can still cancel the form at which point we have uploaded data that should not yet be associated
	- when hitting attachment limits we definitely do not want to start removing data before the form is finally submitted
- there is usually a limit to the amount of files you can upload
	- suppose you are in a create scenario (so nothing fully persisted yet) and you have a limit of 2 files and you add a third.
		- the frontend could either block the third or automatically remove the first. it has been staged in the backend but not yet linked to the owner
	- suppose you are in an update scenario though and 2 files are already linked in the backend
		- again the frontend could simply block the change until you manually delete a file or automatically delete one (which one though?)
		- either way, manual or automatic: the file should not ACTUALLY be deleted until the form is submitted!
	- the intent here is that the backend, upon receiving the full json of the form, automatically deletes any attachments no longer in the json
	- for singular fields it is "easier" because there can be only one
	- for arrays the frontend can't correctly deduce which attachments to delete so instead it will block until the user deletes manually


The attachment uploader works on a form field that contains a REFERENCE to the attachment, not the actual binary data. Because it does not need to visualize the data, it does not need to know the visualization method.
The reference can be either a simple type (e.g. uuid or uri) or (more likely) a structure containing multiple fields.
The uploader assumes that the return value of the services involved conforms to the data structure expected in the form.

This attachment uploader is meant to immediately upload attachments into a potential staging area.
The result of the operation that is called to store it will be set into the form field, this is usually a complex record.
The form field can be singular or a list but is assumed to be part of a larger JSON.
The content of the attachment will NOT be in the json, it will only contain metadata pertaining to the attachment.

There are two modi for this uploader:

- single operation to push data to
- two operations: the first to "quickly" create placeholders records that can be immediately added to the json (in batch!)
	-> the records are assumed to have a public uri field (mappable), in the frontend this uri will be prefilled with a base64 encoded version for instant display while uploading
	-> note that this assumes the uri IS part of the return of the batch placeholder creation service but NOT part of the final operation triggered by the form (otherwise we might submit the base64 data)
	
In the placeholder scenario, we can call a second service with an identifier of a particular placeholder to then upload the data to. The progress of this upload can be fed into a field of the record.
If the field does not exist, a temporary field is added "$progress". Additionally a "$state" field or "$url" field are created if not provided.

Note that images are resized as needed.
*/

Vue.component("n-form-attachment-uploader", {
	template: "#n-form-attachment-uploader",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		parentValue: {
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		edit: {
			type: Boolean,
			required: false
		},
		name: {
			type: String,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false,
			default: false
		},
		contentField: {
			type: String,
			default: "content"
		},
		nameField: {
			type: String,
			default: "contentName"
		},
		typeField: {
			type: String,
			default: "contentType"
		},
		childComponents: {
			type: Object,
			required: false
		}
	},
	data: function() {
		return {
			files: [],
			working: [],
			messages: [],
			valid: null
		}
	},
	computed: {
		isArray: function() {
			if (this.field.name) {
				var arrays = this.$services.page.getAllArrays(this.page, this);
				if (arrays.indexOf(this.field.name) >= 0 || arrays.indexOf("page." + this.field.name) >= 0) {
					return true;
				}
			}
			return false;
		},
		maxFiles: function() {
			if (this.isArray) {
				var max = this.field.maxFiles;
				if (max) {
					return this.$services.page.interpret(max, this); 
				}
			}
			else {
				return 1;
			}
		},
		// how many files can be added before we can't
		remaining: function() {
			// for arrays, it depends on the max size of the array vs the current amount
			if (this.isArray) {
				if (this.maxFiles) {
					// when we use reservation, the value will reflect the size, we don't need to check the working
					return this.maxFiles - (this.value instanceof Array ? this.value.length : 0) - (this.field.reservationOperation ? 0 : this.working.length);
				}
				return Number.MAX_SAFE_INTEGER;
			}
			// for non-arrays we can always set 1
			else {
				return 1;
			}
		},
		allowedFileTypes: function() {
			if (this.field.fileTypes) {
				return this.field.fileTypes.filter(function(x) { 
					return !!x.contentType;
				}).map(function(x) {
					return x.contentType;
				});
			}
		}
	},
	methods: {
		validate: function(soft) {
			return [];
		},
		changed: function() {
			var self = this;
			this.messages.splice(0);
			this.valid = null;
			// too many files
			if (this.files.length > this.remaining) {
				this.messages.push({
					severity: "info",
					code: "too-many-files",
					title: "%{You can only add {maximum} images}", 
					values: {
						maximum: this.maxFiles
					}
				});
			}
			else {
				this.upload(this.files.splice(0));
			}
		},
		upload: function(files) {
			if (this.field.reservationOperation) {
				var self = this;
				this.reserve(files).then(function(result) {
					if (result) {
						if (self.field.reservationOutputArrayName) {
							result = self.$services.page.getValue(result, self.field.reservationOutputArrayName);
						}
						if (result instanceof Array) {
							for (var i = 0; i < result.length; i++) {
								if (i < files.length) {
									self.uploadSingle(files[i], result[i]);
								}
							}
						}
						// not an array, i hope were are only uploading a single file?
						else {
							self.uploadSingle(files[0], result);
						}
					}
				})
			}
			else {
				files.forEach(this.uploadSingle);
			}
		},
		reserve: function(files) {
			var parameters = {};
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			if (this.field.reservationBindings) {
				var self = this;
				files.forEach(function(file) {
					// we assume that it is a batch service
					var newRecord = {};
					Object.keys(self.field.reservationBindings).forEach(function(key) {
						var binding = self.field.reservationBindings[key];
						if (binding) {
							var value = null;
							if (binding == "$file.fileName") {
								value = file.name;
							}
							else if (binding == "$file.contentType") {
								value = file.type;
							}
							else if (binding.indexOf("$file") != 0) {
								value = self.$services.page.getBindingValue(pageInstance, binding, self);
							}
							if (value) {
								// meant for an array
								if (key.indexOf("$reserved") == 0) {
									newRecord[key.substring("$reserved.".length)] = value;
								}
								else {
									self.$services.page.setValue(parameters, key, value);
								}
							}
						}
					});
					if (self.field.reservationInputArrayName) {
						var current = self.$services.page.getValue(parameters, self.field.reservationInputArrayName);
						if (!current) {
							current = [];
							self.$services.page.setValue(parameters, self.field.reservationInputArrayName, current);
						}
						current.push(newRecord);
					}
				});
			}
			if (!parameters["$serviceContext"]) {
				parameters["$serviceContext"] = pageInstance.getServiceContext();
			}
			return this.$services.swagger.execute(this.field.reservationOperation, parameters);
		},
		// the record is optional for the two-phase approach
		uploadSingle: function(file, record) {
			if (record) {
				if (this.value instanceof Array) {
					this.value.push(record);
				}
				else {
					this.$emit("input", record);
				}
			}
			var promise = this.$services.q.defer();
			if (this.field.uploadOperation) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				// add it to the working array
				this.working.push(file);
				var self = this;
				var finalizeWorking = function() {
					self.working.splice(self.working.indexOf(file), 1);
				}
				self.$services.image.resize(file, self.field.maxWidth, self.field.maxHeight).then(function(resized) {
					var parameters = {};
					parameters.body = resized.file;
					if (self.field.uploadBindings) {
						Object.keys(self.field.uploadBindings).forEach(function(key) {
							var binding = self.field.uploadBindings[key];
							if (binding) {
								var value = null;
								if (binding == "$file.fileName") {
									value = file.name;
								}
								else if (binding == "$file.contentType") {
									value = file.type;
								}
								else if (binding.indexOf("$reserved") == 0) {
									if (record) {
										value = self.$services.page.getValue(record, binding.substring("$reserved.".length));
									}
								}
								else if (binding.indexOf("$file") != 0) {
									value = self.$services.page.getBindingValue(pageInstance, binding, self);
								}
								if (value) {
									self.$services.page.setValue(parameters, key, value);
								}
							}
						});
					}
					if (record && self.field.urlField) {
						Vue.set(record, self.field.urlField, resized.url);
					}
					if (!parameters["$serviceContext"]) {
						parameters["$serviceContext"] = pageInstance.getServiceContext();
					}
					self.$services.swagger.execute(self.field.uploadOperation, parameters).then(function(result) {
						if (record) {
							// merge any changes back into the record
							Object.keys(result).forEach(function(key) {
								// NOT the url field, this would just trigger rerenders and not change the content
								// IMPORTANT: we assume the url field does not make it to the backend when submitting the full json
								if (key != self.field.urlField) {
									Vue.set(record, key, result[key]);
								}
							})
						}
						else if (this.value instanceof Array) {
							self.value.push(result);
						}
						else {
							self.$emit("input", result);
						}
						finalizeWorking();
						promise.resolve();
					}, function() {
						finalizeWorking();
						promise.reject();
					});
				})
			}
			else {
				promise.reject();
			}
			return promise;
		},
		getChildComponents: function() {
			return [{
				title: "File Input",
				name: "file-input",
				component: "column"
			}, {
				title: "File Input Button",
				name: "file-input-button",
				component: "button"
			}]
		},
	}
});


Vue.component("n-form-attachment-uploader-configure", {
	template: "#n-form-attachment-uploader-configure",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		},
		childComponents: {
			type: Object,
			required: false
		}
	},
	created: function() {
		if (!this.field.reservationBindings) {
			Vue.set(this.field, "reservationBindings", {});
		}
		if (!this.field.uploadBindings) {
			Vue.set(this.field, "uploadBindings", {});
		}
		if (!this.field.fileTypes) {
			Vue.set(this.field, "fileTypes", []);
		}
	},
	computed: {
		isArray: function() {
			if (this.field.name) {
				var arrays = this.$services.page.getAllArrays(this.page, this);
				if (arrays.indexOf(this.field.name) >= 0 || arrays.indexOf("page." + this.field.name) >= 0) {
					return true;
				}
			}
			return false;
		}
	},
	methods: {
		getOutputUrlFieldOptions: function(value) {
			var output = this.$services.page.getSwaggerOperationOutputDefinition(this.field.uploadOperation);
			if (output) {
				var arrayName = this.$services.page.getArrays(output)[0];
				if (arrayName) {
					arrayName.split(".").forEach(function(x) {
						output = output.properties[x];
					})
					output = output.items;
				}
				return this.$services.page.getSimpleKeysFor(output, false, false)
					.filter(function(x) {
						return !value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
					});
			}
			return [];
		},
		getReservationInputFields: function() {
			if (this.field.reservationOperation) {
				var input = this.$services.page.getSwaggerOperationInputDefinition(this.field.reservationOperation);
				// the reservation may be a batch input or a singular input (depending on setup)
				// if we detect an array, we assume it is a batch upload!
				if (input) {
					var arrayInput = this.$services.page.getArrays(input)[0];
					var keys = this.$services.page.getSimpleKeysFor(input, false, false);
					if (arrayInput != null) {
						arrayInput.split(".").forEach(function(x) {
							input = input.properties[x];
						})
						nabu.utils.arrays.merge(
							keys,
							this.$services.page.getSimpleKeysFor({properties:{$reserved:input.items}}, false, false)
						)
					}
					return keys;
				}
			}
			return {};
		},
		getAvailableReservationParameters: function() {
			var result = {};
			nabu.utils.objects.merge(result, this.$services.page.getAllAvailableParameters(this.page));
			result.$file = {
				properties: {
					fileName: {
						type: "string"
					},
					contentType: {
						type: "string"
					}
				}
			}
			return result;
		},
		getAvailableUploadParameters: function() {
			var result = this.getAvailableReservationParameters();
			if (this.field.reservationOperation) {
				var output = this.$services.page.getSwaggerOperationOutputDefinition(this.field.reservationOperation);
				if (output) {
					var arrayName = this.$services.page.getArrays(output)[0];
					if (arrayName) {
						arrayName.split(".").forEach(function(x) {
							output = output.properties[x];
						})
						result.$reserved = output.items;
					}
					else {
						result.$reserved = output;
					}
				}
			}
			return result;
		},
		getReservationOutputArrayName: function() {
			if (this.field.reservationOperation) {
				var output = this.$services.page.getSwaggerOperationOutputDefinition(this.field.reservationOperation);
				if (output) {
					return this.$services.page.getArrays(output)[0];
				}
			}
			return null;
		},
		getReservationInputArrayName: function() {
			if (this.field.reservationOperation) {
				var input = this.$services.page.getSwaggerOperationInputDefinition(this.field.reservationOperation);
				if (input) {
					return this.$services.page.getArrays(input)[0];
				}
			}
			return null;
		}
	},
	watch: {
		"field.reservationOperation": function() {
			// we need this to dynamically build the reservation call
			this.field.reservationInputArrayName = this.getReservationInputArrayName();
			this.field.reservationOutputArrayName = this.getReservationOutputArrayName();
		}
	}
});

window.addEventListener("load", function() {
	application.bootstrap(function($services) {
		nabu.page.provide("page-form-list-input", { 
			component: "n-form-attachment-uploader", 
			configure: "n-form-attachment-uploader-configure", 
			name: "attachment-uploader",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "n-form-attachment-uploader", 
			configure: "n-form-attachment-uploader-configure", 
			name: "attachment-uploader",
			namespace: "nabu.page"
		});
		$services.router.register({
			alias: "page-form-attachment-uploader",
			enter: function(parameters) {
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "n-form-attachment-uploader";
				cloneParameters.configurationComponent = "n-form-attachment-uploader-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "attachmentUploader",
			category: "Form",
			name: "Attachment uploader",
			description: "Uploads attachments and can resize images",
			icon: "page/core/images/image.svg"
		});
	});
});


if (!nabu) { var nabu = {} }
if (!nabu.page) { nabu.page = {} }
if (!nabu.page.views) { nabu.page.views = {} }

Vue.view("page-image", {
	category: "Media",
	name: "Image",
	description: "Position an image",
	icon: "page/core/images/image.svg",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
		/*, 
		contentType: {
			type: String,
			required: false
		},
		// you can map the bytes
		content: {
			type: Object,
			required: false
		},
		// the "content" can be a blob
		// however, a blob/file/... is not stringifiable and will end up as an empty object in the JSON
		// that means, when you dynamically change the blob based on state, the router can not determine that it is a _different_ blob and nothing will rerender
		// specifically for that, you can add an id here (like an attachment id) which identifies the blob
		contentId: {
			required: false
		}*/
	},
	activate: function(done) {
		if (this.edit) {
			done();
		}
		var self = this;
		var promises = [];
		if (this.cell.state.inline && (this.cell.state.href || this.href)) {
			var self = this;
			var href = this.cell.state.href ? this.cell.state.href : this.href;
			// if not absolute, make it so
			if (href.indexOf("http://") != 0 && href.indexOf("https://") != 0 && href.indexOf("/") != 0) {
				href = "/" + href;
			}
			nabu.utils.ajax({ url: href }).then(function(response) {
				self.inlineContent = response.responseText;
			});
		}
		// we want to convert it to base64
		if (this.content) {
			var blob = this.content instanceof Blob ? this.content : nabu.utils.binary.blob(this.content, this.contentType ? this.contentType : "image/jpeg");
			var reader = new FileReader();
			reader.readAsDataURL(blob);
			var promise = new nabu.utils.promise();
			promises.push(promise);
			reader.onload = function() {
				var result = reader.result;
				var index = result.indexOf(",");
				self.encodedData = result;// result.substring(index + 1);
				promise.resolve();
			};
		}
		this.$services.q.all(promises).then(done, done);
	},
	data: function() {
		return {
			inlineContent: null,
			encodedData: null,
			href: null
		}
	},
	computed: {
		title: function() {
			return this.cell.state.title ? this.$services.page.interpret(this.$services.page.translate(this.cell.state.title), this) : null;
		},
		emptyImage: function() {
			var defaultPlaceholder = application.configuration.root + 'resources/modules/image/placeholder.svg';
			return this.cell.state.emptyImage ? this.$services.page.interpret(this.cell.state.emptyImage) : defaultPlaceholder;
		},
		// we put this in a computed because we want this to be reactive
		calculatedUrl: function() {
			if (this.cell.state.imageType == "operation") {
				this.calculateRESTUrl();
			}
			else if (this.cell.state.imageType == "static") {
				this.calculateFixedUrl();
			}
			else if (this.cell.state.imageType == "bytes") {
				this.calculateByteUrl();
			}
			else if (this.cell.state.imageType == "variable") {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return this.cell.state.imageUrlVariable ? pageInstance.get(this.cell.state.imageUrlVariable) : null;
			}
			return this.href;
		}
	},
	// replaced with computed for reactivity!
	/*
	created: function() {
		if (this.cell.state.imageType == "operation") {
			this.calculateRESTUrl();
		}
		else if (this.cell.state.imageType == "static") {
			this.calculateFixedUrl();
		}
		else if (this.cell.state.imageType == "bytes") {
			this.calculateByteUrl();
		}
	},
	*/
	methods: {
		calculateByteUrl: function() {
			if (this.cell.state.byteValue) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				if (pageInstance) {
					var self = this;
//					var blob = pageInstance.get(this.cell.state.byteValue);
					var blob = this.$services.page.getBindingValue(pageInstance, this.cell.state.byteValue);
					if (blob) {
						var contentType = null;
						if (this.cell.state.contentTypeValue) {
							//contentType = pageInstance.get(this.cell.state.contentTypeValue);		
							contentType = this.$services.page.getBindingValue(pageInstance, this.cell.state.contentTypeValue);
						}
						if (!contentType) {
							contentType = "image/jpeg";
						}
						blob = blob instanceof Blob ? blob : nabu.utils.binary.blob(blob, contentType);
						var reader = new FileReader();
						reader.readAsDataURL(blob);
						var promise = new nabu.utils.promise();
						reader.onload = function() {
							var result = reader.result;
							var index = result.indexOf(",");
							self.href = result;// result.substring(index + 1);
							promise.resolve();
						};
						return promise;
					}
				}
			}
		},
		calculateFixedUrl: function() {
			var href = null;
			if (this.cell.state.href) {
				href = this.$services.page.interpret(this.cell.state.href, this);
			}
			if (href && href.substring(0, 5) == "data:") {
				this.href = href;
				return href;
			}
			// if the href is not an absolute one (either globally absolute or application absolute), we inject the server root
			if (href && href.substring(0, 7) != "http://" && href.substring(0, 8) != "https://" && href.substring(0, 1) != "/") {
				href = application.configuration.root + href;
			}
			// make it absolute if needed
			if (href && href.substring(0, 7) != "http://" && href.substring(0, 8) != "https://" && this.cell.state.absolute) {
				href = application.configuration.url + href;
			}
			// on mobile we don't want absolute paths starting with "/", otherwise it won't fetch from the file system
			else if (href && href.substring(0, 7) != "http://" && href.substring(0, 8) != "https://" && false && href.indexOf("/") == 0) {
				href = href.substring(1);
			}
			if (!href && this.edit) {
				href = application.configuration.root + "resources/modules/image/placeholder.svg";
			}
			this.href = href;
		},
		calculateRESTUrl: function() {
			if (this.cell.state.imageOperation) {
				var operation = this.$services.swagger.operations[this.cell.state.imageOperation];
				var properties = this.$services.page.getBindings(this.cell.state.bindings, this);
				var self = this;
				// we need temporary credentials
				if (operation["x-temporary-id"] && operation["x-temporary-secret"] && this.$services.user && this.$services.user.ltp) {
					this.$services.user.ltp(operation.id).then(function(authorization) {
						properties[operation["x-temporary-id"]] = authorization.authenticationId;
						properties[operation["x-temporary-secret"]] = authorization.secret;
						self.href = self.$services.swagger.parameters(operation.id, properties).url;
						var pageInstance = self.$services.page.getPageInstance(self.page, self);
						var serviceContext = pageInstance.getServiceContext();
						if (serviceContext) {
							self.href += (self.href.indexOf("?") >= 0 ? "&" : "?") + "$serviceContext=" + serviceContext;
						}
					}, function(e) {
						self.href = null;
						console.log("Could not get ltp for", operation.id, e);
					});
				}
				else {
					self.href = self.$services.swagger.properties(operation.id, properties).url;
					var pageInstance = self.$services.page.getPageInstance(self.page, self);
					var serviceContext = pageInstance.getServiceContext();
					if (serviceContext) {
						self.href += (self.href.indexOf("?") >= 0 ? "&" : "?") + "$serviceContext=" + serviceContext;
					}
				}
			}
		},
		getChildComponents: function() {
			return [{
				title: "Image",
				name: "image",
				component: "image"
			}];
		},
		configurator: function() {
			return "page-image-configure";
		}
	}
})

Vue.component("page-image-configure", {
	template: "#page-image-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	created: function() {
		this.load();
		if (!this.cell.state.bindings) {
			Vue.set(this.cell.state, "bindings", {});
		}
	},
	computed: {
		hasPrevious: function() {
			var self = this;
			var entry = this.images.filter(function(x) {
				return x.relativePath == self.cell.state.href;
			})[0];
			return entry && this.images.indexOf(entry) > 0;
		},
		hasNext: function() {
			if (!this.cell.state.href && this.images.length > 0) {
				return true;
			}
			var self = this;
			var entry = this.images.filter(function(x) {
				return x.relativePath == self.cell.state.href;
			})[0];
			return entry && this.images.indexOf(entry) < this.images.length - 1;
		}
	},
	data: function() {
		return {
			images: [],
			files: []
		}
	},
	methods: {
		next: function() {
			var self = this;
			if (!this.cell.state.href) {
				Vue.set(this.cell.state, "href", this.images[0].relativePath);
			}
			else {
				var entry = this.images.filter(function(x) {
					return x.relativePath == self.cell.state.href;
				})[0];
				if (entry) {
					var index = this.images.indexOf(entry);
					this.cell.state.href = this.images[index + 1].relativePath;
				}
			}
		},
		previous: function() {
			var self = this;
			var entry = this.images.filter(function(x) {
				return x.relativePath == self.cell.state.href;
			})[0];
			if (entry) {
				var index = this.images.indexOf(entry);
				this.cell.state.href = this.images[index - 1].relativePath;
			}
		},
		load: function() {
			var self = this;
			return this.$services.swagger.execute("nabu.web.page.core.v2.rest.resource.list", {path:this.cell.state.imagePath}).then(function(list) {
				self.images.splice(0);
				if (list && list.resources) {
					nabu.utils.arrays.merge(self.images, list.resources);
				}
			});
		},
		upload: function() {
			var self = this;
			this.$services.swagger.execute("nabu.web.page.core.v2.rest.resource.create", { path:this.cell.state.imagePath, body: this.files[0] }).then(function(result) {
				self.load();
				if (result && result.relativePath) {
					self.cell.state.href = result.relativePath;
				}
				self.files.splice(0, self.files.length);
			});
		},
		getAllKeys: function(value) {
			var keys = [];
			nabu.utils.arrays.merge(keys, this.$services.page.getAllAvailableKeys(this.page, true));
			if (value) {
				keys = keys.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
			}
			keys.sort();
			return keys;
		}
	},
	watch: {
		'cell.state.imagePath': function() {
			this.load();
		}
	}
})
Vue.view("page-markdown-text", {
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	computed: {
		rowHeight: function() {
			return Math.max(1, this.cell.state.content ? this.cell.state.content.length - this.cell.state.content.replace(/\n/g, "").length + 1 : 1);
		},
		formatted: function() {
			if (nabu.formatters && nabu.formatters.markdown) {
				var blocks = nabu.formatters.markdown.parse(this.cell.state.content);
				var parameters = {};
				var self = this;
				parameters.tagUrl = "http://google.com?q=";
				parameters.variables = {
					right: "left"
				}
				var result = nabu.formatters.markdown.asHtml(blocks, parameters);
				// if we have promises, we need to do some retroactive resolving
				if (Object.keys(result.promises).length > 0) {
					// we wait until at least this is rendered (just in case we have fast resolving promises)
					Vue.nextTick(function() {
						nabu.formatters.markdown.replacePromises(result.promises);
					})
				}
				return result.content;
			}
		}
	}
});


if (!nabu) { var nabu = {} }
if (!nabu.page) { nabu.page = {} }
if (!nabu.page.views) { nabu.page.views = {} }

nabu.page.views.Pages = Vue.extend({
	template: "#nabu-pages",
	data: function() {
		return {
			parameters: {},
			showing: false,
			pageToRoute: null,
			// the currently open category
			opened: null,
			lastColor: {},
			selectedTab: 'settings',
			showTemplates: false,
			selectedTemplates: []
		}
	},
	computed: {
		categories: function() {
			var categories = [];
			var hasEmpty = false;
			this.$services.page.pages.map(function(x) {
				if (!x.content.category) {
					hasEmpty = true;
				}
				else if (categories.indexOf(x.content.category ? x.content.category : null) < 0) {
					categories.push(x.content.category ? x.content.category : null);
				}
			});
			categories.sort();
			if (hasEmpty) {
				categories.unshift(null);
			}
			return categories;
		},
		hasTemplates: function() {
			return this.$services.page.pageTemplates.length > 0;
		},
		templateCategories: function() {
			var groups = [];
			this.$services.page.pageTemplates.forEach(function(x) {
				if (x.category && groups.indexOf(x.category) < 0) {
					groups.push(x.category);
				}
				else if (x.category == null && groups.indexOf("Miscellaneous") < 0) {
					groups.push("Miscellaneous");
				}
			});
			groups.sort(function(a, b) {
				return a.toLowerCase().localeCompare(b.toLowerCase());
			});
			return groups;
		}
	},
	created: function() {
		if (this.$services.page.pages.length > 0) {
			this.selectedTab = "pages";
		}	
	},
	ready: function() {
		document.body.removeAttribute("page");
		document.body.removeAttribute("category");
		// this can make it harder to style the index itself, but otherwise the pages page keeps refreshing while you are styling
		// which can be awefully annoying as it is autosave
		this.$services.page.disableReload = true;
		if (this.$services.page.canEdit()) {
			var self = this;
			this.$el.addEventListener("paste", function(event) {
				var data = event.clipboardData.getData("text/plain");
				if (data) {
					var parsed = JSON.parse(data);
					if (parsed && parsed.type == "page-category") {
						self.$confirm({ 
							message: "Are you sure you want to add the category '" + parsed.category + "' to this website?", 
							type: 'question', 
							ok: 'Add'
						}).then(function() {
							parsed.pages.map(function(page) {
								self.$services.page.update(page);
							})
						});
					}
					// check for some markers that it is a page
					else if (parsed && parsed.category && parsed.name && parsed.rows && parsed.counter != null) {
						self.$prompt(function() {
							return new nabu.page.views.PagesPaste({data: {
								category: parsed.category,
								name: parsed.name
							}});
						}).then(function(result) {
							parsed.name = result.name;
							parsed.label = self.$services.page.prettify(result.name);
							parsed.category = result.category;
							var page = {
								content: parsed,
								name: parsed.name
							}
							self.$services.page.update(page);
						});
						/*
						self.$confirm({ 
							message: "Are you sure you want to add the page '" + parsed.path + "' from category '" + parsed.category + "' to this website?", 
							type: 'question', 
							ok: 'Add'
						}).then(function() {
							var page = {
								content: parsed,
								name: parsed.name ? parsed.name : prompt("Name of the page?")
							}
							if (page.name) {
								self.$services.page.update(page);
							}
						});
						*/
					}
				}
			});
		}
		else {
			this.$services.router.route("login", null, null, true);
		}
	},
	beforeDestroy: function() {
		this.$services.page.disableReload = false;	
	},
	methods: {
		getAdditionalSettings: function() {
			// each entry should have:
			// - icon
			// - name: a technical name
			// - title: pretty name for the user (can be translated)
			// - route
			return nabu.page.providers("page-settings");
		},
		dropOnPages: function(event) {
			if (this.$services.page.getDragData(event, "template-content")) {
				var content = JSON.parse(this.$services.page.getDragData(event, "template-content"));
				console.log("dropped", content);
				// row drop from templates
				if (content.type == "page") {
					console.log("dropped", content);
					this.$services.page.update({
						name: content.content.name,
						content: content.content
					});
				}
				else if (content.type == "pages") {
					var self = this;
					// we assume the content is an array of pages in this case
					content.content.forEach(function(content) {
						self.$services.page.update({
							name: content.name,
							content: content
						});
					});
				}
			}
		},
		dragOverPages: function(event) {
			if (this.$services.page.getDragData(event, "template-content")) {
				var content = JSON.parse(this.$services.page.getDragData(event, "template-content"));
				// row drop from templates
				if (content.type == "page" || content.type == "pages") {
					event.preventDefault();
				}
			}
		},
		toggleSelectionFor: function(template) {
			var index = this.selectedTemplates.indexOf(template);
			if (index >= 0) {
				this.selectedTemplates.splice(index, 1);
			}
			else {
				this.selectedTemplates.push(template);
			}
		},
		dragTemplate: function(event, template) {
			// the content is already stringified at this point
			this.$services.page.setDragData(event, "template-content", template.content);
		},
		getTemplateCategory: function(category) {
			return this.$services.page.pageTemplates.filter(function(x) {
				return x.category == category || (category == "Miscellaneous" && x.category == null);
			});
		},
		getDevice: function(name) {
			var device = this.$services.page.devices.filter(function(x) { return x.name == name })[0];
			if (device == null) {
				device = {
					name: name,
					width: null
				};
				this.$services.page.devices.push(device);
			}
			return device;
		},
		addFunctionParameter: function(transformer, type) {
			transformer[type].push({});
		},
		updatePageName: function(page, newValue) {
			if (newValue) {
				console.log("page name is", page.name, newValue);
				// check that the name is not in use
				this.$services.page.rename(page, newValue);
			}
		},
		customNameValidator: function(newValue) {
			var messages = [];
			if (this.$services.page.pages.filter(function(x) { return x.content.name == newValue }).length > 0) {
				messages.push({
					severity: "error",
					title: "Name already in use",
					soft: false
				});
			}
			if (!newValue.match(/^[a-zA-Z0-9-/]+$/)) {
				messages.push({
					severity: "error",
					title: "Can only use lower case letters, numbers and dashes in the page name",
					soft: false
				});
			}
			console.log("validating custom", newValue, messages);
			return messages;
		},
		copy: function(page) {
			console.log("page is", page);
			nabu.utils.objects.copy(page.content);
		},
		copyCategory: function(category) {
			nabu.utils.objects.copy({
				type: "page-category",
				category: category,
				pages: this.getPagesFor(category)
			});
		},
		getPagesFor: function(category) {
			return this.$services.page.pages.filter(function(x) {
				return (!category && !x.content.category) || x.content.category == category;
			}).sort(function(a, b) {
				var sA = !!a.content.defaultAnchor;
				var sB = !!b.content.defaultAnchor;
				var cA = !a.content.path;
				var cB = !b.content.path;
				// first skeletons, then pages, then components
				if (sA && !sB) {
					return -1;
				}
				else if (!sA && sB) {
					return 1;
				}
				else if (cA && !cB) {
					return 1;
				}
				else if (!cA && cB) {
					return -1;
				}
				return 0;
			});
		},
		getPageTypeBadge: function(page) {
			// a skeleton
			if (page.content.defaultAnchor) {
				return "<span class='is-badge is-variant-neutral-outline is-border-full'>Skeleton</span>";
			}
			// a component
			else if (!page.content.path) {
				return "<span class='is-badge is-variant-secondary-outline is-border-full'>Component</span>";
			}	
			else {
				return "<span class='is-badge is-variant-primary-outline is-border-full'>Page</span>";
			}
		},
		insertColor: function(style, color) {
			this.$refs['editors_' + style.name][0].insert(color);
		},
		remove: function(page) {
			var self = this;
			this.$confirm({
				title: "Delete page",
				message: "Are you sure you want to delete the page '" + page.name + "'?"
			}).then(function() {
				self.$services.page.remove(page);
			});
		},
		create: function(category) {
			var self = this;
			this.$prompt(function() {
				return new nabu.page.views.PageCreate({
					propsData: {
						validator: self.customNameValidator,
						categories: self.categories,
						fixedCategory: category
					}
				});
			}).then(function(resolved) {
				self.$services.page.create(resolved.name, resolved.category);
			});
		},
		save: function(page) {
			this.$services.page.update(page);
			this.$services.page.loadPages([page]);
		},
		route: function(page) {
			this.pageToRoute = page;
			var parentParameters = null;
			if (page.content.pageParent) {
				var parentPage = this.$services.page.pages.filter(function(x) {
					return x.content.name == page.content.pageParent;
				})[0];
				if (parentPage) {
					parentParameters = this.$services.page.getPageParameters(parentPage, true, true);
				}
			}
			var parameters = this.$services.page.getPageParameters(page, true, true);
			if (Object.keys(parameters.properties).length || (parentParameters && Object.keys(parentParameters.properties).length)) {
				var result = {};
				if (parentParameters) {
					Object.keys(parentParameters.properties).map(function(key) {
						result[key] = null;	
					});
				}
				Object.keys(parameters.properties).map(function(key) {
					result[key] = null;
				})
				Vue.set(this, "parameters", result);
				this.showing = true;
			}
			else {
				this.doRoute();
			}
		},
		doRoute: function() {
			this.$services.router.route(this.$services.page.alias(this.pageToRoute), this.parameters);
		}
	}
});

nabu.page.views.PageCreate = Vue.extend({
	template: "#nabu-create-page",
	props: {
		fixedCategory: {
			type: String,
			required: false
		},
		validator: {
			type: Function,
			required: false
		},
		categories: {
			type: Array,
			required: false
		}
	},
	data: function() {
		return {
			category: null,
			name: null,
			newCategory: false
		}
	},
	computed: {
		hasAnyCategories: function() {
			return this.categories.length > 0;
		}	
	},
	created: function() {
		if (!this.hasAnyCategories) {
			this.newCategory = true;
		}	
	},
	methods: {
		checkCategory: function(value) {
			var categories = [];
			nabu.utils.arrays.merge(categories, this.categories.filter(function(x) { return !!x }));
			if (value) {
				categories = categories.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
				if (categories.indexOf(value) < 0) {
					categories.unshift(value);
				}
			}
			console.log("categories are", categories, value);
			return categories;
		}
	}
});

nabu.page.views.PagesPaste = Vue.extend({
	template: "#nabu-pages-paste",
	data: function() {
		return {
			category: null,
			name: null
		}
	}
});
if (!nabu) { var nabu = {} }
if (!nabu.page) { nabu.page = {} }
if (!nabu.page.views) { nabu.page.views = {} }

// there is a hardcoded exception in the focus for fields known to use the combo box as this immediately shows the combo box dropdown
// this component uses a mixture of objects and "." separated syntax for legacy reasons

// the form tries to copy state (for pages) before allowing you to edit it, to then merge the result back into the source
// however because the form copies all page data, if a value differs, it is not entirely sure whether that is because YOU updated it or something else did
// that's why we keep the reference

// the synchronize generally triggers a rerender of the form which in turn means we lose focus

// TODO: resetOnUpdate: currently you can only reset on a single field and only reset to null
// in the to-be we want to be able to reset on multiple fields (so an array instead of a string)
// and the reset should be to the actual initial value which can be null but can also be a bound value

// TODO: page arbitrary config gets the keys from the form but the page arbitrary does not get the values in the record
// this means you can bind the form parameters if you are using page arbitrary, but they won't be passed along at runtime
// i've already done a quick test with :record="{form:createResult()}" and variations thereof, but it didn't work
// will have to dig deeper once needed
nabu.page.formComponentConstructer = function(name) {
	return Vue.component(name, {
		template: "#" + name,
		props: {
			page: {
				type: Object,
				required: true
			},
			parameters: {
				type: Object,
				required: false
			},
			// child components with a name and the applied classes
			// in the future we might add other configuration options
			// {'form-button-ok': { classes: ["test1", "test2"]} }
			childComponents: {
				type: Object,
				required: false
			},
			cell: {
				type: Object,
				required: true
			},
			edit: {
				type: Boolean,
				required: true
			}
		},
		data: function() {
			return {
				configuring: false,
				subscriptions: [],
				result: {},
				// the original data (if possible), we want to be able to only update changed values
				reference: {},
				currentPage: null,
				autoMapFrom: null,
				messages: [],
				readOnly: false,
				// keeps track of the labels set by the fields (if relevant)
				labels: {},
				doingIt: false,
				started: null,
				error: null
			}
		},
		beforeDestroy: function() {
			this.subscriptions.map(function(x) {
				x();
			});
		},
		computed: {
			codes: function() {
				var codes = {};
				if (this.cell.state.codes) {
					var self = this;
					this.cell.state.codes.forEach(function(code) {
						codes[code.code] = self.$services.page.translate(code.title);
					});
				}
				return codes;
			},
			analysisId: function() {
				var id = this.cell.state.analysisId;
				if (!id) {
					id = this.cell.state.formId;
				}
				// if we have nothing specific, we assume there is only one form on the page
				if (!id) {
					id = this.page.name;
				}
				return id;
			},
			operation: function() {
				return this.cell.state.operation ? this.$services.swagger.operations[this.cell.state.operation] : null;
			},
			body: function() {
				var operation = this.$services.swagger.operations[this.cell.state.operation];
				if (operation) {
					var self = this;
					for (var i = 0; i < operation.parameters.length; i++) {
						var parameter = operation.parameters[i];
						if (parameter.in == "body") {
							return self.$services.swagger.resolve(parameter);
						}
					};
				}
				return {};
			},
			availableParameters: function() {
				return this.$services.page.getAvailableParameters(this.page, this.cell, true);
			},
			fieldsToAdd: function() {
				var fields = [];
				var self = this;
				if (this.cell.state.pageForm) {
					var parameters = this.$services.page.getPageParameters(this.page);
					//nabu.utils.arrays.merge(fields, Object.keys(parameters.properties));
					nabu.utils.arrays.merge(fields, this.$services.page.getSimpleKeysFor(parameters, true, true));
				}
				else if (this.cell.state.functionForm) {
					if (this.cell.state.functionId) {
						var parameters = this.$services.page.getFunctionInput(this.cell.state.functionId);
						nabu.utils.arrays.merge(fields, this.$services.page.getSimpleKeysFor(parameters, true, true));
					}
				}
				else if (true) {
					nabu.utils.arrays.merge(fields, this.$services.page.getSimpleKeysFor({properties:this.getOperationInput()}, true, true));
				}
				else {
					Object.keys(this.cell.bindings).map(function(key) {
						fields.push(key);
					});
				}
				return fields;
			},
			self: function() {
				return this;
			},
			form: function() {
				return this;
			}
		},
		created: function() {
			// non-reactive cached schemas
			// this was introduced for the following scenario:
			// if you have a page form and that page has page parameters (or initial state?) that uses parameters defined in the swagger
			// the act of resolving the parameters through getPageParameters and more specifically getResolvedPageParameterType:
			// leads to an "infinite render" loop problem
			// it is entirely unclear why this happens but we had a similar problem where using getPageParameters triggered an infinite render loop
			// possibly we need/want the cache at the page service level for getResolvedPageParameterType?
			// however this cache would be application wide
			// for now, we opt for this option but should we add a cache at the page service level, we may want to revisit this
			this.schemas = {};
			this.normalize(this.cell.state);
			
			this.initialize();
			
			// make sure we set the cell state for the form
			this.cell.cellState = {
				form: this.createResultDefinition()
			};
			
			if (this.cell.state.allowReadOnly && this.cell.state.startAsReadOnly) {
				this.readOnly = true;
			}
			this.started = new Date();
			
			if (this.cell.state.submitOnEvent) {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				this.cell.state.submitOnEvent.forEach(function(x) {
					self.subscriptions.push(pageInstance.subscribe(x, function() {
						self.doIt();
					}));
				});
			}
			
			if (this.cell.state.cancelOnEvent) {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				this.cell.state.cancelOnEvent.forEach(function(x) {
					self.subscriptions.push(pageInstance.subscribe(x, function() {
						self.cancel();
					}));
				});
			}
		},
		// want ready because we need correct root
		ready: function() {
			var self = this;
			this.formListener = this.$root.$on("form-opened", function(form) {
				if (self.cell.state.onlyOneEdit && form != self && !self.readOnly) {
					self.cancel();
				}
			});
		},
		methods: {
			// method for the configurator!
			getChildComponents: function() {
				return [{
					title: "Form",
					name: "form-main",
					component: "form"
				}, {
					title: "Form Container",
					name: "form-container",
					component: "form-section"
				}, {
					title: "Form Title",
					name: "form-title",
					component: "h2"
				}, {
					// human readable
					title: "Button Container",
					// structural so we can save defaults
					name: "form-button-container",
					// the type of component
					component: "menu",
					// the default classes applied when nothing is set
					default: ["layout_align_space-between"]
				}, {
					title: "Ok Button",
					name: "form-button-ok",
					component: "button",
					default: ["button_variant_primary"]
				}, {
					title: "Cancel Button",
					name: "form-button-cancel",
					component: "button",
					default: ["button_variant_link"]
				}, {
					title: "Next Button",
					name: "form-button-next",
					component: "button",
					default: ["button_variant_primary"]
				}, {
					title: "Previous Button",
					name: "form-button-previous",
					component: "button",
					default: ["button_variant_primary"]
				}]	
			},
			
			isPageActive: function(page) {
				var result = this.createResult();
				console.log("checking if page is active", page, result);
				return (!page.enabledIf || this.$services.page.isCondition(page.enabledIf, result, this))
					&& (!page.disabledIf || !this.$services.page.isCondition(page.disabledIf, result, this));	
			},
			hasNextActivePage: function(page) {
				var index = this.cell.state.pages.indexOf(page);
				// no next page at all
				if (index >= this.cell.state.pages.length - 1) {
					return false;
				}
				else {
					for (var i = index + 1; i < this.cell.state.pages.length; i++) {
						if (this.isPageActive(this.cell.state.pages[i])) {
							return true;
						}
					}
					return false;
				}
			},
			// this works in conjunction with this.cell.state
			// if you list it in this.cell.state, we can resolve it here
			getCellValue: function(key) {
				if (key.indexOf("form.") == 0) {
					return this.$services.page.getValue(this.createResult(), key.substring("form.".length));
				}
			},
			generateForm: function() {
				var self = this;
				var page = this.cell.state.pages[0];
				// by default we want inline reporting of exceptions
				this.cell.state.mode = "component";
	
				var ignoreParameters = [];			
				// if we have an operation, we assume path parameters are ids that are not filled in manually but piped from other places
				if (this.cell.state.operation) {
					var operation = this.$services.swagger.operations[this.cell.state.operation];
					if (operation && operation.parameters) {
						nabu.utils.arrays.merge(ignoreParameters, operation.parameters.filter(function(x) {
							return x.in == "path";
						}).map(function(x) {
							return x.name;
						}));
					}
				}
				this.fieldsToAdd.forEach(function(field) {
					if (field != "body" && ignoreParameters.indexOf(field) < 0) {
						var parts = field.split(".");
						var schema = self.getSchemaFor(field);
						var type = "text";
						var textType = null;
						
						var add = {
							arbitrary: false,
							name: field,
							label: "%" + "{" + self.$services.formatter.conventionize(parts[parts.length - 1]) + "}",
							description: null,
							type: "text",
							enumerations: [],
							value: null,
							group: null,
							joinGroup: false
						};
						
						if (schema.format && schema.format.indexOf("date") >= 0) {
							add.type = "date";
						}
						else if (schema.type == "boolean") {
							add.type = "switch";
						}
						else if (schema.type == "integer") {
							add.textType = "number";
						}
						// if we have a uuid as target, it is definitely not a regular input field
						// you probably want a resolver method or masterdata
						// for masterdata, the category is usually named the same as the value (minus Id)
						// it is pretty hard to deduce what enumeration service you want at this point...
						else if (schema.format == "uuid") {
							add.type = "enumeration-operation";
							var fieldName = parts[parts.length - 1];
							if (fieldName.substring(fieldName.length - 2, fieldName.length) == "Id") {
								fieldName = fieldName.substring(0, fieldName.length - 2);
								if (self.$services.masterdata.categories.filter(function(x) { return x.name == fieldName })) {
									add.enumerationOperation = "nabu.cms.core.rest.masterdata.category.suggest";
									add.enumerationOperationLabel = "label";
									add.enumerationOperationValue = "id";
									add.enumerationOperationQuery = "q";
								}
							}
						}
						// if we see a "password" field, use that type
						else if (field.indexOf("password") >= 0) {
							add.type = "password";
						}
						page.fields.push(add);
					}
				});
			},
			dragOver: function($event) {
				var data = $event.dataTransfer.getData("form-name");
				console.log("dragged", data);
				if (data) {
					this.$services.page.pushDragItem(this.$el);
					this.$el.classList.add("hovering");
					$event.stopPropagation();
					$event.preventDefault();
				}
			},
			dragExit: function($event) {
				this.$el.classList.remove("hovering");
			},
			drop: function($event) {
				var data = $event.dataTransfer.getData("form-name");
				if (data) {
					this.currentPage.fields.push({
						arbitrary: false,
						name: null,
						label: null,
						description: null,
						type: data,
						enumerations: [],
						value: null,
						group: null,
						joinGroup: false
					});
					$event.stopPropagation();
					$event.preventDefault();
				}
			},
			getCurrentValue: function(field) {
				var currentValue = this.result[field.name];
				if (!this.result.hasOwnProperty(field.name)) {
					currentValue = this.$services.page.getValue(this.result, field.name);
					// might be overkill, currently done for backwards compatibility
					if (currentValue != null) {
						Vue.set(this.result, field.name, currentValue);
					}
				}
				return currentValue;
			},
			initializePageForm: function() {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				// we currently only copy the root variables, this means complex objects have their values copied "by reference"
				// we use getCurrentValue to get the current value recursively to bind them to our fields
				// but at that point we persist them as "." separated values which means updated values don't end up in the resulting object
				// this means if we have a . separated field, it is already synced "correctly" as a diff, it is only for root fields that we have an issue
				var reference = {};
				/*Vue.set(this, "result", {});
				var page = this.$services.page.getPageParameterValues(self.page, pageInstance);
				Object.keys(page).map(function(key) {
					// we currently only use the reference to check if fields have changed
					// we currently only check this with the dot-based notation, never the object notation
					// as such we can explode into a separate object
					// the problem is: the explode takes into account vue components etc that can not be iterated upon, but if you still have the original result
					// then the JSON.stringify might fail with recursive references
					// we just explode it after
					//reference[key] = page[key];
					Vue.set(self.result, key, page[key]);
				});*/
				// we _need_ to take a serialized copy of the state, otherwise the createResult will always update the state when trying to create a result object
				var page = this.$services.page.getPageParameterValues(self.page, pageInstance);
				// we do need a newly referenced object because we want to enrich it
				// the reason we want to bypass serialization when relevant is for files...
				// we can't use stringification cloning because of objects like file, blob,...
				Vue.set(this, "result", this.$services.page.cloneByReference(page));
				// must recreate the "." separated values, necessary for "complex" multifield form components like address
				// other components get a correct initial value because we get the field from the result (getCurrentValue)
				//this.$services.page.explode(reference, this.result);
				// explode to get correct values
				this.$services.page.explode(this.result, this.result);
				//Vue.set(this, "reference", JSON.parse(JSON.stringify(reference)));
				//Vue.set(this, "reference", reference);
				//Vue.set(this, "reference", JSON.parse(JSON.stringify(this.result)));
				// use the same strategy for cloning the reference, otherwise this might have serialized versions of actual objects, which fail in "hasChanged"
				Vue.set(this, "reference", this.$services.page.cloneByReference(this.result));
			},
			hasChanged: function(path, value) {
				if (this.cell.state.pageForm) {
					var originalValue = this.reference[path];
					//var originalValue = this.$services.page.getValue(this.reference, path);
					
					// for arrays we do a separate check for each item
					if (value instanceof Array && originalValue instanceof Array) {
						var changed = false;
						if (value.length != originalValue.length) {
							changed = true;
						}
						else {
							for (var i = 0; i < value.length; i++) {
								if (value[i] !== originalValue[i]) {
									// check if it contains the same data
									if (JSON.stringify(value[i]) !== JSON.stringify(originalValue[i])) {
										changed = true;
									}
								}
							}
						}
						return changed;
					}
					return value !== originalValue;
				}
				// for now...
				else {
					return true;
				}
			},
			initialize: function() {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				// if we are updating the page itself, get the parameters from there
				if (this.cell.state.pageForm) {
					/*
					var page = this.$services.page.getPageParameterValues(self.page, pageInstance);
					Object.keys(page).map(function(key) {
						Vue.set(self.result, key, page[key]);
					});
					*/
					this.initializePageForm();
				}
				else if (this.cell.bindings) {
					Object.keys(this.cell.bindings).map(function(key) {
						if (self.cell.bindings[key]) {
							var bindingValue = self.$services.page.getBindingValue(pageInstance, self.cell.bindings[key]);
							// duplicate the arrays to prevent refresh issues
							// suppose in our form we add one to the form, but the entire array is watched, then the form is rerendered and rebound
							// additionally we want to be able to "cancel" our form without having the changes persisted, hence the object clone
							// TODO: the same could be set for objects themselves with fields being directly altered by reference, might need more work then
							if (bindingValue instanceof Array) {
								var cloned = bindingValue.map(function(x) { return nabu.utils.objects.clone(x) });
								if (self.result[key] instanceof Array) {
									self.result[key].splice(0);
									nabu.utils.arrays.merge(self.result[key], cloned);
								}
								else {
									Vue.set(self.result, key, cloned);
								}
							}
							else {
								Vue.set(self.result, key, bindingValue);
							}
						}
					});
				}
				
				// get the first page
				this.currentPage = this.cell.state.pages[0];
				
				this.$services.analysis.push({
					pageName: this.page.content.name,
					pageCategory: this.page.content.category,
					category: "form",
					type: "form-page",
					counter: 0,
					method: "start",
					group: this.analysisId,
					event: this.analysisId + "-page-0"
				});
				// DEPRECATED
				if (this.$services.analysis && this.$services.analysis.emit) {
					this.$services.analysis.emit("form-page-0", this.analysisId, null, true);
				}
			},
			automap: function() {
				var source = this.availableParameters[this.autoMapFrom];
				var self = this;
				this.fieldsToAdd.forEach(function(key) {
				//Object.keys(this.cell.bindings).map(function(key) {
					// only automap those that are not filled in
					if (!self.cell.bindings[key]) {
						var keyToCheck = key;
						while (keyToCheck) {
							if (!!source.properties[keyToCheck]) {
								Vue.set(self.cell.bindings, key, self.autoMapFrom + "." + keyToCheck);
								break;
							}
							var index = keyToCheck.indexOf(".");
							if (index < 0) {
								break;
							}
							keyToCheck = keyToCheck.substring(index + 1);
						}
					}
				});
			},
			isHidden: function(field) {
				return !!field.hidden && this.$services.page.isCondition(field.hidden, this.createResult(), this);
			},
			isDisabled: function(field) {
				return !!field.disabled && this.$services.page.isCondition(field.disabled, this.createResult(), this);
			},
			pasteField: function(page) {
				var field = this.$services.page.pasteItem("page-form-field");	
				if (field) {
					if (!page.fields) {
						Vue.set(page, "fields", []);
					}
					page.fields.push(field);
				}
			},
			pastePage: function() {
				var page = this.$services.page.pasteItem("page-form-page");		
				if (page) {
					this.cell.state.pages.push(page);
				}
			},
			getGroupedFields: function(page) {
				var groupedFields = [];
				page.fields.map(function(field) {
					// if we want to join the current group, just do that
					if (field.joinGroup === true) {
						if (groupedFields.length == 0) {
							groupedFields.push({fields:[]});
						}
						groupedFields[groupedFields.length - 1].fields.push(field);
					}
					else {
						groupedFields.push({group:field.group, fields:[field]});
					}
				});
				return groupedFields;
			},
			nextPage: function() {
				var messages = this.$refs.form.validate();
				var self = this;
				var goNext = function() {
					if (!messages.length) {
						self.currentPage = self.cell.state.pages[self.cell.state.pages.indexOf(self.currentPage) + 1];
						self.$services.analysis.push({
							pageName: self.page.content.name,
							pageCategory: self.page.content.category,
							category: "form",
							type: "form-page",
							counter: self.cell.state.pages.indexOf(self.currentPage),
							method: "next",
							group: self.analysisId,
							event: self.analysisId + "-page-" + self.cell.state.pages.indexOf(self.currentPage)
						});
						// DEPRECATED
						if (self.$services.analysis && self.$services.analysis.emit) {
							self.$services.analysis.emit("form-page-" + self.cell.state.pages.indexOf(self.currentPage), self.analysisId, {method: "next"}, true);
						}
					}
					else {
						self.showMessages(messages);
						self.scrollToException(messages);
					}
				}
				if (messages.then) {
					messages.then(goNext, goNext);
				}
				else {
					goNext();
				}
			},
			showMessages: function(messages) {
				if (this.cell.state.formValidationMessages && parseInt(this.cell.state.formValidationMessages) > 0) {
					this.messages.splice(0);
					nabu.utils.arrays.merge(this.messages, messages.filter(function(x) {
						return !x.handled;
					}).splice(0, Math.min(messages.length, parseInt(this.cell.state.formValidationMessages))));
				}
			},
			scrollToException: function(messages) {
				for (var i = 0; i < messages.length; i++) {
					if (messages[i].component && messages[i].component.$el) {
						messages[i].component.$el.scrollIntoView(true);
						break;
					}
				}
			},
			previousPage: function() {
				if (this.cell.state.pages.indexOf(this.currentPage) >= 1) {
					this.currentPage = this.cell.state.pages[this.cell.state.pages.indexOf(this.currentPage) - 1];
					this.$services.analysis.push({
						pageName: this.page.content.name,
						pageCategory: this.page.content.category,
						category: "form",
						type: "form-page",
						counter: this.cell.state.pages.indexOf(this.currentPage),
						method: "previous",
						group: this.analysisId,
						event: this.analysisId + "-page-" + this.cell.state.pages.indexOf(this.currentPage)
					});
					// DEPRECATED
					if (this.$services.analysis && this.$services.analysis.emit) {
						this.$services.analysis.emit("form-page-" + this.cell.state.pages.indexOf(this.currentPage), this.analysisId, {method: "previous"}, true);
					}
				}
			},
			setPage: function(page) {
				var messages = this.$refs.form.validate();
				if (!messages.length || this.edit) {
					this.currentPage = page;
					this.$services.analysis.push({
						pageName: this.page.content.name,
						pageCategory: this.page.content.category,
						category: "form",
						type: "form-page",
						counter: this.cell.state.pages.indexOf(this.currentPage),
						method: "choose",
						group: this.analysisId,
						event: this.analysisId + "-page-" + this.cell.state.pages.indexOf(this.currentPage)
					});
					// DEPRECATED
					if (this.$services.analysis && this.$services.analysis.emit) {
						this.$services.analysis.emit("form-page-" + this.cell.state.pages.indexOf(this.currentPage), this.analysisId, {method: "choose"}, true);
					}
				}
			},
			deletePage: function(page) {
				var self = this;
				this.$confirm({
					message: "Are you sure you want to delete the form page '" + page.name + "'?"
				}).then(function() {
					self.cell.state.pages.splice(self.cell.state.pages.indexOf(page), 1);
				});
			},
			addPage: function() {
				this.cell.state.pages.push({
					name: "Unnamed Page",
					title: null,
					fields: []
				});
			},
			upPage: function(page) {
				var index = this.cell.state.pages.indexOf(page);
				if (index > 0) {
					var replacement = this.cell.state.pages[index - 1];
					this.cell.state.pages.splice(index - 1, 1, this.cell.state.pages[index]);
					this.cell.state.pages.splice(index, 1, replacement);
				}
			},
			downPage: function(page) {
				var index = this.cell.state.pages.indexOf(page);
				if (index < this.cell.state.pages.length - 1) {
					var replacement = this.cell.state.pages[index + 1];
					this.cell.state.pages.splice(index + 1, 1, this.cell.state.pages[index]);
					this.cell.state.pages.splice(index, 1, replacement);
				}
			},
			upAllPage: function(page) {
				var index = this.cell.state.pages.indexOf(page);
				if (index > 0) {
					this.cell.state.pages.splice(index, 1);
					this.cell.state.pages.unshift(page);
				}
			},
			downAllPage: function(page) {
				var index = this.cell.state.pages.indexOf(page);
				if (index < this.cell.state.pages.length - 1) {
					this.cell.state.pages.splice(index, 1);
					this.cell.state.pages.push(page);
				}
			},
			copyPage: function(page) {
				this.cell.state.pages.push(nabu.utils.objects.deepClone(page));
			},
			configurator: function() {
				// sneaky shit!
				if (this.cell.state.autoclose == null) {
					Vue.set(this.cell.state, "autoclose", true);
				}
				return "page-form-configure-all";
			},
			configure: function() {
				if (this.cell.state.autoclose == null) {
					Vue.set(this.cell.state, "autoclose", true);
				}
				this.configuring = true;	
			},
			normalize: function(state) {
				if (!state.hasOwnProperty("title")) {
					Vue.set(state, "title", null);
				}
				if (!state.hasOwnProperty("immediate")) {
					Vue.set(state, "immediate", false);
				}
				if (!(state.pages instanceof Array)) {
					Vue.set(state, "pages", []);
				}
				// if we still have fields directly in the state, it is actually a form with one page (the old way)
				if (state.fields) {
					state.pages.push({
						name: "Form Fields",
						title: null,
						fields: state.fields
					});
					Vue.delete(state, "fields");
				}
				if (!state.pages.length) {
					state.pages.push({
						name: "Form Fields",
						title: null,
						fields: []
					});
				}
				if (!state.hasOwnProperty("class")) {
					Vue.set(state, "class", null);
				}
				if (!state.hasOwnProperty("ok")) {
					Vue.set(state, "ok", "%{Ok}");
				}
				if (!state.hasOwnProperty("edit")) {
					Vue.set(state, "edit", "%{Edit}");
				}
				if (!state.hasOwnProperty("next")) {
					Vue.set(state, "next", "%{Next}");
				}
				if (!state.hasOwnProperty("cancel")) {
					Vue.set(state, "cancel", "%{Cancel}");
				}
				if (!state.hasOwnProperty("event")) {
					Vue.set(state, "event", null);
				}
				if (!state.hasOwnProperty("synchronize")) {
					Vue.set(state, "synchronize", false);
				}
			},
			getEvents: function() {
				var result = {};
				if (this.cell.state.functionForm && this.cell.state.event) {
					result[this.cell.state.event] = this.cell.state.functionId
						? this.$services.page.getFunctionOutput(this.cell.state.functionId)
						: {};
				}
				else if (this.operation && this.cell.state.event) {
					var response = this.operation.responses["200"];
					var schema = null;
					if (response && response.schema) {
						schema = this.$services.swagger.resolve(response.schema);
					}
					if (schema == null) {
						schema = {properties:this.getOperationInput()};
					}
					result[this.cell.state.event] = schema ? schema : {};
				}
				else if (this.cell.state.event) {
					result[this.cell.state.event] = this.cell.on ? this.cell.on : {};
				}
				if (this.cell.state.submitEvent) {
					if (this.cell.state.functionForm) {
						result[this.cell.state.submitEvent] = this.$services.page.getFunctionInput(this.cell.state.functionId);
					}
					else {
						result[this.cell.state.submitEvent] = {properties:this.getOperationInput()};
					}
				}
				if (this.cell.state.cancelEvent) {
					result[this.cell.state.cancelEvent] = this.cell.on ? this.cell.on : {};
				}
				if (this.cell.state.errorEvent) {
					result[this.cell.state.errorEvent] = this.$services.swagger.resolve("#/definitions/StructuredErrorResponse");
				}
				this.cell.state.pages.forEach(function(page) {
					if (page.fields) {
						page.fields.forEach(function(field) {
							var event = nabu.page.event.getName(field, "validationSuccessEvent");
							if (event != null) {
								result[event] = {};
							}
						})
					}
				});
				nabu.utils.objects.merge(result, this.getEventsRecursively(this));
				return result;
			},
			getEventsRecursively: function(component) {
				var events = {};
				if (component.$children) {
					var self = this;
					component.$children.forEach(function(child) {
						if (child.getEvents) {
							nabu.utils.objects.merge(events, child.getEvents());
						}
						else {
							nabu.utils.objects.merge(events, self.getEventsRecursively(child));
						}
					});
				}
				return events;
			},
			getOperationInput: function() {
				var result = {};
				var self = this;
				if (this.cell.state.operation) {
					var operation = this.$services.swagger.operations[this.cell.state.operation];
					if (operation && operation.parameters) {
						operation.parameters.forEach(function(parameter) {
							if (parameter.in == "body") {
								var type = self.$services.swagger.resolve(parameter);
								result[parameter.name] = type.schema;
							}
							else {
								result[parameter.name] = parameter;
							}
						})
					}
				}
				return result;
			},
			cancel: function() {
				if (!this.doingIt) {
					if (this.cell.state.cancelEvent) {
						var pageInstance = this.$services.page.getPageInstance(this.page, this);
						var content = null;
						if (this.cell.on) {
							content = pageInstance.get(this.cell.on);
						}
						if (content == null) {
							content = {};
						}
						pageInstance.emit(this.cell.state.cancelEvent, content);
					}
						this.$emit('close');
					if (!this.cell.state.cancelEvent || this.cell.state.autoclose) {
					}
					if (this.cell.state.allowReadOnly) {
						this.readOnly = true;
						// reinitialize
						this.initialize();
						this.resetValidation();
					}
					this.$services.analysis.push({
						pageName: this.page.content.name,
						pageCategory: this.page.content.category,
						category: "form",
						type: "form-cancel",
						group: this.analysisId,
						event: this.analysisId + "-cancel"
					});
					// DEPRECATED
					if (this.$services.analysis && this.$services.analysis.emit) {
						this.$services.analysis.emit("form-cancel", this.analysisId, null, true);
					}
				}
			},
			resetValidation: function(component) {
				if (component == null) {
					component = this.$refs.form;
				}
				if (component.valid != null) {
					component.valid = null;
				}
				if (component.$children) {
					for (var i = 0; i < component.$children.length; i++) {
						this.resetValidation(component.$children[i]);
					}
				}
			},
			getOperations: function(name) {
				var self = this;
				return this.$services.page.getOperations(function(operation) {
					// must be a put, post, patch or delete
					return (operation.method.toLowerCase() == "put" || operation.method.toLowerCase() == "post" || operation.method.toLowerCase() == "delete" || operation.method.toLowerCase() == "patch")
						// and contain the name fragment (if any)
						&& (!name || operation.id.toLowerCase().indexOf(name.toLowerCase()) >= 0);
				});
			},
			getField: function(name) {
				for (var i = 0; i < this.cell.state.pages.length; i++) {
					var field = this.cell.state.pages[i].fields.filter(function(x) {
						return x.name == name;
					})[0];
					if (field) {
						return field;
					}
				}
			},
			updateOperation: function(operation) {
				this.cell.state.operation = !operation ? null : operation.id;
				var bindings = {};
				if (operation && operation.parameters) {
					var self = this;
					operation.parameters.map(function(parameter) {
						if (parameter.in == "body") {
							var type = self.$services.swagger.resolve(parameter);
							if (type.schema.properties) {
								Object.keys(type.schema.properties).map(function(key) {
									// 1-level recursion (currently)
									// always add the element itself if it is a list (need to be able to add/remove it)
									if (type.schema.properties[key].type != "object") {
										var newKey = "body." + key;
										bindings[newKey] = self.cell.bindings && self.cell.bindings[newKey]
											? self.cell.bindings[newKey]
											: null;
									}
									if (type.schema.properties[key].type == "object" || (type.schema.properties[key].type == "array" && type.schema.properties[key].items.properties)) {
										var properties = type.schema.properties[key].type == "array"
											? type.schema.properties[key].items.properties 
											: type.schema.properties[key].properties;
										Object.keys(properties).map(function(key2) {
											var newKey = "body." + key + "." + key2;
											bindings[newKey] = self.cell.bindings && self.cell.bindings[newKey]
												? self.cell.bindings[newKey]
												: null;	
										});
									}
								});
							}
							// if we have a binary body, expose that
							else if (type.schema.type == "string" && type.schema.format == "binary") {
								bindings["body"] =  self.cell.bindings && self.cell.bindings["body"]
									? self.cell.bindings["body"]
									: null;
							}
						}
						else {
							bindings[parameter.name] = self.cell.bindings && self.cell.bindings[parameter.name]
								? self.cell.bindings[parameter.name]
								: null;
						}
					});
				}
				// if we are event driven, do a best-effort mapping if the fields match
				if (this.cell.on) {
					var self = this;
					var pageInstance = self.$services.page.getPageInstance(self.page, self);
					var event = pageInstance.getEvents()[this.cell.on];
					if (event && event.properties) {
						Object.keys(bindings).map(function(key) {
							var field = key;
							if (field.indexOf("body.") == 0) {
								field = field.substring("body.".length);
							}
							if (event.properties[field]) {
								bindings[key] = self.cell.on + "." + field;
							}
						});
					}
				}
				// TODO: is it OK that we simply remove all bindings?
				// is the table the only one who sets bindings here?
				Vue.set(this.cell, "bindings", bindings);
			},
			getSchemaFor: function(field) {
				if (!field) {
					return null;
				}
				if (!this.schemas[field]) {
					var recursiveGet = function(schema, parts, index) {
						if (schema.items) {
							schema = schema.items;
						}
						var properties = schema.properties;
						if (properties && properties[parts[index]]) {
							if (index < parts.length - 1) {
								return recursiveGet(properties[parts[index]], parts, index + 1);
							}
							else {
								var result = properties[parts[index]];
								result.required = result.required || schema.required && schema.required.indexOf(parts[index]) >= 0;
								return result;
							}
						}
					}
					if (this.cell.state.functionForm) {
						var properties = this.$services.page.getFunctionInput(this.cell.state.functionId);
						var parts = field.split(".");
						result = properties ? recursiveGet(properties, parts, 0) : null;
					}
					else if (this.cell.state.pageForm) {
						var definition = this.$services.page.getPageParameters(this.page);
						var parts = field.split(".");
						result = definition ? recursiveGet(definition, parts, 0) : null;
					}
					else {
						var operation = this.$services.swagger.operations[this.cell.state.operation];
						var result = null;
						if (operation) {
							var self = this;
							// body parameter
							if (field.indexOf("body.") == 0) {
								var body = this.body;
								var parts = field.substring("body.".length).split(".");
								result = body.schema ? recursiveGet(body.schema, parts, 0) : null;
							}
							// non-body parameter
							else {
								for (var i = 0; i < operation.parameters.length; i++) {
									var parameter = operation.parameters[i];
									if (parameter.in != "body" && parameter.name == field) {
										result = parameter;
									}
								};
							}
						}
					}
					this.schemas[field] = result;
				}
				return this.schemas[field];
			},
			isList: function(field) {
				var field = this.getSchemaFor(field);
				return field && field.type == "array";
			},
			isPartOfList: function(field) {
				// only things in the body can be a list (?)
				if (!field || field.indexOf("body.") != 0) {
					return false;
				}
				var parts = field.substring("body.".length).split(".");
				var schema = this.body.schema;
				for (var i = 0; i < parts.length - 1; i++) {
					if (schema.items) {
						schema = schema.items;
					}
					schema = schema.properties[parts[i]];
					if (schema && schema.type == "array") {
						return true;	
					}
				}
				return false;
			},
			set: function(key, value) {
				this.result[key] = value;
			},
			getProvidedListComponent: function(type) {
				var provided = nabu.page.providers("page-form-list-input").filter(function(x) {
					 return x.name == type;
				})[0];
				return provided ? provided.component : null;	
			},
			addInstanceOfField: function(field) {
				if (!this.result[field.name]) {
					Vue.set(this.result, field.name, []);
				}
				var schema = this.getSchemaFor(field.name);
				if (schema.items) {
					schema = schema.items;
				}
				var result = null;
				if (schema.properties) {
					result = {};
					Object.keys(schema.properties).map(function(key) {
						result[key] = null;
					});
				}
				this.result[field.name].push(result);
			},
			createResultDefinition: function() {
				var result = {properties: {}};
				if (this.operation && this.operation.parameters) {
					var self = this;
					Object.keys(this.operation.parameters).map(function(key) {
						if (self.operation.parameters[key].schema) {
							result.properties[self.operation.parameters[key].name] = self.$services.swagger.resolve(self.operation.parameters[key].schema);
						}
						else {
							result.properties[self.operation.parameters[key].name] = self.operation.parameters[key];
						}
					});
				}
				return result;
			},
			createResult: function() {
				var result = this.result;
				var transformed = {};
				Object.keys(result).map(function(name) {
					var parts = name.split(".");
					var tmp = transformed;
					for (var i = 0; i < parts.length - 1; i++) {
						if (tmp[parts[i]] == null) {
							Vue.set(tmp, parts[i], {});
						}
						tmp = tmp[parts[i]];
					}
					// if they are already the same object, no action is needed
					if (tmp[parts[parts.length - 1]] !== result[name]) {
						// merge them, note that typeof(null) == "object"...
						if (tmp[parts[parts.length - 1]] != null && typeof(tmp[parts[parts.length - 1]]) == "object") {
							nabu.utils.objects.merge(tmp[parts[parts.length - 1]], result[name]);
						}
						else {
							Vue.set(tmp, parts[parts.length - 1], result[name]);
						}
					}
					// if it is a complex field, set the string value as well
					// this makes it easier to check later on if it has been set or not
					if (name.indexOf(".") > 0) {
						// set the full name field as well
						transformed[name] = result[name];
					}
				});
				var self = this;
				// no need, this is bound in the created() hook into this.result so picked up in the above mapping (unless overwritten)
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				// bind additional stuff from the page
				Object.keys(this.cell.bindings).map(function(name) {
					// don't overwrite manually set values
					if (self.cell.bindings[name] && Object.keys(transformed).indexOf(name) < 0 && Object.keys(result).indexOf(name) < 0) {
						var parts = name.split(".");
						var tmp = transformed;
						for (var i = 0; i < parts.length - 1; i++) {
							if (!tmp[parts[i]]) {
								Vue.set(tmp, parts[i], {});
							}
							tmp = tmp[parts[i]];
						}
						Vue.set(tmp, parts[parts.length - 1], self.$services.page.getBindingValue(pageInstance, self.cell.bindings[name]));
					}
				});
				return transformed;
			},
			changed: function(fieldName) {
				// reset any values that should be reset...
				if (fieldName && this.cell.state.pages) {
					var self = this;
					this.cell.state.pages.forEach(function(page) {
						page.fields.forEach(function(x) {
							if (x.resetOnUpdate == fieldName || (x.resetOnUpdate instanceof Array && x.resetOnUpdate.indexOf(fieldName) >= 0)) {
								Vue.set(self.result, x.name, null);
							}
						})
					})
				}
				if (this.cell.state.immediate) {
					this.doIt();
				}
				if (this.localState) {
					// update local state to reflect the change
					Vue.set(this.localState, "form", this.createResult());
				}
			},
			doIt: function() {
				return this.execute();
			},
			execute: function(skipValidation) {
				var self = this;
				if (!this.doingIt) {
					var date = new Date();
					var stop = function(error) {
						self.$services.analysis.push({
							pageName: self.page.content.name,
							pageCategory: self.page.content.category,
							category: "form",
							type: "form-finalize",
							group: self.analysisId,
							event: self.analysisId + (error ? "-fail" : "-submit")
						});
						// DEPRECATED
						if (self.$services.analysis && self.$services.analysis.emit) {
							self.$services.analysis.emit(error ? "form-fail" : "form-finalize", self.analysisId, 
								{submitTime: new Date().getTime() - date.getTime(), totalTime: new Date().getTime() - self.started.getTime(), error: error}, true);
						}
					};
					this.doingIt = true;
					// if we have an embedded form with immediate turned on, don't valide it?
					var messages = this.cell.state.immediate && this.cell.target == "page" ? [] : this.$refs.form.validate();
					var continueWithDoIt = function() {
						var promise = null;
						if (!messages.length) {
							self.messages.splice(0, self.messages.length);
							// commit the form
							// refresh things that are necessary
							// send out event! > can use this to refresh stuff!
							// globale parameters that we can pass along
							var result = self.createResult();
							
							if (self.cell.state.submitEvent) {
								var pageInstance = self.$services.page.getPageInstance(self.page, self);
								// if we have a 204 return, we get null back, we don't want to emit null however
								pageInstance.emit(self.cell.state.submitEvent, result);
							}
							
							//console.log("result is", JSON.stringify(result, null, 2));
							if (self.cell.state.pageForm) {
								// close before the page is updated
								if (self.cell.state.autoclose == null || self.cell.state.autoclose) {
									self.$emit("close");
								}
								var pageInstance = self.$services.page.getPageInstance(self.page, self);
								var parameters = self.$services.page.getPageParameters(self.page);
								Object.keys(result).forEach(function(x) {
									// we have both the object-based notation and the . separated notation in the result
									// in this case, for correct merging, we want to use the . separated, never the object in its entirety, unless it is an array!
									if (result[x] == null || result[x] instanceof Array || (result != null && (Object(result[x]) !== result[x] || result[x] instanceof Date || result[x] instanceof File || result[x] instanceof Blob))) {
										// only set if changed, otherwise we might overwrite external changes to the page state
										if (self.hasChanged(x, result[x])) {
											pageInstance.set("page." + x, result[x]);
										}
									}
								});
								if (self.cell.state.event) {
									promise = pageInstance.emit(self.cell.state.event, self.cell.on ? pageInstance.get(self.cell.on) : {});
								}
								// if we allow read only, revert to it after a successful edit
								if (self.cell.state.allowReadOnly) {
									self.readOnly = true;
								}
								self.doingIt = false;
								// don't update the reference without updating the result!!
								// update reference value for accurate checks next time around
								self.initializePageForm();
							}
							else if (self.cell.state.functionForm) {
								promise = self.$services.q.defer();
								var returnValue = self.$services.page.runFunction(self.cell.state.functionId, result, self, promise);
								promise.then(function(result) {
									if (self.cell.state.event) {
										var pageInstance = self.$services.page.getPageInstance(self.page, self);
										pageInstance.emit(self.cell.state.event, result == null ? returnValue : result);
									}
									if (self.cell.state.autoclose == null || self.cell.state.autoclose) {
										self.$emit("close");
									}
									// if we allow read only, revert to it after a successful edit
									if (self.cell.state.allowReadOnly) {
										self.readOnly = true;
									}
									self.doingIt = false;
									stop();
								}, function(error) {
									self.error = "Form submission failed";
									// if we get an XMLHTTPResponse thingy, parse it
									if (error && error.responseText) {
										error = JSON.parse(error.responseText);
									}
									// we get a (hopefully) standardized event back from the function
									if (error) {
										if (!error.code) {
											error.code = "HTTP-" + (error.status != null ? error.status : 500);
										}
										try {
											if (self.cell.state.errorEvent) {
												if (!self.cell.state.errorEventCodes || self.cell.state.errorEventCodes.split(/[\\s]*,[\\s]*/).indexOf(error.code) >= 0) {
													var pageInstance = self.$services.page.getPageInstance(self.page, self);
													pageInstance.emit(self.cell.state.errorEvent, error);
												}
											}
											var translated = self.$services.page.translateErrorCode(error.code, error.title ? error.title : error.message);
											self.error = translated;
											self.messages.push({
												type: "request",
												severity: "error",
												title: translated
											})
										}
										catch (exception) {
											self.messages.push({
												type: "request",
												severity: "error",
												title: self.$services.page.translateErrorCode(error.status ? "HTTP-" + error.status : "HTTP-500")
											})
										}
									}
									else {
										self.messages.push({
											type: "request",
											severity: "error",
											title: self.$services.page.translateErrorCode("HTTP-500")
										});
									}
									self.doingIt = false;
									stop(self.error);
								})
							}
							else if (self.cell.state.operation) {
								try {
									return self.$services.swagger.execute(self.cell.state.operation, result).then(function(returnValue) {
										var pageInstance = self.$services.page.getPageInstance(self.page, self);
										// if we want to synchronize the values, do so
										if (self.cell.state.synchronize) {
											Object.keys(self.cell.bindings).map(function(name) {
												// only set it if we actually bound something to it
												if (self.cell.bindings[name] != null) {
													var newValue = self.result[name];
													var valueSet = false;
													// if we are setting an array, check if the original value was an array as well
													if (newValue instanceof Array) {
														var originalValue = pageInstance.get(self.cell.bindings[name]);
														if (originalValue instanceof Array) {
															originalValue.splice(0);
															nabu.utils.arrays.merge(originalValue, newValue);
															valueSet = true;
														}
													}
													if (!valueSet) {
														pageInstance.set(self.cell.bindings[name], newValue);
													}
												}
											});
										}
										if (self.cell.state.event) {
											// if we have a 204 return, we get null back, we don't want to emit null however
											var emitValue = returnValue == null ? result : returnValue;
											pageInstance.emit(self.cell.state.event, emitValue == null ? {} : emitValue);
										}
										if (self.cell.state.autoclose == null || self.cell.state.autoclose) {
											self.$emit("close");
										}
										// if we allow read only, revert to it after a successful edit
										if (self.cell.state.allowReadOnly) {
											self.readOnly = true;
										}
										self.doingIt = false;
										stop();
									}, function(error) {
										self.error = "Form submission failed";
										try {
											if (error.responseText) {
												error = JSON.parse(error.responseText);
											}
											if (self.cell.state.errorEvent) {
												if (!self.cell.state.errorEventCodes || self.cell.state.errorEventCodes.split(/[\\s]*,[\\s]*/).indexOf(error.code) >= 0) {
													var pageInstance = self.$services.page.getPageInstance(self.page, self);
													pageInstance.emit(self.cell.state.errorEvent, error);
												}
											}
											var translated = self.$services.page.translateErrorCode(error.code, error.title ? error.title : error.message);
											self.error = translated;
											self.messages.push({
												type: "request",
												severity: "error",
												title: translated
											})
										}
										catch (exception) {
											self.messages.push({
												type: "request",
												severity: "error",
												title: self.$services.page.translateErrorCode(error.status ? "HTTP-" + error.status : "HTTP-500")
											})
										}
										self.doingIt = false;
										stop(self.error);
									});
								}
								catch(exception) {
									self.doingIt = false;
									console.error("Could not submit form", exception);
									stop(exception.message);
									promise = self.$services.q.defer();
									promise.reject(exception);
								}
							}
							else {
								var pageInstance = self.$services.page.getPageInstance(self.page, self);
								if (self.cell.state.event) {
									promise = pageInstance.emit(self.cell.state.event, {});
								}
								if (self.cell.state.autoclose == null || self.cell.state.autoclose) {
									self.$emit("close");
								}
								// if we allow read only, revert to it after a successful edit
								if (self.cell.state.allowReadOnly) {
									self.readOnly = true;
								}
								self.doingIt = false;
								stop();
							}
						}
						else {
							self.doingIt = false;
							self.showMessages(messages);
							self.scrollToException(messages);
						}
						// did not work...?
						if (promise == null) {
							promise = self.$services.q.defer();
							promise.reject();
						}
						return promise;
					}
					if (messages.then) {
						var promise = this.$services.q.defer();
						var continueWithPromise = function() {
							continueWithDoIt().then(promise, promise);
						};
						messages.then(continueWithPromise, continueWithPromise);
						return promise;
					}
					else {
						return continueWithDoIt();
					}
				}
			},
			up: function(field) {
				var index = this.cell.state.fields.indexOf(field);
				if (index > 0) {
					var replacement = this.cell.state.fields[index - 1];
					this.cell.state.fields.splice(index - 1, 1, this.cell.state.fields[index]);
					this.cell.state.fields.splice(index, 1, replacement);
				}
			},
			down: function(field) {
				var index = this.cell.state.fields.indexOf(field);
				if (index < this.cell.state.fields.length - 1) {
					var replacement = this.cell.state.fields[index + 1];
					this.cell.state.fields.splice(index + 1, 1, this.cell.state.fields[index]);
					this.cell.state.fields.splice(index, 1, replacement);
				}
			},
			upAll: function(field) {
				var index = this.cell.state.fields.indexOf(field);
				if (index > 0) {
					this.cell.state.fields.splice(index, 1);
					this.cell.state.fields.unshift(field);
				}
			},
			downAll: function(field) {
				var index = this.cell.state.fields.indexOf(field);
				if (index < this.cell.state.fields.length - 1) {
					this.cell.state.fields.splice(index, 1);
					this.cell.state.fields.push(field);
				}
			}
		},
		watch: {
			// if we switch out of read only mode, check autofocus
			readOnly: function(newValue) {
				this.$root.$emit(newValue ? "form-closed" : "form-opened", this);
				if (!newValue && this.cell.state.autofocus) {
					var self = this;
					Vue.nextTick(function() {
						self.$refs.form.$el.querySelector("input").focus();
					});
				}
			}
		}
	});
}

nabu.page.formComponentConstructer("page-form");
nabu.page.formComponentConstructer("page-form-configure-all");

Vue.component("page-form-field", {
	template: "#page-form-field",
	props: {
		page: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: false,
		},
		schema: {
			type: Object,
			required: false
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: Boolean,
			required: false,
			default: true
		},
		timeout: {
			type: Number,
			required: false,
			default: 600
		},
		isDisabled: {
			type: Boolean,
			required: false,
			default: false
		},
		// the parent value that contains the value
		parentValue: {
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		schemaResolver: {
			type: Function,
			required: false
		},
		validateTimeout: {
			required: false
		},
		codes: {
			required: false
		},
		validateOnBlur: {
			required: false
		}
	},
	created: function() {
		// if it is a fixed field, just emit the value
		if (this.field.fixed) {
			this.$emit("input", this.field.value);
		}
		
		if (this.field.listeners && this.field.listeners.length > 0) {
			var self = this;
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			this.field.listeners.forEach(function(x) {
				self.subscriptions.push(pageInstance.subscribe(x.to.replace(/^([^.]+).*/, "$1"), function(value) {
					// there was a circumstance where the event was emitted twice, once with data, once without
					// for this reason, initially we did not allow setting to null
					// however in a new usecase, null resets were actually needed so we disabled the requirement to have null
					// in this new usecase I tested both with and without values and everything worked as expected
					var result = value ? self.$services.page.getValue(value, x.to.replace(/^[^.]+[.](.*)/, "$1")) : null;
					// it seems to immediately trigger to null?
					self.$emit("input", result);
					// currently we reuse this one, but maybe we should always validate at that point?
					if (self.validateOnBlur) {
						setTimeout(self.validate, 1);
					}
				}));
			});
		}
	},
	// mostly a copy paste from form-section
	data: function() {
		return {
			labels: [],
			subscriptions: []
		}
	},
	computed: {
		definition: function() {
			return nabu.utils.vue.form.definition(this);
		},
		mandatory: function() {
			return nabu.utils.vue.form.mandatory(this);
		},
		fieldLabel: function() {
			if (!this.label) {
				return null;
			}
			return this.field.label ? this.field.label : null;
		}
	},
	methods: {
		blur: function() {
			if (this.validateOnBlur) {
				this.validate();
			}
		},
		slowValidate: function() {
			if (this.validateTimer != null) {
				clearTimeout(this.validateTimer);
				this.validateTimer = null;
			}
			if (this.validateTimeout) {
				this.validateTimer = setTimeout(this.validate, this.validateTimeout);
			}
		},
		usesMultipleFields: function(type) {
			var provided = nabu.page.providers("page-form-input").filter(function(x) {
				 return x.name == type;
			})[0];
			return provided ? provided.multipleFields : false;
		},
		getProvidedComponent: function(type) {
			var provided = nabu.page.providers("page-form-input").filter(function(x) {
				 return x.name == type;
			})[0];
			return provided ? provided.component : null;	
		},
		fieldClasses: function(field) {
			var result = [];
			result.push("p-" + field.type);
			if (field.styles) {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				nabu.utils.arrays.merge(result, this.$services.page.getDynamicClasses(field.styles, this.state, this));
			}
			return result;
		},
		validate: function(soft) {
			var messages = nabu.utils.vue.form.validateChildren(this, soft);
			if (this.validator) {
				var additional = this.validator(this.value);
				if (additional && additional.length) {
					for (var i = 0; i < additional.length; i++) {
						additional[i].component = this;
						if (typeof(additional[i].context) == "undefined") {
							additional[i].context = [];
						}
						messages.push(additional[i]);
					}
				}
			}
			if (messages.then) {
				messages.then(this.emitSuccess);
			}
			else {
				this.emitSuccess(messages);
			}
			return messages;
		},
		emitSuccess: function(messages) {
			if (messages && !messages.length) {
				var event = nabu.page.event.getName(this.field, "validationSuccessEvent");
				if (event) {
					var pageInstance = this.$services.page.getPageInstance(this.page, this);
					var content = nabu.page.event.getInstance(this.field, "validationSuccessEvent", this.page, this);
					pageInstance.emit(event, content == null ? {} : content);
				}
			}
		}
	},
	events: {
		'$vue.child.added': function(child) {
			if (child.label) {
				// we pass in the entire component because we are interested in the "hide" property it may have
				// if we simply pass in the hide, it doesn't work...
				this.labels.push({ 
					name: child.label,
					component: child
				});
			}
			else if (!this.labels.length && child.labels) {
				nabu.utils.arrays.merge(this.labels, child.labels);
			}
			else {
				this.labels.push(null);
			}
		}
	}
});

Vue.component("page-form-configure", {
	template: "#page-form-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		cell: {
			type: Object,
			required: true
		},
		title: {
			type: String,
			required: true
		},
		// string list of field names
		possibleFields: {
			type: Array,
			required: true
		},
		// field values
		fields: {
			type: Array,
			required: true
		},
		isList: {
			type: Function,
			required: false
		},
		editName: {
			type: Boolean,
			required: false
		},
		groupable: {
			type: Boolean,
			required: false,
			default: false
		},
		schemaResolver: {
			type: Function,
			required: false,
			default: function(name) { return null }
		},
		allowReadOnly: {
			type: Boolean,
			required: false
		},
		rootTag: {
			type: String,
			required: false,
			default: "n-collapsible"
		},
		dark: {
			type: Boolean,
			required: false,
			default: false
		},
		allowPaste: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	methods: {
		up: function(field) {
			var index = this.fields.indexOf(field);
			if (index > 0) {
				var replacement = this.fields[index - 1];
				this.fields.splice(index - 1, 1, this.fields[index]);
				this.fields.splice(index, 1, replacement);
			}
		},
		down: function(field) {
			var index = this.fields.indexOf(field);
			if (index < this.fields.length - 1) {
				var replacement = this.fields[index + 1];
				this.fields.splice(index + 1, 1, this.fields[index]);
				this.fields.splice(index, 1, replacement);
			}
		},
		upAll: function(field) {
			var index = this.fields.indexOf(field);
			if (index > 0) {
				this.fields.splice(index, 1);
				this.fields.unshift(field);
			}
		},
		downAll: function(field) {
			var index = this.fields.indexOf(field);
			if (index < this.fields.length - 1) {
				this.fields.splice(index, 1, replacement);
				this.fields.push(field);
			}
		},
		pasteField: function(page) {
			var field = this.$services.page.pasteItem("page-form-field");	
			if (field) {
				if (!this.fields) {
					Vue.set(this, "fields", []);
				}
				this.fields.push(field);
			}
		},
		addField: function(content) {
			if (content) {
				this.fields.push({
					arbitrary: true,
					route: null,
					bindings: {}
				});
			}
			else {
				this.fields.push({
					arbitrary: false,
					name: null,
					label: null,
					description: null,
					type: null,
					enumerations: [],
					value: null,
					group: null,
					joinGroup: false
				});
			}
		}
	}
});

Vue.component("page-form-configure-single", {
	template: "#page-form-configure-single",
	props: {
		page: {
			type: Object,
			required: true
		},
		cell: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		possibleFields: {
			type: Array,
			required: true
		},
		allowLabel: {
			type: Boolean,
			required: false,
			default: true
		},
		allowDescription: {
			type: Boolean,
			required: false,
			default: true
		},
		isList: {
			type: Function,
			required: false
		},
		groupable: {
			type: Boolean,
			required: false,
			default: false
		},
		hidable: {
			type: Boolean,
			required: false,
			default: false
		},
		schema: {
			type: Object,
			required: false
		},
		allowReadOnly: {
			type: Boolean,
			required: false
		}
	},
	created: function() {
		this.normalize(this.field);
	},
	computed: {
		types: function() {
			var provided = [];
			if (this.isList && this.isList(this.field.name)) {
				nabu.utils.arrays.merge(provided, nabu.page.providers("page-form-list-input").map(function(x) { return x.name }));
			}
			else {
				provided.push("fixed");
				nabu.utils.arrays.merge(provided, nabu.page.providers("page-form-input").map(function(x) { return x.name }));
			}
			provided.sort();
			return provided;
		}
	},
	methods: {
		getAvailableRowGrouping: function(value) {
			var variants = [];
			this.$services.page.getArisComponentHierarchy("form-group").forEach(function(component) {
				if (component.variants != null) {
					component.variants.forEach(function(variant) {
						if (variants.indexOf(variant.name) < 0) {
							variants.push(variant.name);
						}
					});
				}
			});
			if (value != null) {
				variants = variants.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			variants.sort();
			return variants;
		},
		filterFieldNames: function(value) {
 			var names = this.possibleFields.filter(function(x) {
 				return (!value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0);
 			});
 			return names;
 		},
		filterTypes: function (value) {
			var types = this.types.filter(function(x) {
				return (!value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0);
			});
			return types;	
		},	
		usesMultipleFields: function(type) {
			var provided = nabu.page.providers("page-form-input").filter(function(x) {
				 return x.name == type;
			})[0];
			return provided ? provided.multipleFields : false;
		},
		getProvidedConfiguration: function(type) {
			var provided = nabu.page.providers(this.isList && this.isList(this.field.name) ? "page-form-list-input" : "page-form-input").filter(function(x) {
				 return x.name == type;
			})[0];
			return provided ? provided.configure : null;
		},
		normalize: function(field) {
			if (!field.hasOwnProperty("name")) {
				Vue.set(field, "name", null);
			}
			if (!field.hasOwnProperty("label")) {
				Vue.set(field, "label", null);
			}
			if (!field.hasOwnProperty("description")) {
				Vue.set(field, "description", null);
			}
			if (!field.hasOwnProperty("type")) {
				Vue.set(field, "type", null);
			}
			if (!(field.enumerations instanceof Array)) {
				Vue.set(field, "enumerations", []);
			}
			if (!field.hasOwnProperty("value")) {
				Vue.set(field, "value", null);
			}
		}
	}
});

Vue.component("page-configure-arbitrary", {
	template: "#page-configure-arbitrary",
	props: {
		page: {
			type: Object,
			required: true
		},
		cell: {
			type: Object,
			required: true
		},
		target: {
			type: Object,
			required: true
		},
		keys: {
			type: Array,
			required: false,
			default: function() { return [] }
		}
	},
	data: function() {
		return {
			hasConfigurator: false
		}
	},
	created: function() {
		if (!this.target.arbitraryId) {
			Vue.set(this.target, "arbitraryId", Math.random());
		}
		if (this.target.bindings == null) {
			this.target.bindings = {}
		}
		var self = this;
		// we want to find the rendered instance
		var pageInstance = this.$services.page.getPageInstance(this.page, this);
		var components = pageInstance.components[this.cell.id];
		// note for my future self:
		// this only works if there is at least one page-arbitrary rendered on the page
		// so for example suppose you have a page arbitrary in the fields of a table (e.g. to draw an inline graph)
		// you need at least one record in that table to have an instance of the page arbitrary
		// once you have an instance, we have the configuration parameters
		// note that, if said field is behind a conditional that prevents rendering in certain cases, those cases must be met to make sure it is actually rendered
		this.instance = null;
		if (components) {
			if (components.$$arbitraryCellId == this.cell.id) {
				this.instance = components;
			}
			else if (components instanceof Array) {
				components.forEach(function(x) {
					if (x.$$arbitraryCellId == self.cell.id && x.$$arbitraryId == self.target.arbitraryId) {
						self.instance = x;
					}
				});
			}
			this.hasConfigurator = this.instance != null && this.instance.configurator;
		}
	},
	computed: {
		availableParameters: function() {
			var available = this.$services.page.getAvailableParameters(this.page, this.cell, true);
			// to allow for simple types as well, we don't check for keys
			// this means we will get a "record.$all"
			if (this.keys instanceof Array) {
				available.record = {properties:{}};
				this.keys.forEach(function(key) {
					available.record.properties[key] = {
						type: "string"
					}
				});
			}
			return available;
		}
	},
	methods: {
		getTargetParameters: function(target) {
			var parameters = this.$services.page.getRouteParameters(this.$services.router.get(target.route));
			if (parameters.properties) {
				// these are auto-injected
				delete parameters.properties.cell;
				delete parameters.properties.page;
				delete parameters.properties.edit;
				delete parameters.properties.component;
			}
			return parameters;
		},
		filterRoutes: function(value) {
			var routes = this.$services.router.list().filter(function(x) {
				return x.alias && (!value || x.alias.toLowerCase().indexOf(value.toLowerCase()) >= 0);
			});
			routes.sort(function(a, b) {
				return a.alias.localeCompare(b.alias);
			});
			return routes.map(function(x) { return x.alias });
		},
		getCellConfigurator: function(cell) {
			return this.instance ? this.instance.configurator() : "div";
		},
		getCellConfiguratorInput: function(cell) {
			var result = {};
			if (this.instance) {
				var self = this;
				if (this.instance.$options.props) {
					Object.keys(this.instance.$options.props).forEach(function(prop) {
						result[prop] = self.instance[prop];
					});
				}
			}
			return result;
		}
	}
});

/**
 * The wrapper div in the template is unfortunately _necessary_
 * Otherwise page-arbitrary is no longer reactive and will not rerender when its bound input parameters change
 */

Vue.component("page-arbitrary", {
	template: "#page-arbitrary",
	props: {
		page: {
			type: Object,
			required: true
		},
		cell: {
			type: Object,
			required: true
		},
		target: {
			type: Object,
			required: true
		},
		// the component that owns this arbitrary content
		component: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: false
		},
		record: {
			type: Object,
			required: false
		}
	},
	data: function() {
		return {
			instance: null
		}
	},
	methods: {
		handle: function() {
				
		},
		getParameters: function() {
			var cellClone = nabu.utils.objects.clone(this.cell);
			cellClone.state = this.target;
			var parameters = {
				page: this.page,
				cell: cellClone,
				component: this.component,
				edit: this.edit
			};
			if (this.target.bindings) {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				Object.keys(this.target.bindings).forEach(function(key) {
					if (self.target.bindings[key]) {
						if (self.target.bindings[key].indexOf("record.") == 0) {
							var value = self.record ? self.$services.page.getValue(self.record, self.target.bindings[key].substring("record.".length)) : null;
							if (value != null) {
								parameters[key] = value;
							}
						}
						else {
							parameters[key] = self.$services.page.getBindingValue(pageInstance, self.target.bindings[key]);
						}
					}
				});
			}
			return parameters;
		},
		created: function(result) {
			this.$services.page.rendering++;	
		},
		mounted: function(instance) {
			this.instance = instance;
			var self = this;
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			// make sure we register the instance so it is correctly picked up
			// this will allow for example events to bubble up etc (presumably)
			pageInstance.mounted(this.cell, null, null, instance);
			// if we have events, reset the page ones
			if (this.instance.getEvents) {
				pageInstance.resetEvents();
			}
			// we use this to look up the correct component during configuration
			instance.$$arbitraryCellId = this.cell.id;
			// if we have multiple arbitrary in a single cell (e.g. in page-actions), we want to be able to differentiate them
			instance.$$arbitraryId = this.target.arbitraryId;
		},
		validate: function(soft) {
			if (this.instance && this.instance.validate) {
				return this.instance.validate(soft);
			}
		}
	}
});
if (!nabu) { var nabu = {} };
if (!nabu.page) { nabu.page = {} };
if (!nabu.page.views) { nabu.page.views = {} };

nabu.page.views.FormComponentGenerator = function(name) {
	return Vue.component(name, {
		template: "#" + name,
		props: {
			page: {
				type: Object,
				required: true
			},
			cell: {
				type: Object,
				required: true
			},
			childComponents: {
				type: Object,
				required: false
			},
			formComponent: {
				type: String,
				required: false,
				default: "page-form-input-text"
			},
			configurationComponent: {
				type: String,
				required: false,
				default: "page-form-input-text-configure"
			},
			edit: {
				type: Boolean
			},
			subTabs: {
				type: Array
			}
		},
		computed: {
			// not reactively updated it seems?
			pageInstance: function() {
				return this.$services.page.getPageInstance(this.page, this);
			},
			computedValue: function() {
				var instance = this.pageInstance;
				return this.cell.state.useComputed && this.cell.state.computed ? this.$services.page.eval(this.cell.state.computed, {}, this) : null;
			},
			placeholder: function() {
				if (this.editable) {
					// if we are translating, show the "raw" untranslated value as placeholder
					if (this.language && this.cell.state.translatable && this.translationArrayPath) {
						var instance = this.pageInstance;
						var original = instance && this.cell.state.name ? instance.get('page.' + this.cell.state.name) : null;
						if (original != null) {
							return original;
						}
					}
					return this.$services.page.interpret(this.$services.page.translate(this.cell.state.placeholder), this)	;
				}
				else {
					return this.$services.page.interpret(this.$services.page.translate(this.cell.state.defaultValue), this);
				}
			},
			value: function() {
				var instance = this.pageInstance;
				// if we have a language AND we are translatable, look up the translated value
				if (this.language && this.cell.state.translatable && this.translationArrayPath) {
					var self = this;
					var array = instance.get(self.translationArrayPath);
					if (array != null) {
						var name = this.cell.state.name.replace(/.*?\.([^.]+)$/, "$1");
						var current = array.filter(function(x) {
							return x.name == name && x.language == self.language;
						})[0];
						// if you have set a specific translation, use that
						if (current) {
							return current.translation;
						}
					}
					return null;
				}
				return instance && this.cell.state.name ? instance.get('page.' + this.cell.state.name) : null;
			},
			parentValue: function() {
				var instance = this.pageInstance;
				return instance ? instance.variables : null;
			},
			disabled: function() {
				// if you have switched to a particular language but this field is not translatable, disable it
				if (this.language != null && !this.cell.state.translatable) {
					return true;
				}
				if (this.running) {
					return true;
				}
				var pageInstance = this.pageInstance;
				if (!pageInstance) {
					 return true;
				}
				var state = this.$services.page.getPageState(pageInstance);
				return !!this.cell.state.disabled && this.$services.page.isCondition(this.cell.state.disabled, state, this, null, true);
			},
			readOnly: function() {
				// originally it was modelled as a boolean, we retain this for backwards compatibility until it is phased out
				if (this.cell.state.readOnly) {
					return true;
				}
				// if you have configured a read only condition on the component, it wins over state
				if (this.cell.state.readOnlyCondition) {
					var pageInstance = this.pageInstance;
					if (!pageInstance) {
						 return true;
					}
					var state = this.$services.page.getPageState(pageInstance);
					return this.$services.page.isCondition(this.cell.state.readOnlyCondition, state, this, null, true);
				}
				// check state
				var stateName = "readOnly";
				// the default should be good enough in almost all cases, but we could add a way to set a different one for more complex usecases
				if (this.cell.state.customReadOnlyState) {
					stateName = this.cell.state.customReadOnlyState;
				}
				if (this.getCurrentStates().indexOf(stateName) >= 0) {
					return true;
				}
				
				// otherwise, we check if there is a parent form with the setting
				// @2025-04-18: if we are in a repeat, we need to get the full content to see if there is a form
				var path = this.pageInstance && this.pageInstance.fragmentParent
					? this.$services.page.getTargetPath(this.pageInstance.fragmentParent.page.content, this.cell.id, true)
					: this.$services.page.getTargetPath(this.page.content, this.cell.id, true);
				if (path) {
					var self = this;
					var readOnly = null;
					path.forEach(function(element) {
						if (element.renderer == "form" && element.form) {
							if (element.runtimeAlias && self.pageInstance) {
								readOnly = self.pageInstance.get("page." + element.runtimeAlias + ".readOnly");
							}
							if (readOnly == null && element.form.readOnly) {
								readOnly = true;
							}
						}
					});
					if (readOnly) {
						return readOnly;
					}
				}
				return false;
			}
		},
		watch: {
			value: function() {
				// first hit is for computation
				if (!this.computed) {
					this.computed = true;
				}
				// array values don't pass via the usual "update", instead they manipulate the arrays directly
				else if (this.value instanceof Array) {
					this.notifyUpdate(this.value, this.value);
				}
			},
			readOnly: function(newValue) {
				this.editable = !newValue;
			}
		},
		created: function() {
			this.initializeArray();
			// if we have a raw value capture, we want to unset it when rendering this component
			// it can only be validly set by the component after it receives the actual value (if any)
			if (this.cell.state.rawName) {
				this.getPageInstance().set("page." + this.cell.state.rawName, null);
			}
			// initialize
			this.editable = !this.readOnly;
			this.calculateInitialLanguage();
		},
		// for some reason enumeration (and all derivatives of enumeration) did not get destroyed correctly
		// if you remove the alias for example for form-text, the destroy is called correctly at all levels
		// same for all other tested form components (date, checkbox,...)
		// but with enumeration, the inner page-form-enumeration destroy was correctly called, but the outer destroy in this component was NOT called
		// this left a remaining instance of the component registered in the page at position 0, which made editing impossible until you fully destroyed and recreated the page
		// after various tests it is entirely unclear why the destroy does not correctly cascade in the case of enumerations so we subscribe to that destroy and cascade it here if relevant
		ready: function() {
			var self = this;
			this.$refs.input.$on("hook:beforeDestroy", function() {
				self.$destroy();
			});
		},
		data: function() {
			return {
				running: false,
				editable: true,
				computed: false,
				language: null,
				// the language array path
				translationArrayPath: null
			}
		},
		methods: {
			calculateInitialLanguage: function() {
				var path = this.pageInstance && this.pageInstance.fragmentParent
					? this.$services.page.getTargetPath(this.pageInstance.fragmentParent.page.content, this.cell.id, true)
					: this.$services.page.getTargetPath(this.page.content, this.cell.id, true);
				if (path) {
					var self = this;
					var language = null;
					path.forEach(function(element) {
						if (element.renderer == "form" && element.form) {
							if (element.runtimeAlias && self.pageInstance) {
								language = self.pageInstance.get("page." + element.runtimeAlias + ".language");
								self.translationArrayPath = "page." + element.runtimeAlias + ".translations";
							}
						}
					});
					if (language != null) {
						this.language = language;
					}
				}
			},
			getPrettyName: function(target) {
				if (target.state) {
					var potential = target.state.label ? target.state.label : target.state.placeholder;
					if (potential != null) {
						var content = potential.trim();
						// if the content is a pure variable (e.g. for basic table layouts), we don't want the curlies
						if (content.substring(0, 1) == "{") {
							content = content.substring(1);
						}
						if (content.substring(content.length - 1) == "}") {
							content = content.substring(0, content.length - 1);
						}
						// if we don't have spaces, we camel case it (e.g. in the variable example)
						content = this.$services.page.prettify(content);
						return content;
					}
				}
			},
			initializeArray: function() {
				// if we don't have a value yet and it is an array, initialize as empty array
				if (this.value == null) {
					if (this.cell.state.initializeArray && this.isArrayField()) {
						this.computed = false;
						this.update([]);
					}
					/*
					var arrays = this.$services.page.getAllArrays(this.page, this);
					if (arrays.indexOf(this.cell.state.name) >= 0 || arrays.indexOf("page." + this.cell.state.name) >= 0) {
						this.computed = false;
						this.update([]);
					}
					*/
				}
			},
			isArrayField: function() {
				var arrays = this.$services.page.getAllArrays(this.page, this);
				if (this.cell.state.name && (arrays.indexOf(this.cell.state.name) >= 0 || arrays.indexOf("page." + this.cell.state.name) >= 0)) {   
					return true;
				}
				return false;
			},
			getTriggers: function() {
				return {
					"update": {
						
					},
					"blur": {
						
					}
				}	
			},
			getAvailableSubTabs: function() {
				var tabs = ["component"];
				if (this.subTabs) {
					nabu.utils.arrays.merge(tabs, this.subTabs);
				}
				tabs.push("form");
				tabs.push("validation");
				return tabs;
				//return this.subTabs == null || this.subTabs.length == 0 ? ["component"] : this.subTabs;
			},
			getEvents: function() {
				return this.$services.triggerable.getEvents(this.page, this.cell.state);
			},
			isRequired: function() {
				if (this.cell.state.required == "condition") {
					return this.$services.page.isCondition(this.cell.state.requiredCondition, {}, this);
				}
				else {
					return this.cell.state.required;
				}
			},
			getChildComponents: function() {
				var result = [];
				if (this.$refs.input && this.$refs.input.getChildComponents) {
					nabu.utils.arrays.merge(result, this.$refs.input.getChildComponents());
				}
				if (result.length == 0) {
					result.push({
						title: "Form Component",
						name: "form-component",
						component: "form-component"
					});
				}
				return result;
			},
			configurator: function() {
				return "nabu-form-component-configuration";	
			},
			getPageInstance: function() {
				var instance =  this.$services.page.getPageInstance(this.page, this);
				//console.log("resolving cell state", this.cell.state.name, instance, instance.get("page." + this.cell.state.name));
				return instance;	
			},
			isDisabled: function() {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(this.page, this);
				var state = self.$services.page.getPageState(pageInstance);
				return !!this.cell.state.disabled && this.$services.page.isCondition(this.cell.state.disabled, state, this);
			},
			getSchema: function() {
				if (!this.edit && this.schemaResolved) {
					return this.schema;
				}
				if (!this.cell.state.name) {
					return null;
				}
				var recursiveGet = function(schema, parts, index) {
					if (schema.items) {
						schema = schema.items;
					}
					var properties = schema.properties;
					if (properties && properties[parts[index]]) {
						if (index < parts.length - 1) {
							return recursiveGet(properties[parts[index]], parts, index + 1);
						}
						else {
							var result = properties[parts[index]];
							result.required = result.required || schema.required && schema.required.indexOf(parts[index]) >= 0;
							return result;
						}
					}
				}
				var definition = this.$services.page.getPageParameters(this.page);
				var parts = this.cell.state.name.split(".");
				var result = definition ? recursiveGet(definition, parts, 0) : null;
				if (!this.edit) {
					this.schema = result;
					// make sure we know its resolved, even if it's null
					this.schemaResolved = true;
				}
				return result;
			},
			availableFields: function(value) {
				var fields = [];
				// @2025-08-19: should this be replaced with getAllAvailableParameters?
				// currently things like events are not listed so you can't modify them
				var parameters = this.$services.page.getPageParameters(this.page);
				nabu.utils.arrays.merge(fields, this.$services.page.getSimpleKeysFor(parameters, true, true));
				//console.log("fields are", fields);
				fields.sort();
				if (value) {
					fields = fields.filter(function(x) {
						return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
					});
				}
				return fields;
			},
			updateLabel: function(label) {
				this.getPageInstance().setLabel("page." + this.cell.state.name, label);
			},
			update: function(value, label, rawValue) {
				if (this.cell.state.name) {
					var pageInstance = this.getPageInstance();
					var changed = false;
					// if we have a language toggled, we need different behavior
					if (this.language != null) {
						// only do something if we are translatable
						if (this.cell.state.translatable && this.translationArrayPath) {
							var self = this;
							var array = pageInstance.get(self.translationArrayPath);
							if (array == null) {
								array = [];
								pageInstance.set(self.translationArrayPath, array);
							}
							var name = this.cell.state.name.replace(/.*?\.([^.]+)$/, "$1");
							var current = array.filter(function(x) {
								return x.name == name && x.language == self.language;
							})[0];
							if (current == null) {
								// only add if we actually have a translation
								if (value != null) {
									current = {
										name: name,
										language: self.language,
										translation: null
									}
									array.push(current);
								}
							}
							changed = current.translation != value;
							current.translation = value;
						}
					}
					else {
						changed = value !== pageInstance.get("page." + this.cell.state.name);
						pageInstance.set("page." + this.cell.state.name, value, label);
						if (this.cell.state.rawName) {
							pageInstance.set("page." + this.cell.state.rawName, rawValue != null ? rawValue : value, label);
						}
					}
					// we only want to trigger updates if it actually changed
					// we've had cases where combo elements embedded in a repeat triggered the update of the repeat because the combo does an initial emit for labels etc
					// this may be too restrictive on the other hand because the raw value is not known at that point
					// but the raw value was wrongly mapped at the time of writing, making me assume we haven't really used it much
					if (changed) {
						this.notifyUpdate(value, label, rawValue);
					}
				}
				// computed fields do not have a name but are interested in the updates!
				else {
					this.notifyUpdate(value, label, rawValue);
				}
			},
			notifyUpdate: function(value, label, rawValue) {
				var self = this;
				var triggers = [];
				// Deprecated!
				if (self.cell.state.triggers) {
					nabu.utils.arrays.merge(triggers, self.cell.state.triggers);
				}
				// general cell triggers
				if (self.cell.triggers) {
					nabu.utils.arrays.merge(triggers, self.cell.triggers);
				}
				// because going this route actually disables the component while it is performing the update, it will remove focus
				// if used in combination with say a text field, you probably want to set a timeout on the text field
				if (triggers.length > 0) {
					if (self.cell.state.lockDuringTrigger) {
						this.running = true;
					}
					var done = function() {
						self.running = false;
					};
					// because the value might not have existed before, we need to give vue time to propagate the vue.set to everywhere
					// we had a race condition where often the update would trigger a form submit that would in turn trigger a validate
					// this validate failed because from that components perspective, the value had not yet arrived
					// if we incrementally increased a timeout to allow for propagation, the amount of failures went down
					Vue.nextTick(function() {
						// even waiting for the next tick is not enough to guarantee availability of data, but breaking out of that seems to do the trick...
						setTimeout(function() {
							self.$services.triggerable.trigger({triggers:triggers}, "update", {value:value, rawValue: rawValue}, self).then(done, done);
							// emit it so parent components (like repeat) can take action
							// we don't want to use the standard "input" to avoid accidental conflicts
							self.$emit("update", value, label, self.cell.state.name);
						}, 1);
					})
				}
				// when combined with triggers, it waits until the triggers are done
				// without triggers, we emit immediately
				else {
					self.$emit("update", value, label, self.cell.state.name);
				}
			},
			validate: function () {
				if (this.$refs && this.$refs.input) {
					return this.$refs.input.validate();
				}
			},
			blur: function() {
				if (this.cell.state.validateOnBlur) {
					this.validate();
				}
				this.$services.triggerable.trigger({triggers:this.cell.triggers}, "blur", {}, this);
			}
		}
	})
};

nabu.page.views.FormComponent = nabu.page.views.FormComponentGenerator("nabu-form-component");
nabu.page.views.FormComponentGenerator("nabu-form-component-configuration");




// I tried with the v-fragment directive at the root, because of how its rendered (v-route-render rather than <component> like repeat) it does not work correctly
// it works (sort of) if you put a :key at the root, but this key _must_ be rather volatile (e.G. math.random or an incremental counter)
// you also need to embed the key verbatim in the tpl file, you can NOT use for example a computed property (not sure why...)
// so this works:
// <div v-fragment :key="'page_' + pageInstanceId + '_cell_' + cell.id + '_nabu-form-dynamic-component_' + $window.nabu_form_dynamic_component_counter++">
// except that every time you type something, the whole instance will rerender, giving you the type-one-letter-focus-lost issue
// there are possibly even ways around that but currently I've opted to not use the fragment directive

var nabu_form_dynamic_component_counter = 0;
Vue.view("nabu-form-dynamic-component", {
	mixins: [Vue.component("data-mixin")],
	data: function() {
		return {
			localCounter: nabu_form_dynamic_component_counter++,
			// keep track of the values we removed
			// if they are added again, reuse the previous value
			// this is _necessary_ when the definitions for the actual keys arrive after we get the values
			// because we will first remove them, then re-add the keys
			// additionally if you change definitions a couple of times, you might need the same parameters from time to time
			removed: {},
			// the array we are working on
			array: null,
			updatingSelf: false
		}
	},
	props: {
		readOnly: {
			type: Boolean
		},
		disabled: {
			type: Boolean
		}
	},
	computed: {
		// the field we get the type from in the record
		typeField: function() {
			// TODO: allow configuration of this field
			return "type";
		},
		// the field we get the name from in the record
		nameField: function() {
			return "key";
		},
		labelField: function() {
			return "label";
		},
		// the field we write the key to
		targetKeyField: function() {
			return "key";
		},
		// the field we write the value to
		targetValueField: function() {
			return "value";
		},
		parentValue: function() {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			return pageInstance && this.cell.state.name ? pageInstance.get('page.' + this.cell.state.name) : null;
		}
	},
	methods: {
		getChildComponents: function() {
			return [{
				title: "Form container",
				name: "dynamic-field-container",
				component: "column"
			}];
		},
		postProcess: function(records) {
			var parentValue = this.getArray();
			var self = this;
			var existingKeys = [];
			records.forEach(function(x) {
				var name = x[self.nameField];
				// check that we have an entry for the given key
				var current = parentValue.filter(function(x) {
					return x[self.targetKeyField] == name;
				})[0];
				if (current == null) {
					current = {};
					current[self.targetKeyField] = name;
					current[self.targetValueField] = self.removed[name] == null ? null : self.removed[name];
					parentValue.push(current);
				}
				// set up a list of keys we want
				existingKeys.push(x[self.targetKeyField]);
			});
			// remove any keys we no longer want
			var toRemove = parentValue.filter(function(x) {
				return existingKeys.indexOf(x[self.targetKeyField]) < 0;
			});
			toRemove.forEach(function(x) {
				self.removed[x[self.targetKeyField]] = x[self.targetValueField];
				parentValue.splice(parentValue.indexOf(x), 1);
			});
			return records;
		},
		configurator: function() {
			return "nabu-form-dynamic-component-configure";
		},
		// the label to display, you can translate it but it won't get automatically picked up in translation engine
		getLabelFor: function(record) {
			var label = this.labelField;
			if (label == null) {
				label = this.nameField;
			}
			return this.$services.page.translate(record[label]);
		},
		getComponentFor: function(record) {
			var type = record[this.typeField];
			var name = record[this.nameField];
			if (this.cell.state.custom) {
				var custom = this.cell.state.custom.filter(function(x) {
					return x.component && x.name == type;
				})[0];
				if (custom) {
					var resolved = nabu.page.providers("page-form-input").filter(function(x) {
						return x.name == custom.component;	
					})[0];
					if (resolved) {
						return resolved.component;
					}
				}
			}
			if (type == "boolean") {
				return "page-form-input-checkbox";
			}
			else if (type == "date") {
				return "page-form-input-date";
			}
			else if (type == "string" && name && name.toLowerCase().indexOf("password") >= 0) {
				return "page-form-input-password";
			}
			else {
				return "page-form-input-text";
			}
		},
		getParametersFor: function(record) {
			var type = record[this.typeField];
			var name = record[this.nameField];
			if (this.cell.state.custom) {
				var custom = this.cell.state.custom.filter(function(x) {
					return x.name == type;
				})[0];
				if (custom) {
					return {state: custom.configuration};
				}
			}
			// stuff like mandatory, placeholder etc etc
			// because we want to emulate a cell, we use "state" to do it
			return {state: {}};
		},
		getTargetFor: function(record) {
			var name = record[this.nameField];
			var parentValue = this.getArray();
			var self = this;
			return parentValue.filter(function(x) {
				return x[self.targetKeyField] == name;
			})[0];
		},
		getValueFor: function(record) {
			var target = this.getTargetFor(record);
			return target ? target[this.targetValueField] : null;
		},
		update: function(record, value, label) {
			this.updatingSelf = true;
			var target = this.getTargetFor(record);
			Vue.set(target, this.targetValueField, value);
			//target[this.targetValueField] = value;
		},
		getArray: function(force) {
			if (!this.array || force) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				//return pageInstance && this.cell.state.name ? pageInstance.get('page.' + this.cell.state.name) : null;
				var parentValue = pageInstance && this.cell.state.name ? pageInstance.get('page.' + this.cell.state.name) : null; 
				if (parentValue == null) {
					if (this.cell.state.stringified) {
						parentValue = "{}";
						Vue.set(this, "array", []);
					}
					// we work directly on an array
					else {
						parentValue = [];
						Vue.set(this, "array", parentValue);
					}
					var pageInstance = this.$services.page.getPageInstance(this.page, this);
					if (pageInstance) {
						pageInstance.set("page." + this.cell.state.name, parentValue);
					}
				}
				else {
					if (this.cell.state.stringified) {
						var parsed = JSON.parse(parentValue);
						var array = [];
						Object.keys(parsed).forEach(function(key) {
							array.push({
								key: key,
								value: parsed[key]
							});
						})
						Vue.set(this, "array", array);
					}
					else {
						Vue.set(this, "array", parentValue);
					}
				}
			}
			return this.array;
		},
		getParentValue: function() {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			return pageInstance ? pageInstance.variables : null;
		}
	},
	watch: {
		"parentValue": function() {
			if (this.updatingSelf) {
				this.updatingSelf = false;
			}
			else {
				// reload the array
				this.getArray(true);
			}
		},
		"array": {
			deep: true,
			handler: function() {
				if (this.cell.state.stringified) {
					var result = {};
					this.array.forEach(function(entry) {
						if (entry.value != null) {
							result[entry.key] = entry.value;
						}
					});
					var pageInstance = this.$services.page.getPageInstance(this.page, this);
					if (pageInstance) {
						pageInstance.set("page." + this.cell.state.name, JSON.stringify(result, null, 2));
					}
				}
			}
		}
	}
})

Vue.component("nabu-form-dynamic-component-configure", {
	template: "#nabu-form-dynamic-component-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	created: function() {
		if (!this.cell.state.custom) {
			Vue.set(this.cell.state, "custom", []);
		}
	},
	methods: {
		getCustomConfiguration: function(custom) {
			var component = nabu.page.providers("page-form-input").filter(function(x) {
				return x.name == custom.component;	
			})[0];
			var result = component && component.configure ? component.configure : custom.component + "-configure";
			return Vue.component(result) ? result : null;
		},
		getAvailableComponents: function(value) {
			return nabu.page.providers("page-form-input").filter(function(x) {
				return !value || x.name.toLowerCase().indexOf(value.toLowerCase()) >= 0;
			});
		},
		availableFields: function(value) {
			if (this.cell.state.stringified) {
				var fields = [];
				var parameters = this.$services.page.getPageParameters(this.page);
				nabu.utils.arrays.merge(fields, this.$services.page.getSimpleKeysFor(parameters, true, true));
				//console.log("fields are", fields);
				fields.sort();
				if (value) {
					fields = fields.filter(function(x) {
						return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
					});
				}
				return fields;
			}
			else {
				var parameters = this.$services.page.getAllArrays(this.page);
				parameters.sort();
				if (value) {
					parameters = parameters.filter(function(x) {
						return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
					});
				}
			}
			return parameters;
		}
	}
})
if (!nabu) { var nabu = {} }
if (!nabu.page) { nabu.page = {} }
if (!nabu.page.views) { nabu.page.views = {} }

Vue.component("custom-validator-edit", {
	template: "#custom-validator-edit",
	props: {
		page: {
			type: Object,
			required: true
		},
		cell: {
			type: Object,
			required: true
		}
	},
	computed: {
		availableParameters: function() {
			return this.$services.page.getAvailableParameters(this.page, this.cell, true);
		}
	},
	methods: {
		getOperationParameters: function(operation, explode) {
			// could be an invalid operation?
			if (!this.$services.swagger.operations[operation]) {
				 return [];
			}
			var parameters = this.$services.swagger.operations[operation].parameters;
			if (explode) {
				return this.$services.page.getSwaggerParametersAsKeys(this.$services.swagger.operations[operation]);
			}
			else {
				return parameters ? parameters.map(function(x) { return x.name }) : [];
			}
		},
		getOperations: function(value) {
			var options = Object.keys(this.$services.swagger.operations);
			if (value) {
				options = options.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				})
			}
			return options;
		},
		addValidation: function () {
			if (!this.cell.state.validations) {
				Vue.set(this.cell.state, "validations", []);
			}
			this.cell.state.validations.push({
				label: null,
				code: "error",
				condition: null,
				message: null,
				bindings: {}
			});
		},
		deleteValidation: function (validation) {
			this.cell.state.validations.splice(this.cell.state.validations.indexOf(validation),1);
		}
	}
});

Vue.view("custom-validator", {
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		},
		data: {
			required: false
		},
		shouldStyle: {
			type: Boolean,
			required: false,
			default: true
		},
		label: {
			type: Boolean,
			required: false,
			default: null
		},
		localState: {
			type: Object,
			required: false
		},
		fieldsName: {
			type: String,
			required: false,
			default: "fields"
		}
	},
	data: function() {
		return {
			configuring: false,
			messages: [],
			subscriptions: []
		}
	},
	created: function() {
		var self = this;
		var pageInstance = self.$services.page.getPageInstance(self.page, self);
		if (this.cell.state.validations) {
			this.cell.state.validations.forEach(function(validation) {
				if (validation.resetListeners) {
					validation.resetListeners.forEach(function(x) {
						console.log("subscribing to ", x);
						self.subscriptions.push(pageInstance.subscribe(x.to, function() {
							self.messages.splice(0);
						}));
					});	
				}
			});
		}
	},
	beforeDestroy: function() {
		this.subscriptions.map(function(x) {
			x();
		});
	},
	methods: {
		getEvents: function() {
			var self = this;
			var events = {};
			if (this.cell.state.validations) {
				this.cell.state.validations.forEach(function(validation) {
					if (validation.operationId && validation.operationSuccessEvent) {
						var response = self.$services.swagger.operations[validation.operationId].responses["200"];
						var schema = null;
						if (response && response.schema) {
							schema = self.$services.swagger.resolve(response.schema);
						}
						events[validation.operationSuccessEvent] = schema ? schema : {};
					}
				});
			}
			return events;
		},
		configurator: function() {
			return "custom-validator-edit";
		},
		validate: function(soft) {
			Vue.set(this, "messages", []);
			nabu.utils.schema.addAsyncValidation(this.messages);
			
			if (this.cell.state.validations) {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				var pageState = this.$services.page.getPageState(pageInstance);
				
				this.cell.state.validations.forEach(function (validation) {
					// if we want to call an operation, we want an async validation
					if (validation.operationId != null) {
						var promise = self.$services.q.defer();
						// link the promise to the messages
						self.messages.defer(promise);
						var parameters = {};
						Object.keys(validation.bindings).map(function(key) {
							self.$services.page.setValue(parameters, key, self.$services.page.getBindingValue(pageInstance, validation.bindings[key], self));
						});
						self.$services.swagger.execute(validation.operationId, parameters).then(function(x) {
							var validations = [];
							if (x) {
								// emit it
								if (validation.operationSuccessEvent) {
									pageInstance.emit(validation.operationSuccessEvent, x);
								}
								Object.keys(x).forEach(function(key) {
									// if we have an array, check if we have validations, we need at least a severity!
									if (x[key] instanceof Array && x[key].length > 0 && validations.length == 0) {
										// if we have a severity, we assume these are validation messages
										if (x[key][0].severity) {
											nabu.utils.arrays.merge(validations, x[key]);
										}
									}
								});
							}
							// if we have a condition, evaluate that, including the state from the call
							if (validation.condition) {
								// we set this as "response"
								pageState.response = x;
								if (self.$services.page.isCondition(validation.condition, pageState, self)) {
									validations.push({
										severity: "error",
										code: validation.code ? validation.code : "custom",
										title: validation.message ? self.$services.page.translate(validation.message) : "%{An error has occured}",
										priority: 1,
										variables: {
										},
										context: []
									});
								}
							}
							if (validation.codes) {
								var translatedCodes = validation.codes.map(function(x) {
									return {
										code: x.code,
										title: self.$services.page.translate(x.title)
									}
								});
								nabu.utils.vue.form.rewriteCodes(validations, translatedCodes);
							}
							promise.resolve(validations);
						}, promise);
					}
					// synchronous validation
					else if (validation.condition) {
						if (self.$services.page.isCondition(validation.condition, pageState, self)) {
							self.messages.push({
								severity: "error",
								code: validation.code ? validation.code : "custom",
								title: validation.message ? self.$services.page.translate(validation.message) : "%{An error has occured}",
								priority: 1,
								variables: {
								},
								context: []
							});
						}
					}
				});
			}
			
			return this.messages;
		}		
	}
});
Vue.view("default-offline", {
	alias: "offline",
	priority: -50,
	url: "/offline",
	props: {
		message: {
			type: String,
			default: "%{Sorry, we're down for scheduled maintenance right now.}"
		},
		recover: {
			type: String,
			default: "%{You can&nbsp;<a class='is-color-link' href='javascript:void()' @click='location.reload()'>retry</a>.}"
		}
	}
});
if (!nabu) { var nabu = {} }
if (!nabu.page) { nabu.page = {} }
if (!nabu.page.views) { nabu.page.views = {} }

Vue.view("typography-richtext", {
	template: "#typography-richtext",
	icon: "modules/richtext/logo.svg",
	description: "The rich text component can be used to write static texts with markup",
	name: "Rich Text",
	category: "Typography",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	created: function() {
		console.log("editing?", this.edit);
		if (this.edit && !this.cell.state.content) {
			Vue.set(this.cell.state, "content", "");
		}	
	},
	methods: {
		configurator: function() {
			return "typography-richtext-configure";
		},
		update: function(content) {
			if (this.timer) {
				clearTimeout(this.timer);
				this.timer = null;
			}
			var self = this;
			this.timer = setTimeout(function() {
				self.cell.state.content = nabu.utils.elements.sanitize(content);
			}, 100);
		}
	}
});

Vue.view("typography-richtext-configure", {
	template: "#typography-richtext-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	}
});


if (!nabu) { var nabu = {} }
if (!nabu.page) { nabu.page = {} }
if (!nabu.page.views) { nabu.page.views = {} }

nabu.page.views.Code = Vue.extend({
	template: "#page-code",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		},
		localState: {
			type: Object,
			required: false
		}
	},
	created: function() {
		this.normalize(this.cell.state);
	},
	data: function() {
		return {
			configuring: false,
			state: {}
		}
	},
	methods: {
		configure: function() {
			this.configuring = true;	
		},
		normalize: function(state) {
			if (!state.content) {
				Vue.set(state, "content", null);
			}
		},
		highlight: function(content) {
			var highlighter = nabu.page.providers("page-format").filter(function(x) {
				 return x.name == "highlight";
			})[0];
			return highlighter ? highlighter.format(content) : content;
		}
	}
})
Vue.view("nabu-console", {
	props: {
		initialTab: {
			type: String,
			default: "features"
		}	
	},
	data: function() {
		return {
			selected: null,
			search: null,
			tab: "features"
		}
	},
	computed: {
		enabledFeatures: function() {
			var self = this;
			return this.$services.page.availableFeatures.filter(function(x) {
				return self.$services.page.enabledFeatures.indexOf(x.name) >= 0;
			});
		},
		disabledFeatures: function() {
			var self = this;
			return this.$services.page.availableFeatures.filter(function(x) {
				return self.$services.page.enabledFeatures.indexOf(x.name) < 0;
			});
		},
		cleanedUpContent: function() {
			if (!this.$services.page.inspectContent) {
				return "No content to inspect";
			}
			else {
				var depth = 0;
				var content = this.$services.page.inspectContent;
				// remove comments
				content = content.replace(/(<!---->)/g, "");
				var index = content.lastIndexOf("<");
				while (index >= 0) {
					var isClosing = content.substring(index + 1, index + 2) == "/";
					if (!isClosing) {
						depth--;
					}
					var whitespace = "";
					for (var i = 0; i < depth; i++) {
						whitespace += "\t";
					}
					content = content.substring(0, index) + whitespace + "&lt;" + content.substring(index + 1);
					// closing tag
					// because we loop in reverse, we need to do depth the other way around
					if (isClosing) {
						depth++;
					}
					index = content.lastIndexOf("<");
				}
				// if we have a tag that contains no other tags, we don't do a linefeed
				content = content.replace(/(&lt;[^/>]*)>[\s]*([^>]+?)[\s]*(&lt;\/)/g, "$1&gt;$2$3");
				content = content.replace(/>/g, "&gt;\n");
				// highlighting
				content = content.replace(/(&lt;.*?&gt;)/g, "<span class='console-highlight-tag'>$1</span>");
				return content;
			}
		}
	},
	created: function() {
		this.tab = this.initialTab;
	},
	methods: {
		isHidden: function(report) {
			if (!this.search) {
				return false;
			}
			else {
				var self = this;
				var matches = function(string) {
					return string && string.toLowerCase().match(new RegExp(self.search.replace("*", ".*"), "mi"));
				}
				var match = matches(report.source)
					|| matches(report.type)
					|| matches(JSON.stringify(report.properties));
				return !match;
			}
		},
		resetFeatures: function() {
			// we update the enabled features array in page builder
			this.$services.page.enabledFeatures.splice(0);
			// remerge the standard enabled features
			nabu.utils.arrays.merge(
				this.$services.page.enabledFeatures, 
				this.$services.page.availableFeatures.filter(function(x) { return x.enabled }).map(function(x) { return x.name })
			);
			// clean up the toggled features
			this.$services.page.toggledFeatures.splice(0);
			if (this.$services.swagger.toggledFeatures) {
				this.$services.swagger.toggledFeatures.splice(0);	
			}
		},
		enableFeature: function(feature) {
			// we need to check if it is enabled by default
			var available = this.$services.page.availableFeatures.filter(function(x) { return x.name == feature.name })[0];
			var toggled = this.$services.page.toggledFeatures.filter(function(x) { return x.name == feature.name })[0];
			// remove any toggled features
			if (toggled) {
				this.$services.page.toggledFeatures.splice(this.$services.page.toggledFeatures.indexOf(toggled), 1);
			}
			// make sure it is in the list of enabled features
			this.$services.page.enabledFeatures.push(available.name);
			// we only need to do something special (add it to toggled) if it is not enabled by default
			if (available && !available.enabled) {
				this.$services.page.toggledFeatures.push({
					name: feature.name,
					description: feature.description,
					enabled: true
				});
			}
			// synchronize swagger
			if (this.$services.swagger.toggledFeatures) {
				this.$services.swagger.toggledFeatures.splice(0);
				nabu.utils.arrays.merge(this.$services.swagger.toggledFeatures, this.$services.page.toggledFeatures);
			}
		},
		disableFeature: function(feature) {
			// we need to check if it is enabled by default
			var available = this.$services.page.availableFeatures.filter(function(x) { return x.name == feature.name })[0];
			var toggled = this.$services.page.toggledFeatures.filter(function(x) { return x.name == feature.name })[0];
			// remove any toggled features
			if (toggled) {
				this.$services.page.toggledFeatures.splice(this.$services.page.toggledFeatures.indexOf(toggled), 1);
			}
			var index = this.$services.page.enabledFeatures.indexOf(available.name);
			if (index >= 0) {
				this.$services.page.enabledFeatures.splice(index, 1);
			}
			// we only need to do something special (add it to toggled) if it is not enabled by default
			if (available && available.enabled) {
				this.$services.page.toggledFeatures.push({
					name: feature.name,
					description: feature.description,
					enabled: false
				});
			}
			// synchronize swagger
			if (this.$services.swagger.toggledFeatures) {
				this.$services.swagger.toggledFeatures.splice(0);
				nabu.utils.arrays.merge(this.$services.swagger.toggledFeatures, this.$services.page.toggledFeatures);
			}
		}
	}
});
Vue.view("page-video", {
	category: "Content",
	name: "Video",
	description: "Add a video",
	icon: "page/core/images/image.svg",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		},
		href: {
			type: String,
			required: false
		}
	},
	activate: function(done) {
		var self = this;
		var promises = [];
		if (this.edit) {
			promises.push(this.load());
		}
		if (this.cell.state.inline && (this.cell.state.href || this.href)) {
			var self = this;
			var href = this.cell.state.href ? this.cell.state.href : this.href;
			// if not absolute, make it so
			if (href.indexOf("http://") != 0 && href.indexOf("https://") != 0 && href.indexOf("/") != 0) {
				href = "/" + href;
			}
			nabu.utils.ajax({ url: href }).then(function(response) {
				self.inlineContent = response.responseText;
			});
		}
		this.$services.q.all(promises).then(done, done);
	},
	created: function() {
		this.normalize(this.cell.state);
	},
	data: function() {
		return {
			configuring: false,
			images: [],
			files: [],
			inlineContent: null
		}
	},
	computed: {
		fullHref: function() {
			var href = null;
			if (this.href) {
				href = this.href;
			}
			else if (this.cell.state.href) {
				href = this.cell.state.href;
			}
			// if the href is not an absolute one (either globally absolute or application absolute), we inject the server root
			if (href && href.substring(0, 7) != "http://" && href.substring(0, 8) != "https://" && href.substring(0, 1) != "/") {
				href = "/" + href;
			}
			if (href && href.substring(0, 7) != "http://" && href.substring(0, 8) != "https://" && this.cell.state.absolute) {
				href = "${environment('url')}" + href;
			}
			// on mobile we don't want absolute paths starting with "/", otherwise it won't fetch from the file system
			else if (href && href.substring(0, 7) != "http://" && href.substring(0, 8) != "https://" && false && href.indexOf("/") == 0) {
				href = href.substring(1);
			}
			return href;
		}
	},
	methods: {
		load: function() {
			var self = this;
			return this.$services.swagger.execute("nabu.web.page.core.rest.resource.list", {path:this.cell.state.videoPath}).then(function(list) {
				self.images.splice(0, self.images.length);
				if (list && list.resources) {
					nabu.utils.arrays.merge(self.images, list.resources);
				}
			});
		},
		upload: function() {
			var self = this;
			this.$services.swagger.execute("nabu.web.page.core.rest.resource.create", { path:this.cell.state.videoPath, body: this.files[0] }).then(function(result) {
				self.load();
				if (result && result.relativePath) {
					self.cell.state.href = result.relativePath;
				}
				self.files.splice(0, self.files.length);
			});
		},
		configure: function() {
			this.configuring = true;	
		},
		normalize: function(state) {
			if (!state.href) {
				Vue.set(state, "href", null);
			}
			if (!state.title) {
				Vue.set(state, "title", null);
			}
			if (!state.height) {
				Vue.set(state, "height", "15rem");
			}
			if (!state.videoPath) {
				Vue.set(state, "videoPath", 'videos');
			}
		}
	},
	watch: {
		'cell.state.videoPath': function() {
			this.load();
		}
	}
})
if (!nabu) { var nabu = {} }
if (!nabu.page) { nabu.page = {} }
if (!nabu.page.views) { nabu.page.views = {} }

nabu.page.views.Youtube = Vue.extend({
	template: "#page-youtube",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		},
		localState: {
			type: Object,
			required: false
		}
	},
	data: function() {
		return {
			configuring: false
		}
	},
	created: function() {
		var self = this;
		// this monitor allows us to check whether you have activated the iframe and are thus presumably watching the video
		var monitor = setInterval(function(){
			var element = document.activeElement;
			if (element && element == self.$refs.iframe) {
				clearInterval(monitor);
				self.analyze();
			}
		}, 100);
	},
	computed: {
		url: function() {
			if (this.cell.state.url) {
				// examples:
				// main site: https://www.youtube.com/watch?v=bmLCj8Qba-M&t=553s
				// shorter: https://youtu.be/o0nar1v3jmU
				// already embedded: https://www.youtube.com/embed/bmLCj8Qba-M
				var url = this.cell.state.url;
				var code = null;
				if (url.match(/\\?v=/)) {
					code = url.replace(/^.*\\?v=([^&]+).*/, "$1");
				}
				else if (url.match(/.*youtu\.be/)) {
					code = url.replace(/^.*youtu\.be\/(.*)+/, "$1");
				}
				if (code != null) {
					url = "https://www.youtube.com/embed/" + code;
				}
				if (this.cell.state.hideControls) {
					url += "?controls=0";
				}
				return url;
			}
			return null;
		}	
	},
	methods: {
		configure: function() {
			this.configuring = true;	
		},
		analyze: function() {
			this.$services.analysis.push({
				pageName: this.page.content.name,
				pageCategory: this.page.content.category,
				category: "media",
				type: "media-view",
				event: "youtube",
				url: this.url
			});
			// DEPRECATED
			if (this.$services.analysis && this.$services.analysis.emit) {
				this.$services.analysis.emit("watch-youtube", this.url, null, true);
			}
		}
	}
})
Vue.view("page-share-social", {
	props: {
		page: {
			type: Object,
			required: true
		},
		cell: {
			type: Object,
			required: true
		}
	},
	data: function() {
		return {
			configuring: false
		}
	},
	methods: {
		configure: function() {
			if (!this.cell.state.share) {
				Vue.set(this.cell.state, "share", []);
			}
			this.configuring = true;	
		},
		analyze: function(provider) {
			this.$services.analysis.push({
				pageName: this.page.content.name,
				pageCategory: this.page.content.category,
				category: "social",
				type: "social-share",
				event: provider
			});
			// DEPRECATED
			if (this.$services.analysis && this.$services.analysis.emit) {
				this.$services.analysis.emit("share-" + provider, {url:window.location}, null, true);
			}
		},
		generateLink: function(provider) {
			var url = null;
			if (this.cell.state.link) {
				// if we have an absolute link, just use that
				if (this.cell.state.link.indexOf("http:") == 0 || this.cell.state.link.indexOf("https:") == 0) {
					url = encodeURIComponent(this.cell.state.link);
				}
				// if we have an absolute path, add the host etc
				else if (this.cell.state.link.indexOf("/") == 0) {
					url = encodeURIComponent(window.location.protocol + "//" + window.location.host + this.cell.state.link);
				}
				// relative path? we assume relative to the web root...
				else {
					url = encodeURIComponent(window.location.protocol + "//" + window.location.host + "/" + this.cell.state.link);
				}
			}
			else {
				url = encodeURIComponent(window.location);
			}
			var title = null;
			var summary = null;
			var source = null;
			var tags = [];
			var result = null;
			if (provider == "facebook") {
				result = "https://www.facebook.com/sharer/sharer.php?u=" + url;
			}
			else if (provider == "twitter") {
				result = "http://twitter.com/share?url=" + url;
				if (title != null) {
					result += "&text=" + title;
				}
				if (tags != null && tags.length) {
					result += "&hashtags=" + tags.join(",");
				}
			}
			else if (provider == "google-plus") {
				result = "https://plus.google.com/share?url=" + url;
			}
			else if (provider == "linkedin") {
				result = "https://www.linkedin.com/shareArticle?mini=true&url=" + url;
				if (title != null) {
					result += "&&title=" + title;
				}
				if (summary != null) {
					result += "&summary=" + summary;
				}
				if (source != null) {
					result += "&source=" + source;
				}
			}
			else if (provider == "email") {
				result = "mailto:?subject=" + (title ? title : url);
				if (title) {
					result += "&body=" + url;
				}
			}
			else if (provider == "pinterest") {
				result = "https://pinterest.com/pin/create/button/?url=" + url;
				if (title != null) {
					result += "&description=" + title;
				}
			}
			return result;
		}
	}
});
if (!nabu) { var nabu = {} }
if (!nabu.page) { nabu.page = {} }
if (!nabu.page.views) { nabu.page.views = {} }

nabu.page.views.PageAddCell = Vue.extend({
	template: "#page-add-cell",
	props: {
		page: {
			type: Object,
			required: true
		}
	},
	data: function() {
		return {
			route: null,
			bindings: {},
			target: 'page',
			on: null
		}
	},
	computed: {
		availableEvents: function() {
			var available = nabu.utils.objects.clone(this.$services.page.instances[this.page.name].getEvents());
			return Object.keys(available);
		},
		parameters: function() {
			return this.route ? this.$services.page.getRouteParameters(this.route) : [];
		},
		availableParameters: function() {
			// there are all the events
			var available = nabu.utils.objects.clone(this.$services.page.instances[this.page.name].getEvents());
			var result = {};
			if (this.on) {
				result[this.on] = available[this.on];
			}
			// and the page
			result.page = this.$services.page.getPageParameters(this.page);
			return result;
		}
	},
	methods: {
		filterRoutes: function(value) {
			var routes = this.$services.router.list().filter(function(x) {
				return x.alias && (!value || x.alias.toLowerCase().indexOf(value.toLowerCase()) >= 0);
			});
			routes.sort(function(a, b) {
				return a.alias.localeCompare(b.alias);
			});
			return routes;
		},
		set: function() {
			this.$resolve({
				alias: this.route.alias,
				bindings: this.bindings,
				target: this.on ? this.target : 'page',
				on: this.on
			})
		}
	}
})
Vue.view("page-components-selector", {
	props: {
		// the list of routes that we want to choose from
		components: {
			type: Array,
			required: true
		}
	}
});

Vue.component("page-components-overview", {
	template: "#page-components-overview",
	computed: {
		// should all structures have a row at the root?
		structures: function() {
			return nabu.page.providers("page-structure");
		},
		components: function() {
			// only keep the routes with a visual icon and a name
			var all = this.$services.router.router.routes.filter(function(x) {
				return x.icon && x.name;
			});
			// combine routes and templates
			nabu.utils.arrays.merge(all, this.$services.page.templates);
			return all;
		},
		componentCategories: function() {
			var groups = [];
			this.components.forEach(function(x) {
				if (x.category && groups.indexOf(x.category) < 0) {
					groups.push(x.category);
				}
				else if (x.category == null && groups.indexOf("Miscellaneous") < 0) {
					groups.push("Miscellaneous");
				}
			});
			groups.sort(function(a, b) {
				return a.toLowerCase().localeCompare(b.toLowerCase());
			});
			return groups;
		},
		templateCategories: function() {
			var groups = [];
			this.$services.page.templates.forEach(function(x) {
				if (x.category && groups.indexOf(x.category) < 0) {
					groups.push(x.category);
				}
				else if (x.category == null && groups.indexOf("Miscellaneous") < 0) {
					groups.push("Miscellaneous");
				}
			});
			groups.sort(function(a, b) {
				return a.toLowerCase().localeCompare(b.toLowerCase());
			});
			return groups;
		}
	},
	data: function() {
		return {
			selected: 'components',
			operationSearch: null,
			templateSearch: null,
			componentSearch: null
		}
	},
	methods: {
		hasAnyOperationMatch: function(category, operation) {
			if (!this.operationSearch) {
				return true;
			}
			var operations = [];
			if (operation) {
				operations.push(operation.id);
			}
			else {
				nabu.utils.arrays.merge(operations, this.getOperationCategory(category).map(function(x) {
					return x.id;
				}));
			}
			var regex = new RegExp(this.operationSearch.toLowerCase().replace(/[\s]+/g, ".*"));
			var matches = operations.filter(function(x) {
				return !!x.toLowerCase().match(regex);
			});
			return matches.length > 0;
		},
		getOperationIds: function() {
			return Object.keys(this.$services.swagger.operations)
				.filter(function(x) {
					return x.indexOf("nabu.cms.dynamic.") < 0
						&& x.indexOf("nabu.web.page.") < 0
						&& x.indexOf("nabu.page.") < 0
						&& x != "nabu.passwordProtect";
				})
		},
		getOperationCategories: function() {
			var self = this;
			var tags = [];
			this.getOperationIds().forEach(function(operationId) {
				var operation = self.$services.swagger.operations[operationId];
				if (operation && operation.tags) {
					operation.tags.forEach(function(tag) {
						if (tags.indexOf(tag) < 0) {
							tags.push(tag);
						}	
					});
				}
			});
			tags.sort();
			return tags;
		},
		getOperationCategory: function(category) {
			var self = this;
			var operations = [];
			this.getOperationIds().forEach(function(operationId) {
				var operation = self.$services.swagger.operations[operationId];
				if (operation && operation.tags && operation.tags.indexOf(category) >= 0) {
					operations.push(operation);
				}
			});
			return operations;
		},
		dragOperation: function(event, operation) {
			this.$services.page.setDragData(event, "operation", operation.id);
		},
		prettyPrintOperation: function(id) {
			return this.$services.page.prettify(id.replace(/.*\.([^.]+)\.([^.]+)$/, "$2"));
		},
		operationFolder: function(id) {
			return id.replace(/(.*)\.[^.]+$/, "$1");
		},
		getTemplateCategory: function(category) {
			return this.$services.page.templates.filter(function(x) {
				return x.category == category || (category == "Miscellaneous" && x.category == null);
			});
		},
		getComponentCategory: function(category) {
			return this.components.filter(function(x) {
				return x.category == category || (category == "Miscellaneous" && x.category == null);
			});
		},
		dragComponent: function(event, component) {
			// you're actually dragging a template, we have unified these two
			if (!component.alias && component.content) {
				this.dragTemplate(event, component);
			}
			else {
				this.$services.page.setDragData(event, "component-alias", component.alias);
				if (component.form) {
					this.$services.page.setDragData(event, "form-name", component.form);
				}
			}
		},
		dragTemplate: function(event, template) {
			// the content is already stringified at this point
			this.$services.page.setDragData(event, "template-content", template.content);
		},
		prettyPrint: function(name) {
			name = name.replace(/([A-Z]+)/, " $1");
			return name.substring(0, 1).toUpperCase() + name.substring(1);
		}
	}
});
if (!nabu) { var nabu = {} }
if (!nabu.page) { nabu.page = {} }
if (!nabu.page.views) { nabu.page.views = {} }
if (!nabu.page.mixins) { nabu.page.mixins = {} }

Vue.component("shortkey", {
	template: "#page-shortkey",
	props: {
		ctrl: {
			type: Boolean,
			default: false
		},
		alt: {
			type: Boolean,
			default: false
		}
	}
});

// on created, we want to inject the state of the page into this component so we can access all the data
Vue.mixin({
	props: {
		localState: {
			type: Object,
			required: false
		},
		pageInstanceId: {
			type: Number,
			required: false
		}
	},
	data: function() {
		return {
//			state: {},
			runtimeId: null
		}
	},
	// not ideal, can it be replaced everywhere liwith $services.page.getBindingValue() ?
/*	beforeMount: function() {
		var self = this;
		// map any local state

		if (this.localState) {
			Object.keys(this.localState).map(function(key) {
				Vue.set(self.state, key, self.localState[key]);
			});
		}
		if (this.page) {
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			// when creating the actual page, we do not have an instance yet!
			// nor is it important...
			if (pageInstance) {
				Object.keys(pageInstance.variables).map(function(key) {
					if (typeof(self.state[key]) == "undefined") {
						Vue.set(self.state, key, pageInstance.variables[key]);
					}
				})
				var page = this.$services.page.getPageParameterValues(this.page, pageInstance);
				if (Object.keys(page).length) {
					Vue.set(self.state, "page", page);
				}
			}
			var application = {};
			if (this.$services.page.title) {
				application.title = this.$services.page.title;
			}
			this.$services.page.properties.map(function(x) {
				if (x) {
					application[x.key] = x.value;
				}
			});
			Vue.set(self.state, "application", application);
		}
	},*/
	computed: {
		$self: function() {
			return this;
		}	
	},
	beforeDestroy: function() {
		var target = this.$$target;
		if (!target) {
			target = this.$$cell;
		}
		if (target && target.triggers) {
			// untrigger everything when we get destroyed!
			this.$services.triggerable.untrigger(target, null, this);
		}
		if (target && target.state && target.state.triggers) {
			this.$services.triggerable.untrigger(target.state, null, this);
		}
	},
	methods: {
		// your component may be in a state, that state may (or may not) be inherited
		// for instance if you collapse a menu, we add a state "collapsed" to all the components within so they can adjust their styling
		// those states are targeted by adding adding styling wth the original name of the component and ":state" after it, for example "page-button:collapsed"
		getPotentialStates: function() {
			return this.$parent ? this.$parent.getPotentialStates() : [];
		},
		// the actually applied states
		// how they are applied is component specific
		getCurrentStates: function() {
			return this.$parent ? this.$parent.getCurrentStates() : [];
		},
		// expects a prop with name "childComponents"
		getChildComponentClasses: function(name) {
			var classes = [];
			if (this.childComponents && this.childComponents[name] && this.childComponents[name].classes) {
				nabu.utils.arrays.merge(classes, this.childComponents[name].classes);
			}
			var self = this;
			this.getCurrentStates().forEach(function(state) {
				// not used yet but if we want to add "dynamic" styling in the frontend for different states, it could look like this
				var stateName = name + "--" + state;
				if (self.childComponents && self.childComponents[stateName] && self.childComponents[stateName].classes) {
					nabu.utils.arrays.merge(classes, self.childComponents[stateName].classes);
				}
				
				// inject the state as a modifier
				// it currently collides with modifiers but this is (currently) intentional
				// this allows you to write a state as both an implicitly applied state or a modifier that can also be toggled
				// if this proves to be annoying we can update aris generation and page builder at the same time without breaking anything
				// if it does work we could prevent accidental naming collisions between modifiers and states by always targeting the variant of the modifier much like with states:
				// .is-table:where(.is-full-width)
				classes.push("is-" + state);
			});
			return classes;
		},
		// recalculate events on the page instance (if applicable)
		$updateEvents: function() {
			if (this.page) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				if (pageInstance) {
					pageInstance.resetEvents();
				}
			}
		},
		// check if the component is in a certain state
		$is: function(state) {
			return this.getCurrentStates().indexOf(state) >= 0;	
		},
		$value: function(path, literal) {
			if (!literal) {
				literal = application && application.configuration && 
					(application.configuration.interpretValues == null || application.configuration.interpretValues == false);
			}
			var result = null;
			if (this.page) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				result = this.$services.page.getBindingValue(pageInstance, path);
			}
			else {
				if (path.indexOf("application.") == 0) {
					var property = this.$services.page.properties.filter(function(x) {
						return x.key == path.substring("application.".length);
					})[0];
					result = property ? property.value : null;
				}
			}
			return literal ? result : this.$services.page.parseValue(result);
		}
	}
});

nabu.page.mixins.renderer = {
	created: function() {
		var pageInstance = this.$services.page.getPageInstance(this.page, this);
		pageInstance.mountRenderer(this.target, this);
	}	
};

// methods in cell instances:
// - configure: start configuration for the cell content
// - getEvents: return event definitions
// - getLocalState: return the state definition for this level (e.g. because of for loop or variable scoping)
nabu.page.views.Page = Vue.component("n-page", {
	template: "#nabu-page",
	props: {
		// especially for page fragments, we can link a parent page
		// in a lot of cases, the fragment page needs the parent page for some additional resolving (e.g. state, components...)
		fragmentParent: {
			type: Object,
			required: false
		},
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false,
			default: function() { return {} }
		},
		embedded: {
			type: Boolean,
			required: false
		},
		editable: {
			type: Boolean,
			required: false
		},
		masked: {
			typed: Boolean,
			required: false
		},
		stopRerender: {
			type: Boolean,
			required: false,
			default: false
		},
		pageInstanceId: {
			required: false,
			default: function() {
				return application.services.page.pageCounter++;
			}
		},
		recordIndex: {
			type: Number
		},
		// a custom setter used to set values
		$setValue: {
			type: Function,
			required: false
		}
	},
	activate: function(done) {
		// the page has a path, set it in the body so we can do additional stuff
		// in the beginning we set this in the ready hook, however if you have a slow loading page it would only get set after the slow thingy ended
		// however in the mean time your (presumably synchronous) skeletons have already loaded and perhaps even showing a nice loading icon but on the "old" background styling
		if (this.page.content.path)	{
			document.body.setAttribute("page", this.page.name);
			document.body.setAttribute("category", this.page.content.category);
			document.body.setAttribute("page-type", this.page.content.pageType ? this.page.content.pageType : "page");
		}
		
		var self = this;
		var finalize = function() {
			self.oldTitle = document.title;
			document.title = self.$services.page.templateTitle(self.page);
			// we now do this on the ready hook, assuming any async data is available
			/*
			if (self.page.content.branding) {
				// don't copy it by reference, it will be updated...
				self.oldBranding = nabu.utils.objects.deepClone(self.$services.page.currentBranding);
				self.$services.page.updateBranding(self.page.content.branding);
			}
			*/
			if (self.page.content.autoRefresh) {
				self.autoRefreshTimeout = setTimeout(function() {
					if (!self.edit && !self.$services.page.wantEdit) {
						var target = nabu.utils.router.self(self.$el);
						//window.history.go(0);
						self.$services.router.route(self.$services.page.alias(self.page), self.parameters, target);
					}
				}, parseInt(self.page.content.autoRefresh));
			}
			self.initializeDefaultParameters();
			if (self.page.content.initialEvents) {
				self.page.content.initialEvents.forEach(function(x) {
					self.fireInitialEvent(x);
				});
			}
			if (self.page.content.parameters) {
				self.page.content.parameters.forEach(function(parameter) {
					if (parameter.name != null && parameter.defaults && parameter.defaults.length) {
						parameter.defaults.forEach(function(defaultValue) {
							if (defaultValue.query && defaultValue.value) {
								var currentValue = self.$services.page.getValue(self.variables[parameter.name], defaultValue.query);
								if (currentValue == null) {
									if (self.variables[parameter.name] == null) {
										Vue.set(self.variables, parameter.name, {});
									}
									var result = self.$services.page.parseValue(self.$services.page.translate(self.$services.page.interpret(defaultValue.value, self)));               
									self.$services.page.setValue(self.variables[parameter.name], defaultValue.query, result);
								}
							}
						});
					}	
				});
			}
		
			self.registerStateListeners();
			done();
		};
		if (this.page.content.states.length) {
			var sendStateEvent = function(state) {
				if (nabu.page.event.getName(state, "updateEvent")) {
					self.emit(
						nabu.page.event.getName(state, "updateEvent"),
						nabu.page.event.getInstance(state, "updateEvent", self.page, self)
					);
				}
			}
			// inherit the state from the application
			this.page.content.states.filter(function(state) { return !!state.name && state.inherited }).forEach(function(state) {
				// clone it so they don't have the same references! otherwise the array merges might be weird (splice and merge on same array...)
				Vue.set(self.variables, state.name, nabu.utils.objects.clone(self.$services.page.variables[state.applicationName]));
				// you want to send out the event if _anyone_ updates it, not just you
				self.$watch("$services.page.variables." + state.applicationName, function(newValue) {
					// update local variable as well, otherwise changes won't be seen
					if (self.variables[state.name]) {
						self.$services.page.mergeObject(self.variables[state.name], newValue); // self.$services.page.variables[state.applicationName]
					}
					// first set?
					else {
						Vue.set(self.variables, state.name, newValue);
					}
					sendStateEvent(state);
				}, {deep:false});
			});
			this.page.content.states.filter(function(state) { return !!state.name && !state.inherited && state.enableParameterWatching }).forEach(function(state) {
				var timeout = null;
				Object.keys(state.bindings).map(function(key) {
					var binding = state.bindings[key];
					if (binding && binding.indexOf("parent.") != 0) {
						if (binding.indexOf("page.") == 0) {
							binding = binding.substring("page.".length);
						}
						self.$watch("variables." + binding, function() {
							if (timeout != null) {
								clearTimeout(timeout);
								timeout = null;
							}
							// allow some time to stabilize in case of multiple changes or multiple triggers
							timeout = setTimeout(function() {
								self.loadInitialState(state, true);
							}, 100);
						});
					}
				});
			});
			
			// first we make empty promises! that way we can let state interdepend on one another and resolve eventually
			var promiseMap = {};
			this.page.content.states.filter(function(state) { 
				// it must have a name and not be inherited
				return !!state.name && !state.inherited
					&& (!state.condition || self.$services.page.isCondition(state.condition, self.variables, self));
			}).forEach(function(state) {
				promiseMap[state.name] = self.$services.q.defer();	
			});
			var promises = this.page.content.states.filter(function(state) { 
				// it must have a name and not be inherited
				return !!state.name && !state.inherited
					&& (!state.condition || self.$services.page.isCondition(state.condition, self.variables, self));
			}).map(function(state) {
				var promise = promiseMap[state.name];
				
				// we have dependencies on other promises before we can resolve
				// for instance you might want to chain rest invokes
				var promisesToWaitFor = [];
				Object.keys(state.bindings).map(function(key) {
					//parameters[key] = self.get(state.bindings[key]);
					if (state.bindings[key] != null) {
						// if we have a dependency to page-related information at this point, we may need to wait for promises
						if (state.bindings[key].indexOf("page.") == 0) {
							Object.keys(promiseMap).forEach(function(promiseKey) {
								if (state.bindings[key].indexOf("page." + promiseKey + ".") == 0) {
									promisesToWaitFor.push(promiseMap[promiseKey]);
								}
							});
						}
					}
				});
				self.$services.q.all(promisesToWaitFor).then(function() {
					var parameters = {};
					Object.keys(state.bindings).map(function(key) {
						//parameters[key] = self.get(state.bindings[key]);
						if (state.bindings[key] != null) {
							parameters[key] = self.$services.page.getBindingValue(self, state.bindings[key]);
						}
					});
					if (!parameters["$serviceContext"]) {
						parameters["$serviceContext"] = self.getServiceContext();
					}
					try {
						// @2023-12-19: not sure why this is a separate codebase for initializing the states rather than using the central one
						// but the code differs a lot so currently i'm not updating this bit, I did add the trigger for the initial which was not getting run correctly
						// can throw hard errors
						self.$services.swagger.execute(state.operation, parameters).then(function(result) {
							if (result != null) {
								self.initialStateLoaded.push(state.name);
							}
							Vue.set(self.variables, state.name, result ? result : null);
							promise.resolve(result);
							// the triggerInitial is a boolean we might add if we want to trigger on initial load as well
							self.$services.triggerable.trigger(state, "initial", null, self).then(promise, promise);
						}, promise);
					}
					catch (exception) {
						console.error("Could not execute", state.operation, exception);
						promise.reject(exception);
					}
				}, promise);
				return promise;
			});
			var inSelf = this.page.content.errorInSelf;
			var routeError = function(error, counter) {
				if (!counter) {
					counter = 1;
				}
				if (!self.$el && counter < 5 && inSelf) {
					Vue.nextTick(function() {
						routeError(error, counter + 1);
					});
				}
				else {
					console.log("error is", error);
					var route = "error";
					
					// if we have an array, check all responses
					// if at least one response indicates an offline server, we are going with the offline story!
					if (error instanceof Array) {
						error.forEach(function(x) {
							if (x && (x.status == 503 || x.status == 502)) {
								route = "offline";
							}
						})
					}
					else if (error && (error.status == 503 || error.status == 502)) {
						route = "offline";
					}
					
					// if we have not opted for offline behavior, check if we have custom error routing
					if (route == "error" && error.forEach) {
						error.forEach(function(x) {
							// sometimes x is null?
							if (x && x.code && self.page.content.stateErrors) {
								self.page.content.stateErrors.forEach(function(y) {
									if (y.code == x.code) {
										route = y.route;
									}
								});
							}
						});
					}
					
					console.log("error route is", route);
					
					if (!self.$services.page.canEdit()) {
						// masked route so we can reload
						self.$services.router.route(route, {
							code: "page-load-failed",
							message: "The page you requested could not be loaded, please&nbsp;<a class='is-color-link' href='javascript:void(0)' @click='$window.location.reload()'>try again</a>"
						}, inSelf && self.$el ? nabu.utils.router.self(self.$el) : null, true);
					}
					else {
						self.$services.notifier.push({
							message: "Blocking error routing to '" + route + "' due to editor permissions",
							severity: self.$services.page.notificationStyle
						});
					}
				}
			};
			this.$services.q.all(promises).then(finalize, function(error) {
				// if we are in edit mode, we can be expected to fix this
				if (self.edit || self.$services.page.wantEdit) {
					finalize();
				}
				else {
					done();
					routeError(error, 0);
				}
			});
		}
		else {
			finalize();
		}
	},
	beforeDestroy: function() {
		if (!this.page.content.readOnly) {
			this.stopEdit();
		}
		if (this.autoRefreshTimeout) {
			clearTimeout(this.autoRefreshTimeout);
			this.autoRefreshTimeout = null;
		}
		if (this.oldTitle) {
			document.title = this.oldTitle;
		}
		if (this.oldBranding) {
			this.$services.page.updateBranding(this.oldBranding);
		}
		this.timers.forEach(function(x) {
			clearTimeout(x);
		});
		if (this.oldBodyClasses.length) {
			document.body.classList.remove.apply(document.body.classList, this.oldBodyClasses.splice(0));
		}
	},
	ready: function() {
		this.$services.page.rendering--;
		this.rendered = true;
		this.postRender.splice(0).forEach(function(x) { x() });
		this.emit("$load", {});
		this.$emit("ready", this);
		var self = this;
		if (self.page.content.branding) {
			// don't copy it by reference, it will be updated...
			self.oldBranding = nabu.utils.objects.deepClone(self.$services.page.currentBranding);
			self.$services.page.updateBranding(self.page.content.branding, this);
		}
	},
	created: function() {
		// we want to be able to push data to the page
		// was added for the repeat, but actually broke stuff in the repeat if we passed in all the information so we did it another way
		// this may still be interesting for future purposes, but probably want to do a reactive set via Vue.set
//		nabu.utils.objects.merge(this.variables, this.parameters);
		this.$services.page.rendering++;
		this.$services.page.setPageInstance(this.page, this);
		var self = this;
		// it could be possible that you use a parameter here (with default) in your initial state
		this.initializeDefaultParameters(true);
		if (this.editable) {
			this.edit = true;
		}
		
		if (!this.embedded) {
			// initialize plugins
			this.plugins.forEach(function(plugin) {
				var component = Vue.component(plugin.component);
				new component({propsData: {
					page: self.page,
					edit: self.edit,
					instance: self
				}});
			});
		}
		
		// set the initial state...
		// stuff that should be hidden, is hidden by default
		// for events, it was enough to detect the event, but with the new generic closeable, we need to specifically set this
		// it should continue to work for events as well though
		this.$services.page.listCloseableItems(this.page, null, true).forEach(function(x) {
			if (!x.startVisible) {
				Vue.set(self.closed, x.id, x.on ? x.on : "$any");
			}
			// if there is an auto timeout, register a watcher
			if (x.showTimeout) {
				self.$watch("closed." + x.id, function(newValue) {
					if (!self.showTimeouts) {
						self.showTimeouts = {};
					}
					if (self.showTimeouts[x.id]) {
						clearTimeout(self.showTimeouts[x.id]);
						delete self.showTimeouts[x.id];
					}
					// if we are showing, register a closer
					if (newValue == null) {
						self.showTimeouts[x.id] = setTimeout(function() {
							Vue.set(self.closed, x.id, x.on ? x.on : "$any");
						}, parseInt(x.showTimeout));
					}
				});
			}
		});
	},
	beforeMount: function() {
		this.$services.page.setPageInstance(this.page, this);
		// keep a stringified copy of the last parameters so we can diff
		// no longer needed? @2021-06-10: it seems this was only for the initial rerender
		// which has long since been deprecated
		//this.lastParameters = JSON.stringify(this.parameters);
		this.$emit("beforeMount", this);
	},
	destroyed: function() {
		this.$services.page.destroyPageInstance(this.page, this);
	},
	computed: {
		events: function() {
			return this.getEvents();
		},
		availableParameters: function() {
			return this.$services.page.getAvailableParameters(this.page, null, true);
			// there are all the events
			//var available = nabu.utils.objects.clone(this.getEvents());
			// and the page
			//available.page = this.$services.page.getPageParameters(this.page);
			//return available;
		},
		// we inject this into the tpl only to make it reactive
		// the ultimate goal is to switch classes on the body
		bodyClasses: function () {
			if (this.page.content.bodyStyles && this.page.content.bodyStyles.length) {
				var self = this;
				return this.$services.page.getDynamicClasses(this.page.content.bodyStyles, self.variables, this);
			}
			else {
				return [];
			}
		},
		classes: function() {
			var classes = [];
			if (this.edit) {
				classes.push("is-editing");
				if (this.$services.page.activeViews.length) {
					classes.push("is-active-view");	
				}
				this.$services.page.activeViews.forEach(function(view) {
					classes.push("is-active-view-" + view);
				});
			}
			if (this.page.content.class) {
				classes.push(this.page.content.class);
			}
			if (this.page.content.styles && this.page.content.styles.length) {
				var self = this;
				var dynamics = this.$services.page.getDynamicClasses(this.page.content.styles, self.variables, this);
				nabu.utils.arrays.merge(classes, dynamics);
			}
			if (this.page.content.pageType) {
				classes.push("page-type-" + this.page.content.pageType);
			}
			else {
				classes.push("page-type-page");
			}
			classes.push("is-page-" + this.page.name);
			return classes;
		},
		plugins: function() {
			return nabu.page.providers("page-plugin").filter(function(x) { return x.target == "page" });
		}
	},
	data: function() {
		return {
			// whether or not to collapse the menu
			collapsedMenu: false,
			// you can have active views that enrich information, usually only one is active
			activeViews: ["main"],
			selectedItemPath: [],
			autoRefreshTimeout: null,
			refs: {},
			edit: false,
			// contains all the component instances
			// the key is their id
			components: {},
			// counts upwards for each instance in this page
			// this allows us to differentiate between repeated cells
			instanceCounter: 0,
			// contains (amongst other things) the event instances
			variables: {},
			// labels for values (if relevant)
			labels: {},
			// components can add their own variables
			// each component can have its own name and structure
			//lastParameters: null,
			configuring: false,
			// per cell
			closed: {},
			// centralized storage that exists for the lifetime of the page
			storage: {},
			// subscriptions to events
			subscriptions: {},
			autoMapFrom: null,
			
			// a lot of components load events at the beginning on startup in a computed property
			// however, depending on the mount order, new events come in after those components are started
			// to be able to recompute those events, this should be reactive
			cachedEvents: null,
			// a timer for content saving, we want to batch content updates to prevent a lot of calls
			// the form sets value by value using standard interfaces, it doesn't know that the content is being pushed to the backend
			// we want to keep it that way, which is why it is unaware of the batch
			saveContentTimer: null,
			// the actual contents to save
			saveContents: [],
			savePageTimer: null,
			// the selected item in the side menu
			selectedItem: null,
			// either "cell" or "row"
			selectedType: null,
			// for backwards compatibility we map the selected item to the cell or row it embodies
			cell: null,
			row: null,
			viewComponents: false,
			closing: false,
			saved: null,
			// any timers that might exist and need to be destroyed
			timers: [],
			// actions to run post render (if any)
			postRender: [],
			// whether or not we are ready to go
			rendered: false,
			oldBodyClasses: [],
			initialStateLoaded: [],
			activeTab: "layout",
			// anything waiting for a mount
			waitingForMount: {},
			// in most cases we write conditions on cells to hide themselves or show themselves
			// however, in some cases only the content IN a cell can determine whether it should be shown or not, but this can only be deduced AFTER it is rendered
			// we use the v-show toggle to do that
			hidden: {}
		}
	},
	methods: {
		addTargetState: function(cell) {
			if (!cell.states) {
				Vue.set(cell, "states", []);
			}
			cell.states.push({
				name: null,
				condition: null
			});
		},
		// check if it is an array field or a singular field
		// useful for example for dynamic form elements that can handle both
		isArrayField: function(field) {
			var arrays = this.$services.page.getAllArrays(this.page);
			if (arrays.indexOf(field) >= 0 || arrays.indexOf("page." + field) >= 0) {
				return true;
			}
			else {
				return false;
			}
		},
		getActions: function(target, pageInstance, $services) {
			var actions = [];
			// external variables can always be refreshed
			var hasRefreshableState = this.page.content.states && this.page.content.states.length;
			// internal variables only when they contain a calculation
			if (!hasRefreshableState) {
				if (this.page.content.parameters) {
					hasRefreshableState = this.page.content.parameters.filter(function(x) {
						return x.default || x.defaultScript;
					}).length > 0;
				}
			}
			if (hasRefreshableState) {
				actions.push({
					title: "Refresh State",
					name: "refresh-state",
					description: "Configure the name of the variable that needs to be refreshed",
					input: {
						name: {
							type: "string"
						}
					},
					output: {
					}
				});
			}
			return actions;
		},
		runAction: function(action, parameters) {
			var self = this;
			if (action == "refresh-state" && parameters && parameters.name) {
				if (self.page.content.states) {
					var state = self.page.content.states.filter(function(state) {
						return state.name == parameters.name
					})[0];
					if (state) {
						self.loadInitialState(state, true);
					}
				}
				if (self.page.content.parameters) {
					// currently you can only refresh the default value of a private parameter
					// private parameters are not passed in as a parameter so they should be recalculatable if they have a default script
					// public parameters can be passed in which is currently not compatible with recalculation of default values
					var parameter = self.page.content.parameters.filter(function(parameter) {
						return parameter.name == parameters.name && (parameter.default || parameter.defaultScript) && parameter.private;
					})[0];
					if (parameter) {
						this.loadParameterState(parameter.name, true);
					}
				}
			}
		},
		isActiveView: function(view) {
			return this.$services.page.activeViews.indexOf(view) >= 0;
		},
		acivateView: function(view) {
			this.activeViews.splice(0);
			this.activeViews.push(view);
		},
		updateEvent: function(value, label, name) {
			this.$emit("update", value, label, name);
			/*
			var parent = this.$parent;
			while (parent) {
				if (parent.updateEvent) {
					parent.updateEvent(value, label, name);
				}
				parent = parent.$parent;
			}
			*/
		},
		registerStateListeners: function() {
			var watchers = {};
			var self = this;
			if (this.page.content.parameters) {
				this.page.content.parameters.forEach(function(state) {
					if ((state.triggers && state.triggers.length) || state.store || state.emitUpdate) {
						if (state.name) {
							if (!watchers[state.name]) {
								watchers[state.name] = [];
								self.$watch("variables." + state.name, function() {
									watchers[state.name].forEach(function(listener) {
										listener();
									});
								}, {deep:true})
							}
							if (state.triggers && state.triggers.length) {
								watchers[state.name].push(function() {
									self.$services.triggerable.trigger(state, "change", {}, self);
								});
							}
							if (state.store) {
								watchers[state.name].push(function() {
									// make sure the value is persisted
									setTimeout(function() {
										var value = self.variables[state.name];
										if (value != null) {
											value = JSON.stringify(value);
										}
										var serviceContext = self.getServiceContext();
										localStorage.setItem(self.page.content.name + (serviceContext ? "-" + serviceContext : "") + "-state-" + state.name, value);
									}, 1);
								});
							}
							if (state.emitUpdate) {
								// always send out an update?
								watchers[state.name].push(function() {
									setTimeout(function() {
										self.updateEvent(self.variables[state.name], self.labels[state.name], state.name);
									}, 1);
								})
							}
						}
					}
				});
			}
		},
		getServiceContext: function() {
			if (this.fragmentParent) {
				return this.fragmentParent.getServiceContext();
			}
			if (!this.page.content.useFixedServiceContext && this.page.content.serviceContext) {
				return this.get(this.page.content.serviceContext);
			}
			else if (this.page.content.useFixedServiceContext && this.page.content.fixedServiceContext) {
				return this.page.content.fixedServiceContext;
			}
			return null;
		},
		updateTemplates: function() {
			var self = this;
			this.$confirm({
				message: "Are you sure you want to update all templates?"
			}).then(function() {
				self.$services.page.updateToLatestTemplate(self.page.content, true);
			})
		},
		isContentHidden: function(target) {
			if (this.hidden[target.id] == null) {
				Vue.set(this.hidden, target.id, false);
			}
			return this.hidden[target.id];
		},
		// slots can only be accessed in the direct parent, this means we have a renderer that has specific slots
		getSlots: function(target) {
			var path = this.$services.page.getTargetPath(this.page.content, target.id);
			path.reverse();
			// the first entry is now the target itself, we want the second
			if (path.length >= 2) {
				if (path[1].renderer) {
					var renderer = this.$services.page.getRenderer(path[1].renderer);
					if (renderer.getSlots) {
						return renderer.getSlots(path[1]);
					}
				}
			}
		},
		getParentConfig: function(target) {
			var path = this.$services.page.getTargetPath(this.page.content, target.id);
			path.reverse();
			// the first entry is now the target itself, we want from there onwards
			for (var i = 1; i < path.length; i++) {
				if (path[i].renderer) {
					var renderer = this.$services.page.getRenderer(path[i].renderer);
					if (renderer.getChildConfig) {
						var config = renderer.getChildConfig(path[i], target, path);
						if (config) {
							return config;
						}
					}
				}
			}
		},
		getDefaultTriggers: function() {
			return {
				click: {
					properties: {
						shift: {
							type: "boolean"
						},
						ctrl: {
							type: "boolean"
						},
						alt: {
							type: "boolean"
						},
						meta: {
							type: "boolean"
						}
					}
				},
				hover: {
					properties: {
						// nothing (yet?)
					}
				}
			};
		},
		// this works, but currently we can't get the events correctly
		getTriggersForCell: function(cell) {
			var component = this.components[cell.id];
			// could be because of repeats etc
			if (component instanceof Array) {
				component = component[0];
			}
			// always have a click trigger
			var result = this.getDefaultTriggers();
			var actions = [];
			if (component) {
				// only works for component based actions
				var componentActions = this.$services.page.getActions(component, cell, this);
				if (componentActions) {
					nabu.utils.arrays.merge(actions, componentActions);
				}
				if (component.getTriggers) {
					var componentTriggers = component.getTriggers(cell, this, this.$services);
					if (componentTriggers) {
						nabu.utils.objects.merge(result, componentTriggers);
					}
				}
			}
			// this works for renderer based
			if (cell.renderer) {
				var renderer = this.$services.page.getRenderer(cell.renderer);
				var rendererActions = this.$services.page.getActions(renderer, cell, this);
				if (rendererActions) {
					nabu.utils.arrays.merge(actions, rendererActions);
				}
				if (renderer.getTriggers) {
					var rendererTriggers = renderer.getTriggers(cell, this, this.$services);
					if (rendererTriggers) {
						nabu.utils.objects.merge(result, rendererTriggers);
					}
				}
			}
			if (actions.length > 0) {
				var self = this;
				actions.forEach(function(x) {
					var actionInput = self.$services.page.getActionInput(self, cell.id, x.name);
					var actionOutput = self.$services.page.getActionOutput(self, cell.id, x.name);
					result[x.name + ":before"] = actionInput ? actionInput : {};
					result[x.name + ":after"] = actionOutput ? actionOutput : {};
					result[x.name + ":error"] = {};
				});
			}
			return result;
		},
		getPageArisComponents: function() {
			return [{
				title: "Page Grid",
				name: "page-grid",
				component: "grid"
			}]	
		},
		getGridClasses: function() {
			var classes = [];
			if (this.$services.page.useAris && this.page.content.aris && this.page.content.aris.components) {
				var children = this.$services.page.calculateArisComponents(this.page.content.aris, null, this);
				if (children["page-grid"] && children["page-grid"].classes) {
					nabu.utils.arrays.merge(classes, children["page-grid"].classes);
				}
			}
			return classes;
		},
		// we want to listen for a component, this could be a renderer or a target component
		// it is based on the id
		// it might already be available or it might be mounted at a later point in time
		// either way we return a promise to be consistent
		getComponent: function(id) {
			var promise = this.$services.q.defer();
			// great, resolve it immediately
			if (this.components[id]) {
				promise.resolve(this.components[id]);
			}
			else {
				if (!this.waitingForMount.hasOwnProperty(id)) {
					Vue.set(this.waitingForMount, id, []);	
				}
				this.waitingForMount[id].push(promise);
			}
			return promise;
		},
		addNotification: function() {
			if (!this.page.content.notifications) {
				Vue.set(this.page.content, "notifications", []);
			}	
			this.page.content.notifications.push({
				name: null,
				duration: null,
				// the event you will trigger on
				on: null,
				condition: null,
				title: null,
				message: null,
				severity: null,
				closeable: null,
				icon: null,
				actions: [],
				chainEvent: {
					name: "enrich"
				}
			});
		},
		moveTriggerUp: function(action) {
			var index = this.page.content.actions.indexOf(action);
			if (index > 0) {
				this.page.content.actions.splice(index, 1);
				this.page.content.actions.splice(index - 1, 0, action);
			}
		},
		moveTriggerDown: function(action) {
			var index = this.page.content.actions.indexOf(action);
			// not the last one
			if (index < this.page.content.actions.length - 1) {
				this.page.content.actions.splice(index, 1);
				this.page.content.actions.splice(index + 1, 0, action);
			}
		},
		moveInternalUp: function(parameter) {
			var index = this.page.content.parameters.indexOf(parameter);
			if (index > 0) {
				this.page.content.parameters.splice(index, 1);
				this.page.content.parameters.splice(index - 1, 0, parameter);
			}
		},
		moveInternalDown: function(parameter) {
			var index = this.page.content.parameters.indexOf(parameter);
			// not the last one
			if (index < this.page.content.parameters.length - 1) {
				this.page.content.parameters.splice(index, 1);
				this.page.content.parameters.splice(index + 1, 0, parameter);
			}
		},
		getOperationArrays: function(operation) {
			if (operation) {
				var op = this.$services.swagger.operations[operation];
				if (op && op.responses["200"] != null && op.responses["200"].schema != null) {
					var schema = op.responses["200"].schema;
					if (schema["$ref"]) {
						var definition = this.$services.swagger.resolve(schema["$ref"]);
						return this.$services.page.getArrays(definition);
					}
				}
			}
			return [];
		},
		moveActionTop: function(action) {
			var index = this.page.content.actions.indexOf(action);	
			if (index > 0) {
				this.page.content.actions.splice(index, 1);
				this.page.content.actions.unshift(action);
			}
		},
		getHideMode: function(cell) {
			// not yet defined (backwards compatible)
			if (!cell.state || !cell.state.hasOwnProperty("hideMode")) {
				var mode = null;
				if (cell.on) {
					mode = "event";
				}
				else if (cell.condition) {
					mode = "script";
				}
				else if (cell.devices && cell.devices.length) {
					mode = "device";
				}
				else if (cell.closeable) {
					mode = "toggle";
				}
				if (!cell.state) {
					Vue.set(cell, "state", {});
				}
				Vue.set(cell.state, "hideMode", mode);
			}
			return cell.state.hideMode;
		},
		setHideMode: function(cell, mode) {
			Vue.set(cell.state, "hideMode", mode);
			// set some other states to be backwards compatible and keep the future ability to combine multiple conditions
			Vue.set(cell, "closeable", mode == "toggle");
			if (cell.state.mode != "event") {
				cell.on = null;
			}
			if (cell.state.mode != "script") {
				cell.condition = null;
			}
			if (cell.state.mode != "devices" && cell.devices) {
				cell.devices.splice(0);
			}
		},
		moveActionBottom: function(action) {
			var index = this.page.content.actions.indexOf(action);	
			if (index >= 0) {
				this.page.content.actions.splice(index, 1);
				this.page.content.actions.push(action);
			}
		},
		moveAction: function(action, amount) {
			var index = this.page.content.actions.indexOf(action);	
			if (index >= 0) {
				var targetIndex = index + amount;
				if (targetIndex >= 0 && targetIndex <= this.page.content.actions.length - 1) {
					var targetItem = this.page.content.actions[targetIndex];
					this.page.content.actions.splice(targetIndex, 1, this.page.content.actions[index]);
					this.page.content.actions.splice(index, 1, targetItem);
				}
			}
		},
		route: function(alias, parameters, anchor, mask) {
			var self = this;
			var doIt = function() {
				self.$services.router.route(alias, parameters, anchor, mask);
			};
			if (this.rendered) {
				return doIt();
			}
			else {
				this.postRender.push(doIt);
			}
		},
		fireInitialEvent: function(x) {
			var self = this;
			if (nabu.page.event.getName(x, "definition") && (!x.condition || self.$services.page.isCondition(x.condition, self.$services.page.getPageState(self), self))) {           
				try {
					self.emit(
						nabu.page.event.getName(x, "definition"),
						nabu.page.event.getInstance(x, "definition", self.page, self)
					);
				}
				catch (exception) {
					console.error("Could not fire initial event", exception);
				}
			}
			if (x.timeout) {
				var timer = setTimeout(function() {
					// remove this timer
					var index = self.timers.indexOf(timer);
					if (index >= 0) {
						self.timers.splice(index, 1);
					}
					self.fireInitialEvent(x);
				}, parseInt(x.timeout));
				self.timers.push(timer);
			}
		},
		initializeDefaultParameters: function(isInitial, names, force) {
			var self = this;
			if (this.page.content.parameters) {
				this.page.content.parameters.map(function(x) {
					if (x.name != null && (!names || names.indexOf(x.name) >= 0)) {
						// it is entirely possible that someone already set the state for this variable, for example through an initial state with the same name
						// this "trick" is applied when you want to load initial state _and_ you want to modify it through listeners etc
						// we then make two variables with the same name
						// however, if the initial state in this case does not exist, you do want your default to kick in
						// but not if the state already exists
						// if we force it however (e.g. through reset), we do want to recompute every time
						if (self.initialStateLoaded.indexOf(x.name) < 0 || force) {
							// if it is not passed in as input, we set the default value
							if (self.parameters[x.name] == null) {
								var value = null;
								// check if we have local storage
								if (x.store) {
									value = localStorage.getItem(self.page.content.name + "-" + self.getServiceContext() + "-state-" + x.name);
									if (value != null) {
										value = JSON.parse(value);
									}
								}
								// check if we have a content setting
								//if (value == null) {
								//	value = self.$services.page.getContent(x.global ? null : self.page.name, x.name);
								//}
								if (value == null) {
									if (x.complexDefault) {
										value = self.calculateVariable(x.defaultScript);
									}
									else {
										value = self.$services.page.interpret(x.default, self);
									}
								}
								//else {
								//	value = value.content;
								//}
								// inherit from global state (especially interesting for mails/pdfs...)
								// basically you inject state in a global parameters application.state and it will be auto-bound
								if (value == null && application.state && application.state[x.name] != null) {
									value = application.state[x.name];
								}
								if (value != null || isInitial) {
									Vue.set(self.variables, x.name, value == null ? null : value);
								}
							}
							// but you can override the default with an input parameter (only during created, not activate)
							else if (isInitial) {
								Vue.set(self.variables, x.name, self.parameters[x.name]);
							}
						}
					}
				});
			}
		},
		selectTarget: function(target) {
			if (target.cells) {
				this.selectItem(target, null, "row");
			}
			else if (target.rows) {
				var path = this.$services.page.getTargetPath(this.page.content, target.id);
				this.selectItem(path[path.length - 2], target, "cell");
			}
		},
		selectItem: function(row, cell, type, tab) {
			Vue.set(this, 'row', row);
			Vue.set(this, 'cell', cell);
			Vue.set(this, 'selectedType', type);
			
			if (tab) {
				this.activeTab = tab ? tab : "selected";
			}

			// if we set something, calculate a new path
			if (type) {
				var path = this.$services.page.getTargetPath(this.page.content, this.selectedType == "cell" ? this.cell.id : this.row.id);
				var samePath = false;
				// if our current path is shorter than the one we already have selected (so basically we selected a parent)
				// we keep the longer path! this allows you to switch to a parent and then back to the child you were working on
				if (path.length < this.selectedItemPath.length) {
					samePath = true;
					var self = this;
					path.forEach(function(x, index) {
						if (samePath && self.selectedItemPath[index].id != x.id) {
							samePath = false;
						}
					});
				}
				if (!samePath) {
					this.selectedItemPath.splice(0);
					nabu.utils.arrays.merge(this.selectedItemPath, path);
				}
			}
			
			var component = this.canConfigureInline(cell);
			this.$services.page.availableSubTabs.splice(0);
			if (component) {
				if (component.getAvailableSubTabs) {
					nabu.utils.arrays.merge(this.$services.page.availableSubTabs, component.getAvailableSubTabs());
				}
			}
			var availableTabs = ["container", "styling", "triggers", "analysis"];
			
			if (this.$services.page.availableSubTabs.length) {
				nabu.utils.arrays.merge(availableTabs, this.$services.page.availableSubTabs);
			}
			else if (cell) {
				availableTabs.push("component");
			}
			else {
				availableTabs.push("container");
			}
			// whatever tab we had is no longer valid, reset it
			if (availableTabs.indexOf(this.$services.page.activeSubTab) < 0) {
				this.$services.page.activeSubTab = availableTabs[0];
			}
		},
		stopEdit: function() {
			if (this.edit && !this.closing) {
				this.closing = true;
				//var right = document.querySelector("#n-sidebar-right-instance");
				var right = document.querySelector(".is-sidebar.right");
				if (right && right.__vue__ && right.__vue__.close) {
					right.__vue__.close();
				}
				else if (right && right.$$close) {
					right.$$close();
				}
				//var left = document.querySelector("#n-sidebar-left-instance");
				var left = document.querySelector(".is-sidebar.left");
				if (left && left.__vue__ && left.__vue__.close) {
					left.__vue__.close();
				}
				else if (left && left.$$close) {
					left.$$close();
				}
				/*if (this.$refs.sidemenu) {
					this.$refs.sidemenu.close();
				}*/
				if (this.$services.page.editing) {
					this.$services.page.editing.edit = false;
					this.$services.page.editing = null;
				}
				this.closing = false;
				this.edit = false;
				document.querySelectorAll(".is-hovering").forEach(function(element) {
					element.classList.remove("is-hovering", "is-hover-top", "is-hover-bottom", "is-hover-left", "is-hover-right");
				});
				document.body.removeAttribute("page-editing");
			}
		},
		goIntoEdit: function() {
			if (!this.edit) {
				// normalize
				if (!this.page.content.formatters) {
					Vue.set(this.page.content, "formatters", []);
				}
				if (this.$services.page.editing) {
					if (this.$services.page.editing.edit) {
						this.$services.page.editing.stopEdit();
					}
					this.$services.page.editing = null;
				}
				this.edit = true;
				this.$services.page.editing = this;
				// automatically pop up the new components window
				this.viewComponents = true;
			}	
		},
		addInitialEvent: function() {
			if (!this.page.content.initialEvents) {
				Vue.set(this.page.content, "initialEvents", []);
			}
			this.page.content.initialEvents.push({condition:null, definition: {}});
		},
		listFields: function(type, value) {
			// added try/catch in case the type is unknown
			try {
				var type = this.$services.swagger.resolve(type);
				return this.$services.page.getSimpleKeysFor(type).filter(function(x) { return !value || (x && x.toLowerCase().indexOf(value.toLowerCase()) >= 0) });
			}
			catch (exception) {
				console.warn("Could not list fields for", type, exception);
				return [];
			}
		},
		validateStateName: function(name) {
			var blacklisted = ["page", "application", "record", "state", "localState"];
			var messages = [];
			if (name && blacklisted.indexOf(name) >= 0) {
				messages.push({
					type: "error",
					title: "This name is not allowed"
				});
			}
			return messages;
		},
		isGet: function(operationId) {
			var operation = this.$services.swagger.operations[operationId];
			return operation && operation.method && operation.method.toLowerCase() == "get";
		},
		getParameterTypes: function(value) {
			var types = ['string', 'boolean', 'number', 'integer'];
			nabu.utils.arrays.merge(types, Object.keys(this.$services.swagger.swagger.definitions));
			if (value) {
				types = types.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			return types;
		},
		store: function(key, value) {
			if (typeof(value) == "object") {
				if (!this.storage[key]) {
					Vue.set(this.storage, key, {});
				}
				Object.keys(value).map(function(name) {
					Vue.set(this.storage[key], name, value[name]);
				})
			}
			else {
				Vue.set(this.storage, key, value);
			}
		},
		retrieve: function(key) {
			return this.storage[key];
		},
		automap: function(action) {
			var source = this.availableParameters[this.autoMapFrom];
			var self = this;
			var keys = self.$services.page.getSimpleKeysFor(source);
			this.getOperationParameters(action.operation, true).map(function(key) {
				// only automap those that are not filled in
				if (!action.bindings[key]) {
					var keyToCheck = key.indexOf(".") < 0 ? key : key.substring(key.indexOf(".") + 1);
					//if (!!source.properties[keyToCheck]) {
					var matching = keys.filter(function(x) { return x == keyToCheck || (x.length > keyToCheck.length + 1 && x.substring(x.length - (keyToCheck.length + 1)) == "." + keyToCheck) });
					if (matching.length > 0) {
						Vue.set(action.bindings, key, self.autoMapFrom + "." + matching[0]);
					}
				}
			});
		},
		pasteRow: function(cell) {
			if (cell) {
				cell.rows.push(this.$services.page.renumber(this.page, this.$services.page.copiedRow));
				this.$services.page.copiedRow = null;
			}
			// pushing to page!
			else {
				this.page.content.rows.push(this.$services.page.renumber(this.page, this.$services.page.copiedRow));
				this.$services.page.copiedRow = null;
			}
		},
		getStateOperations: function(value) {
			return this.$services.page.getStateOperations(value);
		},
		setStateOperation: function(state, operation) {
			state.operation = operation;
			var bindings = {};
			if (operation) {
				this.$services.swagger.operations[operation].parameters.map(function(parameter) {
					bindings[parameter.name] = null;
				});
			}
			Vue.set(state, "bindings", bindings);
		},
		addState: function() {
			this.page.content.states.push({
				name: null,
				operation: null,
				bindings: {},
				condition: null
			})	
		},
		addApplicationState: function() {
			this.page.content.states.push({
				inherited: true,
				name: null,
				// the name of the state at the application level
				applicationName: null
			});
		},
		dragMenu: function(event) {
			this.$services.page.setDragData(event, "page-menu", this.page.name);
		},
		// apparently you can't (in chrome at least) access the data during drag
		// this is to prevent inspecting data that is accidently dragged over your website
		// we _can_ however access the list of data types that is available
		dragOver: function(event) {
			if (this.$services.page.hasDragData(event, "page-menu")) {
				event.preventDefault();
			}
			else if (this.$services.page.hasDragData(event, "component-alias")) {
				event.preventDefault();
			}
			else if (this.$services.page.hasDragData(event, "template-content")) {
				event.preventDefault();
			}
			else if (this.$services.page.hasDragData(event, "operation")) {
				event.preventDefault();
			}
		},
		dropMenu: function(event) {
			var self = this;
			if (this.$services.page.getDragData(event, "page-menu")) {
				var rect = this.$el.getBoundingClientRect();
				Vue.set(this.page.content, "menuX", event.clientX - rect.left);
				Vue.set(this.page.content, "menuY", event.clientY - rect.top);
				event.preventDefault();
				event.stopPropagation();
			}
			if (this.$services.page.getDragData(event, "component-alias")) {
				var row = this.addRow(this.page.content);
				var cell = this.addCell(row);
				cell.alias = this.$services.page.getDragData(event, "component-alias");
				event.preventDefault();
				event.stopPropagation();
			}
			if (this.$services.page.getDragData(event, "template-content")) {
				var content = JSON.parse(this.$services.page.getDragData(event, "template-content"));
				// row drop from templates
				if (content.type == "page-row") {
					if (!self.page.content.rows) {
						Vue.set(self.page.content, "rows", []);
					}
					if (content.content instanceof Array) {
						content.content.forEach(function(row) {
							self.page.content.rows.push(self.$services.page.renumber(self.page, self.$services.page.normalizeRow(row)));
						});
					}
					else {
						self.page.content.rows.push(self.$services.page.renumber(self.page, self.$services.page.normalizeRow(content.content)));
					}
				}
				else {
					if (content.rows instanceof Array) {
						var rows = content.rows.map(function(x) {
							return self.$services.page.renumber(self.page, x);	
						});
						nabu.utils.arrays.merge(this.page.content.rows, rows);
					}
					if (content.actions instanceof Array) {
						nabu.utils.arrays.merge(this.page.content.actions, content.actions);
					}
				}
				event.preventDefault();
				event.stopPropagation();
			}
			if (this.$services.page.getDragData(event, "operation")) {
				this.initializeOperation(function(target) {
					return self.addRow(target ? target : self.page.content);
				}, function(row) {
					return self.addCell(row);
				});
				event.preventDefault();
				event.stopPropagation();
			}
		},
		initializeOperation: function(rowGenerator, cellGenerator) {
			var self = this;
			var content = this.$services.page.getDragData(event, "operation");
			if (content) {
				if (this.$services.swagger.operations[content]) {
					this.initializeOperationInternal(rowGenerator, cellGenerator, content);
				}
				// if we can't find the operation, reload the swagger and try again
				// if it's still not there, we fail
				else {
					this.$services.page.reloadSwagger().then(function() {
						if (self.$services.swagger.operations[content]) {
							self.initializeOperationInternal(rowGenerator, cellGenerator, content);
						}
						else {
							console.error("Can not find operation", content);
						}
					});
				}
			}
		},
		initializeOperationInternal: function(rowGenerator, cellGenerator, content) {
			var self = this;
			var acceptedRoutes = this.$services.router.router.list().filter(function(route) {
				if (route.accept) {
					console.log("found acceptor", route.alias);
				}
				return route.accept && route.accept("operation", content);
			});
			// if we have multiple routes, only choose correctly annotated routes that we can ask the user which he wants
			if (acceptedRoutes.length > 1) {
				acceptedRoutes = acceptedRoutes.filter(function(x) {
					return x.icon && x.name;	
				});
			}
			
			var applicableGenerators = nabu.page.providers("page-generator").filter(function(generator) {
				if (generator.accept) {
					console.log("found generator", generator.name);
				}
				return generator.accept && generator.accept("operation", content);
			});
			// the necessary fields for these two are in sync:
			// - icon
			// - name
			// - description
			// we don't have an alias in generators which is what we use to distinguish between the two
			nabu.utils.arrays.merge(acceptedRoutes, applicableGenerators);

			var runRoute = function(route) {
				var row = rowGenerator();
				var cell = cellGenerator(row);
				cell.alias = route.alias;
				if (route.initialize) {
					cell.$$initialize = function(instance) {
						route.initialize("operation", content, instance, cell, row, self, rowGenerator, cellGenerator);
					}
				}
				event.preventDefault();
				event.stopPropagation();
				self.$services.page.slowNormalizeAris(self.page, row, "row");
				self.$services.page.slowNormalizeAris(self.page, cell);
			};
			console.log("accepted routes are", acceptedRoutes);
			// if there is only one, execute it immediately
			if (acceptedRoutes.length == 1) {
				if (acceptedRoutes[0].alias) {
					runRoute(acceptedRoutes[0]);
				}
				else if (acceptedRoutes[0].initialize) {
					acceptedRoutes[0].initialize("operation", content, self, rowGenerator, cellGenerator);
				}
			}
			// if we have multiple, show a popup
			else if (acceptedRoutes.length > 1) {
				this.$prompt("page-components-selector", {components: acceptedRoutes}).then(function(chosen) {
					if (chosen) {
						if (chosen.alias) {
							runRoute(chosen);
						}
						else if (chosen.initialize) {
							chosen.initialize("operation", content, self, rowGenerator, cellGenerator);
						}
					}	
				});
			}
		},
		save: function(event) {
			if (this.edit) {
				var self = this;
				this.$services.page.update(this.page).then(function() {
					self.saved = new Date();
					self.$services.notifier.push({
						message: "Page '" + self.page.content.name + "' saved!",
						severity: self.$services.page.notificationStyle
					});
				}, function(error) {
					self.$services.notifier.push({
						message: "Could not save page '" + self.page.content.name + "'",
						severity: "danger-outline"
					});
				});
				event.preventDefault();
				event.stopPropagation();
			}
		},
		getOperationParameters: function(operation, explode) {
			// could be an invalid operation?
			if (!this.$services.swagger.operations[operation]) {
				 return [];
			}
			var parameters = this.$services.swagger.operations[operation].parameters;
//			parameters["$serviceContext"] = {
//				type: "string"
//			};
			if (explode) {
				return this.$services.page.getSwaggerParametersAsKeys(this.$services.swagger.operations[operation]);
			}
			else {
				return parameters ? parameters.map(function(x) { return x.name }) : [];
			}
		},
		addEventReset: function(action) {
			if (action.eventResets == null) {
				Vue.set(action, "eventResets", []);
			}
			action.eventResets.push('');
		},
		getOperations: function(value) {
			var options = Object.keys(this.$services.swagger.operations);
			if (value) {
				options = options.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				})
			}
			return options;
		},
		getAvailableEvents: function(event) {
			var available = this.getEvents();
			var result = Object.keys(available);
			result = result.filter(function(x) {
				return x != null && typeof(x) == "string";
			});
			if (event) {
				result = result.filter(function(x) {
					return x.toLowerCase().indexOf(event.toLowerCase()) >= 0;
				});
			}
			result.sort();
			return result;
		},
		addAnalysis: function() {
			if (!this.page.content.analysis) {
				Vue.set(this.page.content, "analysis", []);
			}	
			this.page.content.analysis.push({
				name: null,
				on: null,
				condition: null
			});
		},
		addAction: function() {
			this.page.content.actions.push({
				name: null,
				on: null,
				confirmation: null,
				operation: null,
				route: null,
				event: null,
				anchor: null,
				bindings: {},
				expandBindings: true
			});
		},
		removeQuery: function(index) {
			this.page.content.query.splice(index, 1);	
		},
		ref: function(reference) {
			return this.refs[reference];
		},
		// destroy a component from the page
		destroyComponent: function(component, cell) {
			// keep track of the separate instances
			if (this.components["instance_" + component.$$pageInstanceCounter]) {
				Vue.delete(this.components, "instance_" + component.$$pageInstanceCounter, null);
			}
			if (component.getRuntimeAlias) {
				var alias = component.getRuntimeAlias();
				if (alias != null) {
					Vue.delete(this.components, "alias_" + component.getRuntimeAlias(), null);
					// unset the state again so it can be reused
					// or at the very least it is clear that it is gone
					// it should use the custom setter if available
					this.set(component.getRuntimeAlias(), null);
					//Vue.set(this.variables, component.getRuntimeAlias(), null);

					// THIS DOES NOT WORK
					// the problem is that often we set the rendering condition on some far away parent of the component that actually has the state
					// this means we don't "cleanly" destroy it
					// note that mountRenderer() has a beforedestroy hook that is also not correctly called
					// the problem is mostly that they are keyed to the same cell, so they have the same instance
					// because of this reuse, the destroy hooks are not correctly called until it is fully destroyed
					var self = this;
					// reset all he labels belonging to this state
					Object.keys(self.labels).forEach(function(label) {
						if (label == component.getRuntimeAlias() || label.indexOf(component.getRuntimeAlias() + ".") == 0) {
							Vue.set(self.labels, label, null);
						}
					})
				}
			}
			// this keeps track by cell id
			if (this.components[cell.id] != null) {
				if (this.components[cell.id] instanceof Array) {
					var index = this.components[cell.id].indexOf(component);
					if (index >= 0) {
						this.components[cell.id].splice(index, 1);
					}
					if (this.components[cell.id].length == 0) {
						Vue.delete(this.components, cell.id, null);
					}
					// make singular again
					else if (this.components[cell.id].length == 1) {
						this.components[cell.id] = this.components[cell.id][0];
					}
				}
				else if (this.components[cell.id] == component) {
					Vue.delete(this.components, cell.id, null);
				}
			}
		},
		// in the beginning we only kept track of one component per cell id
		// there can not be multiple, it is not entirely clear how this should work for now
		// repeats are turned off in edit mode so shouldn't trigger multiple components, but page-arbitrary can
		// upside: we can offer a solution for configuration of arbitrary, downside: the state etc is still not ok (probably...?)
		getComponentForCell: function(cellId) {
			var result = this.components[cellId];
			if (result instanceof Array) {
				// slightly evil fix, in some rare cases (currently and hopefully only during editing), the destroy routines are not correctly triggered
				// this means we end up picking the "stale" cell that is no longer part of the page
				// instead of taking the first (which was initially the setup), we take the last instance
				return result[result.length - 1];
			}
			return result;
		},
		// can do an explicit renderer mount
		mountRenderer: function(target, component) {
			if (target.renderer && target.runtimeAlias && component.getRuntimeState) {
				var toMerge = null;
				if (target.mergeState) {
					// if there is already state, let's merge it
					if (this.variables[target.runtimeAlias] != null) {
						toMerge = this.variables[target.runtimeAlias];
					}
				}
				//Vue.set(this.variables, target.runtimeAlias, component.getRuntimeState());
				// use potentially localized set
				this.set(target.runtimeAlias, component.getRuntimeState());
				if (!target.retainState) {
				}
				if (toMerge != null) {
					this.$services.page.mergeObject(this.variables[target.runtimeAlias], toMerge);
				}
			}
			// link back for certain functions like beforeDestroy untriggering
			component.$$target = target;
			var self = this;
			// when we exit edit mode, we don't actually destroy the parent page, but we do reroute all the children
			// for whatever reason (possibly because this is asynchronous), it does not play well with the rerendering of the actual children
//			if (!this.edit) {
				component.$on("hook:beforeDestroy", function() {
					// you may have already been replaced! at that point, we assume by an instance of the same thing
					// this usually happens when switching between editing and not editing
					// at that point, the new component should be registered already and we don't want to wipe that out
					if (self.components[target.id] == component) {
						if (target.renderer && target.runtimeAlias && component.getRuntimeState && !target.retainState) {
							//Vue.set(self.variables, target.runtimeAlias, null);
							// use potentially localized set
							self.set(target.runtimeAlias, null);
						}
						if (target.renderer) {
							// only unset if it _is_ you, at some point we were unsetting other instances
							self.components[target.id] = null;	
						}
					}
				});
//			}
			// resolve anyone waiting for this component
			if (this.waitingForMount[target.id] instanceof Array) {
				this.waitingForMount[target.id].forEach(function(x) {
					x.resolve(component);
				});
				Vue.delete(this.waitingForMount, target.id);
			}
			// we set this as the target id, this may conflict with cells?
			if (target.renderer) {
				this.components[target.id] = component;
			}
		},
		mounted: function(cell, row, state, component) {
			var self = this;
			
			if (component.$mounted) {
				self.$services.page.rendering--;
			}
			else {
				component.$on("hook:mounted", function() {
					self.$services.page.rendering--;
				});
			}
			
			component.$on("update", function(value, label, name) {
				if (cell.bindings && cell.bindings[name]) {
					self.set(cell.bindings[name], value, label);
				}
				if (cell.contentRuntimeAlias) {
					self.set(cell.contentRuntimeAlias + "." + name, value, label);
				}
				// @2024-09-27
				// for a while there was only the "emit" line which basically pushes all update statements to the PARENT page (not the parent component of the cell reporting the update)
				// however, combined with the steps above where we _always_ map the data if the conditions apply, this created weird things
				// for instance, we had a nested page which had a contentruntimealias where we automapped the data to another component, but within that nested page we had a form component that triggered an update
				// this update was pushed to the parent page and (because of the content runtime alias) set in the shared object (see getParameters) for that content runtime alias
				// this in turn meant it was part of the parameters which again in turn triggered refreshes which had the potential to unset state
				// the assumption is that "in general" you don't want pages to simply push updates to the parent page at all
				// there is however at least one valid usecase (which is probably the origin of this line): repeats that use fragment pages for partial states
				// there the fragment page does need to report the update to its parent page in order to be able to trigger the "update" in triggers (to have a single update operation trigger instead of having to configure it on every element)
				// so currently I have opted to reduce the emit to only happen if you have a fragment parent (which is only currently used by repeats)
				// if you do want to nest a page and have its content updated, you should use the "emit to parent" to explicitly enable this
				// if there does turn out to be a valid usecase for pushing all updates to the parent page, we should at least limit the setting of the state in the above lines of code to only apply if the cell reporting the update BELONGS to your page
				// otherwise we can have naming conflicts etc appear cross page
				// currently there is no way to cleanly report the source of the original event however, so this would need some additional logic
				if (self.fragmentParent) {				
					self.$emit("update", value, label, name);
				}
				// @2025-03-14
				// when you have form fields in a form, the form "update" was not being triggered
				// so I added this to ensure that it continues...
				else if (component.$parent) {
					component.$parent.$emit("update", value, label, name);
				}
			})
			
			component.$on("close", function() {
				var closed = false;
				if (self.$services.page.isCloseable(cell)) {
					closed = true;
					Vue.set(self.closed, cell.id, cell.on ? cell.on : "$any");
				}
				if (row && self.$services.page.isCloseable(row)) {
					closed = true;
					Vue.set(self.closed, row.id, row.on ? row.on : "$any");
				}
				if (!closed && component.$parent) {
					component.$parent.$emit("close");
				}
			});
			
			// in some cases only the component knows when to hide (e.g. tags)
			// we use the hidden logic to v-show the wrapper cell as well to prevent it taking up empty space that might influence things like css gaps
			if (component.isCellHidden) {
				Vue.set(self.hidden, cell.id, component.isCellHidden());
				// and we listen for updates
				component.$on("hide", function() {
					Vue.set(self.hidden, cell.id, true);	
				});
				component.$on("show", function() {
					Vue.set(self.hidden, cell.id, false);	
				});
			}
			
			// assign a page instance counter for unique temporary reference
			component.$$pageInstanceCounter = this.instanceCounter++;
			this.components["instance_" + component.$$pageInstanceCounter] = component;
			
			// set the cell on the component, we might need to trace it back?
			component.$$cell = cell;
			
			// define an alias
			if (component.getRuntimeAlias) {
				var alias = component.getRuntimeAlias();
				if (alias != null) {
					// not used atm, but could be handy to retrieve a component by its name
					// there might also be a ref that does this? see below cell.ref
					this.components["alias_" + component.getRuntimeAlias()] = component;
					// override the currently empty state with the actual state
					// all modification of that state must occur on this object (by reference)
					if (component.getRuntimeState) {
						Vue.set(this.variables, component.getRuntimeAlias(), component.getRuntimeState());
					}
				}
			}
			// if you were to set a row renderer _and_ a cell renderer, we might not pick it up?
			// the problem with this approach is manyfold:
			// - some renderers _don't_ render children the "normal" way (e.g. repeat), so the mounted() hook of a child is never called, meaning it is never picked up
			// - other renderer can obviously render multiple children (e.g. a form), we don't want to repeatedly register
			/*
			if (cell.renderer && cell.runtimeAlias && component.$parent && component.$parent.getState) {
				Vue.set(this.variables, cell.runtimeAlias, component.$parent.getState());
				if (!cell.retainState) {
					component.$parent.$on("hook:beforeDestroy", function() {
						Vue.set(this.variables, cell.runtimeAlias, null);
					});
				}
			}
			else if (row.renderer && row.runtimeAlias && component.$parent && component.$parent.getState) {
				Vue.set(this.variables, row.runtimeAlias, component.$parent.getState());
				if (!row.retainState) {
					component.$parent.$on("hook:beforeDestroy", function() {
						Vue.set(this.variables, row.runtimeAlias, null);
					});
				}
			}
			*/
			
			// run the initializer function (if any) with the component instance
			if (cell.$$initialize) {
				cell.$$initialize(component);
				cell.$$initialize = null;
			}
			
			if (cell.ref) {
				this.refs[cell.ref] = component;
			}
			
			component.$on("hook:beforeDestroy", function() {
				// clear subscriptions
				if (component.$pageSubscriptions != null) {
					component.$pageSubscriptions.forEach(function(sub) {
						sub();
					});
				}
				if (cell.ref) {
					self.refs[cell.ref] = null;
				}
				// currently all this does is update the components, which is better done here
				//self.$services.page.destroy(component);
				self.destroyComponent(component, cell);
			});
			
			// reset event cache
			this.cachedEvents = null;
			// if it already exists, we have multiple components for the same cell id, this is possible in for example a "for each" scenario
			// or when dealing with arbitrary content that the parent does not have full knowledge about and might register itself
			if (this.components[cell.id] != null) {
				// if not an array yet, we make it an array
				if (!(this.components[cell.id] instanceof Array)) {
					this.components[cell.id] = [this.components[cell.id]];
				}
				this.components[cell.id].push(component);
			}
			else {
				this.components[cell.id] = component;
			}
			
			// we subscribe to a very specific event that will reset all the registered events
			// this is because it is cached...
			component.$on("updatedEvents", function() {
				self.resetEvents();
			});
			
			var self = this;
			
			/*
			// we want to inject all the data into the component so it can be used easily
			var data = {};
			// shallow copy of the variables that exist
			Object.keys(this.variables).map(function(key) {
				data[key] = self.variables[key];
			});
			*/
			
			// actually, the state is not in the parents as rows and cells are not components
			// state is sent in
			/*
			// now we want to walk the parent nodes of the component until we reach the page
			// and check if they have any local state that should be added
			// parents can override page-level properties but because we loop from closest parent to furthest parent, they can not override each others keys
			// as the most specific parent is supposed to win
			var parentKeys = [];
			var parent = component.$parent;
			while (parent) {
				if (parent == this) {
					break;
				}
				if (parent.data) {
					Object.keys(parent.data).map(function(key) {
						if (parentKeys.indexOf(key) < 0) {
							data[key] = parent.data[key];
							parentKeys.push(key);
						}
					})
				}
				parent = parent.$parent;
			}
			*/
			
			/*
			if (state) {
				Object.keys(state).map(function(key) {
					data[key] = state[key];
				})
			}
			*/
			
			// we want to inject all the necessary data into the cell so it can be referenced by components
//			Vue.set(component, "state", data);
		
			// make sure we have a watchable variable for each event
			if (component.getEvents) {
				var self = this;
				var eventResult = component.getEvents();
				if (eventResult) {
					var subscribeToEvent = function(name) {
						if (!self.variables[name]) {
							Vue.set(self.variables, name, null);
						}
						component.$on(name, function(value) {
							self.emit(name, value);
						});
					}
					if (typeof(eventResult) == "string") {
						subscribeToEvent(eventResult);
					}
					else if (eventResult instanceof Array) {
						// TODO: add array support
					}
					else {
						Object.keys(eventResult).map(subscribeToEvent);
					}
				}
			}
			
			// if we have old-timey event registration, use it to pick up page events
			if (component.$options.events) {
				if (component.$pageSubscriptions == null) {	
					component.$pageSubscriptions = [];
				}
				var self = this;
				Object.keys(component.$options.events).forEach(function(name) {
					component.$pageSubscriptions.push(self.subscribe(name, component.$options.events[name].bind(component)));
				});
			}
			
			// resolve anyone waiting for this component
			if (this.waitingForMount[cell.id] instanceof Array) {
				this.waitingForMount[cell.id].forEach(function(x) {
					x.resolve(component);
				});
				Vue.delete(this.waitingForMount, cell.id);
			}
		},
		hasConfigureListener: function(rows) {
			if (!rows) {
				rows = this.page.content.rows;
			}
			if (rows) {
				for (var i = 0; i < rows.length; i++) {
					if (rows[i].on == "$configure") {
						return true;
					}
					if (rows[i].cells) {
						for (var j = 0; j < rows[i].cells.length; j++) {
							var cell = rows[i].cells[j];
							if (cell.on == "$configure") {
								return true;
							}
							if (cell.rows) {
								var has = this.hasConfigureListener(cell.rows);
								if (has) {
									return true;
								}
							}
						}
					}
				}
			}
			return false;
		},
		addCell: function(target, skipInject) {
			if (!target.cells) {
				Vue.set(target, "cells", []);
			}
			var cell = {
				id: this.page.content.counter++,
				rows: [],
				// the alias of the route we want to render here (if any)
				alias: null,
				// the route may have input parameters (path + query), these are the relevant bindings
				// the binding variable contains keys for each path/query parameter in the route
				bindings: {},
				name: null,
				// state that is maintained by the cell owner (the route alias)
				// for example it might offer additional configuration
				state: {},
				// the rendering target (e.g. sidebar, prompt,...)
				target: 'page',
				// it can depend on an event of taking place
				on: null,
				// a class for this cell
				class: null,
				// a custom id for this cell
				customId: null,
				// flex width
				width: null,
				height: null,
				condition: null,
				devices: [],
				clickEvent: null
			};
			if (!skipInject) {
				target.cells.push(cell);
				this.$services.page.normalizeAris(this.page, cell);
			}
			return cell;
		},
		addRow: function(target, skipInject) {
			if (!target.rows) {
				Vue.set(target, "rows", []);
			}
			var row = {
				id: this.page.content.counter++,
				state: {},
				cells: [],
				class: null,
				// a custom id for this row
				customId: null,
				condition: null,
				direction: null,
				align: null,
				on: null,
				collapsed: false,
				name: null
			};
			if (!skipInject) {
				target.rows.push(row);
				this.$services.page.normalizeAris(this.page, row, "row");
			}
			return row;
		},
		addPageParameter: function() {
			if (!this.page.content.parameters) {
				Vue.set(this.page.content, "parameters", []);
			}
			this.page.content.parameters.push({
				name: null,
				type: null,
				format: null,
				default: null,
				global: false,
				// we can listen to events and take a value from them to update the current value
				// e.g. we could update a search parameter if you select something
				listeners: []
			});
		},
		removeRow: function(row) { 
			this.page.content.rows.splice(this.page.content.rows(indexOf(row), 1))
		},
		resetEvents: function() {
			this.cachedEvents = null;
		},
		getDraggables: function() {
			var result = {};
			var self = this;
			Object.keys(this.components).map(function(cellId) {
				var component = self.components[cellId];
				var handle = function(component) {
					// pages will _not_ send their events by default to other pages (only through global events)
					// so this we skip the page components in this listing
					if (component && component.getDraggables && !self.$services.page.isPage(component)) {
						var cellDraggables = component.getDraggables();
						if (cellDraggables) {
							Object.keys(cellDraggables).forEach(function(key) {
								result[key] = cellDraggables[key];
							});
						}
					}
				}
				if (component instanceof Array) {
					component.forEach(handle);
				}
				else {
					handle(component);
				}
			});
			return result;
		},
		getStateEvents: function() {
			return {
				"change": {}
			};
		},
		getEvents: function() {
			// non-watched cache property
			// we have too many problems with update loops that are triggered by this method
			// and in general the result should only change if we route new content
			if (!this.cachedEvents) {
				var events = {
					"$configure": {properties:{}},
					"$clear": {properties:{}},
					"$load": {properties:{}}
				};
				
				var self = this;
				this.cachedEvents = events;
				
				// check which events are picked up globally
				if (this.page.content.globalEventSubscriptions) {
					var globalEventDefinitions = this.$services.page.getGlobalEvents();
					this.page.content.globalEventSubscriptions.map(function(sub) {
						events[sub.localName == null ? sub.globalName : sub.localName] = globalEventDefinitions[sub.globalName] ? globalEventDefinitions[sub.globalName] : {properties:{}};	
					});
				}
				
				// your page actions can trigger success events
				if (this.page.content.actions) {
					this.page.content.actions.filter(function(x) { return x.event != null && x.operation != null }).map(function(action) {
						if (self.$services.swagger.operations[action.operation] == null) {
							console.error("Could not find operation for action", action.operation, action.name, action.event);
						}
						else {
							var response = self.$services.swagger.operations[action.operation].responses["200"];
							var schema = null;
							if (response && response.schema) {
								schema = self.$services.swagger.resolve(response.schema);
							}
							// we only want the array in it
							if (action.singlify) {
								var theParts = action.singlify.split(".");
								for (var i = 0; i < theParts.length; i++) {
									schema = schema.properties[theParts[i]];
								}
								if (schema.items) {
									schema = schema.items;
								}
							}
							events[action.event] = schema ? schema : {};
						}
					});
					this.page.content.actions.filter(function(x) { return x.errorEvent != null && x.operation != null }).map(function(action) {
						events[action.errorEvent] = self.$services.swagger.resolve("#/definitions/StructuredErrorResponse");
					});
					this.page.content.actions.filter(function(action) {
						return nabu.page.event.getName(action, "chainEvent") != null;
					}).forEach(function(action) {
						var type = nabu.page.event.getType(action, "chainEvent");
						if (type.properties && Object.keys(type.properties).length == 0 && action.on) {
							type = action.on;
						}
						events[nabu.page.event.getName(action, "chainEvent")] = type;
					});
					this.page.content.actions.filter(function(action) {
						return nabu.page.event.getName(action, "timeoutEvent") != null;
					}).forEach(function(action) {
						var type = nabu.page.event.getType(action, "timeoutEvent");
						if (type.properties && Object.keys(type.properties).length == 0 && action.on) {
							type = action.on;
						}
						events[nabu.page.event.getName(action, "timeoutEvent")] = type;
					});
					this.page.content.actions.filter(function(action) {
						return nabu.page.event.getName(action, "downloadFailedEvent") != null;
					}).forEach(function(action) {
						var type = nabu.page.event.getType(action, "downloadFailedEvent");
						if (type.properties && Object.keys(type.properties).length == 0 && action.on) {
							type = action.on;
						}
						events[nabu.page.event.getName(action, "downloadFailedEvent")] = type;
					});
					this.page.content.actions.filter(function(action) {
						return action.function && action.functionOutputEvent;
					}).forEach(function(action) {
						events[action.functionOutputEvent] = self.$services.page.getFunctionOutputFull(action.function);
					});
				}
				
				nabu.utils.objects.merge(events, this.$services.triggerable.getEvents(this.page, this.page.content));
				
				// add the cell events
				this.page.content.rows.map(function(row) {
					self.getNestedEvents(row, events);
				});
				
				Object.keys(this.components).map(function(cellId) {
					var component = self.components[cellId];
					if (component) {
						var handle = function(component) {
							// pages will _not_ send their events by default to other pages (only through global events)
							// so this we skip the page components in this listing
							if (component && component.getEvents && !self.$services.page.isPage(component)) {
								var cellEvents = component.getEvents();
								if (cellEvents) {
									// if you have no particular content, you can just send the name of the event
									if (typeof(cellEvents) == "string") {
										events[cellEvents] = {};
									}
									else if (cellEvents instanceof Array) {
										// TODO: support arrays of strings and/or objects?
									}
									else {
										Object.keys(cellEvents).map(function(key) {
											events[key] = cellEvents[key];
										});
									}
								}
							}
						}
						if (component instanceof Array) {
							component.forEach(handle);
						}
						else {
							handle(component);
						}
						// get potential trigger target
						var triggerTarget = component.target ? component.target : (component.cell ? component.cell : component.row);
						if (triggerTarget && triggerTarget.triggers) {
							nabu.utils.objects.merge(events, self.$services.triggerable.getEvents(self.page, triggerTarget, component));
						}
					}
				});
				Object.keys(events).map(function(name) {
					// because events can reference one another in circular fashion, we allow for event references
					// this means if the value is a string rather than an array of fields, we assume it is the name of another event and we should use those parameters
					if (typeof(events[name]) == "string") {
						if (events[events[name]]) {
							events[name] = events[events[name]];
						}
						else {
							console.warn("Can not find event: " + events[events[name]]);
							events[name] = {};
						}
					}
				});
				
				if (this.page.content.initialEvents) {
					this.page.content.initialEvents.forEach(function(event) {
						var name = nabu.page.event.getName(event, "definition");
						if (name) {
							events[name] = nabu.page.event.getType(event, "definition");
						}
					});
				}
				
				if (this.page.content.states) {
					this.page.content.states.forEach(function(state) {
						var name = nabu.page.event.getName(state, "updateEvent");
						if (name) {
							events[name] = nabu.page.event.getType(state, "updateEvent");
						}
						if (state.triggers) {
							nabu.utils.objects.merge(events, self.$services.triggerable.getEvents(self.page, state));
						}
					});
				}
			}
			return this.cachedEvents;
		},
		getRendererEvents: function(name, target) {
			var renderer = nabu.page.providers("page-renderer").filter(function(x) { return x.name == name })[0];
			var result = null;
			if (renderer && renderer.getEvents) {
				result = renderer.getEvents(target);
			}
			return result ? result : {};
		},
		getNestedEvents: function(cellContainer, events) {
			if (cellContainer.renderer) {
				nabu.utils.objects.merge(events, this.getRendererEvents(cellContainer.renderer, cellContainer));
			}
			var self = this;
			if (cellContainer.cells) {
				cellContainer.cells.forEach(function(cell) {
					if (cell.renderer) {
						nabu.utils.objects.merge(events, self.getRendererEvents(cell.renderer, cell));
					}
					
					if (nabu.page.event.getName(cell, "clickEvent")) {
						events[nabu.page.event.getName(cell, "clickEvent")] = nabu.page.event.getType(cell, "clickEvent");
					}
					// <DEPRECATED>
					if (cell.clickEvent && typeof(cell.clickEvent) == "string") {
						events[cell.clickEvent] = {
							properties: {
								value: {
									type: "string"
								}
							}
						};
					}
					// </DEPRECATED>
					if (cell.rows) {
						cell.rows.map(function(row) {
							self.getNestedEvents(row, events);
						});
					}
				});
			}
		},
		subscribe: function(event, handler) {
			if (!this.subscriptions[event]) {
				this.subscriptions[event] = [];
			}
			this.subscriptions[event].push(handler);
			var self = this;
			return function() {
				var index = self.subscriptions[event].indexOf(handler);
				if (index >= 0) {
					self.subscriptions[event].splice(index, 1);
				}
			};
		},
		reset: function(name) {
			Vue.delete(this.variables, name);
		},
		calculateVariable: function(script) {
			try {
				return this.$services.page.eval(script, this.variables, this);
			}
			catch (exception) {
				console.warn("Could not execute script", script, exception);
				return null;
			}
		},
		isBinaryDownload: function(operationId) {
			var operation = this.$services.swagger.operations[operationId];
			return operation && operation.method == "get" && operation.produces && operation.produces.length && operation.produces[0] == "application/octet-stream";
		},
		emit: function(name, value, reset) {
			this.$services.page.report("emit", this.page.content.name, null, name, value);
			var self = this;

			// used to be a regular assign and that seemed to work as well?
			Vue.set(this.variables, name, value);
			
			var promises = [];
			
			if (!reset) {
				if (this.page.content.analysis) {
					this.page.content.analysis.filter(function(x) { return x.on == name }).map(function(analysis) {
						if (analysis.condition && !self.$services.page.isCondition(analysis.condition, value, self)) {
							return;
						}
						var pageInstance = self.$services.page.getPageInstance(self.page, self);
						var content = nabu.page.event.getInstance(analysis, "chainEvent", self.page, self);
						self.$services.analysis.push({
							pageName: self.page.content.name,
							pageCategory: self.page.content.category,
							category: "trigger",
							type: "page-analysis",
							event: nabu.page.event.getName(analysis, "chainEvent"),
							// more consistent with the eventing backend
							content: content,
							// DEPRECATED: needed for backwards compatibility
							data: content
						});
					})
				}
				if (this.page.content.notifications) {
					this.page.content.notifications.filter(function(x) { return x.on == name }).map(function(notification) {
						if (notification.condition && !self.$services.page.isCondition(notification.condition, value, self)) {
							return;
						}
						var pageInstance = self.$services.page.getPageInstance(self.page, self);
						// we take a copy to enrich it (if necessary)
						var notificationContent = value ? nabu.utils.objects.clone(value) : {}; 
						var content = nabu.page.event.getInstance(notification, "chainEvent", self.page, self);
						if (content) {
							Object.keys(content).forEach(function(key) {
								notificationContent[key] = content[key];	
							});
						}
						// we clone the notification so we can enrich it with the data
						var result = nabu.utils.objects.clone(notification);
						// interpret the results
						Object.keys(result).forEach(function(key) {
							result[key] = self.$services.page.interpret(self.$services.page.translate(result[key]), self, notificationContent);
						});
						result.data = notificationContent;
						self.$services.notifier.push(result);
					})
				}
				// check all the actions to see if we need to run something
				this.page.content.actions.map(function(action) {
					
					if (action.on == name) {
						// if we have a condition, run it
						if (action.condition && !self.$services.page.isCondition(action.condition, value, self)) {
							return;
						}
						
						var promise = self.$services.q.defer();
						
						var runFunction = function() {
							if (action.isSlow) {
								self.$wait({promise: promise});
							}
							var func = self.$services.page.getRunnableFunction(action.function);
							if (!func) {
								throw "Could not find function: " + action.function; 
							}
							var input = {};
							if (action.bindings) {
								var pageInstance = self;
								Object.keys(action.bindings).forEach(function(key) {
									if (action.bindings[key]) {
										var value = self.$services.page.getBindingValue(pageInstance, action.bindings[key], self);
										self.$services.page.setValue(input, key, value);
									}
								});
							}
							var result = self.$services.page.runFunction(func, input, self, promise);
							if (action.functionOutputEvent) {
								var def = self.$services.page.getFunctionDefinition(action.function);
								if (def.async) {
									promise.then(function(asyncResult) {
										self.emit(action.functionOutputEvent, asyncResult ? asyncResult : {});
									});
								}
								else {
									self.emit(action.functionOutputEvent, result ? result : {});
								}
							}
							return result;
						}
						
						var runScript = function() {
							if (action.script) {
								var script = action.script;
								// if we don't wrap it in a function, it might only execute the first line
								// when dealing with formatting or conditions that might be wanted
								// however, in this location we want to execute a full script, we are not assigning or conditioning
								if (script.trim().indexOf("function") != 0) {
									script = "function(){ " + script + "}";
								}
								self.$services.page.eval(script, self.variables, self);
							}
						}
						
						promises.push(promise);
						var parameters = {};
						Object.keys(action.bindings).map(function(key) {
							self.$services.page.setValue(parameters, key, self.$services.page.getBindingValue(self, action.bindings[key]));
						});
						
						var eventReset = function() {
							// if we are emitting a "null" value for the current event, we don't want to trigger the reset listeners!
							if (action.eventResets != null && value != null) {
								action.eventResets.forEach(function(event) {
									self.emit(event, null, true);
								});
							}
						};
						
						var date = new Date();
						var stop = function(error) {
							if (action.name) {
								self.$services.analysis.push({
									pageName: self.page.content.name,
									pageCategory: self.page.content.category,
									category: "trigger",
									type: "page-trigger",
									event: action.name
								});
							}
						};
						
						if (nabu.page.event.getName(action, "chainEvent")) {
							promise.then(function() {
								var pageInstance = self.$services.page.getPageInstance(self.page, self);
								var content = nabu.page.event.getInstance(action, "chainEvent", self.page, self);
								if (Object.keys(content).length == 0) {
									content = value;
								}
								var doIt = function() {
									pageInstance.emit(
										nabu.page.event.getName(action, "chainEvent"),
										content
									);
								}
								if (action.chainTimeout) {
									setTimeout(doIt, parseInt(action.chainTimeout));
								}
								else {
									doIt();
								}
							});
						}
						promise.then(function() { stop() }, function(error) { stop(error) });
						
						var wait = !action.timeout || !nabu.page.event.getName(action, "timeoutEvent") ? null : function() {
							var content = nabu.page.event.getInstance(action, "timeoutEvent", self.page, self);
							if (Object.keys(content).length == 0) {
								content = value;
							}
							self.emit(
								nabu.page.event.getName(action, "timeoutEvent"),
								content
							);
						}
						
						var emitDownloadFailed = function() {
							if (nabu.page.event.getName(action, "downloadFailedEvent")) {
								self.emit(
									nabu.page.event.getName(action, "downloadFailedEvent"),
									nabu.page.event.getInstance(action, "downloadFailedEvent", self.page, self)
								);
							}
						}
						
						if (action.confirmation) {
							self.$confirm({message:self.$services.page.translate(self.$services.page.interpret(action.confirmation, self))}).then(function() {
								if (wait) {
									self.$services.q.wait(promise, parseInt(action.timeout), wait);
								}
								var element = null;
								var async = false;
								// already get the element, it can be triggered with or without a route
								if (action.scroll) {
									var element = document.querySelector(action.scroll);
									if (!element) {
										element = document.getElementById(action.scroll);
									}
								}
								if (action.url) {
									var url = self.$services.page.interpret(action.url, self);
									if (action.anchor == "$blank") {
										window.open(url);
									}
									else {
										window.location = url;
									}
								}
								else if (action.route) {
									var routePromise = null;
									eventReset();
									if (action.anchor == "$blank") {
										window.open(self.$services.router.template(action.route, parameters));
									}
									else if (action.anchor == "$window") {
										window.location = self.$services.router.template(action.route, parameters);
									}
									else {
										routePromise = self.route(action.route, parameters, action.anchor ? action.anchor : null, action.anchor ? true : false);
									}
									if (element) {
										if (routePromise && routePromise.then) {
											routePromise.then(function() {
												element.scrollIntoView();
											});
										}
										else {
											element.scrollIntoView();
										}
									}
								}
								else if (action.scroll) {
									eventReset();
									if (element) {
										element.scrollIntoView();
									}
								}
								else if (action.operation && self.isGet(action.operation) && action.anchor == "$blank") {
									window.open(self.$services.swagger.parameters(action.operation, parameters).url, "_blank");
								}
								else if (action.operation) {
									if (action.isSlow) {
										self.$wait({promise: promise});
									}
									var operation = self.$services.swagger.operations[action.operation];
									// currently we hardcode an exception for this service
									// in the future we should use swagger extensions to mark the id & secret fields for downloads with temporary authentication
									// that way we can support it for more services
									if (operation.operationId == "nabu.cms.attachment.rest.internal.get") {
										this.$services.attachment.download(parameters.nodeId, parameters.attachmentId);
										eventReset();
									}
									else if (operation.method == "get" && operation.produces && operation.produces.length && operation.produces[0] == "application/octet-stream") {   
										if (action.anchor != "$window") {
											self.$services.page.download(self.$services.swagger.parameters(action.operation, parameters).url, emitDownloadFailed);
										}
										else {
											window.location = self.$services.swagger.parameters(action.operation, parameters).url;
										}
										eventReset();
									}
									else {
										async = true;
										self.$services.swagger.execute(action.operation, parameters).then(function(result) {
											if (action.singlify) {
												var arr = self.$services.page.getValue(result, action.singlify);
												result = arr && arr.length > 0 ? arr[0] : null;
											}
											if (action.event) {
												// we get null from a 204
												self.emit(action.event, result == null ? {} : result);
											}
											eventReset();
											promise.resolve(result);
										}, function(error) {
											if (action.errorEvent) {
												self.emit(action.errorEvent, error);
											}
											promise.reject(error);
										});
									}
								}
								else if (action.function) {
									runFunction();
								}
								else {
									eventReset();
								}
								runScript();
								if (!async) {
									promise.resolve();
								}
							}, function() {
								promise.reject();
							})
						}
						else {
							if (wait) {
								self.$services.q.wait(promise, parseInt(action.timeout), wait);
							}
							var async = false;
							if (action.url) {
								var url = self.$services.page.interpret(action.url, self);
								if (action.anchor) {
									window.open(url);
								}
								else {
									window.location = url;
								}
							}
							else if (action.scroll) {
								eventReset();
								var element = document.querySelector(action.scroll);
								if (!element) {
									element = document.getElementById(action.scroll);
								}
								if (element) {
									element.scrollIntoView();
								}
							}
							else if (action.route) {
								eventReset();
								if (action.anchor == "$blank") {
									window.open(self.$services.router.template(action.route, parameters));
								}
								else if (action.anchor == "$window") {
									window.location = self.$services.router.template(action.route, parameters);
								}
								else {
									self.route(action.route, parameters, action.anchor ? action.anchor : null, action.anchor ? true : false);
								}
							}
							else if (action.operation && self.isGet(action.operation) && action.anchor == "$blank") {
								window.open(self.$services.swagger.parameters(action.operation, parameters).url, "_blank");
							}
							else if (action.operation) {
								if (action.isSlow) {
									self.$wait({promise: promise});
								}
								var operation = self.$services.swagger.operations[action.operation];
								if (operation.operationId == "nabu.cms.attachment.rest.internal.get") {
									this.$services.attachment.download(parameters.nodeId, parameters.attachmentId);
									eventReset();
								}
								else if (operation.method == "get" && operation.produces && operation.produces.length && operation.produces[0] == "application/octet-stream") {
									if (action.anchor != "$window") {
										self.$services.page.download(self.$services.swagger.parameters(action.operation, parameters).url, emitDownloadFailed);
									}
									else {
										window.location = self.$services.swagger.parameters(action.operation, parameters).url;
									}
									eventReset();
								}
								else {
									async = true;
									self.$services.swagger.execute(action.operation, parameters).then(function(result) {
										if (action.singlify) {
											var arr = self.$services.page.getValue(result, action.singlify);
											result = arr && arr.length > 0 ? arr[0] : null;
										}
										if (action.event) {
											// we get null from a 204
											self.emit(action.event, result == null ? {} : result);
										}
										eventReset();
										promise.resolve(result);
									}, function(error) {
										if (action.errorEvent) {
											self.emit(action.errorEvent, error);
										}
										promise.reject(error);
									});
								}
							}
							else if (action.function) {
								runFunction();
							}
							else {
								eventReset();
							}
							runScript();
							if (!async) {
								promise.resolve();
							}
						}
					}
				});
				
				promises.push(this.$services.triggerable.trigger(this.page.content, name, value, this));
			}
			
			if (this.subscriptions[name]) {
				this.subscriptions[name].forEach(function(handler) {
					var result = handler(value);
					if (result && result.then) {
						promises.push(result);
					}
				});
			}
			else if (this.subscriptions["$any"]) {
				this.subscriptions["$any"].forEach(function(handler) {
					var result = handler(name, value);
					if (result && result.then) {
						promises.push(result);
					}
				});
			}
			
			// check states that have to be refreshed
			if (this.page.content.states.length && !reset) {
				var sendStateEvent = function(state) {
					if (nabu.page.event.getName(state, "updateEvent")) {
						self.emit(
							nabu.page.event.getName(state, "updateEvent"),
							nabu.page.event.getInstance(state, "updateEvent", self.page, self)
						);
					}
				}
				nabu.utils.arrays.merge(promises, this.page.content.states.filter(function(x) { 
					return x.refreshOn != null && x.refreshOn.indexOf(name) >= 0
						&& (!x.condition || self.$services.page.isCondition(x.condition, self.variables, self));
				}).map(function(state) {
					// replaced with utility function
					/*
					if (state.inherited) {
						return self.$services.page.reloadState(state.applicationName).then(function(result) {
							//Vue.set(self.variables, state.name, result ? result : null);
							sendStateEvent(state);
						});
					}
					else {
						var parameters = {};
						Object.keys(state.bindings).map(function(key) {
							parameters[key] = self.$services.page.getBindingValue(self, state.bindings[key]);
						});
						if (!parameters["$serviceContext"]) {
							parameters["$serviceContext"] = self.get("page.$serviceContext");
						}
						try {
							// can throw hard errors
							return self.$services.swagger.execute(state.operation, parameters).then(function(result) {
								if (self.variables[state.name] != null) {
									if (self.variables[state.name] instanceof Array) {
										self.variables[state.name].splice(0);
										if (result instanceof Array) {
											nabu.utils.arrays.merge(self.variables[state.name], result);
										}
										else if (result) {
											self.variables[state.name].push(result);
										}
									}
									// can be resetting to null
									else if (!result) {
										Vue.set(self.variables, state.name, null);
									}
									else {
										var resultKeys = Object.keys(result);
										Object.keys(self.variables[state.name]).forEach(function(key) {
											if (resultKeys.indexOf(key) < 0) {
												self.variables[state.name][key] = null;
											}
										});
										// make sure we use vue.set to trigger other reactivity
										resultKeys.forEach(function(key) {
											Vue.set(self.variables[state.name], key, result[key]);
										});
										// TODO: do a proper recursive merge to maintain reactivity with deeply nested
										
										//nabu.utils.objects.merge(self.variables[state.name], result);
									}
								}
								else {
									Vue.set(self.variables, state.name, result ? result : null);
								}
								sendStateEvent(state);
							});
						}
						catch (exception) {
							console.error("Could not execute", state.operation, exception);
							var promise = self.$services.q.defer();
							promise.reject(exception);
							return promise;
						}
					}*/
					return self.loadInitialState(state, true);
				}));
			}
			
			// remove all the closed stuff for this event, we may want to reopen something
			Object.keys(this.closed).map(function(key) {
				if (self.closed[key] == name) {
					Vue.set(self.closed, key, null);
				}
			});
			return this.$services.q.all(promises).then(function() {
				if (self.page.content.globalEvents && !reset) {
					var globalEvent = self.page.content.globalEvents.filter(function(x) {
						return x.localName == name;
					})[0];
					if (globalEvent) {
						self.$services.page.emit(globalEvent.globalName ? globalEvent.globalName : name, value, reset);
					}
				}
			});
		},
		loadState: function(name, initial) {
			var promise = this.$services.q.defer();
			var state = this.page.content.states.filter(function(x) {
				return x.name == name;
			})[0];
			if (state) {
				var result = this.loadInitialState(state, !initial);
				if (result && result.then) {
					result.then(promise, promise);
				}
				else {
					promise.reject();
				}
			}
			else {
				this.loadParameterState(name, !initial);
				promise.resolve();
			}
			return promise;
		},
		loadParameterState: function(parameter, reload) {
			var self = this;
			parameter = self.page.content.parameters.filter(function(x) {
				return x == parameter || x.name == parameter;
			})[0];
			if (parameter) {
				self.initializeDefaultParameters(true, [parameter.name], true);
				/*
				if (reload) {
					if (nabu.page.event.getName(parameter, "updatedEvent")) {
						self.emit(
							nabu.page.event.getName(parameter, "updatedEvent"),
							nabu.page.event.getInstance(parameter, "updatedEvent", self.page, self)
						);
					}
				}
				*/
			}
		},
		loadInitialState: function(state, reload) {
			// you can pass in the full state or the name of a state
			state = this.page.content.states.filter(function(x) {
				return x == state || x.name == state;
			})[0];
			if (state) {
				var self = this;
				var sendStateEvent = function(state) {
					if (nabu.page.event.getName(state, "updateEvent")) {
						self.emit(
							nabu.page.event.getName(state, "updateEvent"),
							nabu.page.event.getInstance(state, "updateEvent", self.page, self)
						);
					}
				}
				if (state.inherited) {
					if (reload) {
						return self.$services.page.reloadState(state.applicationName).then(function(result) {
							//Vue.set(self.variables, state.name, result ? result : null);
							sendStateEvent(state);
						});
					}
				}
				else {
					var parameters = {};
					Object.keys(state.bindings).map(function(key) {
						parameters[key] = self.$services.page.getBindingValue(self, state.bindings[key]);
					});
					if (!parameters["$serviceContext"]) {
						parameters["$serviceContext"] = self.getServiceContext();
					}
					try {
						var promise = self.$services.q.defer();
						// can throw hard errors
						self.$services.swagger.execute(state.operation, parameters).then(function(result) {
							if (self.variables[state.name] != null) {
								if (self.variables[state.name] instanceof Array) {
									self.variables[state.name].splice(0);
									if (result instanceof Array) {
										nabu.utils.arrays.merge(self.variables[state.name], result);
									}
									else if (result) {
										self.variables[state.name].push(result);
									}
								}
								// can be resetting to null
								else if (!result) {
									Vue.set(self.variables, state.name, null);
								}
								else {
									var resultKeys = Object.keys(result);
									Object.keys(self.variables[state.name]).forEach(function(key) {
										if (resultKeys.indexOf(key) < 0) {
											self.variables[state.name][key] = null;
										}
									});
									// make sure we use vue.set to trigger other reactivity
									resultKeys.forEach(function(key) {
										Vue.set(self.variables[state.name], key, result[key]);
									});
									// TODO: do a proper recursive merge to maintain reactivity with deeply nested
									
									//nabu.utils.objects.merge(self.variables[state.name], result);
								}
							}
							else {
								Vue.set(self.variables, state.name, result ? result : null);
							}
							// deprecated
							sendStateEvent(state);
							
							// the triggerInitial is a boolean we might add if we want to trigger on initial load as well
							self.$services.triggerable.trigger(state, reload ? "update" : "initial", null, self).then(promise, promise);
						}, promise);
						return promise;
					}
					catch (exception) {
						console.error("Could not execute", state.operation, exception);
						var promise = self.$services.q.defer();
						promise.reject(exception);
						return promise;
					}
				}
			}
		},
		addGlobalEvent: function() {
			if (!this.page.content.globalEvents) {
				Vue.set(this.page.content, "globalEvents", []);
			}
			this.page.content.globalEvents.push({localName: null, globalName: null});
		},
		addGlobalEventSubscription: function() {
			if (!this.page.content.globalEventSubscriptions) {
				Vue.set(this.page.content, "globalEventSubscriptions", []);
			}
			this.page.content.globalEventSubscriptions.push({localName: null, globalName: null});
		},
		getLabel: function(name) {
			// state can be dynamically inserted and removed without triggering new labels
			// usually when state is manipulated into an actual value, it _does_ go through the proper channels, but specifically state resets are generally not well supported
			// check comments in destroyComponent()
			
			// the workaround is getting the original value. if its null, we assume there is no label value either
			// note that this prevents setting a label for null though...
			// for "default" values that are set when rerendering, this will not work if you have an actual label. most fields don't have labels though
			var value = this.get(name);
			if (value == null) {
				return null;
			}
			return this.$services.page.getValue(this.labels, name);	
		},
		setLabel: function(name, label) {
			this.$services.page.setValue(this.labels, name, label);
		},
		get: function(name) {
			// probably not filled in the value yet
			if (!name) {
				return null;
			}
//			if (this.fragmentParent && (name == "$serviceContext" || name == "page.$serviceContext")) {
//				return this.fragmentParent.get(name);
//			}
			if (name == "page") {
				return this.fragmentParent ? this.fragmentParent.get(name) : this.variables;
			}
			else if (name == "page.$this" || name == "$page" || name == "$this") {
				return this.fragmentParent ? this.fragmentParent.get(name) : this;
			}
			else if (name == "parent.$this" || name == "$parent") {
				var parentInstance = this.page.content.pageParent ? this.$services.page.getPageInstanceByName(this.page.content.pageParent) : null;
				if (parentInstance == null) {
					parentInstance = this.$services.page.getParentInstance(this);
				}
				return parentInstance;
			}
			else if (name == "parent") {
				var parentInstance = this.page.content.pageParent ? this.$services.page.getPageInstanceByName(this.page.content.pageParent) : null;
				if (parentInstance == null) {
					parentInstance = this.$services.page.getParentInstance(this);
				}
				return parentInstance ? parentInstance.variables : null;
			}
			else if (name == "application.title") {
				return this.$services.page.title;
			}
			else if (name.indexOf("application.") == 0) {
				var name = name.substring("application.".length);
				var value = this.$services.page.properties.filter(function(x) {
					return x.key == name;
				})[0];
				if (value == null) {
					value = this.$services.page.environmentProperties.filter(function(x) {
						return x.key == name;
					})[0];
				}
				return value ? value.value : null;
			}
			else if (name.indexOf("parent.") == 0) {
				// TODO: to be verified that this work in a stable way
				// the problem we have is: you want to persist state at for example the skeleton level
				// however, some pages might be nested in other pages (especially page components)
				// they don't need to / want to know the depth at which they are rendered (and this may differ)
				// so instead of going up 1 level, we want to check all levels until we find a match
				// the potential problems can arise if there is a recursive loop possibly in this structure
				var name = name.substring("parent.".length);
				var parentInstance = this.page.content.pageParent ? this.$services.page.getPageInstanceByName(this.page.content.pageParent) : this.$services.page.getParentInstance(this);
				//var result = parentInstance ? parentInstance.get("page." + name) : null;
				var result = parentInstance ? parentInstance.get(name) : null;
				if (result == null && parentInstance) {
					result = parentInstance.get("parent." + name);
					//var parentInstance = this.$services.page.getParentPageInstance(parentInstance ? parentInstance.page : this.page, parentInstance ? parentInstance : this);
					//if (parentInstance) {
					//	result = parentInstance.get("parent." + name);
					//}
				}
				return result;
			}
			else if (name.indexOf("page.") == 0) {
				var name = name.substring("page.".length);
				var dot = name.indexOf(".");
				var localName = dot >= 0 ? name.substring(0, dot) : name;
				var relativeName = dot >= 0 ? name.substring(dot + 1) : null;
				var applicationProperty = this.$services.page.properties.filter(function(property) {
					return property.key == localName;
				})[0];
				var pageParameter = this.page.content.parameters ? this.page.content.parameters.filter(function(parameter) {
					return parameter.name == localName;
				})[0] : null;
				var stateParameter = this.page.content.states ? this.page.content.states.filter(function(state) { return state.name == localName })[0] : null;
				
				var result = null;
				if (applicationProperty) {
					result = applicationProperty.value;
				}
				else if (pageParameter != null) {
					result = this.variables[pageParameter.name];
				}
				else if (stateParameter != null) {
					result = this.variables[stateParameter.name];
				}
				else {
					result = this.parameters ? this.parameters[name] : null;
					// best effort get from local variables
					if (result == null) {
						result = this.variables[localName];
					}
					// cascade to fragment parent BEFORE we do the next bit
					if (result == null && this.fragmentParent) {
						result = this.fragmentParent.get(name);
					}
					// if it exists nowhere else, we will create an entry for it in variables
					// at least then there is SOMETHING to bind to reactively, if we _do_ get the state at a later point in variables, it should be reactive
					if (result == null) {
						if (!this.variables.hasOwnProperty(localName)) {
							Vue.set(this.variables, localName, null);
						}
						result = this.variables[localName];
					}
				}
				if (result != null && relativeName != null) {
					var parts = relativeName.split(".");
					for (var i = 0; i < parts.length; i++) {
						result = result[parts[i]];
						if (result == null) {
							break;
						}
					}
				}
				return result;
			}
			// note: currently this is slightly out of sync with "page." logic
			// the problem is if you simply do get("queryParameter"), it won't work
			// because query paramters are not available in variables
			// solution 1: copy all page parameters to variables (this is likely the best option though it may break reactivity of query parameters?)
			// solution 2: add resolving here to also check the page parameters.
			// workaround: use "page.queryParameter" syntax to resolve (currently used until decision is made) for example by page form components
			// note that set() also suffers from the same problem it seems!
			else {
				
				// let's check if there is a provider for it
				var result = null;
				// check if there is a provider for it
				nabu.page.providers("page-bindings").forEach(function(provider) {
					var provided = provider();
					if (Object.keys(provided.definition).indexOf(parts[0]) >= 0) {
						result = provided.resolve(name.substring(name.indexOf(".") + 1));
					}
				});
				// if we found it through a provider, so be it
				if (result != null) {
					return result;
				}
				
				// at this point, it _has_ to be in variables
				// note that (like above with page.) if there is a value missing we want an empty value in variables so it is at least responsive if we do eventually get the value
				
				var parts = name.split(".");
				if (!this.variables.hasOwnProperty(parts[0])) {
					Vue.set(this.variables, parts[0], null);
				}
				result = this.variables[parts[0]];
				
				// we want a whole variable
				if (result == null || parts.length == 1 || (parts.length == 2 && parts[1] == "$all")) {
					return result;
				}
				
				var value = this.variables[parts[0]];
				for (var i = 1; i < parts.length; i++) {
					if (value) {
						if (value instanceof Array) {
							value = value.map(function(x) { return x[parts[i]] });
						}
						else {
							value = value[parts[i]];
						}
					}
				}
				return value;
			}
		},
		savePage: function() {
			if (this.savePageTimer) {
				clearTimeout(this.savePageTimer);
				this.savePageTimer = null;
			}
			var self = this;
			this.savePageTimer = setTimeout(function() {
				self.$services.page.update(self.page);
			}, 300);
		},
		isDevelopment: function() {
			return true;	
		},
		hasLanguageSet: function() {
			// the current value can be automatically deduced from the browser settings instead of an active choice by the user
			// the cookieValue is only present if the user has actively chosen a language so check that to allow "unsetting" of the value for json manipulation
			return this.$services.language.current && this.$services.language.cookieValue;
		},
		// the idea was to force the user to select a language if none is selected
		// this however may not be possible if the site does not actually support multiple languages (the language service is always injected if you have CMS)
		triggerConfiguration: function() {
			// if you trigger the $configure event, it is usually for page parameter editing
			// if you don't have a selected language, the result will be stored in the JSON itself
			// this is OK (and intended) for development to have default content but not OK in for example qlty where:
			// a) you might be in a cluster (and only save the json on one server) 
			// b) changes are overwritten on the next deployment
			// so if there is no language service alltogether, we have no option but to store it in the json
			// otherwise you can only "not" have a language if you are in development mode
			if (this.isDevelopment() || !this.$services.language || this.$services.language.current) {
				this.emit("$configure", {});
			}
			else {
				this.$confirm({
					message: "You must select a language"
				});
			}
		},
		setRouteParameters: function(parameters) {
			var blacklist = ["page", "cell", "childComponents", "edit", "pageInstanceId", "stopRerender"];
			var self = this;
			Object.keys(parameters).forEach(function(key) {
				if (blacklist.indexOf(key) < 0) {
					// @2024-10-10: if it does not have the prefix "page", it is sometimes assumed to be in variables which means it will not be correctly picked up as an actual parameter change
					// in theory, route parameters are always page level parameters so it should be fine to prefix them like this, this needs further testing though....
					var finalKey = key;
					if (key.indexOf("page.") != 0) {
						finalKey = "page." + key;
					}
					console.log("setting", key, finalKey, parameters[key]);
					self.set(finalKey, parameters[key]);
				}
			});
			return false;
		},
		set: function(name, value, label) {
			// we added support for custom setting specifically for fragment pages like repeat
			// we create fragment pages usually because we want to scope some state
			// however, when we want to update said state we might not know conclusively where it lives
			// the repeat (and others) can provide a custom set that knows enough of the fragments to decide where the data should go
			if (this.$setValue instanceof Function) {
				this.$setValue(this, name, value, label);
			}
			else {
				this.internalSet(name, value, label);
			}
		},
		internalSet: function(name, value, label) {
			var target = null;
			var parts = null;
			var updateUrl = false;
			// update something in the page parameters
			if (name.indexOf && name.indexOf("page.") == 0) {
				var pageParameter = this.page.content.parameters ? this.page.content.parameters.filter(function(parameter) {
					return parameter.name == name.substring("page.".length).split(".")[0];
				})[0] : null;
				parts = name.substring("page.".length).split(".");
				// @2025-05-20 you can expose a variable as internal AND query parameter
				// so we might also want to update the url when updating an internal page parameter
				var isPublicParameter = this.$services.page.isPublicPageParameter(this.page, name.substring("page.".length));
				if (pageParameter) {
					target = this.variables;
					updateUrl = isPublicParameter && !this.masked;
				}
				else if (isPublicParameter) {
					// check if it is explicitly a query or path parameter, if not, we still put it in the variables!!
					// otherwise we might accidently update the parameters object which is passed along to all children
					target = this.parameters;
					// @2024-03-08: only update the url if we have a public parameter, previously it was updating on _every_ set
					if (!this.masked) {
						updateUrl = true;
					}
				}
				else {
					target = this.variables;
				}
			}
			else if (name.split) {
				parts = name.split(".");
				// we can set the component state without the page. prefix
				target = this.variables;
			}
			// TODO: if single input, single output => can automatically bypass transformer?
			// or set a reverse transformer?
			// for now, transformers are only for going forward, not syncing data back, use events + reload if needed atm
			if (parts && target) {
				for (var i = 0; i < parts.length - 1; i++) {
					if (!target[parts[i]]) {
						Vue.set(target, parts[i], {});
					}
					target = target[parts[i]];
				}
				Vue.set(target, parts[parts.length - 1], value);
				// always set label (can be an unset)
				// in the past we set the label to the value if not filled in. however, this means we _have_ to clean it up every time
				// it is not perfect but by setting the label to null, we at least narrow the cleanup routines to those values that actually have a label
				// unclear if all components support this!
				this.$services.page.setValue(this.labels, name, label == null || label == value ? null : label);
				if (updateUrl) {
					// @2024-03-08: the original update did not take into account paths in the parents
					// it is still not entirely clean though because the template internally does a templateUrl as does the updateUrl
					// router needs to get cleaned up
					var route = this.$services.router.get(this.$services.page.alias(this.page));
					if (route.url != null) {
						var alias = this.$services.page.alias(this.page);
						var newUrl = this.$services.router.router.template(alias, this.parameters);
						this.$services.router.router.updateUrl(alias, newUrl, this.parameters);
						/*
						this.$services.router.router.updateUrl(
							route.alias,
							route.url,
							this.parameters,
							route.query)
						*/
					}
				}
				var self = this;
				// if we have a page variable update, check if we have any subscribers
				if (name.indexOf && name.indexOf("page.") == 0) {
					// we want to alert anyone listening to a parent as well that something has changed
					while (name != null) {
						if (this.subscriptions[name]) {
							var valueToEmit = self.get(name);
							this.subscriptions[name].forEach(function(handler) {
								handler(valueToEmit);
							});
						}
						var index = name.lastIndexOf(".");
						if (index < 0) {
							name = null;
							break;
						}
						else {
							name = name.substring(0, index);
						}
					}
				}
			}
			else {
				console.log("Could not set", name, value);
			}
		},
		pageContentTag: function() {
			if (!this.page.content.pageType || this.page.content.pageType == "page") {
				return null;
			}
			var self = this;
			var provider = nabu.page.providers("page-type").filter(function(x) {
				return x.name == self.page.content.pageType;
			})[0];
			return provider ? provider.pageContentTag : null;
		},
		pageTag: function() {
			// the default
			if (!this.page.content.pageType || this.page.content.pageType == "page") {
				return "div";
			}
			var self = this;
			var provider = nabu.page.providers("page-type").filter(function(x) {
				return x.name == self.page.content.pageType;
			})[0];
			// special override for editing purposes
			if (this.edit && provider && provider.pageTagEdit) {
				return provider.pageTagEdit;
			}
			return provider && provider.pageTag ? provider.pageTag : "div";
		},
		getPageTypes: function(value) {
			var items = ['page'];
			nabu.utils.arrays.merge(items, nabu.page.providers("page-type").map(function(x) { return x.name }));
			if (value) {
				items = items.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			return items;
		},
		// ported from page-rows
		hasConfigure: function(cell) {
			var self = this;
			var pageInstance = this;
			var cellInstance = pageInstance.getComponentForCell(cell.id);
			return cellInstance && cellInstance.configure;
		},
		getRouteParameters: function(cell) {
			var route = this.$services.router.get(cell.alias);
			return route ? this.$services.page.getRouteParameters(route) : {};
		},
		getAvailableParameters: function(cell) {
			return this.$services.page.getAvailableParameters(this.page, cell, true);
		},
		/*
		double copy paste?
		getAvailableEvents: function(event) {
			var available = this.getEvents();
			var result = Object.keys(available);
			if (event) {
				result = result.filter(function(x) {
					return x.toLowerCase().indexOf(event.toLowerCase()) >= 0;
				});
			}
			result.sort();
			return result;
		},
		*/
		canConfigureInline: function(cell) {
			if (!cell) {
				return false;
			}
			var pageInstance = this;
			var component = pageInstance.getComponentForCell(cell.id);
			if (component && component.configurator) {
				return component;
			}
			return false;
		},
		getCellConfigurator: function(cell) {
			var pageInstance = this;
			var component = pageInstance.getComponentForCell(cell.id);
			return component && component.configurator();
		},
		getCellConfiguratorInput: function(cell) {
			var pageInstance = this;
			var cellInstance = pageInstance.getComponentForCell(cell.id);
			var result = {};
			if (cellInstance.$options.props) {
				Object.keys(cellInstance.$options.props).forEach(function(prop) {
					result[prop] = cellInstance[prop];
				});
			}
			return result;
		},
		addDevice: function(cell) {
			if (!cell.devices) {
				Vue.set(cell, "devices", []);
			}
			cell.devices.push({name: null, operator: '>'});
		},
		suggestDevices: function(value) {
			var devices = this.$services.page.devices.map(function(x) { return x.name }); 
			if (value && value.match(/[0-9]+/)) { 
				devices.unshift(value) 
			}
			return devices;
		},
		removeCell: function(cells, cell) {
			var self = this;
			this.$confirm({
				title: "Delete cell",
				message: "Are you sure you want to delete this cell?"
			}).then(function() {
				self.$services.page.closeRight();
				cells.splice(cells.indexOf(cell), 1);
			});
		},
		/*
		// presumably wrong copy paste...
		removeRow: function(cell, row) { 
			cell.rows.splice(cell.rows(indexOf(row), 1));
		},
		*/
		removeInstance: function(target, name) {
			// currently just reset the instances thing, we currently only allow one
			Vue.set(target, "instances", {});	
		},
		renameInstance: function(target, oldName, newName) {
			Vue.set(target.instances, newName, target.instances[oldName]);
			Vue.delete(target.instances, oldName);
		},
		setContent: function(cell) {
			var self = this;
			this.$prompt(function() {
				return new nabu.page.views.PageAddCell({propsData: {
					page: self.page
				}});
			}).then(function(content) {
				nabu.utils.objects.merge(cell, content);
			});
		},
		copyCell: function(cell) {
			nabu.utils.objects.copy({
				type: "page-cell",
				content: cell
			});
			this.$services.page.copiedCell = JSON.parse(JSON.stringify(cell));
			this.$services.page.copiedRow = null;
		},
		copyRow: function(row) {
			nabu.utils.objects.copy({
				type: "page-row",
				content: row
			});
			this.$services.page.copiedRow = JSON.parse(JSON.stringify(row));
			this.$services.page.copiedCell = null;
		},
		pasteCell: function(row) {
			row.cells.push(this.$services.page.renumber(this.page, this.$services.page.copiedCell));
			this.$services.page.copiedCell = null;
		}
		
	},
	watch: {
		/*parameters: function(newValue) {
			var oldValue = JSON.parse(this.lastParameters);
			var changedValues = [];
			// find all the fields that have changed
			Object.keys(newValue).map(function(name) {
				if (oldValue[name] != newValue[name]) {
					changedValues.push("page." + name);
				}
			});
			this.lastParameters = JSON.stringify(newValue);
			//this.rerender(changedValues);
		},*/
		'page.content.globalEvents': {
			deep: true,
			handler: function(newValue) {
				var self = this;
				if (newValue) {
					newValue.forEach(function(globalEvent) {
						globalEvent.properties = self.getEvents()[globalEvent.localName];
					});
				}
			}
		},
		bodyClasses: function (newVal) {
			var self = this;
			// the context is important here, it has to be the classList object itself
			// otherwise you get an exception like "illegal invocation"
			document.body.classList.remove.apply(document.body.classList, self.oldBodyClasses.splice(0));
			document.body.classList.add.apply(document.body.classList, newVal);
			nabu.utils.arrays.merge(self.oldBodyClasses, newVal);
		},
		'cell.aris': {
			deep: true,
			handler: function(newValue) {
				this.$services.page.setRerender(newValue);
			}
		},
		edit: function(newValue) {
			if (newValue) {
				document.body.setAttribute("page-editing", this.collapsedMenu ? "small" : "large");
			}
			else {
				document.body.removeAttribute("page-editing");
			}
		},
		collapsedMenu: function(newValue) {
			if (this.edit) {
				document.body.setAttribute("page-editing", newValue ? "small" : "large");
			}
		},
		// if you choose a tab, open it
		activeTab: function(newValue) {
			if (this.edit) {
				this.collapsedMenu = false;
			}
		}
	}
});

Vue.component("n-page-rows", {
	template: "#page-rows",
	props: {
		page: {
			type: Object,
			required: true
		},
		rows: {
			type: Array,
			required: true
		},
		edit: {
			type: Boolean,
			required: false
		},
		parameters: {
			type: Object,
			required: false
		},
		events: {
			type: Object,
			required: true
		},
		// pass in state that is built up in rows/cells above (e.g. repeats)
		localState: {
			type: Object,
			required: false
		},
		root: {
			type: Boolean,
			required: false,
			default: false
		},
		stopRerender: {
			type: Boolean,
			required: false,
			default: false
		},
		depth: {
			type: Number,
			default: 0
		}
	},
	methods: {
		rowsTag: function() {
			if (this.depth > 0 || !this.page.content.pageType || this.page.content.pageType == "page") {
				return "div";	
			}
			var self = this;
			var provider = nabu.page.providers("page-type").filter(function(x) {
				return x.name == self.page.content.pageType;
			})[0];
			// special override for editing purposes
			if (this.edit && provider && provider.pageContentTagEdit) {
				return provider.pageContentTagEdit;
			}
			return provider && provider.pageContentTag ? provider.pageContentTag : "div";
		}
	}
});

nabu.page.views.PageOptimized = Vue.component("n-page-optimized", {
	mixins: [Vue.component("n-page")],
	template: "#nabu-optimized-page"
});

nabu.page.views.PageOptimized = Vue.component("n-page-optimized-column", {
	mixins: [Vue.component("n-page")],
	template: "#nabu-optimized-page-column"
});


Vue.component("n-page-row", {
	template: "#page-row",
	props: {
		page: {
			type: Object,
			required: true
		},
		row: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: false
		},
		parameters: {
			type: Object,
			required: false
		},
		stopRerender: {
			type: Boolean,
			required: false,
			default: false
		},
		depth: {
			type: Number,
			default: 0
		},
		root: {
			type: Boolean,
			required: false,
			default: false
		},
		activeViews: {
			type: Array,
			default: function() {
				return []
			}
		}
	},
	data: function() {
		return {
			configuring: null,
			// keeps a reactive boolean linked to the permission resolving
			permissionRendering: {},
			states: []
		}
	},
	created: function() {
		var self = this;
		this.$on("close", function() {
			self.$parent.$emit("close");
		});
	},
	methods: {
		getCurrentStates: function() {
			var states = [];
			nabu.utils.arrays.merge(states, this.states);
			if (this.$parent) {
				nabu.utils.arrays.merge(states, this.$parent.getCurrentStates())
			}
			return states;
		},
		isNoActiveView: function() {
			return this.$services.page.activeViews.length == 0;
		},
		isActiveView: function(view) {
			return this.$services.page.activeViews.indexOf(view) >= 0;
		},
		acivateView: function(view) {
			this.activeViews.splice(0);
			this.activeViews.push(view);
		},
		updateEvent: function(value, label, name) {
			if (this.$parent) {
				this.$parent.$emit("update", value, label, name);
			}
			//this.$emit("update", value, label, name);
		},
		isContentHidden: function(target) {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			return pageInstance.isContentHidden(target);
		},
		getRendererParameters: function(target) {
			var result = {};
			if (target && target.rendererBindings) {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				Object.keys(target.rendererBindings).forEach(function(key) {
					var value = self.$services.page.getBindingValue(pageInstance, target.rendererBindings[key]);
					if (value != null) {
						self.$services.page.setValue(result, key, value);
					}
				});
			}
			return result;
		},
		copyArisStyling: function(event, target) {
			if (target.aris) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				this.$services.page.copiedStyling = JSON.parse(JSON.stringify(target.aris));
				this.$services.notifier.push({
					message: "Copied styling for '" + this.$services.page.formatPageItem(pageInstance, target) + "'",
					severity: this.$services.page.notificationStyle
				});
			}
			event.stopPropagation();
			event.preventDefault();
		},
		pasteArisStyling: function(event, target) {
			if (this.$services.page.copiedStyling) {
				if (target.aris == null) {
					Vue.set(target, "aris", {
						components: {}
					});
				}
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				Vue.set(target, "aris", this.$services.page.copiedStyling);
				this.$services.page.setRerender(target.aris);
				this.$services.notifier.push({
					message: "Pasted styling onto '" + this.$services.page.formatPageItem(pageInstance, target) + "'",
					severity: this.$services.page.notificationStyle
				});
			}
			event.stopPropagation();
			event.preventDefault();
		},
		goto: function(event, row, cell, tab) {
			if (this.edit) {
				this.$emit("select", row, cell, cell ? "cell" : "row", tab ? tab : "selected");
				var doDefault = true;
				var scrollTo = null;
				// if we have a cell target with a configuration, show that, otherwise, we do the generic configuration
				if (cell != null) {
					var component = this.canConfigureInline(cell);
					if (component) {
						this.configuring = cell.id;
					}
					else {
						var self = this;
						var pageInstance = self.$services.page.getPageInstance(self.page, self);
						var cellInstance = pageInstance.getComponentForCell(cell.id);
						if (cellInstance && cellInstance.configure) {
							cellInstance.configure();
							doDefault = false;
						}
					}
					scrollTo = document.getElementById("layout-entry-" + cell.id);
				}
				else {
					scrollTo = document.getElementById("layout-entry-" + row.id);
				}
				if (doDefault) {
					this.configuring = cell ? cell.id : row.id;
				}
				if (scrollTo) {
					scrollTo.scrollIntoView();
				}
				if (event) {
					event.stopPropagation();
					event.preventDefault();
				}
			}
		},
		suggesPageRowClasses: function(value) {
			return this.$services.page.classes("page-row", value).filter(function(x) {
				return ["empty", "is-hover-top", "is-hover-bottom", "is-hover-left", "is-hover-right", "is-hovering"].indexOf(x) < 0;
			});
		},
		getCellById: function(row, cell) {
			return cell.customId && !cell.alias && !cell.rows.length && !cell.renderer ? document.getElementById(cell.customId) : document.getElementById(this.page.name + '_' + row.id + '_' + cell.id);
		},
		getRowById: function(row) {
			return row.customId && !row.renderer ? document.getElementById(row.customId) : document.getElementById(this.page.name + "_" + row.id);
		},
		dropCell: function(event, row, cell) {
			if (!cell.alias) {
				var self = this;
				var data = this.$services.page.getDragData(event, "component-alias");
				var cellTarget = this.getCellById(row, cell);
				if (data) {
					cell.alias = data;
					event.preventDefault();
					event.stopPropagation();
				}
				else {
					data = this.$services.page.getDragData(event, "template-content");
					if (data) {
						var structure = JSON.parse(data);
						if (structure.type == "page-cell") {
							self.$services.page.renumber(self.page, structure.content);
							structure = structure.content;
							// do a reactive merge
							Object.keys(structure).forEach(function(key) {
								Vue.set(cell, key, structure[key]);
							});
							/*if (structure.alias) {
								cell.alias = structure.alias;
							}
							if (structure.rows) {
								var rows = structure.rows.map(function(x) { return self.$services.page.renumber(self.page, x) });
								nabu.utils.arrays.merge(cell.rows, rows);
							}*/
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		},
		drop: function(event, row) {
			var self = this;
			var data = this.$services.page.getDragData(event, "component-alias");
			var rowTarget = document.getElementById(this.page.name + '_' + row.id);
			var rect = rowTarget.getBoundingClientRect();
			var below = Math.abs(event.clientY - rect.top) >= rect.height - (rect.height / 6);
			var above = Math.abs(event.clientY - rect.top) <= rect.height / 6;
			var left = Math.abs(event.clientX - rect.left) <= rect.width / 6;
			var right = Math.abs(event.clientX - rect.left) >= rect.width - (rect.width / 6);
			if (data) {
				// if we inserted at bottom, get the parent, insert behind it
				if (below) {
					var parent = this.$services.page.getTarget(this.page.content, row.id, true);
					var index = parent.rows.indexOf(row);
					row = this.addRow(parent, true);
					parent.rows.splice(index + 1, 0, row);
				}
				// position above it
				else if (above) {
					var parent = this.$services.page.getTarget(this.page.content, row.id, true);
					var index = parent.rows.indexOf(row);
					row = this.addRow(parent, true);
					parent.rows.splice(index, 0, row);
				}
				var cell = this.addCell(row);
				cell.alias = data;
				event.preventDefault();
				event.stopPropagation();
			}
			else {
				data = this.$services.page.getDragData(event, "template-content");
				if (data) {
					var structure = JSON.parse(data);
					if (structure.type == "page-row" || structure.type == "page-cell") {
						structure = structure.content;
					}
					// we assume the structure is a valid cell or row
					// we want to copy all the stuff configured on the actual cell or row as well
					// renumber the structure
					self.$services.page.renumber(self.page, structure);
					
					// it's a row
					if (structure.cells) {
						//var rows = structure.rows.map(function(x) { return self.$services.page.renumber(self.page, x) });
						var parent = this.$services.page.getTarget(this.page.content, row.id, true);
						var index = parent.rows.indexOf(row);
						if (below) {
							if (index == parent.rows.length - 1) {
								parent.rows.push(structure);
							}
							else {
								parent.rows.splice(index + 1, 0, structure);
							}
							//rows.unshift(0);
							//rows.unshift(index + 1);
							//parent.rows.splice.apply(null, rows);
						}
						else if (above) {
							if (index == 0) {
								parent.rows.unshift(structure);
							}
							else {
								parent.rows.splice(index, 0, structure);
							}
							//rows.unshift(0);
							//rows.unshift(index);
							//parent.rows.splice.apply(null, rows);
						}
						else {
							//var cell = this.addCell(row);
							//nabu.utils.arrays.merge(cell.rows, rows);
							parent.rows.push(structure);
							//cell.rows.push(structure);
						}
					}
					// it's a cell
					else if (structure.rows) {
						//var cells = structure.cells.map(function(x) { return self.$services.page.renumber(self.page, x) });
						var parent = this.$services.page.getTarget(this.page.content, row.id, true);
						var index = parent.rows.indexOf(row);
						if (below) {
							// there is nothing underneath, let's add a row
							if (index >= parent.rows.length - 1) {
								row = self.addRow(parent);
							}
							else {
								row = self.addRow(parent, true);
								parent.rows.splice(index + 1, 0, row);
							}
						}
						else if (above) {
							if (index == 0) {
								row = self.addRow(parent, true);
								parent.rows.unshift(row);
							}
							else {
								row = self.addRow(parent, true);
								parent.rows.splice(index, 0, row);
							}
						}
						row.cells.push(structure);
					}
					if (structure.actions) {
						nabu.utils.arrays.merge(this.page.content.actions, structure.actions);
					}
					event.preventDefault();
					event.stopPropagation();
				}
			}
		},
		dragOverCell: function($event, row, cell) {
			// can only accept drags if there is nothing in the cell yet
			if (!cell.alias && this.edit) {
				var data = this.$services.page.hasDragData($event, "component-alias");
				if (!data) {
					data = this.$services.page.hasDragData($event, "template-content");
					// check that it is the correct type of data
					if (data) {
						var structure = JSON.parse(this.$services.page.getDragData(event, "template-content"));
						// we can only drop cell templates here?
						if (structure.type != "page-cell") {
							data = null;
						}
					}
				}
				// TODO: in the future also drop page-cell and page-row from the side menu?
				if (data) {
					var self = this;
					var cellTarget = document.getElementById(self.page.name + '_' + row.id + '_' + cell.id);
					this.$services.page.pushDragItem(cellTarget);
					var rect = cellTarget.getBoundingClientRect();
					cellTarget.classList.remove("is-hovering", "is-hover-top", "is-hover-bottom", "is-hover-left", "is-hover-right");
					cellTarget.classList.add("is-hovering");
					$event.preventDefault();
					$event.stopPropagation();
				}
			}
		},
		dragOver: function($event, row) {
			if (this.edit) {
				var data = this.$services.page.hasDragData($event, "component-alias");
				if (!data) {
					data = this.$services.page.hasDragData($event, "template-content");
				}
				// TODO: in the future also drop page-cell and page-row from the side menu?
				if (data) {
					var self = this;
					var rowTarget = document.getElementById(self.page.name + '_' + row.id);
					this.$services.page.pushDragItem(rowTarget);
					var rect = rowTarget.getBoundingClientRect();
					rowTarget.classList.remove("is-hovering", "is-hover-top", "is-hover-bottom", "is-hover-left", "is-hover-right");
					// bottom 15%, highlight bottom
					if (Math.abs(event.clientY - rect.top) >= rect.height - (rect.height / 6)) {
						rowTarget.classList.add("is-hover-bottom");
					}
					// top 15%, highlight top
					else if (Math.abs(event.clientY - rect.top) <= rect.height / 6) {
						rowTarget.classList.add("is-hover-top");
					}
					// not yet sure what this would entail
					/*
					// left 15%
					else if (Math.abs(event.clientX - rect.left) <= rect.width / 6) {
						rowTarget.classList.add("is-hover-left");
					}
					// right 15%
					else if (Math.abs(event.clientX - rect.left) >= rect.width - (rect.width / 6)) {
						rowTarget.classList.add("is-hover-right");
					}
					*/
					else {
						rowTarget.classList.add("is-hovering");
					}
					$event.preventDefault();
					$event.stopPropagation();
				}
			}
		},
		dragExitCell: function($event, row, cell) {
			if (!cell.alias && this.edit) {
				var self = this;
				var cellTarget = document.getElementById(self.page.name + '_' + row.id + '_' + cell.id);
				if (cellTarget) {
					cellTarget.classList.remove("is-hovering");
				}
				$event.preventDefault();
				$event.stopPropagation();
			}
		},
		dragExit: function($event, row) {
			var self = this;
			var rowTarget = document.getElementById(self.page.name + '_' + row.id);
			if (rowTarget) {
				rowTarget.classList.remove("is-hovering");
			}
			$event.preventDefault();
			$event.stopPropagation();
		},
		setRowConfiguring: function(id) {
			this.configuring = id;	
		},
		rowTagFor: function(row) {
			var renderer = row.renderer == null ? null : nabu.page.providers("page-renderer").filter(function(x) { return x.name == row.renderer })[0];
			if (renderer == null) {
				var result = this.getPageType(row);
				var pageType = result ? result.pageType : null;
				if (!pageType || pageType == "page") {
					return this.isLinkContainer(row) ? "a" : "div";
				}
				var self = this;
				var provider = nabu.page.providers("page-type").filter(function(x) {
					return x.name == pageType;
				})[0];
				var rowTag = null;
				// if it is a function, we can do more stuff
				if (provider && provider.rowTag instanceof Function) {
					rowTag = provider.rowTag(row, this.depth, this.edit, result.path, this.page);
				}
				// special override for editing purposes
				else if (this.edit && provider && provider.rowTagEdit) {
					rowTag = provider.rowTagEdit;
				}
				else if (provider && provider.rowTag) {
					rowTag = provider.rowTag;
				}
				return rowTag ? rowTag : "div";
			}
			else {
				return renderer.component;
			}
		},
		getPageType: function(target) {
			return this.$services.page.getPageType(this.page, target);
		},
		targetHref: function(target) {
			if (this.isLinkContainer(target)) {
				return this.$services.triggerable.calculateUrl(target.triggers[0].actions[0], this, {});
			}
		},
		// a link container is a cell or row that should not be rendered as a div
		isLinkContainer: function(target) {
			// should not have content routed in it
			if (target.renderer == null && target.alias == null) {
				if (target.triggers && target.triggers.length == 1 && target.triggers[0].actions.length == 1 && 
						target.triggers[0].actions[0].type == "route") {
					return true;
				}
			}
			return false;
		},
		// we want explicitly "false" if we are rendering it as a clickable target
		// otherwise you end up dragging the card (or whatever it is) when you swipe on the phone to scroll
		// in the future we might add other draggable logic, but for now in all other cases we don't want a draggable attribute at all
		isDraggable: function(target) {
			if (this.isLinkContainer(target)) {
				return false;
			}	
		},
		cellTagFor: function(row, cell) {
			var renderer = cell.renderer == null ? null : nabu.page.providers("page-renderer").filter(function(x) { return x.name == cell.renderer })[0];
			// once we have a cell.alias, we can not use a renderer!
			// must be enforced here
			// the problem is that we only store a single id for now, if we have a renderer, it will overwrite the id that is already registering the component
			// we "could" find a way around this (component is also registered under instance_<id>) but then we need to do some refactoring on actions
			// where we keep track of the possibility that both exist etc
			// it is an unlikely usecase...
			if (renderer == null || cell.alias) {
				var result = this.getPageType(cell);
				var pageType = result ? result.pageType : null;
				if (!pageType || pageType == "page") {
					return this.isLinkContainer(cell) ? "a" : "div";
				}
				var self = this;
				var provider = nabu.page.providers("page-type").filter(function(x) {
					return x.name == pageType;
				})[0];
				var cellTag = null;
				// if it is a function, we can do more stuff
				if (provider && provider.cellTag instanceof Function) {
					cellTag = provider.cellTag(row, cell, this.depth, this.edit, result.path, this.page);
				}
				// special override for editing purposes
				else if (this.edit && provider && provider.cellTagEdit) {
					cellTag = provider.cellTagEdit;
				}
				else if (provider && provider.cellTag) {
					cellTag = provider.cellTag;
				}
				return cellTag ? cellTag : "div";
			}
			else {
				return renderer.component;
			}
		},
		getInstance: function() {
			return this.$services.page.instances[this.name];	
		},
		getState: function(row, cell) {
			var self = this;
			var localState = this.getLocalState(row, cell);
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			Object.keys(pageInstance.variables).map(function(key) {
				if (typeof(localState[key]) == "undefined") {
					localState[key] = pageInstance.variables[key];
				}
			});
			var page = this.$services.page.getPageParameterValues(this.page, pageInstance);
			if (Object.keys(page).length) {
				localState.page = page;
			}
			return localState;
		},
		getLocalState: function(row, cell) {
			var state = {};
			// inherit state from above
			if (this.localState) {
				var self = this;
				Object.keys(this.localState).map(function(key) {
					state[key] = self.localState[key];
				});
			}
			// add local state of row
			if (row && row.data) {
				Object.keys(row.data).map(function(key) {
					state[key] = row.data[key];
				})
			}
			// add local state of cell
			if (cell && cell.data) {
				Object.keys(cell.data).map(function(key) {
					state[key] = cell.data[key];
				})
			}
			return state;
		},
		getSideBarStyles: function(cell) {
			var styles = [];
			if (cell.width != null) {
				if (typeof(cell.width) == "number" || (cell.width.match && cell.width.match(/^[0-9.]+$/))) {
					styles.push({'flex-grow': cell.width});
				}
				else {
					styles.push({'min-width': cell.width});
				}
			}
			return styles;
		},
		getStyles: function(cell) {
			var width = cell.width;
			var styles = [];
			if (width != null) {
				if (typeof(width) == "number" || (width.match && width.match(/^[0-9.]+$/))) {
					styles.push({'flex-grow': width});
				}
				else {
					styles.push({'min-width': width});
				}
			}
			if (cell.height) {
				styles.push({'height': cell.height});
			}
			if (false && (this.edit || this.$services.page.wantEdit) && cell.name) {
				styles.push({"border": "solid 2px " + this.getNameColor(cell.name), "border-style": "none solid solid solid"})
			}
			if (cell.styleVariables) {
				this.$services.page.getDynamicVariables(cell.styleVariables, this.variables, this).forEach(function(variable) {
					var single = {};
					single["--" + variable.name] = variable.value;
					styles.push(single);
				});
			}
			return styles;
		},
		hasPageRoute: function(cell) {
			if (cell.alias) {
				var route = this.$services.router.get(cell.alias);
				if (route && route.isPage) {
					return true;
				}
			}
			return false;
		},
		up: function(row) {
			var index = this.rows.indexOf(row);
			if (index > 0) {
				var replacement = this.rows[index - 1];
				this.rows.splice(index - 1, 1, row);
				this.rows.splice(index, 1, replacement);
			}
		},
		down: function(row) {
			var index = this.rows.indexOf(row);
			if (index < this.rows.length - 1) {
				var replacement = this.rows[index + 1];
				this.rows.splice(index + 1, 1, row);
				this.rows.splice(index, 1, replacement);
			}
		},
		cellDown: function(row, cell) {
			var index = this.rows.indexOf(row);
			if (index < this.rows.length - 1) {
				var target = this.rows[index + 1];
				row.cells.splice(row.cells.indexOf(cell));
				target.cells.push(cell);
			}
		},
		cellUp: function(row, cell) {
			var index = this.rows.indexOf(row);
			if (index > 0) {
				var target = this.rows[index - 1];
				row.cells.splice(row.cells.indexOf(cell));
				target.cells.push(cell);
			}
		},
		left: function(row, cell) {
			var index = row.cells.indexOf(cell);
			if (index > 0) {
				var replacement = row.cells[index - 1];
				row.cells.splice(index - 1, 1, cell);
				row.cells.splice(index, 1, replacement);
			}
		},
		right: function(row, cell) {
			var index = row.cells.indexOf(cell);
			if (index < row.cells.length - 1) {
				var replacement = row.cells[index + 1];
				row.cells.splice(index + 1, 1, cell);
				row.cells.splice(index, 1, replacement);
			}
		},
		canConfigure: function(cell) {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			var component = pageInstance.getComponentForCell(cell.id);
			return component && component.configure;
		},
		canConfigureInline: function(cell) {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			var component = pageInstance.getComponentForCell(cell.id);
			if (component && component.configurator) {
				return component;
			}
			return false;
		},
		configureCell: function(event, row, cell) {
			var self = this;
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			var component = pageInstance.getComponentForCell(cell.id);
			if (component && component.configurator) {
				this.goto(event, row, cell, "cell");
			}
			// backwards compatible
			else if (component.configure) {
				component.configure();
			}
			else {
				this.goto(event, row, cell, "cell");
			}
		},
		close: function(row, cell, childRow) {
			var self = this;
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			// if we didn't close anything, we want to send this up to the parent
			var closed = false;
			if (cell && this.$services.page.isCloseable(cell)) {
				closed = true;
				Vue.set(pageInstance.closed, cell.id, cell.on ? cell.on : "$any");
				// if we want to cascade, don't mark the closed as done
				if (cell.cascadeClose) {
					closed = false;
				}
			}
			if (row && this.$services.page.isCloseable(row)) {
				closed = true;
				Vue.set(pageInstance.closed, row.id, row.on ? row.on : "$any");
				// if we want to cascade, don't mark the closed as done
				if (row.cascadeClose) {
					closed = false;
				}
			}
			if (childRow && this.$services.page.isCloseable(childRow)) {
				closed = true;
				Vue.set(pageInstance.closed, childRow.id, childRow.on ? childRow.on : "$any");
				// if we want to cascade, don't mark the closed as done
				if (childRow.cascadeClose) {
					closed = false;
				}
			}
			if (!closed) {
				this.$parent.$emit("close");
			}
		},
		shouldRenderRow: function(row) {
			if (this.edit) {
				return true;
			}
			// if we have width limitations, check those first
			if (row.devices) {
				if (!this.isDevice(row.devices)) {
					return false;
				}
			}
			if (!!row.condition) {
				if (!this.$services.page.isCondition(row.condition, this.getState(row), this)) {
					return false;
				}
			}
			var self = this;
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			if (row.permission || row.permissionContext || row.permissionServiceContext) {
				var permission = row.permission && row.permission.indexOf("=") == 0 ? this.$services.page.interpret(row.permission, this) : row.permission;
				var permissionContext = row.permissionContext && row.permissionContext.indexOf("=") == 0 ? this.$services.page.interpret(row.permissionContext, this) : row.permissionContext;
				var permissionServiceContext = row.permissionServiceContext && row.permissionServiceContext.indexOf("=") == 0 ? this.$services.page.interpret(row.permissionServiceContext, this) : row.permissionServiceContext;
				if (!permissionServiceContext) {
					permissionServiceContext = pageInstance.getServiceContext();
				}
				var key = permissionServiceContext + "::" + permissionContext + "::" + permission;
				// if we haven't resolved it yet, do so
				if (!this.permissionRendering.hasOwnProperty(key)) {
					Vue.set(this.permissionRendering, key, false);
					// if successfully resolved, we will render it!
					this.$services.user.can({
						context: permissionContext,
						name: permission,
						serviceContext: permissionServiceContext
					}).then(function() {
						Vue.set(self.permissionRendering, key, true);
					})
				}
				if (this.permissionRendering[key] === false) {
					return this.permissionRendering[key];
				}
			}
			/*
			if (!!row.permission) {
				if (!this.$services.user.hasPermission(row.permission, row.permissionContext, row.permissionServiceContext)) {
					return false;
				}
			}
			else if (!!row.permissionContext) {
				if (!this.$services.user.hasPermissionInContext(row.permissionContext, row.permissionServiceContext)) {
					return false;
				}
			}
			else if (!!row.permissionServiceContext) {
				if (!this.$services.user.hasPermissionInServiceContext(row.permissionServiceContext)) {
					return false;
				}
			}
			*/
			if (row.on) {
				// if we explicitly closed it, leave it closed until it is reset
				if (pageInstance.closed[row.id]) {
					return false;
				}
				else if (!pageInstance.get(row.on)) {
					return false;
				}
			}
			else if (this.$services.page.isCloseable(row) && pageInstance.closed[row.id]) {
				return false;
			}
			if (this.$services.page.isCloseable(row)) {
				return !pageInstance.closed[row.id];
			}
			return true;
		},
		// backwards compatible
		isDevice: function(devices) {
			return this.$services.page.isDevice(devices);
		},
		cellId: function(cell) {
			var cellId = 'page_' + this.pageInstanceId + '_cell_' + cell.id;
			if (cell.on && cell.optimizeVueKey) {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				var on = pageInstance.get(cell.on);
				if (on) {
					cellId += JSON.stringify(on);
				}
			}
			return cellId;
		},
		cellClasses: function(cell) {
			var self = this;
			var classes = [];
			if (cell.renderer) {
				var renderer = this.$services.page.getRenderer(cell.renderer);
				if (renderer && renderer.cssComponent) {
					classes.push("is-" + renderer.cssComponent);
				}
			}
			var resultingComponent = null;
			if (classes.length == 0) {
				var result = this.getPageType(cell);
				var pageType = result ? result.pageType : null;
				if (pageType) {
					var provider = nabu.page.providers("page-type").filter(function(x) {
						return x.name == pageType;
					})[0];
					if (provider && cell.renderer && provider[cell.renderer + "Component"] instanceof Function) {
						resultingComponent = provider[cell.renderer + "Component"](cell);
					}
					else if (provider && cell.renderer && provider[cell.renderer + "Component"]) {
						resultingComponent = provider[cell.renderer + "Component"];
					}
					else if (provider && provider.cellComponent instanceof Function) {
						resultingComponent = provider.cellComponent(cell, result.path, this.page);
					}
					else if (provider && provider.cellComponent) {
						resultingComponent = provider.cellComponent;
					}
					if (resultingComponent) {
						classes.push("is-" + resultingComponent);
					}
				}
			}
			// only a page column if we don't have a component yet
			if (classes.length == 0) {
				resultingComponent = "page-column";
				if (this.edit || !cell.target || cell.target == "page") {
					classes.push("is-page-column");
				}
				else if (cell.target == "prompt" || cell.target == "sidebar" || cell.target == "absolute") {
					//classes.push("is-page-prompt");
					// @2023-06-01 we want to be able to apply default column styling, in v1 we differentiated between the two
					classes.push("is-page-column");
				}
				//{'is-page-column': edit || !cell.target || cell.target == 'page', 'page-prompt': cell.target == 'prompt' || cell.target == 'sidebar' || cell.target == 'absolute' }
			}
			if (cell.target == "pane") {
				classes.push("is-pane-layer");
				// check the max layer currently active and go one higher
				var maxLayer = 0;
				document.querySelectorAll(".is-pane-layer").forEach(function(x) {
					if (x.getAttribute("cell-id") != cell.id) {
						x.classList.forEach(function(y) {
							if (y.indexOf("is-pane-layer") == 0) {
								var tmp = y.substring("is-pane-layer".length);
								if (tmp && parseInt(tmp) > maxLayer) {
									maxLayer = parseInt(tmp);
								}
							}
						})
					}
				});
				classes.push("is-pane-layer-" + (maxLayer + 1));
			}
			if (this.$services.page.useAris && cell.aris && cell.aris.components) {
				var children = this.$services.page.calculateArisComponents(cell.aris, cell.alias, this);
				if (children[resultingComponent] && children[resultingComponent].classes) {
					nabu.utils.arrays.merge(classes, children[resultingComponent].classes);
				}
			}
			if (cell.styles) {
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				// if we use state here, it does not get modified as we send out new events
				// so let's watch the variables instead
				//return this.$services.page.getDynamicClasses(cell.styles, this.state, this);
				nabu.utils.arrays.merge(classes, this.$services.page.getDynamicClasses(cell.styles, pageInstance.variables, this));
			}
			if (cell.states) {
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				cell.states.forEach(function(state) {
					if (!state.condition || self.$services.page.isCondition(state.condition, pageInstance.variables, self)) {
						classes.push("is-" + state.name);
					}
				})
			}
			// if we have an explicit open trigger on click, we explicitly close it as well
			// deprecated
			/*
			if (cell.state.openTrigger == "click") {
				classes.push("is-closed");
			}
			*/
			return classes;
		},
		rowClasses: function(row) {
			var self = this;
			var classes = [];
			if (row.renderer) {
				var renderer = this.$services.page.getRenderer(row.renderer);
				if (renderer && renderer.cssComponent) {
					classes.push("is-" + renderer.cssComponent);
				}
			}
			var resultingComponent = null;
			if (classes.length == 0) {
				var result = this.getPageType(row);
				var pageType = result ? result.pageType : null;
				if (pageType) {
					var provider = nabu.page.providers("page-type").filter(function(x) {
						return x.name == pageType;
					})[0];
					if (provider && row.renderer && provider[row.renderer + "Component"] instanceof Function) {
						resultingComponent = provider[row.renderer + "Component"](row);
					}
					else if (provider && row.renderer && provider[row.renderer + "Component"]) {
						resultingComponent = provider[row.renderer + "Component"];
					}
					else if (provider && provider.rowComponent instanceof Function) {
						resultingComponent = provider.rowComponent(row, result.path, this.page);
					}
					else if (provider && provider.rowComponent) {
						resultingComponent = provider.rowComponent;
					}
					if (resultingComponent) {
						classes.push("is-" + resultingComponent);
					}
				}
			}
			// only a page row if we don't have a component yet
			if (classes.length == 0) {
				resultingComponent = "page-row";
				classes.push("is-page-row");
			}
			if (this.$services.page.useAris && row.aris && row.aris.components) {
				var children = this.$services.page.calculateArisComponents(row.aris, row.renderer, this);
				if (children[resultingComponent] && children[resultingComponent].classes) {
					nabu.utils.arrays.merge(classes, children[resultingComponent].classes);
				}
			}
			if (row.styles) {
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				// if we use state here, it does not get modified as we send out new events
				// so let's watch the variables instead
				//return this.$services.page.getDynamicClasses(row.styles, this.state, this);
				nabu.utils.arrays.merge(classes, this.$services.page.getDynamicClasses(row.styles, pageInstance.variables, this));
			}
			return classes;
		},
		hasCellClickEvent: function(cell) {
			if (!cell.clickEvent) {
				return false;
			}
			else if (typeof(cell.clickEvent) == "string") {
				return true;
			}
			else {
				return nabu.page.event.getName(cell, "clickEvent");
			}
		},
		shouldRenderCell: function(row, cell) {
			if (this.edit) {
				/*if (row.collapsed) {
					return false;
				}*/
				return true;
			}
			else if (!cell.alias && !cell.rows.length && !cell.customId) {
				return false;
			}
			// if we have width limitations, check those first
			if (cell.devices) {
				if (!this.isDevice(cell.devices)) {
					return false;
				}
			}
			
			if (cell.condition) {
				if (!this.$services.page.isCondition(cell.condition, this.getState(row, cell), this)) {
					return false;
				}
			}
			
			var self = this;
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			// Check it!
			if (cell.permission || cell.permissionContext || cell.permissionServiceContext) {
				var permission = cell.permission && cell.permission.indexOf("=") == 0 ? this.$services.page.interpret(cell.permission, this) : cell.permission;
				var permissionContext = cell.permissionContext && cell.permissionContext.indexOf("=") == 0 ? this.$services.page.interpret(cell.permissionContext, this) : cell.permissionContext;
				var permissionServiceContext = cell.permissionServiceContext && cell.permissionServiceContext.indexOf("=") == 0 ? this.$services.page.interpret(cell.permissionServiceContext, this) : cell.permissionServiceContext;
				if (!permissionServiceContext) {
					permissionServiceContext = pageInstance.getServiceContext();
				}
				var inversion = cell.permissionInversion ? "::inverse" : "";
				var key = permissionServiceContext + "::" + permissionContext + "::" + permission + inversion;
				// if we haven't resolved it yet, do so
				if (!this.permissionRendering.hasOwnProperty(key)) {
					Vue.set(this.permissionRendering, key, false);
					// if successfully resolved, we will render it!
					this.$services.user.can({
						context: permissionContext,
						name: permission,
						serviceContext: permissionServiceContext
					}).then(function() {
						Vue.set(self.permissionRendering, key, cell.permissionInversion ? false : true);
					})
				}
				if (this.permissionRendering[key] === false) {
					return this.permissionRendering[key];
				}
			}
			/*
			if (!!cell.permission) {
				if (!this.$services.user.hasPermission(cell.permission, cell.permissionContext)) {
					return false;
				}
			}
			else if (!!cell.permissionContext) {
				if (!this.$services.user.hasPermissionInContext(cell.permissionContext, cell.permissionServiceContext)) {
					return false;
				}
			}
			else if (!!cell.permissionServiceContext) {
				if (!this.$services.user.hasPermissionInServiceContext(cell.permissionServiceContext)) {
					return false;
				}
			}
			*/
			// if we depend on an event and it hasn't happened yet, don't render
			// not sure if it will rerender if we close it?
			if (cell.on) {
				// if we explicitly closed it, leave it closed until it is reset
				if (pageInstance.closed[cell.id]) {
					return false;
				}
				else if (!pageInstance.get(cell.on)) {
					return false;
				}
			}
			else if (this.$services.page.isCloseable(cell) && pageInstance.closed[cell.id]) {
				return false;
			}
			var providers = [];
			nabu.page.providers("page-enumerate").map(function(x) {
				providers.push(x.name);
			});
			var consensus =  Object.keys(cell.bindings).reduce(function(consensus, name) {
				// fixed values are always ok
				if (cell.bindings[name] && cell.bindings[name].indexOf && cell.bindings[name].indexOf("fixed") == 0) {
					return consensus;
				}
				else if (cell.bindings[name] && cell.bindings[name].label && cell.bindings[name].label == "fixed") {
					return consensus;
				}
				// always allow enumerated values
				else if (cell.bindings[name] && cell.bindings[name].split && providers.indexOf(cell.bindings[name].split(".")[0]) >= 0) {
					return consensus;
				}
				// if we have a bound value and it does not originate from the (ever present) page, it must come from an event
				// check that the event has occurred
				// use the cell.on to define this?
				// sometimes need to always show an empty table or whatever
				// may need to allow an array in cell.on?
				/*if (cell.bindings[name] && cell.bindings[name].indexOf("page.") != 0) {
					var parts = cell.bindings[name].split(".");
					// if the event does not exist yet, stop
					if (!pageInstance.variables[parts[0]]) {
						return false;
					}
				}*/
				return consensus;
			}, true);
			return consensus;
		},
		// changedValues is an array of field names that have changed, e.g. "page.test" or "select.$all" etc
		shouldRerenderCell: function(cell, changedValues) {
			if (!changedValues || !changedValues.length) {
				return false;
			}
			return Object.keys(cell.bindings).reduce(function(consensus, name) {
				return consensus || changedValues.indexOf(cell.bindings[name]) >= 0;
			}, false);
		},
		getCreatedComponent: function(row, cell) {
			return this.createdComponent.bind(this, row, cell);
		},
		createdComponent: function(row, cell, result) {
			this.$services.page.rendering++;
		},
		mounted: function(cell, row, state, component) {
			var self = this;
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			// especially at startup it can not always be found?
			if (!pageInstance) {
				var current = this;
				// the parent is either the page or a page cell (which is in a row, which might be in the page)
				// either way, we just go up and check if there is a mounted
				// if that is the mounted function of the page, great, if that is the mounted function of another row, it will in turn go up
				while (current.$parent) {
					current = current.$parent;	
					if (current.mounted) {
						current.mounted(cell, row, state, component);
						break;
					}
				}
			}
			else {
				pageInstance.mounted(cell, row, state, component);
			}
			component.$on("close", function() {
				self.close(cell);
			});
		},
		getMountedFor: function(cell, row) {
			return this.mounted.bind(this, cell, row, this.getLocalState(row, cell));
		},
		getCell: function(id) {
			for (var i = 0; i < this.rows.length; i++) {
				if (this.rows[i].cells) {
					for (var j = 0; j < this.rows[i].cells.length; j++) {
						if (this.rows[i].cells[j].id == id) {
							return this.rows[i].cells[j];
						}
					}
				}
			}
			return null;
		},
		getRowEditStyle: function(row) {
			return 'background-color:' + this.getNameColor(row.name) + '; color: #fff';	
		},
		getCellEditStyle: function(cell) {
			return 'background-color:' + this.getNameColor(cell.name) + '; color: #fff';	
		},
		getNameColor: function(name) {
			var saturation = 80;
			var lightness = 40;
			var hash = 0;
			for (var i = 0; i < name.length; i++) {
				hash = name.charCodeAt(i) + ((hash << 5) - hash);
			}
			var hue = hash % 360;
			return 'hsl('+ hue +', '+ saturation +'%, '+ lightness +'%)';
		},
		getParameters: function(row, cell) {
			var self = this;
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			var result = null;
			// to allow other components to map data that is rendered, we have a persistant object that is (by reference) reused to trigger redraws
			if (cell.contentRuntimeAlias && !this.edit) {
				result = pageInstance.variables[cell.contentRuntimeAlias];
				if (result == null) {
					result = {};
					Vue.set(pageInstance.variables, cell.contentRuntimeAlias, result);
				}
			}
			if (result == null) {
				result = {};
			}
			if (!result.page) {
				result.page = this.page;
			}
			if (!result.cell) {
				result.cell = cell;
			}
			if (result.edit == null) {
				result.edit = this.edit;
			}
			if (result.pageInstanceId == null) {
				result.pageInstanceId = this.pageInstanceId;
			}
			if (result.stopRerender == null) {
				result.stopRerender = this.edit;
			}
			/*
			var result = {
				page: this.page,
				// does not seem to serve a purpose, they end up in "parameters.parameters" from the perspective of a child page
//				parameters: this.parameters,
				cell: cell,
				edit: this.edit,
				//state: pageInstance.variables,
				// if we are in edit mode, the local state does not matter
				// and if we add it, we retrigger a redraw everytime we change something
				//localState: this.edit ? null : this.getLocalState(row, cell),
				pageInstanceId: this.pageInstanceId,
				stopRerender: this.edit
			};
			*/
			// if we have an aris aware component, add a childComponents parameter
			if (this.$services.page.useAris && cell && cell.aris && cell.aris.components) {
				result.childComponents = this.$services.page.calculateArisComponents(cell.aris, null, this);
			}
			// if we have a trigger event, add it explicitly to trigger a redraw if needed
			if (cell.on) {
				result[cell.on] = pageInstance.variables[cell.on];
			}
			Object.keys(cell.bindings).map(function(key) {
				if (cell.bindings[key]) {
					var value = self.$services.page.getBindingValue(pageInstance, cell.bindings[key]);
					// only set the value if it actually has some value
					// otherwise we might accidently trigger a redraw with no actual new value
					// if we remove a value that was there before, it will still redraw as the parameters will have fewer keys
					// and adding something "should" trigger redraw anyway
					if (typeof(value) != "undefined" && value != null) {
						result[key] = value;
					}
				}
			});
			return result;
		},
		resetEvents: function() {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			pageInstance.resetEvents();	
		},
		getClickParameters: function($event) {
			var result = {};
			result.ctrl = !!$event.ctrlKey;
			result.shift = !!$event.shiftKey;
			result.alt = !!$event.altKey;
			result.meta = !!$event.metaKey;
			return result;
		},
		clickOnCell: function(row, cell, $event) {
			if (!this.edit && cell && cell.state && cell.state.stopClickPropagation && $event) {
				$event.stopPropagation();
			}
			if (!this.edit && this.$services.triggerable.canTrigger(cell, "click")) {
				if ($event) {
					$event.preventDefault();
				}
				var promise = this.$services.triggerable.trigger(cell, "click", this.getClickParameters($event), this);
				return promise;
			}
		},
		clickOnRow: function(row, $event) {
			if (!this.edit && row && row.state && row.state.stopClickPropagation && $event) {
				$event.stopPropagation();
			}
			if (!this.edit && this.$services.triggerable.canTrigger(row, "click")) {
				if ($event) {
					$event.preventDefault();
				}
				var promise = this.$services.triggerable.trigger(row, "click", this.getClickParameters($event), this);
				return promise;
			}
		},
		clickOnContentCell: function(row, cell) {
			// opentrigger is deprecated, it was a tryout that was never used
			/*
			if (cell.state.openTrigger == "click") {
				var cellInstance = document.getElementById(this.page.name + '_' + row.id + '_' + cell.id);
				if (cellInstance) {
					if (cellInstance.classList.contains("is-open")) {
						cellInstance.classList.remove("is-open");
						cellInstance.classList.add("is-closed");
					}
					else {
						cellInstance.classList.remove("is-closed");
						cellInstance.classList.add("is-open");
					}
				}
			}
			*/
		},
		autocloseCell: function(row, cell, inside) {
			this.close(row, cell);
			// deprecated
			/*
			if (cell.state.openTrigger == "click") {
				var cellInstance = document.getElementById(this.page.name + '_' + row.id + '_' + cell.id);
				if (cellInstance) {
					if (cellInstance.classList.contains("is-open")) {
						cellInstance.classList.remove("is-open");
						cellInstance.classList.add("is-closed");
					}
				}
			}
			*/
		},
		
		addCell: function(target) {
			var self = this;
			var cell = {
				id: this.page.content.counter++,
				rows: [],
				// the alias of the route we want to render here (if any)
				alias: null,
				// the route may have input parameters (path + query), these are the relevant bindings
				// the binding variable contains keys for each path/query parameter in the route
				bindings: {},
				name: null,
				// state that is maintained by the cell owner (the route alias)
				// for example it might offer additional configuration
				state: {},
				// the rendering target (e.g. sidebar, prompt,...)
				target: 'page',
				// it can depend on an event of taking place
				on: null,
				// a class for this cell
				class: null,
				// a custom id for this cell
				customId: null,
				// flex width
				width: null,
				height: null,
				condition: null,
				devices: [],
				clickEvent: null
			};
			if (!target.cells) {
				Vue.set(target, "cells", []);
			}
			this.$services.page.normalizeAris(this.page, cell);
			target.cells.push(cell);
			return cell;
		},
		addRow: function(target, skipInject) {
			if (!target.rows) {
				Vue.set(target, "rows", []);
			}
			var row = {
				id: this.page.content.counter++,
				state: {},
				cells: [],
				class: null,
				// a custom id for this row
				customId: null,
				condition: null,
				direction: null,
				align: null,
				on: null,
				collapsed: false,
				name: null
			};
			if (!skipInject) {
				target.rows.push(row);
				this.$services.page.normalizeAris(this.page, row, "row");
			}
			return row;
		},
		
		rowStyles: function(row) {
			var styles = [];
			if (row.direction == "horizontal") {
				styles.push({"flex-direction": "row"})
			}
			else if (row.direction == "vertical") {
				styles.push({"flex-direction": "column"})
			}
			if (!!row.align) {
				styles.push({"align-items": row.align});
			}
			if (!!row.justify) {
				styles.push({"justify-content": row.justify});
			}
			if (false && (this.edit || this.$services.page.wantEdit) && row.name) {
				styles.push({"border": "solid 2px " + this.getNameColor(row.name), "border-style": "none solid solid solid"})
			}
			if (row.styleVariables) {
				this.$services.page.getDynamicVariables(row.styleVariables, this.variables, this).forEach(function(variable) {
					var single = {};
					single["--" + variable.name] = variable.value;
					styles.push(single);
				});
			}
			return styles;
		},
		rowButtonStyle: function(row) {
			var styles = [];
			if (row.direction == "vertical") {
				styles.push({"display": "inline-block"})
			}
			return styles;
		},
		
		mouseOut: function(event, row, cell) {
			var self = this;
			if (self.edit) {
				var rowTarget = document.getElementById(self.page.name + '_' + row.id);
				if (rowTarget) {
					rowTarget.classList.remove("is-hovering");
				}
				if (cell) {
					var cellTarget = document.getElementById(self.page.name + '_' + row.id + '_' + cell.id);
					if (cellTarget) {
						cellTarget.classList.remove("is-hovering");
					}
				}
			}
			else {
				if (cell && cell.state && cell.state.stopHoverPropagation) {
					event.stopPropagation();
				}
				if (cell) {
					this.$services.triggerable.untrigger(cell, "hover", this);
				}
				// it's hard to hover a row filled with content so we just trigger it always if you have something
				this.$services.triggerable.untrigger(row, "hover", this);
				if (row && row.state && row.state.stopHoverPropagation) {
					event.stopPropagation();
				}
			}
		},
		mouseOver: function(event, row, cell) {
			if (this.edit) {
				var rowTarget = document.getElementById(this.page.name + '_' + row.id);
				if (rowTarget) {
					rowTarget.classList.add("is-hovering");
				}
				if (cell) {
					var cellTarget = document.getElementById(this.page.name + '_' + row.id + '_' + cell.id);
					if (cellTarget) {
						cellTarget.classList.add("is-hovering");
					}
					if (!event.shiftKey) {
						event.stopPropagation();
					}
				}
			}
			// in non-edit mode, we want to trigger the hover
			else {
				if (cell && cell.state && cell.state.stopHoverPropagation) {
					event.stopPropagation();
				}
				if (cell) {
					this.$services.triggerable.trigger(cell, "hover", null, this);
				}
				// it's hard to hover a row filled with content so we just trigger it always if you have something
				this.$services.triggerable.trigger(row, "hover", null, this);
				if (row && row.state && row.state.stopHoverPropagation) {
					event.stopPropagation();
				}
			}
		},
		menuHover: function($event) {
			if (this.edit) {
				var self = this;
				if ($event.target.$unhover) {
					clearTimeout($event.target.$unhover);
					$event.target.$unhover = null;
				}
				$event.target.classList.add("is-menu-hovering");
			}
		},
		menuUnhover: function($event) {
			if (this.edit) {
				var self = this;
				$event.target.$unhover = setTimeout(function() {
					$event.target.classList.remove("is-menu-hovering");
					$event.target.$unhover = null;
				}, 500);
			}
		}
	}
});

Vue.component("n-prompt", {
	template: "#n-prompt",
	props: {
		autoclose: {
			type: Boolean,
			required: false
		}
	}
});

Vue.component("n-absolute", {
	template: "#n-absolute",
	props: {
		top: {
			required: false
		},
		bottom: {
			required: false
		},
		left: {
			required: false
		},
		right: {
			required: false
		},
		fixed: {
			required: false
		},
		autoclose: {
			type: Boolean,
			required: false
		},
		snapPoint: {
			type: String,
			default: "top-left"
		}
	},
	data: function() {
		return {
			relativeX: 0,
			relativeY: 0
		}	
	},
	ready: function() {
		// we need the bounding box of the first relative parent
		var relative = this.$el.offsetParent;
		if (relative) {
			var rect = relative.getBoundingClientRect();
			this.relativeX = rect.left;
			this.relativeY = rect.top;
		}
	},
	methods: {
		// if we do this as a computed, it will update everytime we move the mouse
		getStyles: function() {
			var styles = [];
			if (this.top != null) {
				styles.push({"top": this.top });
			}
			if (this.bottom != null) {
				styles.push({"bottom": this.bottom });
			}
			if (this.left != null) {
				styles.push({"left": this.left });
			}
			if (this.right != null) {
				styles.push({"right": this.right });
			}
			// if no specific styling, position it at mouse
			if (!styles.length) {
				// these are not reactive, use mouseX and mouseY if you want reactive coordinates
				var x = this.$services.page.mouseXPassive - this.relativeX;
				var y = this.$services.page.mouseYPassive - this.relativeY;
				styles.push({"left": + x + "px" });
				styles.push({"top": + y + "px"});
				//styles.push({"left": + JSON.parse(JSON.stringify(this.$services.page.mouseX)) + "px" });
				//styles.push({"top": + JSON.parse(JSON.stringify(this.$services.page.mouseY)) + "px"});
			}
			else {
				// we want the positioning (left, top...) to be to a different point than the default top left
				if (this.snapPoint == "center") {
					styles.push({"transform": "translate(-50%, -50%)"});
				}
				else if (this.snapPoint == "bottom-right") {
					styles.push({"transform": "translate(-100%, -100%)"});
				}
				else if (this.snapPoint == "bottom-left") {
					styles.push({"transform": "translate(0, -100%)"});
				}
				else if (this.snapPoint == "top-right") {
					styles.push({"transform": "translate(-100%, 0%)"});
				}
			}
			// can also use fixed positioning
			if (this.fixed) {
				styles.push({"position": "fixed"});
			}
			else {
				styles.push({"position": "absolute"});
			}
			return styles;
		}
	}
});

Vue.component("page-sidemenu", {
	template: "#page-sidemenu",
	props: {
		page: {
			type: Object,
			required: true
		},
		rows: {
			type: Array,
			required: true
		},
		selected: {
			type: Object,
			required: false
		}
	},
	data: function() {
		return {
			opened: [],
			editing: null,
			aliasing: null,
			showMenuItem: null,
			showMenuType: null,
			offsetX: 0,
			offsetY: 0
		}	
	},
	methods: {
		showMenu: function(row, cell, $event) {
			this.offsetX = $event.offsetX;
			this.offsetY = $event.offsetY;
			console.log("offset", this.offsetX, this.offsetY);
			if (cell) {
				this.showMenuType = "cell";
				this.showMenuItem = cell;
			}
			else if (row) {
				this.showMenuType = "row";
				this.showMenuItem = row;
			}
		},
		closeMenu: function() {
			this.showMenuType = null;
			this.showMenuItem = null;
		},
		getCellIcon: function(cell) {
			var self = this;
			if (cell.templateIcon) {
				return cell.templateIcon;
			}
			if (cell.templateReferenceId) {
				var current = this.$services.page.templates.filter(function(x) {
					return x.id == cell.templateReferenceId;
				})[0];
			}
			return current && current.icon ? current.icon : "cube";
		},
		formatPageItem: function(target) {
			var self = this;
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			return this.$services.page.formatPageItem(pageInstance, target);
		},
		requestFocusCell: function(cell) {
			if (this.$refs["cell_" + cell.id] && this.$refs["cell_" + cell.id].length) {
				this.$refs["cell_" + cell.id][0].focus();
			}
		},
		requestFocus: function() {
			var self = this;
			Vue.nextTick(function() {
				console.log("input is", self.$el.querySelector("input"));
				self.$el.querySelector("input").focus();
			});
		},
		wrapCell: function(row, cell) {
			var newCell = this.addCell(row, true);
			// we keep aris styling!
			newCell.aris = cell.aris;
			newCell.name = "Wrapper" + (cell.alias ? " for " + this.$services.page.prettifyRouteAlias(cell.alias) : "");
			cell.aris = null;
			var index = row.cells.indexOf(cell);
			row.cells.splice(index, 1, newCell);
			var row = this.addRow(newCell);
			row.cells.push(cell);
		},
		rotate: function(row) {
			this.$services.page.normalizeAris(this.page, row, "row");
			var options = row.aris.components["page-row"].options;
			// we remove vertical
			var index = options.indexOf("direction_vertical");
			if (index >= 0) {
				options.splice(index, 1);
			}
			// otherwise we add it and remove any explicit horizontal
			else {
				index = options.indexOf("direction_horizontal");
				if (index >= 0) {
					options.splice(index, 1);	
				}
				options.push("direction_vertical");
			}
		},
		up: function(row) {
			var index = this.rows.indexOf(row);
			if (index > 0) {
				var replacement = this.rows[index - 1];
				this.rows.splice(index - 1, 1, row);
				this.rows.splice(index, 1, replacement);
				// focus so you can do more commands
				Vue.nextTick(function() {
					document.getElementById("layout-entry-" + row.id).querySelector("[tabindex]").focus();
				})
			}
		},
		down: function(row) {
			var index = this.rows.indexOf(row);
			if (index < this.rows.length - 1) {
				var replacement = this.rows[index + 1];
				this.rows.splice(index + 1, 1, row);
				this.rows.splice(index, 1, replacement);
				// focus so you can do more commands
				Vue.nextTick(function() {
					document.getElementById("layout-entry-" + row.id).querySelector("[tabindex]").focus();
				})
			}
		},
		cellDown: function(row, cell) {
			console.log("moving cell down!");
			var index = this.rows.indexOf(row);
			if (index < this.rows.length - 1) {
				var target = this.rows[index + 1];
				row.cells.splice(row.cells.indexOf(cell));
				target.cells.push(cell);
				Vue.nextTick(function() {
					document.getElementById("layout-entry-" + cell.id).querySelector("[tabindex]").focus();
				});
			}
		},
		cellUp: function(row, cell) {
			var index = this.rows.indexOf(row);
			if (index > 0) {
				var target = this.rows[index - 1];
				row.cells.splice(row.cells.indexOf(cell));
				target.cells.push(cell);
				// focus so you can do more commands
				Vue.nextTick(function() {
					document.getElementById("layout-entry-" + cell.id).querySelector("[tabindex]").focus();
				});
			}
		},
		left: function(row, cell) {
			var index = row.cells.indexOf(cell);
			if (index > 0) {
				var replacement = row.cells[index - 1];
				row.cells.splice(index - 1, 1, cell);
				row.cells.splice(index, 1, replacement);
				Vue.nextTick(function() {
					document.getElementById("layout-entry-" + cell.id).querySelector("[tabindex]").focus();
				})
			}
		},
		right: function(row, cell) {
			var index = row.cells.indexOf(cell);
			if (index < row.cells.length - 1) {
				var replacement = row.cells[index + 1];
				row.cells.splice(index + 1, 1, cell);
				row.cells.splice(index, 1, replacement);
				Vue.nextTick(function() {
					document.getElementById("layout-entry-" + cell.id).querySelector("[tabindex]").focus();
				})
			}
		},
		mouseOut: function(event, row, cell) {
			var self = this;
			var rowTarget = document.getElementById(self.page.name + '_' + row.id);
			if (rowTarget) {
				rowTarget.classList.remove("is-hovering");
			}
			if (cell) {
				var cellTarget = document.getElementById(self.page.name + '_' + row.id + '_' + cell.id);
				if (cellTarget) {
					cellTarget.classList.remove("is-hovering");
				}
			}
		},
		mouseOver: function(event, row, cell) {
			var rowTarget = document.getElementById(this.page.name + '_' + row.id);
			if (rowTarget) {
				rowTarget.classList.add("is-hovering");
			}
			if (cell) {
				var cellTarget = document.getElementById(this.page.name + '_' + row.id + '_' + cell.id);
				if (cellTarget) {
					cellTarget.classList.add("is-hovering");
				}
				if (!event.shiftKey) {
					event.stopPropagation();
				}
			}
		},
		showHtml: function(row, cell) {
			var target = document.getElementById(this.page.name + '_' + row.id);
			if (cell) {
				target = document.getElementById(this.page.name + '_' + row.id + '_' + cell.id);
			}
			if (target != null) {
				var html = target.innerHTML;
				this.$services.page.showContent(html);
			}
		},
		scrollIntoView: function(row, cell) {
			var target = this.page.name + '_' + row.id;
			if (cell) {
				target += "_" + cell.id;
			}
			document.getElementById(target).scrollIntoView();
		},
		hasConfigure: function(cell) {
			var self = this;
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			var cellInstance = pageInstance.getComponentForCell(cell.id);
			return cellInstance && cellInstance.configure;
		},
		configure: function(cell) {
			var self = this;
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			var cellInstance = pageInstance.getComponentForCell(cell.id);
			cellInstance.configure();
		},
		toggleRow: function(row) {
			var index = this.opened.indexOf(row.id);
			if (index < 0) {
				this.opened.push(row.id);
			}
			else {
				this.opened.splice(index, 1);
			}
		},
		selectRow: function(row) {
			var wasSelected = this.selected == row;
			this.$emit("select", row, null, "row");
			var index = this.opened.indexOf(row.id);
			if (index < 0) {
				this.configureRow(row);
				this.opened.push(row.id);
			}	
			else if (wasSelected) {
				this.opened.splice(index, 1);
			}
			else {
				this.configureRow(row);
			}
		},
		configureRow: function(row) {
			var target = this.getRowById(row);
			var parent = target.parentNode;
			while (parent != null && (!parent.__vue__ || !parent.__vue__.setRowConfiguring)) {
				parent = parent.parentNode;
			}
			if (parent) {
				parent.__vue__.setRowConfiguring(row.id);
			}
			//target.parentNode.__vue__.configuring = row.id;
		},
		selectCell: function(row, cell) {
			var wasSelected = this.selected == cell;
			this.$emit("select", row, cell, "cell");
			this.configureCell(row, cell);
		},
		getCellById: function(row, cell) {
			return cell.customId && !cell.alias && !cell.rows.length && !cell.renderer ? document.getElementById(cell.customId) : document.getElementById(this.page.name + '_' + row.id + '_' + cell.id);
		},
		getRowById: function(row) {
			return row.customId && !row.renderer ? document.getElementById(row.customId) : document.getElementById(this.page.name + "_" + row.id);
		},
		configureCell: function(row, cell) {
			var target = this.getCellById(row, cell);
			if (target != null) {
				//target.parentNode.parentNode.__vue__.configuring = cell.id;
				var parent = target.parentNode;
				while (parent != null && (!parent.__vue__ || !parent.__vue__.setRowConfiguring)) {
					parent = parent.parentNode;
				}
				if (parent) {
					parent.__vue__.setRowConfiguring(cell.id);
				}
			}
		},
		addRow: function(target) {
			if (!target.rows) {
				Vue.set(target, "rows", []);
			}
			var row = {
				id: this.page.content.counter++,
				state: {},
				cells: [],
				class: null,
				// a custom id for this row
				customId: null,
				condition: null,
				direction: null,
				align: null,
				on: null,
				collapsed: false,
				name: null
			};
			target.rows.push(row);
			return row;
		},
		removeCell: function(cells, cell) {
			this.$confirm({
				message: "Are you sure you want to remove this cell?"
			}).then(function() {
				cells.splice(cells.indexOf(cell), 1);
			});
		},
		removeRow: function(cell, row) { 
			self.$services.page.closeRight();
			cell.rows.splice(cell.rows(indexOf(row), 1));
		},
		addCell: function(target, skipInject) {
			if (!target.cells) {
				Vue.set(target, "cells", []);
			}
			var cell = {
				id: this.page.content.counter++,
				rows: [],
				// the alias of the route we want to render here (if any)
				alias: null,
				// the route may have input parameters (path + query), these are the relevant bindings
				// the binding variable contains keys for each path/query parameter in the route
				bindings: {},
				name: null,
				// state that is maintained by the cell owner (the route alias)
				// for example it might offer additional configuration
				state: {},
				// the rendering target (e.g. sidebar, prompt,...)
				target: 'page',
				// it can depend on an event of taking place
				on: null,
				// a class for this cell
				class: null,
				// a custom id for this cell
				customId: null,
				// flex width
				width: null,
				height: null,
				condition: null,
				devices: [],
				clickEvent: null
			};
			if (!skipInject) {
				target.cells.push(cell);
				this.$services.page.normalizeAris(this.page, cell);
			}
			return cell;
		},
		copyCell: function(cell) {
			nabu.utils.objects.copy({
				type: "page-cell",
				content: cell
			});
			this.$services.page.copiedCell = JSON.parse(JSON.stringify(cell));
			this.$services.page.copiedRow = null;
		},
		copyRow: function(row) {
			nabu.utils.objects.copy({
				type: "page-row",
				content: row
			});
			this.$services.page.copiedRow = JSON.parse(JSON.stringify(row));
			this.$services.page.copiedCell = null;
		},
		pasteCell: function(row) {
			row.cells.push(this.$services.page.renumber(this.page, this.$services.page.copiedCell));
			//this.$services.page.copiedCell = null;
			// when you paste again, we want a new copy that is not by reference the previous copy!
			this.$services.page.copiedCell = nabu.utils.objects.deepClone(this.$services.page.copiedCell);
		},
		pasteRow: function(cell) {
			if (!cell.rows) {
				Vue.set(cell, "rows", []);
			}
			cell.rows.push(this.$services.page.renumber(this.page, this.$services.page.copiedRow));
			//this.$services.page.copiedRow = null;
			this.$services.page.copiedRow = nabu.utils.objects.deepClone(this.$services.page.copiedRow);
		},
		dragCell: function(event, row, cell) {
			this.$services.page.setDragData(event, "page-cell", cell.id);
			if (event.ctrlKey) {
				this.$services.page.setDragData(event, "drag-action", "copy");
			}
		},
		dragRow: function(event, row) {
			this.$services.page.setDragData(event, "page-row", row.id);
			if (event.ctrlKey) {
				this.$services.page.setDragData(event, "drag-action", "copy");
			}
		},
		acceptDragRow: function(event, row) {
			if (this.$services.page.hasDragData(event, "page-cell")) {
				event.preventDefault();
			}
			else if (this.$services.page.hasDragData(event, "page-row")) {
				this.$services.page.pushDragItem(event.target);
				var rect = event.target.getBoundingClientRect();
				if (Math.abs(event.clientY - rect.top) >= rect.height / 2) {
					event.target.classList.remove("is-hover-top");
					event.target.classList.add("is-hover-bottom");
				}
				else {
					event.target.classList.remove("is-hover-bottom");
					event.target.classList.add("is-hover-top");
				}
				event.preventDefault();
			}
		},
		acceptDragCell: function(event, row, cell) {
			if (this.$services.page.hasDragData(event, "page-row")) {
				event.preventDefault();
			}
			else if (this.$services.page.hasDragData(event, "page-cell")) {
				this.$services.page.pushDragItem(event.target);
				var rect = event.target.getBoundingClientRect();
				if (Math.abs(event.clientY - rect.top) >= rect.height / 2) {
					event.target.classList.remove("is-hover-top");
					event.target.classList.add("is-hover-bottom");
				}
				else {
					event.target.classList.remove("is-hover-bottom");
					event.target.classList.add("is-hover-top");
				}
				event.preventDefault();
			}
		},
		dropRow: function(event, row) {
			var cellId = this.$services.page.getDragData(event, "page-cell");
			var rowId = this.$services.page.getDragData(event, "page-row");
			if (cellId) {
				var content = this.$services.page.getTarget(this.page.content, cellId);
				var action = this.$services.page.getDragData(event, "drag-action");
				if (!row.cells) {
					Vue.set(row, "cells", []);
				}
				if (action == "copy") {
					content = JSON.parse(JSON.stringify(content));
					this.$services.page.renumber(this.page, content);
				}
				else {
					var parent = this.$services.page.getTarget(this.page.content, content.id, true);
					// do nothing, we don't want to add it to ourselves again
					if (parent == row) {
						return null;
					}
					var index = parent.cells.indexOf(content);
					if (index >= 0) {
						parent.cells.splice(index, 1);
						// if we emptied out the cells, remove it
						if (parent.cells.length == 0) {
							var grandParent = this.$services.page.getTarget(this.page.content, parent.id, true);
							index = grandParent.rows.indexOf(parent);
							grandParent.rows.splice(index, 1);
						}
					}
				}
				row.cells.push(content);
			}
			if (rowId && row.id != rowId) {
				var content = this.$services.page.getTarget(this.page.content, rowId);
				var action = this.$services.page.getDragData(event, "drag-action");
				var parent = this.$services.page.getTarget(this.page.content, row.id, true);
				
				if (action == "copy") {
					content = JSON.parse(JSON.stringify(content));
					this.$services.page.renumber(this.page, content);
				}
				else {
					this.$services.page.closeRight();
					var og = this.$services.page.getTarget(this.page.content, content.id, true);
					var index = og.rows.indexOf(content);
					if (index >= 0) {
						og.rows.splice(index, 1);
						// if the og is not the page and the rows are empty and it has no other content, remove it
						if (og.rows.length == 0 && og.id && !og.alias) {
							var grandParent = this.$services.page.getTarget(this.page.content, og.id, true);
							index = grandParent.cells.indexOf(og);
							grandParent.cells.splice(index, 1);
						}
					}
				}
				var rect = event.target.getBoundingClientRect();
				
				var index = parent.rows.indexOf(row);
				// position below it
				if (Math.abs(event.clientY - rect.top) >= rect.height / 2) {
					parent.rows.splice(index + 1, 0, content);
				}
				else {
					parent.rows.splice(index, 0, content);
				}
			}
			this.$services.page.clearAllDrag();
		},
		dropCell: function(event, row, cell) {
			var cellId = this.$services.page.getDragData(event, "page-cell");
			var rowId = this.$services.page.getDragData(event, "page-row");
			// if you drop a cell on a cell, you want to position it before or after it
			if (cellId && cell.id != cellId) {
				var content = this.$services.page.getTarget(this.page.content, cellId);
				var action = this.$services.page.getDragData(event, "drag-action");
				var parent = this.$services.page.getTarget(this.page.content, cell.id, true);
				
				if (action == "copy") {
					content = JSON.parse(JSON.stringify(content));
					this.$services.page.renumber(this.page, content);
				}
				else {
					this.$services.page.closeRight();
					var og = this.$services.page.getTarget(this.page.content, content.id, true);
					var index = og.cells.indexOf(content);
					if (index >= 0) {
						og.cells.splice(index, 1);
						if (og.cells.length == 0) {
							var grandParent = this.$services.page.getTarget(this.page.content, og.id, true);
							index = grandParent.rows.indexOf(og);
							grandParent.rows.splice(index, 1);
						}
					}
				}
				
				var rect = event.target.getBoundingClientRect();
				var index = parent.cells.indexOf(cell);
				// position below it
				if (Math.abs(event.clientY - rect.top) >= rect.height / 2) {
					parent.cells.splice(index + 1, 0, content);
				}
				else {
					parent.cells.splice(index, 0, content);
				}
			}
			if (rowId && row.id != rowId) {
				var content = this.$services.page.getTarget(this.page.content, rowId);
				var action = this.$services.page.getDragData(event, "drag-action");
				if (action == "copy") {
					content = JSON.parse(JSON.stringify(content));
					this.$services.page.renumber(this.page, content);
				}
				else {
					var parent = this.$services.page.getTarget(this.page.content, content.id, true);
					var index = parent.rows.indexOf(content);
					if (index >= 0) {
						parent.rows.splice(index, 1);
						// if the parent is not the page and the rows are empty and it has no other content, remove it
						if (parent.rows.length == 0 && parent.id && !parent.alias) {
							var grandParent = this.$services.page.getTarget(this.page.content, parent.id, true);
							index = grandParent.cells.indexOf(parent);
							grandParent.cells.splice(index, 1);
						}
					}
				}
				var rect = event.target.getBoundingClientRect();
				if (!cell.rows) {
					Vue.set(cell, "rows", []);
				}
				cell.rows.push(content);
			}
			this.$services.page.clearAllDrag();
		}
	},
	watch: {
		selected: function(newValue) {
			if (this.rows.indexOf(newValue) >= 0) {
				var index = this.opened.indexOf(newValue.id);
				if (index < 0) {
					this.opened.push(newValue.id);
				}
				this.$emit("open");
			}
			else {
				var self = this;
				this.rows.forEach(function(row) {
					if (row.cells && row.cells.indexOf(newValue) >= 0) {
						var index = self.opened.indexOf(row.id);
						if (index < 0) {
							self.opened.push(row.id);
						}
						self.$emit("open");
					}
				});
			}
		},
		// @2024-01-19
		// this piece of code keeps stealing focus when you are for example typing in a rich text area
		// it is currently unclear why this was added so disabling for now
		// if weird behavior starts popping up, we might be able to deduce why it was added
		/*
		rows: {
			deep: true,
			handler: function() {
				if (this.selected && this.$refs["cell_" + this.selected.id] && this.$refs["cell_" + this.selected.id].length) {
					var self = this;
					setTimeout(function() {
						self.$refs["cell_" + self.selected.id][0].focus();
					}, 0);
				}
			}
		}
		*/
	}
});

Vue.component("aris-editor", {
	template: "#aris-editor",
	props: {
		childComponents: {
			type: Array,
			required: true
		},
		// where to store the changes
		container: {
			type: Object,
			required: true
		},
		specific: {
			type: String,
			required: false
		}
	},
	data: function() {
		return {
			conditioning: null,
			search: null
		}
	},
	methods: {
		hasAnySearchHits: function(dimension, option) {
			if (!this.search) {
				return true;
			}
			var options = [];
			// a dimension search across all options
			if (!option) {
				nabu.utils.arrays.merge(options, dimension.options);
			}
			else {
				options.push(option);
			}
			var matches = false;
			var regex = new RegExp(this.search.toLowerCase().replace(/[\s]+/g, ".*"));
			options.forEach(function(x) {
				if (!matches && (!!x.name.toLowerCase().match(regex) || !!x.body.toLowerCase().match(regex))) {
					matches = true;
				}
			});
			return matches;
		},
		getAmountOfAppliedOptions: function(component) {
			var self = this;
			var modifiers = this.getAvailableModifiers(component);
			var activeModifiers = Object.keys(modifiers).filter(function(key) {
				return self.isActiveModifier(component, key);
			}).length;
			var dimensions = this.getAvailableDimensions(component);
			var activeOptions = 0;
			dimensions.forEach(function(x) {
				activeOptions += x.options.filter(function(y) {
					return self.isActiveOption(component, x, y.name);
				}).length;
			});
			return activeOptions + activeModifiers;
		},
		// we format it here to prevent having to call it twice for condition
		getFormattedAmountOfAppliedOptions: function(component) {
			var amount = this.getAmountOfAppliedOptions(component);	
			if (this.search) {
				var amountOfHits = this.getAmountOfSearchHits(component);
				return amount ? " (" + amount + " active, " + amountOfHits + " matches)" : " (" + amountOfHits + " matches)";
			}
			return amount ? " (" + amount + " active)" : "";
		},
		getAmountOfSearchHits: function(component) {
			if (!this.search) {
				return 0;
			}
			var self = this;
			return this.getAvailableDimensions(component).filter(function(x) {
				return self.hasAnySearchHits(x);
			}).length;
		},
		formatBody: function(body) {
			return ("\t" + body).replace(/[\n]+/g, "<br/>").replace(/[\t]/g, "&nbsp;&nbsp;&nbsp;");
		},
		getAvailableDimensions: function(childComponent) {
			var hierarchy = this.$services.page.getArisComponentHierarchy(childComponent.component);
			var dimensions = [];
			var self = this;
			hierarchy.forEach(function(component) {
				if (component.dimensions) {
					component.dimensions.forEach(function(x) {
						var current = dimensions.filter(function(y) { return y.name == x.name })[0];
						if (!current) {
							current = {name: x.name };
							dimensions.push(current);
						}
						if (!current.options) {
							current.options = [];
						}
						// a dimension can exist across multiple components (being more specific in a certain extension)
						if (!current.components) {
							current.components = [];
						}
						current.components.push(component.name);
						// only add options that we don't know about yet
						if (current.options.length > 0) {
							x.options.forEach(function(y) {
								var option = current.options.filter(function(z) { return z.name == y.name })[0];
								if (option == null) {
									current.options.push(JSON.parse(JSON.stringify(y)));
								}
								// append the body so we see the full effect
								else if (option.body.indexOf(y.body) < 0) {
									option.body += "\n" + y.body;
								}
							});
						}
						else {
							nabu.utils.arrays.merge(current.options, x.options);
						}
						current.options = current.options.filter(function(x) {
							return self.$services.page.isThemeCompliant(x);
						});
					})
				}
			});
			// a dimension without options is worthless!
			dimensions = dimensions.filter(function(x) {
				return x.options.length > 0;
			});
			// sort the dimensions alphabetically
			dimensions.sort(function(a, b) { return a.name.localeCompare(b.name) });
			return dimensions;
		},
		getAvailableVariants: function(childComponent) {
			var variants = [];
			var self = this;
			this.$services.page.getArisComponentHierarchy(childComponent.component).forEach(function(component) {
				if (component.variants != null) {
					component.variants.filter(function(x) {
						return self.$services.page.isThemeCompliant(x)
					}).forEach(function(variant) {
						var clone = JSON.parse(JSON.stringify(variant));
						clone.component = component.name;
						variants.push(clone);
					});
				}
			});
			return variants;
		},
		getAvailableVariantNames: function(childComponent, value) {
			var variants = [];
			this.getAvailableVariants(childComponent).forEach(function(x) { 
				if (variants.indexOf(x.name) < 0) {
					variants.push(x.name);
				}
			});
			if (value) {
				variants = variants.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			variants.sort();
			return variants;
		},
		isActiveModifier: function(childComponent, modifier) {
			return this.container.components[childComponent.name].modifiers.indexOf(modifier) >= 0;
		},
		hasCondition: function(childComponent, name) {
			return this.container.components[childComponent.name].conditions[name] != null;	
		},
		getCondition: function(childComponent, name) {
			return this.container.components[childComponent.name].conditions[name];	
		},
		setCondition: function(childComponent, name, condition) {
			this.container.components[childComponent.name].conditions[name] = condition == null ? null : condition;
		},
		toggleModifier: function(childComponent, modifier) {
			var index = this.container.components[childComponent.name].modifiers.indexOf(modifier);
			if (index >= 0) {
				this.container.components[childComponent.name].modifiers.splice(index, 1);
				this.container.components[childComponent.name].conditions[modifier] = null;
			}
			else {
				this.container.components[childComponent.name].modifiers.push(modifier);
			}
		},
		getAvailableModifiers: function(childComponent) {
			var current = this.container.components[childComponent.name].variant;
			var available = {};
			var self = this;
			this.getAvailableVariants(childComponent).filter(function(x) {
				return self.$services.page.isThemeCompliant(x) && (x.name == "default" || x.name == current);
			}).forEach(function(x) { 
				if (x.modifiers) {
					x.modifiers.forEach(function(y) {
						if (available[y] == null) {
							available[y] = [];
						}
						available[y].push({
							variant: x.name,
							component: x.component
						});
					})
				} 
			});
			return available;
		},
		getAvailableModifierNames: function(childComponent) {
			var available = Object.keys(this.getAvailableModifiers(childComponent));
			available.sort();
			return available;
		},
		getAvailableOptions: function(childComponent, dimension) {
			var self = this;
			var current = this.getAvailableDimensions(childComponent).filter(function(x) { return self.$services.page.isThemeCompliant(x) && x.name == dimension.name });
			return current ? current.options : [];
		},
		toggleOption: function(childComponent, dimension, option) {
			var index = this.container.components[childComponent.name].options.indexOf(dimension.name + "_" + option);
			if (index >= 0) {
				this.container.components[childComponent.name].options.splice(index, 1);
				this.container.components[childComponent.name].conditions[dimension.name + '_' + option] = null;
			}
			else {
				this.container.components[childComponent.name].options.push(dimension.name + "_" + option);
			}
		},
		isActiveOption: function(childComponent, dimension, option) {
			return this.container.components[childComponent.name].options.indexOf(dimension.name + "_" + option) >= 0;
		},
		listActiveOptions: function(childComponent, dimension) {
			var active = this.container.components[childComponent.name].options.filter(function(x) {
				return x.indexOf(dimension.name + "_") == 0;
			}).map(function(x) {
				return x.substring((dimension.name + "_").length);
			});
			return active.length == 0 ? null : active.join(", ");
		},
		listActiveModifiers: function(childComponent) {
			var active = this.container.components[childComponent.name].modifiers;
			return active.length == 0 ? null : active.join(", ");
		},
		clearOptions: function(childComponent) {
			this.container.components[childComponent.name].variant = null;
			this.container.components[childComponent.name].options.splice(0);
			this.container.components[childComponent.name].modifiers.splice(0);
		},
		clearDimension: function(childComponent, dimension) {
			// we want to retain all options not linked to this dimension
			var retain = this.container.components[childComponent.name].options.filter(function(x) {
				return x.indexOf(dimension + "_") < 0;
			});
			this.container.components[childComponent.name].options.splice(0);
			nabu.utils.arrays.merge(this.container.components[childComponent.name].options, retain);
		},
		saveAsDefaultAris: function(childComponent) {
			var settings = this.container.components[childComponent.name];
			if (settings) {
				var result = "";
				// default variants don't need to be explicitly included!
				if (settings.variant != null && settings.variant != "default") {
					// we need to know which component in the hierarchy the variant is from
					var variants = this.getAvailableVariants(childComponent);
					var applicable = variants.filter(function(x) {
						return x.name == settings.variant;
					})
					applicable.forEach(function(x) {
						// include the variant itself
						result += "\t@include " + x.component + "_variant_" + settings.variant + ";\n";
					});
				}
				var dimensions = this.getAvailableDimensions(childComponent);
				settings.options.forEach(function(x) {
					var parts = x.split("_");
					var dimension = parts[0];
					var option = parts[1];
					var found = dimensions.filter(function(x) {
						return x.name == dimension;
					})[0];
					if (found) {
						found.components.forEach(function(component) {
							result += "\t@include " + component + "_" + dimension + "_" + option + ";\n";
						});
					}
				});
				var modifiers = this.getAvailableModifiers(childComponent);
				settings.modifiers.forEach(function(x) {
					if (modifiers[x] != null) {
						modifiers[x].forEach(function(variant) {
							result += "\t@include " + variant.component + "-" + variant.variant + "_modifier_" + x + ";\n";
						});
					}
				});
				this.$services.swagger.execute("nabu.web.page.core.v2.rest.aris.variant.update", {
					variant: childComponent.component + "_variant_" + (childComponent.defaultVariant ? childComponent.defaultVariant : childComponent.name) + (this.specific && childComponent.name == "page-column" ? "-" + this.specific : ""),
					body: {
						// we want to skip the trailing linefeed
						content: result.length == 0 ? null : result.substring(0, result.length - 1)
					}
				});
			}
			// clear the options, it is now the default!
			this.clearOptions(childComponent);
		},
		prettifyOption: function(option) {
			return option;
		}
	},
	watch: {
		// used for force rerendering of cell in edit mode
		container: {
			deep: true,
			handler: function(newValue) {
				if (newValue && !newValue.hasOwnProperty("rerender")) {
					Object.defineProperty(newValue, "rerender", {
						value: true,
						enumerable: false,
						writable: true
					});
				}
				else {
					newValue.rerender = true;
				}
			}
		}
	}
})

Vue.component("renderer-bindings", {
	template: "#renderer-bindings",
	props: {
		page: {
			type: Object,
			required: true
		},
		target: {
			type: Object,
			required: true
		}
	},
	created: function() {
		console.log("created bindings thing", this.fields);
		if (!this.target.rendererBindings) {
			Vue.set(this.target, "rendererBindings", {});
		}
	},
	computed: {
		fields: function() {
			var fields = [];
			if (this.target.renderer) {
				var state = this.$services.page.getRendererState(this.target.renderer, this.target, this.page, this.$services.page.getAllAvailableParameters(this.page));
				if (state) {
					nabu.utils.arrays.merge(fields, this.$services.page.getSimpleKeysFor(state, true, true));
				}
			}
			console.log("fields are", fields);
			return fields;
		}
	},
	data: function() {
		return {
			automapFrom: null
		}
	},
	methods: {
		automap: function() {
			if (this.automapFrom) {
				var generator = nabu.page.providers("page-generator").filter(function(x) {
					return x.name.toLowerCase() == "form";
				})[0];
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				generator.automap(this.target, pageInstance, this.automapFrom);
			}
		}
	}
});

Vue.component("template-manager", {
	template: "#template-manager",
	props: {
		page: {
			type: Object,
			required: true
		},
		// the cell or row
		target: {
			type: Object,
			required: true
		}
	},
	computed: {
		path: function() {
			return this.$services.page.getTargetPath(this.page.content, this.target.id);
		},
		excluded: function() {
			var self = this;
			return this.path.filter(function(x) { return x.id != self.target.id && !!x.excludeFromTemplate }).length > 0;
		},
		partOfTemplate: function() {
			var self = this;
			return this.path.filter(function(x) { return x.id != self.target.id && !!x.isTemplate }).length > 0;
		},
		latestAvailableVersion: function() {
			var self = this;
			var current = this.$services.page.templates.filter(function(x) {
				return x.id == self.target.templateReferenceId;
			})[0];
			console.log("current version is", current);
			return current ? current.templateVersion : null;
		}
	},
	methods: {
		release: function() {
			// make sure we include this in the stable version!
			this.target.templateVersion++;
			// the current stable release of the template
			this.target.templateStable = JSON.parse(JSON.stringify(this.target));
			// remove any nested stable!! otherwise we keep it indefinitely
			// while this might be nice for versioning, it would just blow up
			this.target.templateStable.templateStable = null;
			// the template (when injected) should not be marked as a template
			this.target.templateStable.isTemplate = false;
			// mark it as a template instance though, otherwise only the availability of the version is a marker which is not very clean
			this.target.templateStable.isTemplateInstance = true;
			// also unset the template id, it is stored in the ref
			this.target.templateStable.templateId = null;
			
			var self = this;
			// on injecting this template into a page, it will be renumbered, we need to keep a reference to the original template
			var createRef = function(target) {
				// the id of the full template
				target.templateReferenceId = self.target.templateId;
				// the id of the content within the template
				target.templateFragmentId = target.id;
				var repeat = target.cells ? target.cells : target.rows;
				if (repeat) {
					// first we remove any exclusions
					var exclusions = repeat.filter(function(x) {
						return !!x.excludeFromTemplate;
					});
					exclusions.forEach(function(exclusion) {
						repeat.splice(repeat.indexOf(exclusion), 1);
					});
					// when we recurse over the remaining
					repeat.forEach(function(single) {
						createRef(single);
					});
				}
			}
			createRef(this.target.templateStable);
		},
		updateToLatest: function() {
			var self = this;
			var latest = this.$services.page.templates.filter(function(x) {
				return x.id == self.target.templateReferenceId;
			})[0];
			var instance = JSON.parse(latest.content).content;
			var getOriginal = function(instance, id) {
				if (instance.id == id) {
					return instance;
				}
				else if (instance.cells) {
					return instance.cells.reduce(function(all, x) {
						return all == null ? getOriginal(x, id) : all;
					}, null);
				}
				else if (instance.rows) {
					return instance.rows.reduce(function(all, x) {
						return all == null ? getOriginal(x, id) : all;
					}, null);
				}
			}
			var recursiveUpdate = function(target) {
				var original = getOriginal(instance, target.templateFragmentId);
				if (original && original.aris) {
					Vue.set(target, "aris", original.aris);
					self.$services.page.setRerender(target.aris);
				}
				if (target.cells) {
					target.cells.forEach(recursiveUpdate);
				}
				if (target.rows){
					target.rows.forEach(recursiveUpdate);
				}
			}
			recursiveUpdate(this.target);
			this.target.templateVersion = latest.templateVersion;
		}
	},
	watch: {
		"target.isTemplate": function(newValue) {
			if (newValue) {
				// the current version of the template, we start a 0 indicating that no release has happened yet
				// we don't immediately release because we want to give you the option to fill in the title etc
				Vue.set(this.target, "templateVersion", 0);
				
				// mark the page as having templates, this is only meant to speed up page checking on larger applications
				Vue.set(this.page.content, "hasTemplates", true);
				
				// make sure we have a template id
				Vue.set(this.target, "templateId", this.page.content.name + "-" + this.target.id);
			}
		}
	}
})

document.addEventListener("keydown", function(event) {
	if (event.key == "s" && (event.ctrlKey || event.metaKey) && application.services.page.editing) {
		application.services.page.editing.save(event);
	}
	else if (event.key == "d" && (event.ctrlKey || event.metaKey) && application.services.page.editing) {
		application.services.page.editing.activeTab = 'layout';
		event.preventDefault();
		event.stopPropagation();
	}
	else if (event.key == "g" && (event.ctrlKey || event.metaKey) && application.services.page.editing) {
		if (application.services.page.editing.cell || application.services.page.editing.row) {
			application.services.page.editing.activeTab = 'selected';
			event.preventDefault();
		}
		event.stopPropagation();
	}
	else if (event.key == "b" && (event.ctrlKey || event.metaKey) && application.services.page.editing) {
		application.services.page.editing.activeTab = 'settings';
		event.preventDefault();
		event.stopPropagation();
	}
	else if (event.code == "Digit1" && event.altKey && application.services.page.editing) {
		application.services.page.activeSubTab = "container";
		event.preventDefault();
	}
	else if (event.code == "Digit2" && event.altKey && application.services.page.editing) {
		application.services.page.activeSubTab = "styling";
		event.preventDefault();
	}
	else if (event.code == "Digit3" && event.altKey && application.services.page.editing) {
		application.services.page.activeSubTab = "triggers";
		event.preventDefault();
	}
	else if ((event.code == "Digit4" || event.code == "Digit5" || event.code == "Digit6" || event.code == "Digit7" || event.code == "Digit8" || event.code == "Digit9") && event.altKey && application.services.page.editing) {
		var offset = parseInt(event.code.substring(5)) - 4;
		if (offset < application.services.page.availableSubTabs.length) {
			application.services.page.activeSubTab = application.services.page.availableSubTabs[offset];
		}
		else {
			// no available subtabs, 4 means container
			if (application.services.page.availableSubTabs.length == 0 && event.code == "Digit4") {
				application.services.page.activeSubTab = "component";
			}
			else {
				application.services.page.activeSubTab = "analysis";
			}
		}
		event.preventDefault();
	}
	else if (event.key == "s" && event.altKey && application.services.page.editing) {
		application.services.page.editing.activeTab = "selected";
		application.services.page.activeSubTab = 'styling';
		event.preventDefault();
		event.stopPropagation();
	}
	else if (event.key == "t" && event.altKey && application.services.page.editing) {
		application.services.page.editing.activeTab = "selected";
		application.services.page.activeSubTab = 'triggers';
		event.preventDefault();
		event.stopPropagation();
	}
	else if (event.key == "e" && (event.ctrlKey || event.metaKey) && application.services.page.editing) {
		application.services.page.editing.stopEdit();
		event.preventDefault();
		event.stopPropagation();
	}
}, true);

document.addEventListener("dragend", function() {
	application.services.page.clearAllDrag();	
});



if (!nabu) { var nabu = {} }
if (!nabu.page) { nabu.page = {} }
if (!nabu.page.views) { nabu.page.views = {} }

nabu.page.views.PageFieldsEdit = Vue.component("page-fields-edit", {
	template: "#page-fields-edit",
	props: {
		page: {
			type: Object,
			required: true
		},
		cell: {
			type: Object,
			required: true
		},
		allowMultiple: {
			type: Boolean,
			required: false,
			default: true
		},
		keys: {
			type: Array,
			required: false
		},
		allowEditable: {
			type: Boolean,
			required: false,
			default: false
		},
		localState: {
			type: Object,
			required: false
		},
		fieldsName: {
			type: String,
			required: false,
			default: "fields"
		},
		basic: {
			type: Boolean,
			required: false,
			default: false
		},
		allowArbitrary: {
			type: Boolean,
			required: false,
			default: true
		},
		allowEvents: {
			type: Boolean,
			default: true
		}
	},
	data: function() {
		return {
			addAllSelector: null
		}
	},
	created: function() {
		if (!this.cell.state[this.fieldsName]) {
			Vue.set(this.cell.state, this.fieldsName, []);
		}
		if (!this.allowMultiple && !this.cell.state[this.fieldsName].length) {
			this.addField();
		}
		this.normalize();
	},
	computed: {
		fragmentTypes: function() {
			var provided = nabu.page.providers("page-field-fragment");
			// if we don't allow editable fields (because we have nowhere to update them to), ignore the update types (e.g. form)
			if (!this.allowEditable) {
				provided = provided.filter(function(x) { return !x.editable });
			}
			provided = provided.map(function(x) {
				 return x.name;
			});
			provided.sort();
			return provided;
		}
	},
	methods: {
		addAll: function() {
			if (this.addAllSelector) {
				var self = this;
				this.getKeys(this.addAllSelector).forEach(function(x) {
					var field = self.addField(false);
					// set the key
					field.fragments[0].key = x;
					var parts = x.split(".");
					var name = parts[parts.length - 1];
					field.label = "%" + "{" + name.substring(0, 1).toUpperCase() + name.substring(1).replace(/([A-Z])/g, " $1") + "}";
				})
				// unset
				this.addAllSelector = null;
			}
		},
		getProvidedConfiguration: function(fragmentType) {
			var provided = nabu.page.providers("page-field-fragment").filter(function(x) {
				 return x.name == fragmentType;
			})[0];
			return provided ? provided.configure : null;
		},
		normalize: function() {
			this.cell.state[this.fieldsName].map(function(field) {
				if (!field.label) {
					Vue.set(field, "label", null);
				}
				if (!field.fragments) {
					Vue.set(field, "fragments", []);
				}
				if (!field.styles) {
					Vue.set(field, "styles", []);
				}
				if (!field.hidden) {
					Vue.set(field, "hidden", null);
				}
				field.fragments.map(function(fragment) {
					if (!fragment.type) {
						Vue.set(fragment, "type", "data");
					}
					if (!fragment.content) {
						Vue.set(fragment, "content", null);
					}
					if (!fragment.format) {
						Vue.set(fragment, "format", null);
					}
					if (!fragment.javascript) {
						Vue.set(fragment, "javascript", null);
					}
					if (!fragment.template) {
						Vue.set(fragment, "template", null);
					}
					if (!fragment.class) {
						Vue.set(fragment, "class", null);
					}
					if (!fragment.key) {
						Vue.set(fragment, "key", null);
					}
					if (!fragment.form) {
						Vue.set(fragment, "form", {});
					}
				});
			});
		},
		addStyle: function(field) {
			field.styles.push({
				class: null,
				condition: null
			});
		},
		fieldUp: function(field) {
			var index = this.cell.state[this.fieldsName].indexOf(field);
			if (index > 0) {
				var replacement = this.cell.state[this.fieldsName][index - 1];
				this.cell.state[this.fieldsName].splice(index - 1, 1, field);
				this.cell.state[this.fieldsName].splice(index, 1, replacement);
			}
		},
		fieldDown: function(field) {
			var index = this.cell.state[this.fieldsName].indexOf(field);
			if (index < this.cell.state[this.fieldsName].length - 1) {
				var replacement = this.cell.state[this.fieldsName][index + 1];
				this.cell.state[this.fieldsName].splice(index + 1, 1, field);
				this.cell.state[this.fieldsName].splice(index, 1, replacement);
			}
		},
		fieldBeginning: function(field) {
			var index = this.cell.state[this.fieldsName].indexOf(field);
			if (index > 0) {
				this.cell.state[this.fieldsName].splice(index, 1);
				this.cell.state[this.fieldsName].unshift(field);
			}
		},
		fieldEnd: function(field) {
			var index = this.cell.state[this.fieldsName].indexOf(field);
			if (index < this.cell.state[this.fieldsName].length - 1) {
				this.cell.state[this.fieldsName].splice(index, 1);
				this.cell.state[this.fieldsName].push(field);
			}
		},
		up: function(field, fragment) {
			var index = field.fragments.indexOf(fragment);
			if (index > 0) {
				var replacement = field.fragments[index - 1];
				field.fragments.splice(index - 1, 1, fragment);
				field.fragments.splice(index, 1, replacement);
			}
		},
		down: function(field, fragment) {
			var index = field.fragments.indexOf(fragment);
			if (index < field.fragments.length - 1) {
				var replacement = field.fragments[index + 1];
				field.fragments.splice(index + 1, 1, fragment);
				field.fragments.splice(index, 1, replacement);
			}
		},
		addField: function(arbitrary) {
			var field = {
				label: null,
				info: null,
				infoIcon: null,
				fragments: [],
				hidden: null,
				styles: [],
				arbitrary: !!arbitrary
			};
			this.cell.state[this.fieldsName].push(field);
			// already add a fragment, a field is generally useless without it...
			this.addFragment(field);
			return field;
		},
		addFragment: function(field) {
			// default to a data fragment (generally the case)
			var fragment = {
				type: "data",
				content: null,
				format: null,
				javascript: null,
				template: null,
				class: null,
				key: null,
				disabled: null,
				hidden: null,
				form: {}
			};
			field.fragments.push(fragment);
			return fragment;
		},
		getKeys: function(value) {
			var keys;
			// you can provide external keys
			if (this.keys) {
				keys = this.keys;
			}
			else {
				// otherwise we just try to get the default ones available to you
				var parameters = this.$services.page.getAvailableParameters(this.page, this.cell, true);
				keys = this.$services.page.getSimpleKeysFor({properties:parameters}, true);
			}
			return value ? keys.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 }) : keys;
		}
	}
});

Vue.component("page-fields-edit-main", {
	template: "#page-fields-edit-main",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		},
		data: {
			required: false
		},
		shouldStyle: {
			type: Boolean,
			required: false,
			default: true
		},
		label: {
			type: Boolean,
			required: false,
			default: null
		},
		localState: {
			type: Object,
			required: false
		},
		fieldsName: {
			type: String,
			required: false,
			default: "fields"
		}
	}
})

nabu.page.views.PageFields = Vue.component("page-fields", {
	template: "#page-fields",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		},
		data: {
			required: false
		},
		shouldStyle: {
			type: Boolean,
			required: false,
			default: true
		},
		label: {
			type: Boolean,
			required: false,
			default: null
		},
		localState: {
			type: Object,
			required: false
		},
		fieldsName: {
			type: String,
			required: false,
			default: "fields"
		}
	},
	data: function() {
		return {
			configuring: false
		}
	},
	created: function() {
		this.normalize(this.cell.state);
	},
	methods: {
		/*
		configure: function() {
			this.configuring = true;	
		},
		*/
		configurator: function() {
			return "page-fields-edit-main";
		},
		normalize: function(state) {
			if (!state.class) {
				Vue.set(state, "class", null);
			}
		},
		getEvents: function() {
			var result = {};
			var self = this;
			if (this.cell.state[this.fieldsName]) {
				this.cell.state[this.fieldsName].forEach(function(field) {
					if (field.fragments) {
						field.fragments.forEach(function(fragment) {
							if (fragment.clickEvent) {
								if (typeof(fragment.clickEvent) == "string") {
									result[fragment.clickEvent] = {};
								}
								else if (nabu.page.event.getName(fragment, "clickEvent") && nabu.page.event.getName(fragment, "clickEvent") != "$close") {
									var type = nabu.page.event.getType(fragment, "clickEvent");
									if (type.properties && Object.keys(type.properties).length == 0 && self.cell.on) {
										type = self.cell.on;
									}
									result[nabu.page.event.getName(fragment, "clickEvent")] = type;
								}
							}	
						});
					}	
				});
			}
			return result;
		}
	}
});

nabu.page.views.PageFieldsTable = Vue.component("page-fields-table", {
	template: "#page-fields-table",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		},
		data: {
			required: false
		},
		shouldStyle: {
			type: Boolean,
			required: false,
			default: true
		},
		label: {
			type: Boolean,
			required: false,
			default: null
		},
		localState: {
			type: Object,
			required: false
		},
		fieldsName: {
			type: String,
			required: false,
			default: "fields"
		}
	},
	data: function() {
		return {
			configuring: false
		}
	},
	created: function() {
		this.normalize(this.cell.state);
	},
	methods: {
		configure: function() {
			this.configuring = true;	
		},
		normalize: function(state) {
			if (!state.class) {
				Vue.set(state, "class", null);
			}
			if (!state.display) {
				Vue.set(state, "class", "row");
			}
		},
		getEvents: function() {
			var result = {};
			var self = this;
			if (this.cell.state[this.fieldsName]) {
				this.cell.state[this.fieldsName].forEach(function(field) {
					if (field.fragments) {
						field.fragments.forEach(function(fragment) {
							if (fragment.clickEvent) {
								if (typeof(fragment.clickEvent) == "string") {
									result[fragment.clickEvent] = {};
								}
								else if (nabu.page.event.getName(fragment, "clickEvent") && nabu.page.event.getName(fragment, "clickEvent") != "$close") {
									var type = nabu.page.event.getType(fragment, "clickEvent");
									if (type.properties && Object.keys(type.properties).length == 0 && self.cell.on) {
										type = self.cell.on;
									}
									result[nabu.page.event.getName(fragment, "clickEvent")] = type;
								}
							}	
						});
					}	
				});
			}
			return result;
		}
	}
});

Vue.component("page-field", {
	template: "#page-field",
	props: {
		page: {
			type: Object,
			required: true
		},
		cell: {
			type: Object,
			required: true
		},
		data: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		shouldStyle: {
			type: Boolean,
			required: false
		},
		label: {
			type: Boolean,
			required: false
		},
		edit: {
			type: Boolean,
			required: false
		},
		actions: {
			type: Array,
			required: false,
			default: function() {
				return [];
			}
		}
	},
	computed: {
		// the action that applies to the entire field (if any)
		fieldAction: function() {
			return this.actions.filter(function(x) {
				return !x.icon && !x.label;
			})[0];
		},
		otherActions: function() {
			return this.actions.filter(function(x) {
				return x.icon || x.label;
			})
		}
	},
	methods: {
		trigger: function(action) {
			if (action) {
				if (!action.condition || this.$services.page.isCondition(action.condition, {record:this.data}, this)) {
					var pageInstance = this.$services.page.getPageInstance(this.page, this);
					return pageInstance.emit(action.name, this.data);
				}
			}
		},
		hasClickEvent: function(fragment) {
			if (!fragment.clickEvent) {
				return false;
			}
			else if (typeof(fragment.clickEvent) == "string") {
				return true;
			}
			else {
				return nabu.page.event.getName(fragment, "clickEvent");
			}	
		},
		handleClick: function(fragment) {
			if (this.hasClickEvent(fragment)) {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				pageInstance.emit(
					nabu.page.event.getName(fragment, "clickEvent"),
					nabu.page.event.getInstance(fragment, "clickEvent", self.page, self)
				);
			}	
		},
		getDynamicClasses: function(field) {
			var classes = null;
			if (this.shouldStyle) {
				classes = this.$services.page.getDynamicClasses(field.styles, this.data, this);
			}
			else {
				classes = [];
			}
			if (this.label) {
				classes.push("with-label");
			}
			if (this.fieldAction) {
				classes.push("with-action");
			}
			return classes;
		},
		getProvidedComponent: function(fragmentType) {
			var provided = nabu.page.providers("page-field-fragment").filter(function(x) {
				 return x.name == fragmentType;
			})[0];
			return provided ? provided.component : null;
		},
		isHidden: function(fragment) {
			if (!!fragment.hidden) {
				return this.$services.page.isCondition(fragment.hidden, {record:this.data}, this); 
			}
			return false;
		}
	}
});

Vue.component("page-formatted-configure", {
	template: "#page-formatted-configure",
	props: {
		page: {
			type: Object,
			required: true,
		},
		cell: {
			type: Object,
			required: true
		},
		fragment: {
			type: Object,
			required: true
		},
		allowHtml: {
			type: Boolean,
			required: false,
			default: false
		},
		keys: {
			type: Array,
			required: false
		}
	},
	created: function() {
		this.normalize(this.fragment);
	},
	computed: {
		nativeTypes: function() {
			var types = ['date', 'number', 'masterdata', 'javascript', 'text', 'literal'];
			if (this.allowHtml) {
				types.push('link');
				types.push('html');
				types.push('checkbox');
			}
			return types;
		},
		types: function() {
			var types = [];
			nabu.utils.arrays.merge(types, this.nativeTypes);
			nabu.utils.arrays.merge(types, nabu.page.providers("page-format").map(function(x) { return x.name }));
			types.sort();
			return types;
		},
		skipCompile: function() {
			var self = this;
			// don't compile literals
			if (this.fragment.format == "literal") {
				return true;
			}
			var formatter = nabu.page.providers("page-format").filter(function(x) { return x.name == self.fragment.format })[0];
			return formatter && formatter.skipCompile;
		}
	},
	methods: {
		isProvided: function(type) {
			return this.nativeTypes.indexOf(type) < 0;
		},
		getConfiguration: function(type) {
			var provider = nabu.page.providers("page-format").filter(function(x) { return x.name == type })[0];
			return provider ? provider.configure : null;
		},
		normalize: function(fragment) {
			if (!fragment.dateFormat) {
				Vue.set(fragment, "dateFormat", null);
			}
			if (!fragment.tag) {
				Vue.set(fragment, "tag", null);
			}
			if (!fragment.html) {
				Vue.set(fragment, "html", null);
			}
			if (!fragment.javascript) {
				Vue.set(fragment, "javascript", null);
			}
			if (!fragment.amountOfDecimals) {
				Vue.set(fragment, "amountOfDecimals", null);
			}
		}
	}
});

/**
 * For v2, we changed sanitization rules etc
 * From now on, the "default" is text, this was already the case in most places except specifically in the "plain" option of v-content
 * With the plain option now turned on in the default setting, we will get verbatim what you typed if we do nothing (so for example verbatim <b>test</b> rather than a bolded "test")
 * 
 * We will now _always_ sanitize, even for html-based components. There has not yet been a valid usecase (even for power-users) to actually inject javascript through script tags or href or...
 * If a usecase pops up in the future, we can add an _explicit_ skipSanitize option.
 * 
 * Because of how widespread this component is used, this should severely reduce accidental XSS bugs
 */
Vue.component("page-formatted", {
	template: "<component :is='tag' v-content.parameterized=\"{value:formatted,plain:isPlain, sanitize: !skipSanitize, compile: (mustCompile || fragment.compile) && !skipCompile, allowDataAttributes: allowDataAttributes, allowLinkIds: allowLinkIds }\"/>",
	props: {
		page: {
			type: Object,
			required: true,
		},
		cell: {
			type: Object,
			required: true
		},
		value: {
			required: false
		},
		fragment: {
			type: Object,
			required: true
		},
		state: {
			required: false,
			default: function() {
				return {};
			}
		},
		// called when we receive an update (?)
		updater: {
			required: false,
			type: Function
		},
		allowDataAttributes: {
			required: false,
			default: false
		},
		allowLinkIds: {
			required: false,
			default: false
		}
	},
	computed: {
		nativeTypes: function() {
			var types = ['date', 'number', 'masterdata', 'javascript', 'literal'];
			types.push('link');
			types.push('html');
			types.push('checkbox');
			return types;
		},
		tag: function() {
			if (this.fragment.tag) {
				return this.fragment.tag;	
			}
			else {
				return "span";
			}
		},
		// we must skip sanitize because we use a vue component!
		// this must be compiled before it can be sanitized...
		// could also update the order in which it is compiled? or add a mandatory post-sanitize
		skipSanitize: function() {
			if (this.fragment.format == "checkbox") {
				return true;
			}
			else if (this.fragment.skipSanitize) {
				return true;
			}
			var self = this;
			var formatter = nabu.page.providers("page-format").filter(function(x) { return x.name == self.fragment.format })[0];
			return formatter && formatter.skipSanitize;
		},
		isHtml: function() {
			if (!this.fragment.format) {
				return false;
			}
			if (["link", "html", "checkbox"].indexOf(this.fragment.format) >= 0) {
				return true;
			}
			var self = this;
			var formatter = nabu.page.providers("page-format").filter(function(x) { return x.name == self.fragment.format })[0];
			return formatter && formatter.html;
		},
		skipCompile: function() {
			var self = this;
			// don't compile literals
			if (this.fragment.format == "literal") {
				return true;
			}
			var formatter = nabu.page.providers("page-format").filter(function(x) { return x.name == self.fragment.format })[0];
			return formatter && formatter.skipCompile;
		},
		mustCompile: function() {
			if (this.fragment.format == "checkbox") {
				return true;
			}
			var self = this;
			var formatter = nabu.page.providers("page-format").filter(function(x) { return x.name == self.fragment.format })[0];
			return formatter && formatter.mustCompile;
		},
		isPlain: function() {
			var self = this;
			if (!this.fragment.format || this.fragment.format == 'text') {
				return true;
			}
			else if (this.nativeTypes.indexOf(this.fragment.format) >= 0) {
				return false;
			}
			else {
				var provider =  nabu.page.providers("page-format").filter(function(x) { return x.name == self.fragment.format })[0];
				// if we can't find the provider, we want to treat it as text
				return !provider;
			}
		},
		formatted: function() {
			// slow retrofit for array support
			// unsure if we always simply take the first or concat them all or...
			var value = this.value;
			if (value instanceof Array && value.length == 1) {
				value = value[0];
			}
			else if (value instanceof Array && value.length == 0) {
				return null;
			}
			if (this.fragment.format == "checkbox") {
				if (this.fragment.inverse) {
					return "<n-form-checkbox :value='!value' />";	
				}
				else {
					return "<n-form-checkbox :value='value' />";
				}
			}
			else if (value == null || typeof(value) == "undefined") {
				return null;
			}
			// formatting is optional
			else if (this.fragment.format == null || this.fragment.format == "text") {
				if (this.fragment.maxLength && this.value) {
					var result = ("" + this.value);
					if (result.length > parseInt(this.fragment.maxLength)) {
						result = result.substring(0, parseInt(this.fragment.maxLength)) + "...";
					}
					return result;
				}
				return this.value;
			}
			else if (this.fragment.format == "literal") {
				return this.value.replace ? this.value.replace(/</g, "&lt;").replace(/>/g, "&gt;") : null;
			}
			else if (this.fragment.format == "html") {
				return this.fragment.html ? this.fragment.html : this.value;
			}
			else if (this.fragment.format == "link") {
				var label = this.fragment.label;
				if (!label) {
					label = value.replace(/http[s]*:\/\/([^/]+).*/, "$1");
				}
				label = this.$services.page.translate(this.$services.page.interpret(label, this));
				return "<a target='_blank' class='is-button is-variant-link is-spacing-none' ref='noopener noreferrer nofollow' href='" + value + "'>" + label + "</a>";
			}
			// if it is native, format it that way
			else if (this.nativeTypes.indexOf(this.fragment.format) >= 0) {
				// did some retrofitting magic to get the state into the javascript object
				// this allows us to evaluate against the actual record state in a data list
				var fraggy = this.fragment ? nabu.utils.objects.clone(this.fragment) : {};
				fraggy.state = this.state;
				fraggy.$value = this.$value;
				return this.$services.formatter.format(this.value, fraggy, this.page, this.cell, this.state, this);
			}
			// otherwise we are using a provider
			else {
				var self = this;
				// if the provider is not known, we still want to provide the basic content
				var provider =  nabu.page.providers("page-format").filter(function(x) { return x.name == self.fragment.format })[0];
				if (!provider) {
					return this.value;
				}
				var result = provider.format(this.value, this.fragment, this.page, this.cell, this.state, this, this.updater);
				return result;
			}
		}
	}
});
Vue.component("typography-core-configure", {
	template: "#typography-template-configure",	
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	data: function() {
		return {
			icon: true
		}
	},
	created: function() {
		if (!this.cell.state.fragments) {
			Vue.set(this.cell.state, "fragments", {});
		}	
	}
});
Vue.service("typography", {
	methods: {
		getVariables: function(content) {
			var variables = [];
			var index = 0;
			var disqualifiers = ["%", "$", "{"];
			while (content != null && index >= 0) {
				// find next match
				index = content.indexOf("{", index);
				if (index < 0) {
					break;
				}
				// make sure we don't intercept other stuff
				var disqualified = index > 0 && disqualifiers.indexOf(content.charAt(index - 1)) >= 0;
				if (!disqualified) {
					var endIndex = content.indexOf("}", index);
					// no closing bracket
					if (endIndex < 0) {
						break;
					}
					var substring = content.substring(index, endIndex + 1);
					// if it contains another opening tag (because we are hitting the first of {{ or because you have nested tags), we skip it
					if (substring.substring(1).indexOf("{") < 0) {
						var variable = substring.substring(1, substring.length - 1);
						if (variables.indexOf(variable) < 0) {
							variables.push(variable);
						}
					}
					index = endIndex + 1;
				}
				else {
					index++;
				}
			}
			return variables;
		},
		// the container holds the fragment configuration
		replaceVariables: function(pageInstance, container, content, elementPromise, state) {
			var self = this;
			var component = Vue.component("page-formatted");
			this.getVariables(content).forEach(function(variable) {
				// we must at the very least have selected a key
				if (container.fragments && container.fragments[variable] && container.fragments[variable].key) {
					var placeholder = container.fragments[variable].placeholder;
					if (placeholder != null) {
						placeholder = self.$services.page.interpret(self.$services.page.translate(placeholder), pageInstance);
					}
					var formatted;
					var oldContent;
					var updateContent = function(newValue) {
						elementPromise.then(function(element) {
							// if we passed something in, use it
							if (newValue != null) {
								element.querySelectorAll("[variable='" + variable + "']").forEach(function(x) {
									x.classList.remove("is-placeholder");
									if (!newValue && placeholder != null) {
										x.classList.add("is-placeholder");
										x.innerHTML = placeholder;
									}
									else {
										x.innerHTML = newValue == null ? "" : newValue;
									}
								});
								oldContent = newValue;
							}
						});
					}
					var updateFunction = function() {
						elementPromise.then(function(element) {
							if (formatted) {
								var newContent = formatted.$el.innerHTML;
								if (newContent != oldContent) {
									element.querySelectorAll("[variable='" + variable + "']").forEach(function(x) {
										x.classList.remove("is-placeholder");
										if (!newContent && placeholder != null) {
											x.classList.add("is-placeholder");
											x.innerHTML = placeholder;
										}
										else {
											x.innerHTML = newContent == null ? "" : newContent;
										}
									})
									oldContent = newContent;
								}
							}
						});
					};
					//content = content.replace(new RegExp("\{[\s]*" + variable + "[\s]*\}", "g"), "<page-formatted :page='page' :cell='cell' :value=\"getVariableValue('" + variable + "')\" :fragment=\"getVariableFragment('" + variable + "')\"/>");
					var div = document.createElement("div");
					formatted = new component({propsData: {
						page: pageInstance.page,
						cell: {state: container},
						value: state ? self.$services.page.getValue(state, container.fragments[variable].key) : pageInstance.get(container.fragments[variable].key),
						fragment: container.fragments[variable],
						updater: updateFunction,
						// we might need it
						allowDataAttributes: true,
						allowLinkIds: true
					}, updated: updateFunction, ready: updateFunction, watch: {
						formatted: function(newValue) {
							updateContent(newValue);
						}
					}, methods: {
						$value: pageInstance.$value
					}});
					formatted.$mount();
					oldContent = formatted.$el.innerHTML;
					var contentToShow = oldContent;
					if (!contentToShow && placeholder != null) {
						contentToShow = placeholder;
					}
					// if synchronous, remove the placeholder
					if (container.fragments[variable].synchronous) {
						content = content.replace(new RegExp("\{[\s]*" + variable + "[\s]*\}", "g"), formatted.$el.innerText);
					}
					else {
						content = content.replace(new RegExp("\{[\s]*" + variable + "[\s]*\}", "g"), "<span class='is-variable " + (contentToShow != oldContent ? 'is-placeholder' : '') + "' variable='" + variable + "'>" + (contentToShow == null ? "" : contentToShow) + "</span>");
					}
				}
			});
			return this.$services.page.translate(content);
		}
	}
});
Vue.component("typography-variable-replacer", {
	template: "#typography-variable-replacer",
	props: {
		page: {
			type: Object,
			required: true
		},
		container: {
			type: Object,
			required: true
		},
		content: {
			type: String,
			required: false
		},
		// you can define a list of keys in a specific context
		keys: {
			type: Array,
			required: false
		}
	},
	created: function() {
		if (!this.container.fragments) {
			Vue.set(this.container, "fragments", {});
		}
		var self = this;
		if (this.content) {
			this.$services.typography.getVariables(this.content).forEach(function(x) {
				if (!self.container.fragments[x]) {
					Vue.set(self.container.fragments, x, {});
				}
			});
		}
	},
	methods: {
		getAllKeys: function(value) {
			var keys = [];
			if (this.keys && this.keys.length) {
				nabu.utils.arrays.merge(keys, this.keys);
			}
			else {
				nabu.utils.arrays.merge(keys, this.$services.page.getAllAvailableKeys(this.page, true));
			}
			if (value) {
				keys = keys.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
			}
			keys.sort();
			return keys;
		}
	}
});
Vue.component("typography-core", {
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	computed: {
		icon: function() {
			var icon = this.cell.state.icon;
			if (icon) {
				icon = this.$services.page.interpret(icon, this);
			}
			return icon;
		}
	},
	created: function() {
		this.elementPromise = this.$services.q.defer();
	},
	ready: function() {
		this.elementPromise.resolve(this.$el);	
	},
	data: function() {
		return {
			timer: null
		}
	},
	methods: {
		getPrettyName: function(target) {
			if (target.state && target.state.content) {
				var content = target.state.content.trim();
				// if the content is a pure variable (e.g. for basic table layouts), we don't want the curlies
				if (content.substring(0, 1) == "{") {
					content = content.substring(1);
				}
				if (content.substring(content.length - 1) == "}") {
					content = content.substring(0, content.length - 1);
				}
				// if we don't have spaces, we camel case it (e.g. in the variable example)
				if (content.indexOf(" ") < 0) {
					content = this.$services.page.prettify(content);
				}
				return content;
			}
		},
		getContentWithVariables: function(content) {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			return !content ? content : this.$services.typography.replaceVariables(pageInstance, this.cell.state, content, this.elementPromise);
		},
		getVariableValue: function(variable) {
			console.log("getting value for", variable);
		},
		getVariableFragment: function(variable) {
			return this.cell.state.fragments[variable];
		},
		highlight: function(content) {
			var highlighter = nabu.page.providers("page-format").filter(function(x) {
				 return x.name == "highlight";
			})[0];
			if (!highlighter) {
				highlighter = nabu.page.providers("page-format").filter(function(x) {
					 return x.name == "code";
				})[0];
				if (!highlighter) {
					return content;
				}
				else {
					return highlighter.format(content, {codeFormat: this.cell.state.highlightFormat});
				}
			}
			else {
				return highlighter.format(content, this.cell.state.highlightFormat ? "language-" + this.cell.state.highlightFormat : null);
			}
		},
		getChildComponents: function() {
			var components = [{
				title: "Typography",
				name: "typography",
				defaultVariant: "typography-" + this.tag,
				component: "typography"
			}];
			if (this.cell.state.tooltip) {
				components.push({
					title: "Tooltip",
					name: "tooltip",
					defaultVariant: "tooltip-" + this.tag,
					component: "tooltip"
				});
			}
			return components;
		},
		configurator: function() {
			return "typography-core-configure";
		},
		update: function() {
			if (this.timer) {
				clearTimeout(this.timer);
				this.timer = null;
			}
			var self = this;
			var last = self.$refs.editor.innerHTML;
			this.timer = setTimeout(function() {
				self.cell.state.content = nabu.utils.elements.sanitize(self.$refs.editor ? self.$refs.editor.innerHTML : last);
			}, 100);
		}
	}
});
Vue.view("typography-h1", {
	template: "#typography-template",
	mixins: [Vue.component("typography-core")],
	icon: "heading",
	description: "A level 1 header",
	name: "H1",
	category: "Typography",
	data: function() {
		return {
			tag: "h1",
			placeholder: "Heading 1"
		}
	}
});
Vue.view("typography-h2", {
	template: "#typography-template",
	mixins: [Vue.component("typography-core")],
	icon: "heading",
	description: "A level 2 header",
	name: "H2",
	category: "Typography",
	data: function() {
		return {
			tag: "h2",
			placeholder: "Heading 2"
		}
	}
})
Vue.view("typography-h3", {
	template: "#typography-template",
	mixins: [Vue.component("typography-core")],
	icon: "heading",
	description: "A level 3 header",
	name: "H3",
	category: "Typography",
	data: function() {
		return {
			tag: "h3",
			placeholder: "Heading 3"
		}
	}
})
Vue.view("typography-h4", {
	template: "#typography-template",
	mixins: [Vue.component("typography-core")],
	icon: "heading",
	description: "A level 4 header",
	name: "H4",
	category: "Typography",
	data: function() {
		return {
			tag: "h4",
			placeholder: "Heading 4"
		}
	}
})
Vue.view("typography-h5", {
	template: "#typography-template",
	mixins: [Vue.component("typography-core")],
	icon: "heading",
	description: "A level 5 header",
	name: "H5",
	category: "Typography",
	data: function() {
		return {
			tag: "h5",
			placeholder: "Heading 5"
		}
	}
})
Vue.view("typography-h6", {
	template: "#typography-template",
	mixins: [Vue.component("typography-core")],
	icon: "heading",
	description: "A level 6 header",
	name: "H6",
	category: "Typography",
	data: function() {
		return {
			tag: "h6",
			placeholder: "Heading 6"
		}
	}
})
Vue.view("typography-paragraph", {
	template: "#typography-template",
	mixins: [Vue.component("typography-core")],
	icon: "paragraph",
	description: "A paragraph of text",
	name: "Paragraph",
	category: "Typography",
	data: function() {
		return {
			tag: "p",
			placeholder: "Paragraph"
		}
	}
})
Vue.view("typography-fragment", {
	template: "#typography-template",
	mixins: [Vue.component("typography-core")],
	icon: "paragraph",
	description: "A short fragment of text",
	name: "Fragment",
	category: "Typography",
	data: function() {
		return {
			tag: "span",
			placeholder: "Fragment"
		}
	}
})

Vue.component("typography-blockquote-configure", {
	template: "#typography-template-configure",	
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	computed: {
		canHighlight: function() {
			return nabu.page.providers("page-format").filter(function(x) {
				 return x.name == "highlight";
			}).length > 0;
		}	
	},
	data: function() {
		return {
			highlightable: true
		}
	}
})
Vue.view("typography-blockquote", {
	template: "#typography-template",
	mixins: [Vue.component("typography-core")],
	icon: "quote-left",
	description: "A block quote",
	name: "Blockquote",
	category: "Typography",
	data: function() {
		return {
			tag: "blockquote",
			placeholder: "Blockquote",
			icon: false,
			highlightable: true
		}
	},
	methods: {
		configurator: function() {
			return "typography-blockquote-configure";
		}
	}
});
if (!nabu) { var nabu = {} }
if (!nabu.page) { nabu.page = {} }
if (!nabu.page.views) { nabu.page.views = {} }

// it's a horrible pattern but a quick fix!
// basically we want to split up runtime & configuration
// configuration usually has a large chunk of embedded tpl that has no business in the operational bit
// however, for state reasons and automapping the configuration is expected to have the same inputs as the component
// additionally the configuration _might_ make overlapping use of some operational functions that are needed there as well
// to solve this (quickly), the original definition was turned into a generator so we can just generate two components with identical javascript but differing templates
nabu.page.views.PageActionsGenerator = function(name) { 
	return Vue.component(name, {
		template: "#" + name,
		props: {
			page: {
				type: Object,
				required: true
			},
			parameters: {
				type: Object,
				required: false
			},
			cell: {
				type: Object,
				required: true
			},
			edit: {
				type: Boolean,
				required: true
			},
			localState: {
				type: Object,
				required: false
			},
			actions: {
				type: Array,
				required: false
			},
			active: {
				type: String,
				required: false
			},
			root: {
				type: Boolean,
				default: true
			},
			childComponents: {
				type: Object,
				required: false
			}
		},
		created: function() {
			this.normalize(this.cell.state);
			this.resolveActions();
		},
		data: function() {
			return {
				configuring: false,
				state: {},
				showing: [],
				lastAction: null,
				configuringAction: null,
				resolvedActions: [],
				subscriptions: [],
				running: []
			}
		},
		beforeDestroy: function() {
			this.subscriptions.splice(0).map(function(x) {
				x();
			});
		},
		computed: {
			// if we got actions in the input, we are likely a nested actions!
			// don't auto calculate anymore!
			isAutoCalculated: function() {
				return this.cell.state.autoActions && !this.actions;
			},
			autoCategories: function() {
				var categories = [];
				var hasEmpty = false;
				this.$services.page.pages.map(function(x) {
					if (!x.content.category) {
						hasEmpty = true;
					}
					else if (categories.indexOf(x.content.category ? x.content.category : null) < 0) {
						categories.push(x.content.category ? x.content.category : null);
					}
				});
				categories.sort();
				if (hasEmpty) {
					categories.unshift(null);
				}
				return categories;
			},
			autoActions: function() {
				var self = this;
				var normalize = function(action) {
					if (!action.bindings) {
						action.bindings = {};
					}
					if (!action.actions) {
						action.actions = [];
					}
					if (!action.activeRoutes) {
						action.activeRoutes = [];
					}
					return action;
				}
				var result = this.autoCategories.map(function(x) {
					return normalize({
						label: x ? x : "Misc",
						auto: true,
						actions: self.getPagesFor(x).filter(function(y) { return !!y.content.path }).map(function(y) {
							return normalize({
								label: y.content.label ? y.content.label : y.content.name,
								route: y.content.name,
								auto: true
							});
						})
					});
				});
				for (var i = result.length - 1; i >= 0; i--) {
					if (result[i].actions.length == 0) {
						result.splice(i, 1);
					}
				}
				nabu.utils.arrays.merge(result, this.resolvedActions);
				return result;
			}
		},
		ready: function() {
			var self = this;
			if (this.active || this.cell.state.defaultAction) {
				var action = this.cell.state.actions.filter(function(action) {
					// the new match
					return (action.name == (self.active ? self.active : self.cell.state.defaultAction))
					// backwards compatible matching
						|| (action.label == (self.active ? self.active : self.cell.state.defaultAction));
				})[0];
				if (action) {
					this.handle(action, true);
				}
			}
			var self = this;
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			
			this.getAllActions().forEach(function(action) {
				if (action.triggers) {
					action.triggers.forEach(function(trigger) {
						self.subscriptions.push(pageInstance.subscribe(trigger, function() {
							// we need to check that the action is not hidden or if we explicitly allow hidden actions to be triggered
							if (action.triggerIfHidden || self.isVisible(action)) {
								self.handle(action, true);
							}
						}));
					})
				}
			});
		},
		methods: {
			getActionComponents: function(action) {
				var components = [{title: 'Button', name: 'action-entry-button', component: 'button'}, {title: 'Button Wrapper', name: 'action-entry-wrapper', component: 'column'}];
				if (action.badge) {
					components.push({
						title: "Badge",
						name: "action-entry-badge",
						component: "badge"
					});
				}
				return components;
			},
			getAvailableVariants: function(component, value) {
				var variants = [];
				this.$services.page.getArisComponentHierarchy(component).forEach(function(component) {
					if (component.variants != null) {
						component.variants.forEach(function(variant) {
							if (variants.indexOf(variant.name) < 0) {
								variants.push(variant.name);
							}
						});
					}
				});
				if (value != null) {
					variants = variants.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
				}
				variants.sort();
				return variants;
			},
			getAvailableButtonVariants: function(value) {
				return this.getAvailableVariants("button", value);
			},
			getAvailableBadgeVariants: function(value) {
				return this.getAvailableVariants("badge", value);
			},
			getChildComponents: function() {
				var components = [{
					title: "Menu",
					name: "actions-menu",
					component: "menu"
				}, {
					title: "Title",
					name: "actions-title",
					component: "h2"
				}, {
					title: "Default button",
					name: "actions-button-default",
					component: "button"
				}];
				return components;
			},
			getAdditionalClasses: function() {
				var classes = [];
				if (this.root) {
					classes.push("is-menu");
					nabu.utils.arrays.merge(classes, this.getChildComponentClasses("actions-menu"));
				}
				else {
					classes.push("is-row");
				}
				return classes;
			},
			paste: function() {
				var action = this.$services.page.pasteItem("page-action");	
				if (action) {
					this.getAllActions().push(action);
				}
			},
			getPagesFor: function(category) {
				return this.$services.page.pages.filter(function(x) {
					return (!category && !x.content.category) || x.content.category == category;
				});
			},
			validatableItems: function(value) {
				var values = [];
				var elements = document.getElementsByTagName("form");
				if (elements) {
					for (var i = 0; i < elements.length; i++) {
						var id = elements[i].getAttribute("id");
						if (id) {
							values.push(id);
						}
					}
				}
				var elements = document.querySelectorAll("[component-group]");
				if (elements) {
					for (var i = 0; i < elements.length; i++) {
						var id = elements[i].getAttribute("component-group");
						if (id && values.indexOf(id) < 0) {
							values.push(id);
						}
					}
				}
				if (value) {
					values = values.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
				}
				if (values.indexOf(value) < 0) {
					values.unshift(value);
				}
				return values;
			},
			addStyle: function(action) {
				if (!action.styles) {
					Vue.set(action, "styles", []);
				}
				action.styles.push({
					class: null,
					condition: null
				});
			},
			getEvents: function(actions, result) {
				var self = this;
				if (!result) {
					result = {};
				}
				if (!actions) {
					actions = this.cell.state.actions;
				}
				actions.forEach(function(action) {
					if (action.event && action.event != "$close") {
						if (action.dynamic) {
							if (action.operation) {
								result[action.event] = self.getOperationDefinition(action);
							}
						}
						// backwards compatible, should not be necessary anymore
						else if (typeof(action.event) == "string" && (action.eventState || action.eventFixedState)) {
							result[action.event] = {
								properties: {
									value: {
										type: "string"
									},
									// the sequence of the event
									sequence: {
										type: "integer"
									},
									// the amount of events (works with the sequence)
									length: {
										type: "integer"
									}
								}
							};
						}
						else if (nabu.page.event.getName(action, "event") && nabu.page.event.getName(action, "event") != "$close") {
							var type = nabu.page.event.getType(action, "event");
							if (type.properties && Object.keys(type.properties).length == 0 && self.cell.on) {
								type = self.cell.on;
							}
							result[nabu.page.event.getName(action, "event")] = type;
						}
					}
					if (action.actions) {
						self.getEvents(action.actions, result);
					}
					if (action.validationErrorEvent) {
						result[action.validationErrorEvent] = {
							type: "array", 
							items: {
								type: "object",
								properties: {
									code: { type: "string" },
									severity: { type: "string" },
									title: { type: "string" },
									priority: { type: "integer", format: "int64" },
									soft: { type: "boolean" }
								}
							}
						}
					}
				});
				if (nabu.page.event.getName(this.cell.state, "handledEvent") != null) {
					var type = nabu.page.event.getType(this.cell.state, "handledEvent");
					if (type.properties && Object.keys(type.properties).length == 0 && this.cell.on) {
						type = this.cell.on;
					}
					result[nabu.page.event.getName(this.cell.state, "handledEvent")] = type;
				}
				return result;
			},
			resolveActions: function() {
				var promises = [];
				var self = this;
				// need new array
				nabu.utils.arrays.merge(this.resolvedActions, this.actions ? this.actions : this.cell.state.actions);
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				this.resolvedActions.forEach(function(action) {
					if (action.dynamic) {
						if (action.operation) {
							var parameters = {};
							// bind additional stuff from the page
							Object.keys(action.bindings).forEach(function(name) {
								if (action.bindings[name]) {
									var value = self.$services.page.getBindingValue(pageInstance, action.bindings[name]);
									if (value != null && typeof(value) != "undefined") {
										parameters[name] = value;
									}
								}
							});
							promises.push(self.$services.swagger.execute(action.operation, parameters).then(function(result) {
								var list = [];
								Object.keys(result).forEach(function(key) {
									if (result[key] instanceof Array) {
										list = result[key];
									}	
								});
								list = list.map(function(x) {
									var clone = nabu.utils.objects.clone(action);
									clone.dynamic = false;
									clone.content = x;
									clone.label = self.$services.page.getValue(x, clone.label);
									return clone;
								});
								var index = self.resolvedActions.indexOf(action);
								list.unshift(1);
								list.unshift(index);
								self.resolvedActions.splice.apply(self.resolvedActions, list);
								if (action.autotrigger && list.length > 2) {
									self.handle(list[2], true);
								}
							}));
						}
					}
				});
				return this.$services.q.all(promises);
			},
			getAllActions: function() {
				return this.actions ? this.actions : this.cell.state.actions;
			},
			// still need to allow configuring of child actions
			configureChild: function() {
				this.configuring = true;
			},
			configurator: function() {
				return "page-actions-configure";	
			},
			normalize: function(state) {
				if (!state.class) {
					Vue.set(state, "class", null);
				}
				if (!state.actions) {
					Vue.set(state, "actions", []);
				}
				if (!state.activeClass) {
					Vue.set(state, "activeClass", null);
				}
				if (!state.disabledClass) {
					Vue.set(state, "disabledClass", null);
				}
				if (!state.pastClass) {
					Vue.set(state, "pastClass", null);
				}
				if (!state.defaultAction) {
					Vue.set(state, "defaultAction", null);
				}
				if (state.useButtons == null) {
					Vue.set(state, "useButtons", true);
				}
				state.actions.map(function(action) {
					if (!action.activeRoutes) {
						Vue.set(action, "activeRoutes", []);
					}
					if (!action.actions) {
						Vue.set(action, "actions", []);
					}
					if (!action.bindings) {
						Vue.set(action, "bindings", {});	
					}
				});
			},
			hasActiveChild: function(action) {
				var activeClass = this.cell.state.activeClass ? this.cell.state.activeClass : "is-active";
				return this.getDynamicClasses(action).indexOf(activeClass) >= 0;
			},
			getDynamicWrapperClasses: function(action) {
				var classes = [];
				if (this.$services.page.useAris && action.aris) {
					var components = this.$services.page.calculateArisComponents(action.aris, null, this);
					if (components && components["action-entry-wrapper"] && components["action-entry-wrapper"].classes) {
						nabu.utils.arrays.merge(classes, components["action-entry-wrapper"].classes);
					}
				}
				if (action.auto) {
					classes.push("is-automatic");
				}
				return classes;
			},
			getDynamicClasses: function(action) {
				var classes = [];
				if (this.running.indexOf(action) >= 0) {
					classes.push("is-running");
				}
				if (action.styles) {
					nabu.utils.arrays.merge(classes, this.$services.page.getDynamicClasses(action.styles, this.state, this));
				}
				if (action.buttonClass) {
					classes.push(action.buttonClass);
				}
				var hasSpecificAris = false;
				if (this.$services.page.useAris && action.aris) {
					var components = this.$services.page.calculateArisComponents(action.aris, null, this);
					if (components && components["action-entry-button"] && components["action-entry-button"].classes && components["action-entry-button"].classes.length > 0) {
						nabu.utils.arrays.merge(classes, components["action-entry-button"].classes);
						hasSpecificAris = true;
					}
				}
				if (!hasSpecificAris) {
					nabu.utils.arrays.merge(classes, this.getChildComponentClasses("actions-button-default"));
				}
				if (action.iconReverse) {
					classes.push("is-direction-reverse");
				}
				// set the active class if applicable
				var activeClass = this.cell.state.activeClass ? this.cell.state.activeClass : "is-active";
				if (this.lastAction == action) {
					classes.push(activeClass);
				}
				else if (this.$services.vue.route) {
					var self = this;
					if (this.$services.vue.route == action.route) {
						classes.push(activeClass);
					}
					else if (action.activeRoutes) {
						var match = action.activeRoutes.filter(function(route) {
							if (route && (route == self.$services.vue.route || self.$services.vue.route.match("^" + route + "$"))) {
								return true;
							}
						}).length > 0;
						if (match) {
							classes.push(activeClass);
						}
					}
				}
				// set the disabled class if applicable
				var disabledClass = this.cell.state.disabledClass ? this.cell.state.disabledClass : "is-disabled";
				if (this.isDisabled(action)) {
					classes.push(disabledClass);
				}
				
				// we use this to highlight steps that are already done in a wizard-like step process
				var pastClass = this.cell.state.pastClass ? this.cell.state.pastClass : "is-past";
				if (this.lastAction) {
					var lastIndex = this.resolvedActions.indexOf(this.lastAction);
					var actionIndex = this.resolvedActions.indexOf(action);
					if (actionIndex < lastIndex) {
						classes.push(pastClass);
					}
				}
				return classes;
			},
			toggle: function(action) {
				if (this.cell.state.clickBased && this.$services.page.isCondition(this.cell.state.clickBased, {}, this)) {
					var index = this.showing.indexOf(action);
					if (index >= 0) {
						this.showing.splice(index, 1);
					}
					else {
						if (this.cell.state.showOnlyOne) {
							this.showing.splice(0);
						}
						this.showing.push(action);
					}
				}
			},
			hide: function(action) {
				if (!this.cell.state.clickBased || !this.$services.page.isCondition(this.cell.state.clickBased, {}, this)) {
					var index = this.showing.indexOf(action);
					if (index >= 0) {
						this.showing.splice(index, 1);
					}
				}
			},
			show: function(action) {
				if (!this.cell.state.clickBased || !this.$services.page.isCondition(this.cell.state.clickBased, {}, this)) {
					if (this.showing.indexOf(action) < 0) {
						if (this.cell.state.showOnlyOne) {
							this.showing.splice(0);
						}
						this.showing.push(action);
					}
				}
			},
			autoclose: function() {
				if (!this.cell.state.leaveOpen) {
					this.showing.splice(0);
					// if we have an autoclose on the root instance (so because of a click outside the entire menu, not just a subpart of the menu)
					// then we also want to send out a handled event (if any)
					if (this.root) {
						// we want to emit a handled because we are closing the menu
						if (nabu.page.event.getName(this.cell.state, "handledEvent")) {
							var pageInstance = this.$services.page.getPageInstance(this.page, this);
							pageInstance.emit(
								nabu.page.event.getName(this.cell.state, "handledEvent"),
								nabu.page.event.getInstance(this.cell.state, "handledEvent", this.page, this)
							);
						}
					}
				}
			},
			listRoutes: function(value, includeValue) {
				if (value != null && value.substring(0, 1) == "=") {
					return [value];
				}
				var routes = this.$services.router.list().map(function(x) { return x.alias });
				if (value) {
					routes = routes.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
				}
				routes.sort();
				if (value && includeValue) {
					routes.unshift(value);
				}
				return routes;
			},
			addContent: function() {
				this.getAllActions().push({
					arbitrary: true,
					name: null,
					class: null,
					content: {},
					label: "Content" + (this.getAllActions().length + 1),
					activeRoutes: []
				});
			},
			addAction: function(dynamic) {
				this.getAllActions().push({
					dynamic: dynamic,
					operation: null,
					label: "Action" + (this.getAllActions().length + 1),
					route: null,
					event: null,
					eventState: null,
					eventFixedState: null,
					hasFixedState: false,
					anchor: null,
					mask: false,
					condition: null,
					disabled: null,
					bindings: {},
					actions: [],
					icons: null,
					activeRoutes: [],
					class: null,
					buttonClass: null
				});
			},
			isVisible: function(action) {
				return this.edit || !action.condition || this.$services.page.isCondition(action.condition, this.state, this);
			},
			isDisabled: function(action) {
				return this.running.indexOf(action) >= 0 || (!!action.disabled && this.$services.page.isCondition(action.disabled, this.state, this));
			},
			getActionHref: function(action) {
				if (!this.cell.state.useButtons && action.url) {
					return this.$services.page.interpret(action.url, this);
				}
				if (action.absolute && action.route) {
					var route = action.route;
					if (route.charAt(0) == "=") {
						route = this.$services.page.interpret(route, this);
					}
					var parameters = {};
					var self = this;
					var pageInstance = self.$services.page.getPageInstance(this.page, this);
					Object.keys(action.bindings).map(function(key) {
						if (action.bindings[key] != null) {
							var value = self.$services.page.getBindingValue(pageInstance, action.bindings[key], self);
							// the old way... should disable it?
							if (value == null) {
								var parts = action.bindings[key].split(".");
								var value = self.state;
								parts.map(function(part) {
									if (value) {
										value = value[part];
									}
								});
								if (value) {
									parameters[key] = value;
								}
							}
							if (value != null) {
								parameters[key] = value;
							}
						}
					});
					var url = this.$services.router.template(route, parameters);
					if (action.absolute) {
						// in multi-domain situations the fixed environment url is not always correct
						//url = "http://" + window.location.host + url;
						url = window.location.protocol + "//" + window.location.host + url;
						//url = "${environment('url')}" + url;
					}
					return url;
				}
				return "javascript:void(0)";
			},
			validateTarget: function(target, execute) {
				var element = document.getElementById(target);
				var elements = [];
				if (element && element.__vue__ && element.__vue__.validate) {
					elements.push(element);
				}
				else {
					var forms = document.body.querySelectorAll("[component-group='" + target + "']");
					if (forms && forms.length) {
						for (var i = 0; i < forms.length; i++) {
							elements.push(forms.item(i));
						}
					}
				}
				var self = this;
				var promises = elements.map(function(x) {
					return self.validateSingle(x);
				}).filter(function(x) {
					return x != null;
				});
				var promise = null;
				if (promises.length) {
					promise = this.$services.q.all(promises);
				}
				else {
					promise = this.$services.q.defer();
					promise.resolve();
				}
				var doIts = elements
					.filter(function(element) { return !!element.__vue__.$parent.doIt })
					.map(function(element) { return element.__vue__.$parent.doIt });
				if (doIts.length) {
					promise.then(function() {
						doIts.forEach(function(doIt) {
							doIt();
						});
					});
				}
				return promise;
			},
			getValidationResults: function(promiseResult) {
				var messages = [];
				promiseResult.forEach(function(x) {
					x.forEach(function(y) {
						if (messages.indexOf(y) < 0) {
							messages.push(y);
						}
					})
				});
				return messages;
			},
			validateSingle: function(element) {
				if (element && element.__vue__ && element.__vue__.validate) {
					var filterResults = function(results) {
						return results.filter(function(x) {
							// the backend sends back uppercase
							return x.severity != null && x.severity.toLowerCase() == "error";
						})
					};
					var result = element.__vue__.validate();
					var promise = this.$services.q.defer();
					if (result.then) {
						result.then(function(x) {
							x = filterResults(x);
							if (x && x.length) {
								promise.reject(x);
							}
							else {
								promise.resolve([]);
							}
						});
					}
					else {
						result = filterResults(result);
						if (result.length) {
							promise.reject(result);
						}
						else {
							promise.resolve(result);
						}
					}
					return promise;
				}
				return null;
			},
			hasEvent: function(action) {
				if (action.event && typeof(action.event) == "string") {
					return true;
				}
				else {
					return !!nabu.page.event.getName(action, "event");
				}
			},
			handle: function(action, force) {
				if (action.name) {
					this.$services.analysis.push({
						pageName: this.page.content.name,
						pageCategory: this.page.content.category,
						category: "action",
						type: "action-trigger",
						group: this.cell.state.analysisId ? this.cell.state.analysisId : null,
						event: action.name
					});
				}
				// DEPRECATED
				if (action.name && this.$services.analysis && this.$services.analysis.emit) {
					this.$services.analysis.emit("trigger-" + (this.cell.state.analysisId ? this.cell.state.analysisId : "action"), action.name, {url: window.location}, true);
				}
				// we must validate some target before we can proceed
				if (action.validate && !force) {
					var self = this;
					this.validateTarget(action.validate).then(function(x) {
						self.handle(action, true);
					}, function(x) {
						var messages = self.getValidationResults(x);
						if (action.validationErrorScroll) {
							var elementToFocus = messages.filter(function(x) {
								return !!x.component;
							})[0];
							if (elementToFocus) {
								elementToFocus.scrollIntoView();
								elementToFocus.focus();
							}
						}
						if (action.validationErrorEvent) {
							var pageInstance = self.$services.page.getPageInstance(self.page, self);
							// we need to strip the component references within the messages
							// otherwise they have circular references which will break later on (e.g. in form state)
							messages = messages.map(function(x) {
								var clone = nabu.utils.objects.clone(x);
								delete clone.component;
								return clone;
							});
							pageInstance.emit(action.validationErrorEvent, { messages: messages });
						}
					});
					return null;
				}
				// we already have a valid href on there, no need to do more
				if (!this.cell.state.useButtons && action.route && action.absolute) {
					return;
				}
				else if (!this.cell.state.useButtons && action.url) {
					return;
				}
				if (force || !this.isDisabled(action)) {
					if (action.route) {
						var route = action.route;
						if (route.charAt(0) == "=") {
							route = this.$services.page.interpret(route, this);
						}
						var parameters = {};
						var self = this;
						var pageInstance = self.$services.page.getPageInstance(this.page, this);
						Object.keys(action.bindings).map(function(key) {
							if (action.bindings[key] != null) {
								var value = self.$services.page.getBindingValue(pageInstance, action.bindings[key], self);
								// the old way... should disable it?
								if (value == null) {
									var parts = action.bindings[key].split(".");
									var value = self.state;
									parts.map(function(part) {
										if (value) {
											value = value[part];
										}
									});
									if (value) {
										parameters[key] = value;
									}
								}
								if (value != null) {
									parameters[key] = value;
								}
							}
						});
						if (action.anchor == "$blank") {
							window.open(self.$services.router.template(route, parameters));
						}
						else if (action.anchor == "$window") {
							window.location = self.$services.router.template(route, parameters);
						}
						else {
							this.$services.router.route(route, parameters, action.anchor, action.mask);
						}
					}
					else if (action.url) {
						var url = this.$services.page.interpret(action.url, this);
						if (action.anchor == "$blank") {
							window.open(url);
						}
						else {
							window.location = url;
						}
					}
					else if (action.event == "$close" || nabu.page.event.getName(action, "event") == "$close") {
						this.$emit("close");
					}
					else if (action.event) {
						// if you are working event-based, you are using events to show parts of the screen
						// currently we assume only one event should be "active" at a time, so we unset all other events this tab provider can emit
						this.unsetEvent(this.cell.state.actions);
						
						var self = this;
						var pageInstance = self.$services.page.getPageInstance(self.page, self);
						var content = null;
						var addDefaults = false;
						var eventName = null;
						// backwards compatible
						if (typeof(action.event) == "string") {
							eventName = action.event;
							if (action.hasFixedState && action.eventFixedState) {
								content = {
									value: this.$services.page.interpret(action.eventFixedState, this)
								}
								addDefaults = true;
							}
							else if (action.content) {
								content = action.content;
							}
							else if (action.eventState) {
								content = {
									value: pageInstance.get(action.eventState)
								}
								addDefaults = true;
							}
						}
						else if (action.event && nabu.page.event.getName(action, "event")) {
							eventName = nabu.page.event.getName(action, "event");
							// you have a custom event
							if (action.event.eventFields && action.event.eventFields.length) {
								content = nabu.page.event.getInstance(action, "event", this.page, this);
							}
							else if (action.content) {
								content = action.content;
							}
							else if (this.cell.on) {
								content = pageInstance.get(this.cell.on);
							}
						}
						if (addDefaults) {
							content.sequence = this.resolvedActions.indexOf(action) + 1;
							content.length = this.resolvedActions.length;
							content.actor = this.cell.id;
						}
						if (eventName != null) {
							self.running.push(action);
							var unlock = function() {
								self.running.splice(self.running.indexOf(action), 1);
							};
							var result = pageInstance.emit(eventName, content ? content : {});
							if (result.then) {
								result.then(unlock, unlock);
							}
							else {
								unlock();
							}
						}
						this.lastAction = action;
					}
					if (action.close) {
						this.$emit("close");
					}
					if (nabu.page.event.getName(this.cell.state, "handledEvent") && !action.skipHandleEvent) {
						var pageInstance = this.$services.page.getPageInstance(this.page, this);
						// might have already browsed away
						if (pageInstance) {
							pageInstance.emit(
								nabu.page.event.getName(this.cell.state, "handledEvent"),
								nabu.page.event.getInstance(this.cell.state, "handledEvent", this.page, this)
							);
						}
					}
				}
			},
			unsetEvent: function(actions) {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				actions.map(function(action) {
					if (action.event) {
						pageInstance.reset(typeof(action.event) == "string" ? action.event : nabu.page.event.getName(action, "event"));
					}
					if (action.actions) {
						self.unsetEvent(action.actions);
					}
				});
			},
			configureAction: function(action) {
				this.configuringAction = action;
				var self = this;
				// give it time to render and resolve the $ref
				Vue.nextTick(function() {
					var key = "action_" + self.getAllActions().indexOf(action);
					self.$refs[key][0].configureChild();
				});
			},
			up: function(action) {
				var actions = this.getAllActions();
				var index = actions.indexOf(action);
				if (index > 0) {
					var replacement = actions[index - 1];
					actions.splice(index - 1, 1, actions[index]);
					actions.splice(index, 1, replacement);
				}
			},
			down: function(action) {
				var actions = this.getAllActions();
				var index = actions.indexOf(action);
				if (index < actions.length - 1) {
					var replacement = actions[index + 1];
					actions.splice(index + 1, 1, actions[index]);
					actions.splice(index, 1, replacement);
				}
			},
			
			// copy paste from data component => datautils getdatoperations
			getActionOperations: function(name) {
				var self = this;
				return this.$services.page.getOperations(function(operation) {
					// must be a get
					var isAllowed = operation.method.toLowerCase() == "get"
						// and contain the name fragment (if any)
						&& (!name || operation.id.toLowerCase().indexOf(name.toLowerCase()) >= 0)
						// must have _a_ response
						&& operation.responses["200"];
					// we also need at least _a_ complex array in the results
					if (isAllowed && operation.responses["200"] != null && operation.responses["200"].schema != null) {
						var schema = operation.responses["200"].schema;
						var definition = self.$services.swagger.definition(schema["$ref"]);
						isAllowed = false;
						if (definition.properties) {
							Object.keys(definition.properties).map(function(field) {
								if (definition.properties[field].type == "array") {
									isAllowed = true;
								}
							});
						}
					}
					return isAllowed;
				}).map(function(x) { return x.id });
			},
			getInputParameters: function(action) {
				var result = {
					properties: {}
				};
				var self = this;
				var operation = this.$services.swagger.operations[action.operation];
				if (operation && operation.parameters) {
					var blacklist = ["limit", "offset", "orderBy", "connectionId"];
					var parameters = operation.parameters.filter(function(x) {
						return blacklist.indexOf(x.name) < 0;
					}).map(function(x) {
						result.properties[x.name] = self.$services.swagger.resolve(x);
					})
				}
				return result;
			},
			getOperationDefinition: function(action) {
				var properties = {};
				var operation = this.$services.swagger.operations[action.operation];
				if (operation && operation.responses["200"]) {
					var definition = this.$services.swagger.resolve(operation.responses["200"].schema);
					//var definition = this.$services.swagger.definition(schema["$ref"]);
					if (definition.properties) {
						var self = this;
						Object.keys(definition.properties).forEach(function(field) {
							if (definition.properties[field].type == "array") {
								var items = definition.properties[field].items;
								if (items.properties) {
									nabu.utils.objects.merge(properties, items.properties);
								}
							}
						});
					}
				}
				return {properties:properties};
			},
			getOperationProperties: function(action) {
				return this.$services.page.getSimpleKeysFor(this.getOperationDefinition(action));
			}
		}
	});
}

nabu.page.views.PageActions = nabu.page.views.PageActionsGenerator("page-actions");
nabu.page.views.PageActionsGenerator("page-actions-configure");
// the v-html directive actually allows for self-XSS so switched it to sanitized content
Vue.view("page-tag", {
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},  
	name: "Tag",
	category: "Data",
	description: "A tag",
	icon: "link",
	created: function() {
		this.elementPromise = this.$services.q.defer();
	},
	ready: function() {
		this.elementPromise.resolve(this.$el);	
	},
	data: function() {
		return {
			requiresPagePrefix: false,
			running: false
		}
	},
	computed: {
		icon: function() {
			var icon = this.cell.state.icon;
			return icon ? icon : "times";
		},
		computedValue: function() {
			try {
				var instance = this.$services.page.getPageInstance(this.page, this);
				return this.cell.state.useComputed && this.cell.state.computed ? this.$services.page.eval(this.cell.state.computed, {}, this) : null;
			}
			catch(exception) {
				console.error("Could not calculate computed", exception);
				return null;
			}
		}
	},
	methods: {
		getPrettyName: function(target) {
			return this.$services.page.getPrettyNameForTypography(target);
		},
		isCellHidden: function() {
			return this.getValue() == null;	
		},
		reset: function() {
			if (!this.running) {
				var originalValue = this.getRawValue();
				if (this.cell.state.field) {
					// for arrays we simply empty them out rather than deleting them
					if (originalValue instanceof Array) {
						originalValue.splice(0);
					}
					else {
						var pageInstance = this.$services.page.getPageInstance(this.page, this);
						pageInstance.set(this.cell.state.field, null);
						if (this.requiresPagePrefix) {
							pageInstance.set("page." + this.cell.state.field, null);	
						}
					}
				}
				var self = this;
				var done = function() {
					self.running = false;
				};
				this.running = true;
				this.$services.triggerable.trigger(this.cell.state, "remove", {value:originalValue}, this).then(done, done);
			}
		},
		getEvents: function() {
			return this.$services.triggerable.getEvents(this.page, this.cell.state);
		},
		getRawValue: function() {
			var value = null;
			if (this.cell.state.useComputed) {
				value = this.computedValue;
			}
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			value = pageInstance.get(this.cell.state.field);
			if (value == null) {
				value = pageInstance.get("page." + this.cell.state.field);
			}
			return value;
		},
		getValue: function() {
			var value = null;
			if (this.cell.state.useComputed) {
				value = this.computedValue;
			}
			if (this.cell.state.field) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				if (pageInstance) {
					value = pageInstance.getLabel(this.cell.state.field);
					if (value == null) {
						value = pageInstance.getLabel("page." + this.cell.state.field);
						if (value != null) {
							this.requiresPagePrefix = true;
						}
					}
					if (value == null) {
						value = pageInstance.get(this.cell.state.field);
					}
				}
			}
			// an empty array is the same as null!
			if (value instanceof Array && !value.length) {
				value = null;
			}
			// toggle the cell
			if (value != null) {
				this.$emit("show");
			}
			else {
				this.$emit("hide");
			}
			return value;
		},
		getChildComponents: function() {
			return [{
				title: "Tag",
				name: "page-tag",
				component: "badge"
			}]	
		},
		configurator: function() {
			return "page-tag-configure";
		},
		update: function() {
			if (this.timer) {
				clearTimeout(this.timer);
				this.timer = null;
			}
			var self = this;
			if (this.$refs.editor) {
				var last = self.$refs.editor.innerHTML;
				this.timer = setTimeout(function() {
					self.cell.state.content = nabu.utils.elements.sanitize(self.$refs.editor ? self.$refs.editor.innerHTML : last);
				}, 100);
			}
		}
	}
});

Vue.component("page-tag-configure", {
	template: "#page-tag-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	methods: {
		getAllKeys: function(value) {
			var keys = [];
			nabu.utils.arrays.merge(keys, this.$services.page.getAllAvailableKeys(this.page, true));
			if (value) {
				keys = keys.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
			}
			keys.sort();
			return keys;
		}
	}
});
Vue.view("page-smart-check", {
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	}, 
	computed: {
		component: function() {
			return this.cell.state.component ? this.cell.state.component : "n-form-checkbox";
		},
		checked: function() {
			return this.$services.page.isCondition(this.cell.state.checkCondition, {}, this);
		},
		disabled: function() {
			return this.cell.state.disabledCondition ? this.$services.page.isCondition(this.cell.state.disabledCondition, {}, this) : false;
		}
	},
	data: function() {
		return {
			running: false
		}
	},
	methods: {
		configurator: function() {
			return "page-smart-check-configure"
		},
		toggle: function() {
			this.running = true;
			var promise = this.$services.triggerable.trigger(this.cell.state, this.checked ? "clear" : "check", null, this);
			var self = this;
			var done = function() {
				self.running = false;
			}
			promise.then(done, done);
		}
	}
});

Vue.component("page-smart-check-configure", {
	template: "#page-smart-check-configure",
		props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	}
})
nabu.page.provide("page-renumberer", {
	component: "page-button",
	renumber: function(target, mapping) {
		// update the action target
		if (target.state.actionTarget != null && mapping[target.state.actionTarget] != null) {
			target.state.actionTarget = mapping[target.state.actionTarget];	
		}
	}
});

Vue.view("page-button", {
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},  
	name: "Button",
	category: "Interactive",
	description: "A button to send out events, go to a different page,...",
	icon: "link",
	data: function() {
		return {
			timer: null,
			running: false,
			activated: false
		}
	},
	created: function() {
		this.elementPromise = this.$services.q.defer();
		// click was renamed to activate
		// for the forseeable future we do this rewriting
		// might disable it at some point
		if (this.cell.state.triggers) {
			this.cell.state.triggers.forEach(function(x) {
				if (x.trigger == "click") {
					x.trigger = "activate";
				}
			})
		}
	},
	computed: {
		tagName: function() {
			var triggers = this.triggers;
			if (triggers && triggers.length == 1 && triggers[0].actions.length == 1 && 
					triggers[0].actions[0].type == "route") {
				return "a";
			}
			return "button";
		},
		tooltip: function() {
			if (this.cell.state.tooltip) {
				return this.$services.page.interpret(this.$services.page.translate(this.cell.state.tooltip), this);
			}	
		},
		badge: function() {
			if (this.cell.state.badge) {
				return this.$services.page.interpret(this.$services.page.translate(this.cell.state.badge), this);
			}	
		},
		active: function() {
			var active = false;
			var self = this;
			if (this.activationType == "route") {
				if (this.cell.state.activeRoutes && this.cell.state.activeRoutes.length) {
					var activeRoutes = this.cell.state.activeRoutes.filter(function(x) {
						if (x.route == self.$services.vue.route) {
							return !x.condition
								|| self.$services.page.isCondition(x.condition, self.$services.vue.parameters, self, function(value) {
									var result = self.$services.page.getValue(self.$services.vue.parameters, value);
									if (result == null) {
										result = self.$value(value);
									}
									return result;
								});
						}
						return false;
					});
					return activeRoutes.length > 0;
				}
				var routes = [];
				// old triggers
				nabu.utils.arrays.merge(routes, this.$services.triggerable.getActiveRoutes(this.cell.state));
				// new triggers
				nabu.utils.arrays.merge(routes, this.$services.triggerable.getActiveRoutes(this.cell));
				return routes.indexOf(this.$services.vue.route) >= 0;
			}
			else if (this.activationType == "condition" && this.cell.state.active) {
				return this.$services.page.isCondition(this.cell.state.active, null, this);
			}
			else if (this.activationType == "group") {
				// todo?
			}
		},
		disabled: function() {
			return this.cell.state.disabled ? this.$services.page.isCondition(this.cell.state.disabled, null, this, null, true) : false;
		},
		activationType: function() {
			var activationType = this.cell.state.activationType;
			if (!this.cell.state.hasOwnProperty("activationType")) {
				// we have group-based activation
				if (this.cell.state.componentGroup) {
					activationType = "group";
				}
				else if (this.cell.state.active) {
					activationType = "condition";
				}
				// by default we use route-based activation
				else {
					activationType = "route";
				}
			}
			return activationType;
		},
		triggers: function() {
			var triggers = [];
			var cell = this.cell;
			// old school
			if (cell.state.triggers) {
				nabu.utils.arrays.merge(triggers, cell.state.triggers);
			}
			// new school
			if (cell.triggers) {
				nabu.utils.arrays.merge(triggers, cell.triggers);
			}
			return triggers;
		}
	},
	ready: function() {
		// we _have_ to do this in ready because the vue.nexttick logic assures us that all components have at least been created (and hopefully mounted) which means any state manipulation we want to do of for instance a repeat filter object, will have access to the correct object
		if (this.cell.state.activateByDefault) {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			// we must not be in a repeat or we must be the first iteration
			if (pageInstance.recordIndex == null || pageInstance.recordIndex == 0) {
				this.handle();
			}
		}
		this.elementPromise.resolve(this.$el);	
		if (this.cell.state.activeInitial) {
			if (this.$services.page.isCondition(this.cell.state.activeInitial, null, this)) {
				this.handle();
			}
		}
	},
	methods: {
		getPrettyName: function(target) {
			return this.$services.page.getPrettyNameForTypography(target);
		},
		getTriggers: function() {
			var triggers = {"activate": {}};
			if (this.cell.triggers) {
				if (this.cell.triggers.map(function(x) {
						return x.trigger;
					}).indexOf("activate") >= 0) {
					triggers.deactivate = {};	
				}
			}
			return triggers;
		},
		getHref: function() {
			if (this.tagName == "a") {
				return this.$services.triggerable.calculateUrl(this.triggers[0].actions[0], this, {});
			}
		},
		guessButtonType: function() {
			var isSubmit = false;
			if (this.triggers) {
				this.triggers.forEach(function(trigger) {
					if (trigger.actions) {
						trigger.actions.forEach(function(action) {
							if (action.type == "action" && action.action == 'submit') {
								isSubmit = true;
							}
						});
					}
				})
			}
			return isSubmit ? "submit" : "button";
		},
		getContentWithVariables: function(content) {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			return !content ? content : this.$services.typography.replaceVariables(pageInstance, this.cell.state, content, this.elementPromise);
		},
		getChildComponents: function() {
			var childComponents = [{
				title: "Button",
				name: "page-button",
				component: "button"
			}];
			if (this.cell.state.badge) {
				childComponents.push({
					title: "Badge",
					name: "page-button-badge",
					component: "badge"
				});
			}
			if (this.cell.state.tooltip) {
				childComponents.push({
					title: "Tooltip",
					name: "page-button-tooltip",
					component: "tooltip"
				});
			}
			return childComponents;
		},
		getEvents: function() {
			var result = {};
			nabu.utils.objects.merge(result, this.$services.triggerable.getEvents(this.page, this.cell.state));

			if (this.cell.state.action && this.cell.state.actionTarget && this.cell.state.actionEvent) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				var output = this.$services.page.getActionOutput(pageInstance, this.cell.state.actionTarget, this.cell.state.action);
				// we may just want marker events without output
				result[this.cell.state.actionEvent] = output ? {properties:output} : {};
			}
			return result;
		},
		// when you hit space bar in edit mode on a button, it ativates the button rather than inserting a space
		// to be mutually exclusive with the alt+click, we check specifically for that key as well
		hitSpace: function($event) {
			// no longer necessary?
			/*
			if (this.edit && this.$refs.editor && !$event.altKey) {
				document.execCommand("insertHTML", null, " ");
			}
			*/
		},
		getTriggerObject: function() {
			var triggers = [];
			var self = this;
			// Deprecated!
			if (self.cell.state.triggers) {
				nabu.utils.arrays.merge(triggers, self.cell.state.triggers);
			}
			// general cell triggers
			if (self.cell.triggers) {
				nabu.utils.arrays.merge(triggers, self.cell.triggers);
			}
			return {triggers:triggers};
		},
		handle: function($event, middleMouseButton) {
			// if you are in edit mode, you have to explicitly click alt to enable the button
			// it seems that vue also intercepts spaces and sends it as a click event, meaning when you type in the rich text, it can trigger
			if (!this.edit || ($event && $event.shiftKey)) { 
				
				if (this.cell.analysisId) {
					this.$services.analysis.push({
						event: "activate",
						category: "button",
						component: this.cell.analysisId ? this.cell.analysisId : "button-" + this.cell.id,
						page: this.$services.page.getRootPage(this.$services.page.getPageInstance(this.page, this)).page.content.name
					});
				}
				
				// left is for normal systems like linux and windows. the metakey is for those unfortunate enough to use apple devices
				var isNewTab = $event && ($event.button == 1 || ($event.metaKey == true && $event.button == 0));
				// if we have a link opening in a new tab, we don't want local routing
				if (this.tagName == "a" && isNewTab) {
					return true;
				}
				
				// if we are part of a component group, we will first untrigger any existing active component group buttons
				// we rather have an intermittent situation where no buttons are active than where two buttons are active
				if (this.cell.state.componentGroup) {
					document.querySelectorAll("[component-group='" + this.cell.state.componentGroup + "']").forEach(function(x) {
						if (x.__vue__) {
							if (x.__vue__.deactivate) {
								x.__vue__.deactivate();
							}
						}	
					});
				}
				this.running = true;
				// on mac you can use CMD+left click to open in a new tab, this means the metakey will be set to true
				// note that for links, the browser already does the right thing so we don't want to add that, it will open double!
				var promise = this.$services.triggerable.trigger(this.getTriggerObject(), "activate", null, this, {anchor: this.tagName != "a" && (middleMouseButton || ($event && $event.metaKey)) ? "$blank" : null});
				
				if (this.cell.state.stopPropagation && $event) {
					$event.stopPropagation();
					$event.preventDefault();
				}
				
				var self = this;
				var unlock = function() {
					self.running = false;
					if (self.cell.state.emitClose) {
						self.$emit("close");
					}
					if (self.cell.state.componentGroup) {
						self.activated = true;
					}
				}
				promise.then(unlock, unlock);
				// if we have a link 
				if (this.tagName == "a") {
					$event.preventDefault();
					return false;
				}
				else {
					return promise;
				}
			}
			// we want to prevent default behavior in edit mode
			else if ($event) {
				// we want to stop the browser for executing the a but we do want the click to propagate to the cell so you can do ctrl+click to focus etc
				if (this.tagName == "a") {
					//$event.stopPropagation();
					$event.preventDefault();
				}
			}
		},
		deactivate: function() {
			if (this.activated) {
				this.$services.triggerable.untrigger(this.getTriggerObject(), "activate", this);
				this.$services.triggerable.trigger(this.getTriggerObject(), "deactivate", this);
				this.activated = false;	
			}
		},
		configurator: function() {
			return "page-button-configure";
		},
		update: function() {
			if (this.timer) {
				clearTimeout(this.timer);
				this.timer = null;
			}
			var self = this;
			if (this.$refs.editor) {
				var last = self.$refs.editor.innerHTML;
				this.timer = setTimeout(function() {
					self.cell.state.content = nabu.utils.elements.sanitize(self.$refs.editor ? self.$refs.editor.innerHTML : last);
				}, 100);
			}
		}
	}
});

Vue.component("page-button-configure", {
	template: "#page-button-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	created: function() {
		if (!this.cell.state.bindings) {
			Vue.set(this.cell.state, "bindings", {});
		}
		// otherwise not reactive...?
		if (!this.cell.state.actionTarget) {
			Vue.set(this.cell.state, "actionTarget", null);
		}
		if (!this.cell.state.activeRoutes) {
			Vue.set(this.cell.state, "activeRoutes", []);
		}
		// for older buttons, we need to calculate what we need
		if (!this.cell.state.hasOwnProperty("activationType")) {
			// we have group-based activation
			if (this.cell.state.componentGroup) {
				Vue.set(this.cell.state, "activationType", "group");
			}
			else if (this.cell.state.active) {
				Vue.set(this.cell.state, "activationType", "condition");
			}
			// by default we use route-based activation
			else {
				Vue.set(this.cell.state, "activationType", "route");
			}
		}
	},
	computed: {
		triggers: function() {
			// we can activate
			var triggers = {"activate": {}};
			if (this.cell.state.triggers) {
				if (this.cell.state.triggers.map(function(x) {
						return x.trigger;
					}).indexOf("activate") >= 0) {
					triggers.deactivate = {};	
				}
			}
			return triggers;
		}
	},
	watch: {
		'cell.state.activateByDefault': function(newValue) {
			// disable this in others from the same group
			if (newValue) {
				var self = this;
				document.querySelectorAll("[component-group='" + this.cell.state.componentGroup + "']").forEach(function(x) {
					if (x.__vue__ && x.__vue__.cell.id != self.cell.id) {
						Vue.set(x.__vue__.cell.state, "activateByDefault", false);
					}
				});
			}
		}
	}
});
/**
 * TODO
 * 
 * Postgresql uses different "nulls first" and "nulls last" logic depending on the direction (asc/desc)
 * This is good enough for now, it is unclear, if we expose it as config, whether you want it to toggle as well or as a fixed value etc
 * 
 * Currently we are going with "reverse appending" for multisort
 * This is a new strategy for us and unclear whether or not this is going to cover all usecases
 * If it does, we leave it as is, otherwise we will offer a configuration to toggle this behavior
 * It is unclear whether this configuration should be at the sort button level or the target level
 */

nabu.page.provide("page-renumberer", {
	component: "page-button-sort",
	renumber: function(target, mapping) {
		// update the action target
		if (target.state.actionTarget != null && mapping[target.state.actionTarget] != null) {
			target.state.actionTarget = mapping[target.state.actionTarget];	
		}
	}
});

Vue.view("page-button-sort", {
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},  
	name: "Sort button",
	category: "Interactive",
	description: "A button that can be used to sort for example a repeat",
	icon: "link",
	data: function() {
		return {
			timer: null,
			running: false,
			// the component we are sorting on
			component: null,
			currentDirection: null
		}
	},
	created: function() {
		this.elementPromise = this.$services.q.defer();
	},
	mounted: function() {
		this.getComponent();
	},
	ready: function() {
		this.elementPromise.resolve(this.$el);
	},
	watch: {
		"component.state.order.by": function() {
			this.matchOrderBy();
		}
	},
	computed: {
		icon: function() {
			if (this.currentDirection == "asc") {
				return this.cell.state.iconAsc ? this.cell.state.iconAsc : "sort-up";
			}
			else if (this.currentDirection == "desc") {
				return this.cell.state.iconDesc ? this.cell.state.iconDesc : "sort-down";
			}
			else if (this.cell.state.hideNoneIcon) {
				return null;
			}
			return this.cell.state.iconNone ? this.cell.state.iconNone : "sort";
		},
		active: function() {
			var active = false;
			if (this.cell.state.active) {
				active = this.$services.page.isCondition(this.cell.state.active, null, this);
			}
			return active || this.$services.triggerable.getActiveRoutes(this.cell.state).indexOf(this.$services.vue.route) >= 0;
		},
		disabled: function() {
			return this.cell.state.disabled && this.$services.page.isCondition(this.cell.state.disabled, null, this);
		}
	},
	methods: {
		getPrettyName: function(target) {
			return this.$services.page.getPrettyNameForTypography(target);
		},
		getComponent: function() {
			if (this.cell.state.target) {
				var self = this;
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				pageInstance.getComponent(this.cell.state.target).then(function(component) {
					Vue.set(self, 'component', component);
					self.matchOrderBy();
				});
			}
		},
		matchOrderBy: function() {
			if (this.component && this.component.state && this.component.state.order) {
				// get the current order by and adjust our state to match
				var current = this.component.state.order.by;
				
				// we need a correct match for all our fields
				// in other words, if complex sorting ends in an overlap...we don't show any particular state
				
				if (current && this.cell.state.sortFields) {
					var ascMatch = true;
					var descMatch = true;
					var self = this;
					this.cell.state.sortFields.forEach(function(x) {
						// TODO: this does not support nulls first etc syntax yet!
						if (current.indexOf(x.name) < 0 && current.indexOf(x.name + " asc") < 0) {
							ascMatch = false;
						}
						if (current.indexOf(x.name + " desc") < 0) {
							descMatch = false;
						}
					});
					if (ascMatch && descMatch) {
						console.log("Confusing order matching");
					}
					else if (ascMatch) {
						this.currentDirection = "asc";
					}
					else if (descMatch) {
						this.currentDirection = "desc";
					}
				}
			}
		},
		getContentWithVariables: function(content) {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			return !content ? content : this.$services.typography.replaceVariables(pageInstance, this.cell.state, content, this.elementPromise);
		},
		getChildComponents: function() {
			return [{
				title: "Sort Button",
				name: "page-button-sort",
				component: "button"
			}];
		},
		getEvents: function() {
			var result = {};
			nabu.utils.objects.merge(result, this.$services.triggerable.getEvents(this.page, this.cell.state));

			
			if (nabu.page.event.getName(this.cell.state, "clickEvent") && nabu.page.event.getName(this.cell.state, "clickEvent") != "$close") {
				var type = nabu.page.event.getType(this.cell.state, "clickEvent");
				result[nabu.page.event.getName(this.cell.state, "clickEvent")] = type;
			}
			if (this.cell.state.action && this.cell.state.actionTarget && this.cell.state.actionEvent) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				var output = this.$services.page.getActionOutput(pageInstance, this.cell.state.actionTarget, this.cell.state.action);
				// we may just want marker events without output
				result[this.cell.state.actionEvent] = output ? {properties:output} : {};
			}
			return result;
		},
		handle: function($event) {
			// no direction yet
			if (this.currentDirection == null) {
				this.currentDirection = this.cell.state.reverse ? "desc" : "asc";
			}
			else if (this.currentDirection == "asc") {
				this.currentDirection = this.cell.state.reverse ? null : "desc";
			}
			else if (this.currentDirection == "desc") {
				this.currentDirection = this.cell.state.reverse ? "asc" : null;
			}
			var self = this;
			if (this.cell.state.sortFields && this.component) {
				var orderBy = this.cell.state.sortFields.map(function(x) {
					return x.name + " " + (self.currentDirection ? self.currentDirection : "none");
				});
				this.component.runAction("order-by", {
					by: orderBy,
					append: true
				});
			}
		},
		configurator: function() {
			return "page-button-sort-configure";
		},
		update: function() {
			if (this.timer) {
				clearTimeout(this.timer);
				this.timer = null;
			}
			var self = this;
			if (this.$refs.editor) {
				var last = self.$refs.editor.innerHTML;
				this.timer = setTimeout(function() {
					self.cell.state.content = nabu.utils.elements.sanitize(self.$refs.editor ? self.$refs.editor.innerHTML : last);
				}, 100);
			}
		}
	}
});

Vue.component("page-button-sort-configure", {
	template: "#page-button-sort-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	created: function() {
		// otherwise not reactive...?
		if (!this.cell.state.sortFields) {
			Vue.set(this.cell.state, "sortFields", []);
		}
	},
	data: function() {
		return {
			component: null,
			fields: []
		}
	},
	mounted: function() {
		this.findTarget();
	},
	methods: {
		findTarget: function() {
			var self = this;
			this.fields.splice(0);
			if (this.cell.state.target) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				pageInstance.getComponent(this.cell.state.target).then(function(component) {
					self.fields.splice(0);
					Vue.set(self, 'component', component);
					component.runAction("list-available").then(function(result) {
						if (result.available) {
							nabu.utils.arrays.merge(self.fields, result.available);
						}
					});
				});
			}
			else {
				Vue.set(self, 'component', null);
			}
		},
		getAvailableFields: function(value) {
			return this.fields.filter(function(x) {
				return !value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
			});
		}
	},
	watch: {
		'cell.state.target': function() {
			this.findTarget();
		}
	}
});
Vue.view("page-badge", {
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},  
	name: "Badge",
	category: "Typography",
	description: "A badge",
	icon: "link",
	created: function() {
		this.elementPromise = this.$services.q.defer();
	},
	ready: function() {
		this.elementPromise.resolve(this.$el);	
	},
	computed: {
		tooltip: function() {
			if (this.cell.state.tooltip) {
				return this.$services.page.interpret(this.$services.page.translate(this.cell.state.tooltip), this);
			}	
		}
	},
	methods: {
		getContentWithVariables: function(content) {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			return !content ? content : this.$services.typography.replaceVariables(pageInstance, this.cell.state, content, this.elementPromise);
		},
		getChildComponents: function() {
			return [{
				title: "Badge",
				name: "page-badge",
				component: "badge"
			}]	
		},
		configurator: function() {
			return "page-badge-configure";
		},
		update: function() {
			if (this.timer) {
				clearTimeout(this.timer);
				this.timer = null;
			}
			var self = this;
			if (this.$refs.editor) {
				var last = self.$refs.editor.innerHTML;
				this.timer = setTimeout(function() {
					self.cell.state.content = nabu.utils.elements.sanitize(self.$refs.editor ? self.$refs.editor.innerHTML : last);
				}, 100);
			}
		}
	}
});

Vue.component("page-badge-configure", {
	template: "#page-badge-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	}
});
Vue.service("basicNotifier", {
	created: function() {
		nabu.page.provide("page-notifier", this);
	},
	data: function() {
		return {
			// for the notification ranking
			priority: -1,
			// the root element where we append to
			root: null,
			// the basic component we use, it could theoretically be swapped out for another
			component: "basic-notification",
			defaultDuration: 5000
		}	
	},
	methods: {
		push: function(notification) {
			var component = Vue.component(this.component);
			var result = new component({propsData: notification});
			var target = this.getRoot();
			this.$render({
				target: target,
				content: result,
				append: true
			});
			if (notification.duration == null) { 
				notification.duration = this.defaultDuration;
			}
			if (notification.duration > 0) {
				setTimeout(function() {
					result.close();
				}, notification.duration);
			}
		},
		getRoot: function() {
			if (this.root == null) {
				this.root = document.createElement("div");
				this.root.setAttribute("class", "global-notifications");
				document.body.appendChild(this.root);
			}
			return this.root;
		}
	}	
});

Vue.component("basic-notification", {
	props: {
		name: {
			type: String
		},
		event: {
			type: String
		},
		title: {
			type: String
		},
		message: {
			type: String
		},
		icon: {
			type: String
		},
		severity: {
			type: String
		},
		closeable: {
			type: Boolean
		},
		actions: {
			type: Array
		},
		data: {
			type: Object
		}
	},
	template: "<div class='is-alert has-button-close is-spacing-large is-spacing-horizontal-right-xlarge' :class='\"is-color-\" + (severity ? severity : \"info\")'>"
		+ "		<icon v-if='icon' :name='icon'/>"
		+ "		<div class='is-text'>"
		+ "			<h4 class='is-h4' v-if='title' v-content.sanitize.compile='title'/>"
		+ "			<p class='is-p' v-if='message' v-content.sanitize.compile='message'/>"
		+ "			<button class='is-button is-variant-close is-size-small' @click='close' v-if='closeable'><icon name='times'/></button>"
		+ "		</div>"
		+ "</div>",
	methods: {
		close: function() {
			this.$el.parentNode.removeChild(this.$el);
		}
	}
});
if (!nabu) { var nabu = {} }
if (!nabu.page) { nabu.page = {} }
if (!nabu.page.skeletons) { nabu.page.skeletons = {} }

nabu.page.skeletons.Email = Vue.extend({
	template: "#page-skeleton-email"
});
nabu.page.provide("page-renumberer", {
	component: "page-paging",
	renumber: function(target, mapping) {
		// update the action target
		if (target.state.target != null && mapping[target.state.target] != null) {
			target.state.target = mapping[target.state.target];	
		}
	}
});

Vue.view("page-paging", {
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		},
		childComponents: {
			type: Object,
			required: false
		}
	},
	name: "Paging",
	category: "Data",
	icon: "sort-numeric-down",
	description: "Allow you to page through a data set",
	data: function() {
		return {
			// we start with _some_ paging so we see something in edit mode
			paging: {},
			component: null
		}
	},
	// hook into component
	mounted: function() {
		var self = this;
		var pageInstance = this.$services.page.getPageInstance(this.page, this);
		if (this.cell.state.target) {
			pageInstance.getComponent(this.cell.state.target).then(function(component) {
				self.component = component;
				Vue.set(self, "paging", component.getRuntimeState().paging);
				/*component.runAction("get-paging").then(function(paging) {
					// this should be reactive!
					Vue.set(self, "paging", paging);
				});*/
			});
		}
	},
	methods: {
		getChildComponents: function() {
			return [{
				title: "Menu",
				name: "paging-menu",
				description: "The menu that contains the paging buttons",
				component: "menu"
			}, {
				title: "Button",
				name: "paging-button",
				description: "The button used for paging",
				component: "button"
			}];
		},
		load: function(page) {
			if (this.component) {
				var self = this;
				// our paging is already reactive, don't need to update it again
				return this.component.runAction("jump-page", {
					page: page
				});
			}
			return this.$services.q.reject();
		},
		configurator: function() {
			return "page-paging-configure";
		}
	}
});

Vue.component("page-paging-configure", {
	template: "#page-paging-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		},
		childComponents: {
			type: Object,
			required: false
		}
	}
})
nabu.page.provide("page-renumberer", {
	component: "page-paging-next",
	renumber: function(target, mapping) {
		// update the action target
		if (target.state.target != null && mapping[target.state.target] != null) {
			target.state.target = mapping[target.state.target];	
		}
	}
});

Vue.view("page-paging-next", {
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		},
		childComponents: {
			type: Object,
			required: false
		}
	},
	name: "Paging Without Count",
	category: "Data",
	icon: "sort-numeric-down",
	description: "Allow you to page through a data set without a total count",
	data: function() {
		return {
			// we start with _some_ paging so we see something in edit mode
			paging: {},
			component: null,
			loading: false
		}
	},
	computed: {
		pageNumber: function() {
			return this.paging && this.paging.current ? this.paging.current : 0;
		}
	},
	// hook into component
	mounted: function() {
		var self = this;
		var pageInstance = this.$services.page.getPageInstance(this.page, this);
		if (this.cell.state.target) {
			pageInstance.getComponent(this.cell.state.target).then(function(component) {
				self.component = component;
				Vue.set(self, "paging", component.getRuntimeState().paging);
			});
		}
	},
	methods: {
		getChildComponents: function() {
			return [{
				title: "Menu",
				name: "paging-menu",
				description: "The menu that contains the paging buttons",
				component: "menu"
			}, {
				title: "Button",
				name: "paging-button",
				description: "The button used for paging",
				component: "button"
			},
			{
				title: "Form Field",
				name: "paging-page-number",
				description: "The form field where you can manipulate the page number",
				component: "form-text"
			}];
		},
		load: function(page) {
			if (this.component) {
				var self = this;
				this.loading = true;
				var done = function(x) {
					console.log("loading done", x, self.paging);
					self.loading = false;
				};
				console.log("jumping to page", page);
				// our paging is already reactive, don't need to update it again
				return this.component.runAction("jump-page", {
					page: page
				}).then(done, done);
			}
			return this.$services.q.reject();
		},
		configurator: function() {
			return "page-paging-next-configure";
		}
	},
	watch: {
		'paging.page': function(newValue) {
			console.log("updated to", newValue);
			this.pageNumber = newValue && newValue.current ? newValue.current : 0;
		}
	}
});

Vue.component("page-paging-next-configure", {
	template: "#page-paging-next-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		cell: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		},
		childComponents: {
			type: Object,
			required: false
		}
	}
})
Vue.component("page-field-fragment-image-configure", {
	template: "#page-field-fragment-image-configure",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		fragment: {
			type: Object,
			required: true
		},
		// available data keys
		// this could be generated for cell/page but could also be provided by a wrapper component
		keys: {
			type: Array,
			required: true
		}
	},
	methods: {
		getOperations: function(value) {
			return this.$services.page.getOperations(function(operation) {
				if (!value || operation.id.toLowerCase().indexOf(value.toLowerCase()) >= 0) {
					return true;
				}
				return false;
			});
		},
		getOperationParameters: function(operation) {
			return this.$services.page.getSwaggerParametersAsKeys(operation);
		},
		getAvailableParameters: function() {
			var result = this.$services.page.getAvailableParameters(this.page, null, true);
			if (this.keys.length) {
				var record = {};
				this.keys.forEach(function(x) {
					record[x] = {type: "string"};
				});
				result.record = {properties:record};
			}
			return result;
		}
	},
	created: function() {
		if (!this.fragment.fixedHref) {
			Vue.set(this.fragment, "fixedHref", false);
		}
		if (!this.fragment.imageHref) {
			Vue.set(this.fragment, "imageHref", null);
		}
		if (!this.fragment.imageTitle) {
			Vue.set(this.fragment, "imageTitle", null);
		}
		if (!this.fragment.imageHeight) {
			Vue.set(this.fragment, "imageHeight", null);
		}
		if (!this.fragment.imageSize) {
			Vue.set(this.fragment, "imageSize", 'cover');
		}
		if (!this.fragment.bindings) {
			Vue.set(this.fragment, "bindings", {});
		}
	}
});

Vue.component("page-field-fragment-image", {
	template: "<div class='image' :style=\"{'background-image': 'url(' + href + ')', height: fragment.imageHeight ? fragment.imageHeight : 'inherit', 'background-size': fragment.imageSize, 'background-repeat': 'no-repeat', 'background-position': 'center' }\"></div>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		fragment: {
			type: Object,
			required: true
		},
		data: {
			type: Object,
			required: true
		}
	},
	computed: {
		href: function() {
			var href = null;
			if (this.fragment.operationParameter) {
				if (this.fragment.operation) {
					var parameters = {};
					var self = this;
					var pageInstance = this.$services.page.getPageInstance(this.page, this);
					Object.keys(this.fragment.bindings).forEach(function(key) {
						if (self.fragment.bindings[key]) {
							if (self.fragment.bindings[key].indexOf("record.") == 0) {
								parameters[key] = self.$services.page.getValue(self.data, self.fragment.bindings[key].substring("record.".length));
							}
							else {
								parameters[key] = self.$services.page.getBindingValue(pageInstance, self.fragment.bindings[key]);
							}
						}
					})
					var properties = this.$services.swagger.parameters(this.fragment.operation, parameters);
					return properties.url;
				}
			}
			else {
				if (this.fragment.fixedHref) {
					href = this.fragment.imageHref;
				}
				else if (this.fragment.imageHref) {
					href = this.$services.page.getValue(this.data, this.fragment.imageHref);
				}
				// we assume the data is base64encoded
				if (href && this.fragment.dataUrl) {
					href = URL.createObjectURL(href);
				}
				// if the href is not an absolute one (either globally absolute or application absolute), we inject the server root
				else if (href && href.substring(0, 7) != "http://" && href.substring(0, 8) != "https://" && href.substring(0, 1) != "/") {
					href = "/" + href;
				}
			}
			return href;
		}
	}
});
Vue.component("page-field-fragment-text-configure", {
	template: "<n-form-section>"
		+ "		<n-form-switch label='Multiline' v-model='fragment.multiline'/>"
		+ "		<n-form-switch label='Compile' v-model='fragment.compile'/>"
		+ "		<n-form-combo label='Type' v-model='fragment.tag' :items=\"['span', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div']\"/>"
		+ "		<n-form-switch label='Html' v-model='fragment.html'/>"
		+ "		<n-form-text label='Text' v-if='!fragment.html' :type=\"fragment.multiline ? 'area' : 'text'\" v-model='fragment.content' :timeout='600'/>"
		+ "		<n-form-ace label='Text' mode='html' v-else :type=\"fragment.multiline ? 'area' : 'text'\" v-model='fragment.content' :timeout='600'/>"
		+ "</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		fragment: {
			type: Object,
			required: true
		}
	},
	created: function() {
		if (!this.fragment.multiline) {
			Vue.set(this.fragment, "multiline", false);
		}
		if (!this.fragment.content) {
			Vue.set(this.fragment, "content", null);
		}
		if (!this.fragment.tag) {
			Vue.set(this.fragment, "tag", null);
		}
	}
});

Vue.component("page-field-fragment-text", {
	template: "<component :is='tag' v-content.parameterized='{value:$services.page.translate($services.page.interpret(fragment.content, $self)), compile:fragment.compile, plain:!fragment.html}'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		fragment: {
			type: Object,
			required: true
		},
		data: {
			type: Object,
			required: true
		}
	},
	computed: {
		tag: function() {
			if (this.fragment.tag) {
				return this.fragment.tag;	
			}
			else {
				return "span";
			}
		}
	}
});
Vue.component("page-field-fragment-data-configure", {
	template: "<page-formatted-configure :fragment='fragment' :allow-html='true' :cell='cell' :page='page' :keys='keys'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		fragment: {
			type: Object,
			required: true
		},
		keys: {
			type: Array,
			required: false
		}
	}
});

Vue.component("page-field-fragment-data", {
	// the "state" is already a workaround to allow access to the data-specific state (e.g. in a data-card) via "state.firstName" logic
	// however, the global mixin for state management will enrich the state with "page" and "application" etc, and by reference update the state passed in here
	// this in turn meant that if you used a page form on the same data, which was now "corrupted" with page & application data
	// could no longer build a reference stringified string because it would end in a circularreferenceerror
	// as a workaround, the "data" that was passed in as state, is now cloned first
	// once again: state HAS TO GO
	template: "<page-formatted :value='value' :fragment='fragment' :cell='cell' :page='page' :state='$window.nabu.utils.objects.clone(data)'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		fragment: {
			type: Object,
			required: true
		},
		data: {
			type: Object,
			required: true
		}
	},
	computed: {
		value: function() {
			// if we get values from the page, they don't have local state so get them there directly
			// the problem is: state is copied on creation but is no longer watched, so updating that state in the page does not reflect changes in the data
			// we could use a general refactor of the whole state model though...
			// but this is important enough to warrant a workaround because of content management going through page parameters now
			if (this.fragment.key && (this.fragment.key.indexOf("page.") == 0 || this.fragment.key.indexOf("parent.") == 0)) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return pageInstance.get(this.fragment.key);
			}
			return this.fragment.key ? this.$services.page.getValue(this.data, this.fragment.key) : null;
		}
	}
});
Vue.component("page-field-fragment-javascript-configure", {
	template: "<n-form-section>"
		+ "		<n-ace mode='javascript' v-model='fragment.content'/>"
		+ "		<n-form-combo label='Type' v-model='fragment.tag' :items=\"['span', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div']\"/>"
		+ "		<n-form-switch v-model='fragment.html' label='Allow html'/>"
		+ "		<n-form-switch v-model='fragment.compile' label='Compile'/>"
		+ "</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		fragment: {
			type: Object,
			required: true
		}
	},
	created: function() {
		if (!this.fragment.content) {
			Vue.set(this.fragment, "content", null);
		}
		if (!this.fragment.tag) {
			Vue.set(this.fragment, "tag", null);
		}
	}
});

Vue.component("page-field-fragment-javascript", {
	template: "<component :is='tag' v-content.parameterized='{value:value,plain:!fragment.html,compile:!!fragment.compile}'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		fragment: {
			type: Object,
			required: true
		},
		data: {
			type: Object,
			required: true
		}
	},
	computed: {
		value: function() {
			return this.$services.page.eval(this.fragment.content, this.data, this);
		},
		tag: function() {
			if (this.fragment.tag) {
				return this.fragment.tag;	
			}
			else {
				return "span";
			}
		}
	}
});
Vue.component("page-field-fragment-richtext-configure", {
	template: "<n-form-section><n-form-richtext v-model='fragment.content'/>"
		+ "		<n-form-switch label='Compile' v-model='fragment.compile'/>"
		+ "	</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		fragment: {
			type: Object,
			required: true
		}
	},
	created: function() {
		if (!this.fragment.content) {
			Vue.set(this.fragment, "content", null);
		}
	}
});

Vue.component("page-field-fragment-richtext", {
	template: "<div v-content.parameterized='{value:$services.page.translate(fragment.content), sanitize:true, compile: fragment.compile }'></div>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		fragment: {
			type: Object,
			required: true
		},
		data: {
			type: Object,
			required: true
		}
	}
});
Vue.component("page-field-fragment-form-configure", {
	template: "<n-form-section><page-form-configure-single :field='fragment.form' :possible-fields='keys'"
					+ "		:allow-label='false'"
					+ "		:allow-description='false'"
					+ "		:page='page'"
					+ "		:cell='cell'/><n-form-text v-model='fragment.disabled' label='Disabled If'/><n-form-text v-model='fragment.componentGroup' label='Component Group' :timeout='600'/>"
					+ "     <n-form-text v-model='fragment.messageMode' label='Message Mode (the literal component or a number)' :timeout='600'/></n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		fragment: {
			type: Object,
			required: true
		},
		keys: {
			type: Array,
			required: true
		}
	},
	created: function() {
		if (!this.fragment.form) {
			Vue.set(this.fragment, "form", {});
		}
		if (!this.fragment.disabled) {
			Vue.set(this.fragment, "disabled", null);
		}
	}
});

Vue.component("page-field-fragment-form", {
	template: "<page-form-field :key=\"fragment.form.name + '_value'\" :field='fragment.form'" 
				+ "		:value='formValue(fragment)'"
				+ "		:parent-value='data'"
				+ "		@input='function(newValue) { updateForm(fragment, newValue) }'"
				+ "		:label='false'"
				+ "		:page='page'"
				+ "		:cell='cell'"
				+ "		:mode='fragment.mode'"
				+ "		:component-group=\"fragment.componentGroup ? fragment.componentGroup : 'form'\""
				+ "		:is-disabled='!!fragment.disabled && $services.page.isCondition(fragment.disabled, {record:data}, $self)'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		fragment: {
			type: Object,
			required: true
		},
		data: {
			type: Object,
			required: true
		}
	},
	methods: {
		formValue: function(fragment) {
			if (fragment.form.name) {
				return this.data[fragment.form.name];
			}
		},
		updateForm: function(fragment, newValue) {
			Vue.set(this.data, fragment.form.name, newValue);
			this.$emit("updated", fragment.form.name);
		}
	}
});
Vue.component("page-renderer-slider", {
	template: "#page-renderer-slider",
	props: {
		group: {
			type: String,
			required: false,
			default: "slider-default"
		},
		tag: {
			type: String,
			required: false
		}
	},
	data: function() {
		return {
			active: 0
		}
	},
	ready: function() {
		this.show();
	},
	methods: {
		show: function(index) {
			var counter = -1;
			var foundActive = false;
			var last = null;
			for (var i = 0; i < this.$slots.default.length; i++) {
				var node = this.$slots.default[i];
				if (node.tag != null) {
					counter++;
					last = counter;
					if (counter == index) {
						foundActive = true;
						this.active = counter;
						node.elm.classList.add("is-active");
					}
					else {
						node.elm.classList.remove("is-active");
					}
				}
			}
			if (!foundActive) {
				this.active = index < 0 ? last : 0;
				// unless you were attempting 0, show that one
				if (index != this.active) {
					this.show(this.active);
				}
			}
		},
		beforeEnter: function(element) {
			console.log("element is", element);
			element.style.opacity = 0;
		},
		previous: function() {
			this.show(this.active - 1);
		},
		next: function() {
			this.show(this.active + 1);
		}
	}
});

Vue.component("enumeration-provider", {
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		}
	},
	data: function() {
		return {
			provider: null
		}
	},
	created: function() {
		if (this.field.provider == "provider") {
			this.provider = this.getProvider();
		}
	},
	computed: {
		operationBinding: function() {
			var parameters = {};
			var self = this;
			if (this.field.enumerationOperationBinding) {
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				Object.keys(this.field.enumerationOperationBinding).map(function(key) {
					// if the binding is not set, we don't want to overwrite any parameters that are already there (e.g. the resolve field)
					if (self.field.enumerationOperationBinding[key] != null) {
						var target = parameters;
						var parts = key.split(".");
						for (var i = 0; i < parts.length - 1; i++) {
							if (!target[parts[i]]) {
								target[parts[i]] = {};
							}
							target = target[parts[i]];
						}
						if (self.field.enumerationOperationBinding[key].indexOf("record.") == 0) {
							target[parts[parts.length - 1]] = self.$services.page.getValue(self.parentValue, self.field.enumerationOperationBinding[key].substring("record.".length));
						}
						else {
							target[parts[parts.length - 1]] = self.$services.page.getBindingValue(pageInstance, self.field.enumerationOperationBinding[key], self);
						}
					}
				});
			}
			return parameters;
		}	
	},
	methods: {
		getProvider: function() {
			if (this.field.enumerationProvider) {
				var self = this;
				return nabu.page.providers("page-enumerate").filter(function(x) { return x.name == self.field.enumerationProvider })[0];
			}
			return null;
		},
		// enumerationOperation: null,
		// enumerationFormatter
		// enumerationFieldLabel: null,
		// enumerationFieldValue: null,
		// enumerationOperationQuery: null,
		// enumerationOperationBinding: {}
		enumerationFilter: function(value) {
			return this.enumerationFilterAny(value, false);
		},
		// if we set the "asResolve", we are actually resolving the existing value, so for example if you have an ID already
		// and you want to resolve it to the full object so you can get the correct label to show, it will be called with the resolve id
		// the query is used to find _new_ values
		enumerationFilterAny: function(value, asResolve) {
			if (this.field.provider == "operation") {
				if (!this.field.enumerationOperation) {
					return [];
				}
				var parameters = {};
				// don't set a default, use the binding if it's needed
				//parameters.limit = 20;
				nabu.utils.objects.merge(parameters, this.operationBinding);
				if (!asResolve && this.field.enumerationOperationQuery) {
					parameters[this.field.enumerationOperationQuery] = value;
				}
				else if (asResolve && this.field.enumerationOperationResolve) {
					parameters[this.field.enumerationOperationResolve] = value;
				}
				var self = this;
				// map any additional bindings
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				if (this.field.enumerationOperationBinding && false) {
					Object.keys(this.field.enumerationOperationBinding).map(function(key) {
						// if the binding is not set, we don't want to overwrite any parameters that are already there (e.g. the resolve field)
						if (self.field.enumerationOperationBinding[key] != null) {
							var target = parameters;
							var parts = key.split(".");
							for (var i = 0; i < parts.length - 1; i++) {
								if (!target[parts[i]]) {
									target[parts[i]] = {};
								}
								target = target[parts[i]];
							}
							if (self.field.enumerationOperationBinding[key].indexOf("record.") == 0) {
								target[parts[parts.length - 1]] = self.$services.page.getValue(self.parentValue, self.field.enumerationOperationBinding[key].substring("record.".length));
							}
							else {
								target[parts[parts.length - 1]] = self.$services.page.getBindingValue(pageInstance, self.field.enumerationOperationBinding[key], self);
							}
						}
					});
				}
				if (!parameters["$serviceContext"]) {
					parameters["$serviceContext"] = pageInstance.getServiceContext();
				}
				return this.$services.swagger.execute(this.field.enumerationOperation, parameters, function(response) {
					var result = null;
					if (response) {
						var arrayFound = false;
						Object.keys(response).map(function(key) {
							if (response[key] instanceof Array && arrayFound == false) {
								result = response[key];
								if (self.field.selectFirstIfEmpty && self.value == null && result && result.length > 0) {
									self.$emit("input", self.enumerationExtracter(result[0]));
								}
								arrayFound = true;
							}
						});
					}
					return result ? result : [];
				});
			}
			else if (this.field.provider == "array") {
				if (this.field.enumerationArray) {
					var self = this;
					var pageInstance = self.$services.page.getPageInstance(self.page, self);
					var pageArray = pageInstance.get(this.field.enumerationArray);
					var array = [];
					if (pageArray && pageArray.length) {
						nabu.utils.arrays.merge(array, pageArray);
					}
					if (this.field.filter) {
						array = array.filter(function(x) {
							return self.$services.page.isCondition(self.field.filter, x, self);
						})
					}
						
					if (array && array.length) {
						
						if (this.field.addEmptyState == true && this.field.emptyState != null) {
							// create empty object
							var empty = {}
							if (this.field.enumerationFieldValue) {
								empty[this.field.enumerationFieldValue] = null;
								empty['emptyState'] = true;
							}
							
							var emptyInArray = array.filter(function(x) {
								return x.emptyState == true;	
							});
							if (emptyInArray != null && emptyInArray.length == 0) {
								array.push(empty);
							}
						}
						
						if (!value) {
							return array;
						}
						else {
							return array.filter(function(x) {
								if (x == value) {
									return true;
								}
								if (self.field.enumerationArrayLabel != null) {
									var label = x[self.field.enumerationArrayLabel];
									if (label && label.toLowerCase && label.toLowerCase().indexOf(value.toLowerCase()) >= 0) {
										return true;
									}
								}
								if (self.field.enumerationFieldValue != null) {
									var label = x[self.field.enumerationFieldValue];
									if (label && label.toLowerCase && label.toLowerCase().indexOf(value.toLowerCase()) >= 0) {
										return true;
									}
								}
							});
						}
					}
				}
				return [];
			}
			else if (this.field.provider == "provider") {
				var provider = this.provider;
				if (provider) {
					var self = this;
					var values = provider.enumerate();
					if (this.field.filter && values) {
						values = values.filter(function(x) {
							return self.$services.page.isCondition(self.field.filter, x, self);
						})
					}
					if (value) {
						values = values.filter(function(x) {
							var formatted = self.enumerationFormatter(x);
							return formatted.toLowerCase().indexOf(value.toLowerCase()) >= 0;
						});
					}
					// the sorting can conflict with explicit sorting you want to manage from the outside
					// additionally, it can cause an infinite render loop
					/*
					values.sort(function(a, b) {
						var valueA = self.enumerationFormatter(a);
						var valueB = self.enumerationFormatter(b);
						return valueA ? valueA.localeCompare(valueB) : (valueB ? -1 : 0);
					});
					*/
					return values;
				}
				else {
					return [];
				}
			}
			else if (this.field.provider == "fixed") {
				var self = this;
				var result = this.field.enumerations.map(function(x) {
					if(typeof(x) == "string"){
						return "" + self.$services.page.translate((x && x.indexOf("=") == 0 ? self.$services.page.interpret(x, self) : x));
					}
					else {
						x = nabu.utils.objects.clone(x);
						x.value = "" + self.$services.page.translate((x && x.value && x.value.indexOf("=") == 0 ? self.$services.page.interpret(x.value, self) : x.value));
						return x;
					}
				}).filter(function(x) {
					if(typeof(x) == "string") {
						return !value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
					}
					else {
						return !value || x.value.toLowerCase().indexOf(("" + value).toLowerCase()) >= 0;
					}
				});
				if (this.field.allowCustom && result.indexOf(value) < 0) {
					result.unshift(value);
				}
				return result;
			}
			return [];
		},
		getFixedMatch: function(value) {
			var self = this;
			var result = this.field.enumerations.filter(function(x) {
				if (x.key != null) {
					return self.$services.page.interpret(x.key) == value;
				}
				else if (x.value != null) {
					return self.$services.page.interpret(x.value) == value;
				}
				else {
					return self.$services.page.interpret(x) == value;
				}
			});
			return result;
		},
		enumerationResolver: function(value) {
			if (this.field.provider == "operation" && this.field.enumerationOperationResolve && this.field.enumerationFieldValue) {
				return this.enumerationFilterAny(value, true);
			}
			else if (this.field.provider == "array") {
				return this.enumerationFilterAny();
			}
			else if (this.field.provider == "provider") {
				return this.enumerationFilterAny();
			}
			else if (this.field.provider == "fixed") {
				return this.getFixedMatch(value);
			}
			return value;
		},
		enumerationFormatter: function(value) {
			if (this.field.provider == "fixed") {
				if (typeof(value) == "string") {
					return value;
				}
				else if (value) {
					// probably not used because we already resolve interpretations in the enumerate (?)
					if (value.value) {
						return this.$services.page.interpret(this.$services.page.translate(value.value, this), this);
					}
					else {
						return value.key;
					}
				}
			}
			else {
				if (value == null) {
					return null;
				}
				else if (this.field.enumerationFieldLabelComplex) {
					var pageInstance = this.$services.page.getPageInstance(this.page, this);
					return !this.field.complexLabel ? this.field.complexLabel : this.$services.typography.replaceVariables(pageInstance, this.field, this.field.complexLabel, this.$services.q.reject(), value);
				}
				else if (this.field.enumerationFormatter) {
					return this.field.enumerationFormatter(value);
				}
				else if (this.field.enumerationFieldLabel) {
					return value[this.field.enumerationFieldLabel];
				}
				else {
					return value;
				}
			}
		},
		enumerationPrettyFormatter: function(value) {
			if (value == null) {
				return null;
			}
			if (value && value.emptyState == true && this.field.addEmptyState == true && !!this.field.emptyState) {
				return this.$services.page.interpret(this.$services.page.translate(this.field.emptyState), this);
			}
			else if (this.field.enumerationFieldPrettyLabelComplex) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return !this.field.complexPrettyLabel ? this.field.complexPrettyLabel : this.$services.typography.replaceVariables(pageInstance, this.field, this.field.complexPrettyLabel, this.$services.q.reject(), value);
			}
			else if (this.field.enumerationFieldPrettyLabel) {
				return value[this.field.enumerationFieldPrettyLabel];
			}
			else {
				return this.enumerationFormatter(value);
			}
		},
		enumerationExtracter: function(value) {
			if (this.field.provider == "fixed") {
				if (typeof(value) == "string") {
					return value;
				}
				else if (value) {
					if (value.key) {
						return this.$services.page.interpret(value.key, this);
					}
					else {
						return value.value;
					}
				}
			}
			else {
				if (value == null) {
					return null;
				}
				else if (this.field.enumerationFieldValue) {
					return value[this.field.enumerationFieldValue];
				}
				else {
					return value;
				}
			}
		},
		validate: function(soft) {
			return this.$refs.form ? this.$refs.form.validate(soft) : true;
		}
	}
})
Vue.component("enumeration-provider-configure", {
	template: "#enumeration-provider-configure",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		}
	},
	created: function() {
		if (!this.field.enumerationOperationBinding) {
			Vue.set(this.field, "enumerationOperationBinding", {});
		}
		if (this.field.enumerations == null) {
			Vue.set(this.field, "enumerations", []);
		}
	},
	computed: {
		availableParameters: function() {
			return this.$services.page.getAvailableParameters(this.page, this.cell, true);
		},
		providerValueOptions: function() {
			if (this.field.enumerationProvider != null) {
				var self = this;
				var providers = nabu.page.providers("page-enumerate").map(function(x) { return x.name });
				var provider = nabu.page.providers("page-enumerate").filter(function(x) { return x.name == self.field.enumerationProvider })[0];
				if (provider && provider.values) {
					return provider.values;
				}
			}
			return null;
		},
		providerLabelOptions: function() {
			if (this.field.enumerationProvider != null) {
				var self = this;
				var providers = nabu.page.providers("page-enumerate").map(function(x) { return x.name });
				var provider = nabu.page.providers("page-enumerate").filter(function(x) { return x.name == self.field.enumerationProvider })[0];
				if (provider && provider.labels) {
					return provider.labels;
				}
			}
			return null;
		}
	},
	methods: {
		addEnumeration: function() {
			if (this.field.complex) {
				this.field.enumerations.push({value:null,key:null});
			}
			else {
				this.field.enumerations.push('');
			}
		},
		getEnumerationArrays: function(name) {
			var self = this;
			return this.$services.page.getAllArrays(this.page, this.cell.id).filter(function(x) {
				return !name || x.toLowerCase().indexOf(name.toLowerCase()) >= 0;
			});
		},
		getEnumerationServices: function(name) {
			var self = this;
			return this.$services.page.getOperations(function(operation) {
				// must be a get
				var isAllowed = operation.method.toLowerCase() == "get"
					// and contain the name fragment (if any)
					&& (!name || operation.id.toLowerCase().indexOf(name.toLowerCase()) >= 0)
					// must have _a_ response
					&& operation.responses["200"];
				// we also need at least _a_ complex array in the results
				if (isAllowed) {
					var schema = operation.responses["200"] ? operation.responses["200"].schema : null;
					if (schema) {
						var definition = self.$services.swagger.definition(schema["$ref"]);
						// now we need a child in the definition that is a record array
						// TODO: we currently don't actually check for a complex array, just any array, could be an array of strings...
						isAllowed = false;
						if (definition.properties) {
							Object.keys(definition.properties).map(function(field) {
								if (definition.properties[field].type == "array") {
									isAllowed = true;
								}
							});
						}
					}
				}
				return isAllowed;
			}).map(function(x) {
				 return x.id;
			});	
		},
		getEnumerationFields: function(operationId, value) {
			var fields = [];
			if (this.field.provider == "operation") {
				if (this.$services.swagger.operations[operationId]) {
					var resolved = this.$services.swagger.resolve(this.$services.swagger.operations[operationId].responses["200"]);
					Object.keys(resolved.schema.properties).map(function(property) {
						if (resolved.schema.properties[property].type == "array") {
							nabu.utils.arrays.merge(fields, Object.keys(resolved.schema.properties[property].items.properties));
						}
					});
				}
			}
			else if (this.field.provider == "array") {
				var properties = {};
				var available = null;
				var variable = null;
				var rest = null;
				if (this.field.enumerationArray.indexOf("parent.") == 0) {
					var self = this;
					variable = this.field.enumerationArray.substring("parent.".length);
					var parentPage = this.$services.page.pages.filter(function(x) {
						return x.content.name == self.page.content.pageParent;
					})[0];
					if (parentPage != null) {
						//result.parent = this.getPageParameters(parentPage);
						available = this.$services.page.getAllAvailableParameters(parentPage);
					}
					rest = variable.substring(variable.indexOf(".") + 1);
					variable = variable.substring(0, variable.indexOf("."));
				}
				else {
					available = this.$services.page.getAllAvailableParameters(this.page, this.cell);
					variable = this.field.enumerationArray.substring(0, this.field.enumerationArray.indexOf("."));
					rest = this.field.enumerationArray.substring(this.field.enumerationArray.indexOf(".") + 1);
				}
				if (available[variable]) {
					var childDefinition = this.$services.page.getChildDefinition(available[variable], rest);
					console.log("variable", available, variable, childDefinition);
					if (childDefinition) {
						nabu.utils.objects.merge(properties, childDefinition.items.properties);
					}
				}
				nabu.utils.arrays.merge(fields, this.$services.page.getSimpleKeysFor({properties:properties}));
			}
			else if (this.field.provider == "provider") {
				nabu.utils.arrays.merge(fields, this.providerLabelOptions);
			}
			if (value) {
				fields = fields.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
			}
			return fields;
		},
		getEnumerationParameters: function(operationId, value) {
			var parameters = this.$services.swagger.operations[operationId].parameters;
			var result = parameters ? parameters.map(function(x) { return x.name }) : [];
			if (value != null) {
				result = result.filter(function(x) {
					return x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				});
			}
			return result;
		},
		getMappableEnumerationParameters: function(field) {
			var result = {
				properties: {}
			};
			if (this.$services.swagger.operations[field.enumerationOperation]) {
				Object.keys(this.$services.page.getInputBindings(this.$services.swagger.operations[field.enumerationOperation])).map(function(key) {
					if (key != field.enumerationOperationQuery) {
						result.properties[key] = {
							type: "string"
						}
					}
				});
				result.properties["$serviceContext"] = {
					type: "string"
				}
			}
			return result;
		},
		hasMappableEnumerationParameters: function(field) {
			var amount = Object.keys(this.getMappableEnumerationParameters(field).properties).length;
			return amount > 0;
		},
		searchPossible: function(value) {
			return this.possibleFields.filter(function(x) {
				return !value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
			});
		},
		getEnumerationProviders: function(value) {
			var providers = nabu.page.providers("page-enumerate").map(function(x) { return x.name });
			if (value) {
				providers = providers.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			providers.sort();
			return providers;
		}
	}
}) 
Vue.component("page-form-combo-configure", {
	template: "#page-form-combo-configure",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		}
	}
});


Vue.component("page-form-combo", {
	mixins: [Vue.component("enumeration-provider")],
	template: "#page-form-combo",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		parentValue: {
			type: Object,
			required: false
		},
		childComponents: {
			required: false
		}
	},
	// if we have an operation binding, let's retrigger the data lookup (for combo 2)
	watch: {
		operationBinding: {deep: true, handler: function(newValue) {
			// set to dirty
			// the first combo is the form-combo which in turn has its own ref
			if (this.$refs.combo && this.$refs.combo.$refs.combo) {
				this.$refs.combo.$refs.combo.markDirty();
			}
		}}
	},
	methods: {
		configurator: function() {
			return "page-form-combo-configure";
		},
		getChildComponents: function() {
			return {
				title: "Form Combo",
				name: "page-form-combo",
				component: "form-combo"
			};
		},
		validate: function(soft) {
			if (this.$refs.combo) {
				return this.$refs.combo.validate(soft);
			}
		}
	}
})


window.addEventListener("load", function() {
	application.bootstrap(function($services) {
		$services.router.register({
			alias: "page-form-combo",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-combo";
				cloneParameters.configurationComponent = "page-form-combo-configure";
				cloneParameters.subTabs = ["data"];
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "combo",
			category: "Form",
			name: "Combo box",
			description: "A combo box that allows the user to choose one or more values",
			icon: "page/core/images/enumeration.png"
		});
	})
});
Vue.component("page-form-checkbox-list-configure", {
	template: "#page-form-checkbox-list-configure",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		}
	}
});


Vue.component("page-form-checkbox-list", {
	mixins: [Vue.component("enumeration-provider")],
	template: "#page-form-checkbox-list",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		parentValue: {
			type: Object,
			required: false
		},
		childComponents: {
			required: false
		}
	},
	// if we have an operation binding, let's retrigger the data lookup (for checkbox-list 2)
	watch: {
		operationBinding: {deep: true, handler: function(newValue) {
			// set to dirty
			// the first checkbox-list is the form-checkbox-list which in turn has its own ref
			if (this.$refs.checkbox-list && this.$refs.checkbox-list.$refs.checkbox-list) {
				this.$refs.checkbox-list.$refs.checkbox-list.markDirty();
			}
		}}
	},
	methods: {
		configurator: function() {
			return "page-form-checkbox-list-configure";
		},
		getChildComponents: function() {
			return {
				title: "Form checkbox-list",
				name: "page-form-checkbox-list",
				component: "form-checkbox-list"
			};
		},
		validate: function(soft) {
			if (this.$refs["checkbox-list"]) {
				return this.$refs["checkbox-list"].validate(soft);
			}
		}
	}
})


window.addEventListener("load", function() {
	application.bootstrap(function($services) {
		$services.router.register({
			alias: "page-form-checkbox-list",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-checkbox-list";
				cloneParameters.configurationComponent = "page-form-checkbox-list-configure";
				cloneParameters.subTabs = ["data"];
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "checkbox-list",
			category: "Form",
			name: "checkbox-list",
			description: "A checkbox-list that allows the user to choose one or more values",
			icon: "page/core/images/enumeration.png"
		});
	})
});

Vue.component("page-form-radio-configure", {
	template: "#page-form-radio-configure",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		}
	}
});


Vue.component("page-form-radio", {
	mixins: [Vue.component("enumeration-provider")],
	template: "#page-form-radio",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		parentValue: {
			type: Object,
			required: false
		},
		childComponents: {
			required: false
		}
	},
	// if we have an operation binding, let's retrigger the data lookup (for radio 2)
	watch: {
		operationBinding: {deep: true, handler: function(newValue) {
			// set to dirty
			// the first radio is the form-radio which in turn has its own ref
			if (this.$refs.radio && this.$refs.radio.$refs.radio) {
				this.$refs.radio.$refs.radio.markDirty();
			}
		}}
	},
	methods: {
		disabler: function(item) {
			if (this.field.disableEntryCondition) {
				return this.$services.page.isCondition(this.field.disableEntryCondition, item, this, null, false);
			}
			return false;
		},
		configurator: function() {
			return "page-form-radio-configure";
		},
		getChildComponents: function() {
			return {
				title: "Form radio",
				name: "page-form-radio",
				component: "form-radio-list"
			};
		},
		validate: function(soft) {
			if (this.$refs.radio) {
				return this.$refs.radio.validate(soft);
			}
		}
	}
})


window.addEventListener("load", function() {
	application.bootstrap(function($services) {
		$services.router.register({
			alias: "page-form-radio",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-radio";
				cloneParameters.configurationComponent = "page-form-radio-configure";
				cloneParameters.subTabs = ["data"];
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "radio",
			category: "Form",
			name: "Radio box",
			description: "A radio box that allows the user to choose one or more values",
			icon: "page/core/images/enumeration.png"
		});
	})
});
Vue.component("page-form-list-input-predefined-configure", {
	template: "#page-form-list-input-predefined-configure",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		},
		schema: {
			type: Object,
			required: false
		}
	},
	computed: {
		operation: function() {
			return this.field.fieldProviderOperation ? this.$services.swagger.operations[this.field.fieldProviderOperation] : null;
		},
		// copy paste from data.js
		definition: function() {
			var properties = {};
			if (this.operation && this.operation.responses["200"]) {
				var definition = this.$services.swagger.resolve(this.operation.responses["200"].schema);
				//var definition = this.$services.swagger.definition(schema["$ref"]);
				if (definition.properties) {
					var self = this;
					Object.keys(definition.properties).map(function(field) {
						if (definition.properties[field].type == "array") {
							var items = definition.properties[field].items;
							if (items.properties) {
								nabu.utils.objects.merge(properties, items.properties);
							}
						}
					});
				}
			}
			return properties;
		},
		availableFields: function() {
			return this.$services.page.getSimpleKeysFor({properties:this.definition});
		},
		availableResultFields: function() {
			var schema = this.schema;
			if (schema.items) {
				schema = schema.items;
			}
			return Object.keys(schema.properties);
		}
	},
	created: function() {
		if (!this.field.fieldOperationBinding) {
			Vue.set(this.field, "fieldOperationBinding", {});
		}
	},
	methods: {
		// copy pasted from table getOperations
		listOperations: function(name) {
			var self = this;
			return this.$services.page.getOperations(function(operation) {
				// must be a get
				var isAllowed = operation.method.toLowerCase() == "get"
					// and contain the name fragment (if any)
					&& (!name || operation.id.toLowerCase().indexOf(name.toLowerCase()) >= 0)
					// must have _a_ response
					&& operation.responses["200"];
				// we also need at least _a_ complex array in the results
				if (isAllowed) {
					var schema = operation.responses["200"] ? operation.responses["200"].schema : null;
					if (schema) {
						var definition = self.$services.swagger.definition(schema["$ref"]);
						// now we need a child in the definition that is a record array
						// TODO: we currently don't actually check for a complex array, just any array, could be an array of strings...
						isAllowed = false;
						if (definition.properties) {
							Object.keys(definition.properties).map(function(field) {
								if (definition.properties[field].type == "array") {
									isAllowed = true;
								}
							});
						}
					}
				}
				return isAllowed;
			}).map(function(x) {
				 return x.id;
			});	
		},
		// copy paste from enumerationOperation
		getMappableParameters: function(field) {
			var result = {
				properties: {}
			};
			Object.keys(this.$services.page.getInputBindings(this.$services.swagger.operations[field.fieldProviderOperation])).map(function(key) {
				result.properties[key] = {
					type: "string"
				}
			});
			return result;
		},
		hasMappableParameters: function(field) {
			var amount = Object.keys(this.getMappableParameters(field).properties).length;
			return amount > 0;
		}
	}
});

Vue.component("page-form-list-input-predefined", {
	template: "#page-form-list-input-predefined",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		}
	},
	data: function() {
		return {
			fields: []
		}
	},
	created: function () {
		var self = this;
		if (this.field.fieldProviderOperation) {
			var parameters = {};
			// map any additional bindings
			if (this.field.fieldOperationBinding) {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				Object.keys(this.field.fieldOperationBinding).map(function(key) {
					var target = parameters;
					var parts = key.split(".");
					for (var i = 0; i < parts.length - 1; i++) {
						if (!target[parts[i]]) {
							target[parts[i]] = {};
						}
						target = target[parts[i]];
					}
					target[parts[parts.length - 1]] = self.$services.page.getBindingValue(pageInstance, self.field.fieldOperationBinding[key], self);
				});
			}
			this.$services.swagger.execute(this.field.fieldProviderOperation, parameters).then(function(list) {
				if (list) {
					Object.keys(list).map(function(key) {
						if (list[key] instanceof Array) {
							nabu.utils.arrays.merge(self.fields, list[key].map(function(x) {
								var type = self.field.typeField ? x[self.field.typeField] : null;
								var name = self.field.nameField ? x[self.field.nameField] : null;
								var nameCounter = 1;
								var label = self.field.labelField ? x[self.field.labelField] : null;
								var value = null;
								if (self.field.valueField) {
									value = x[self.field.valueField];
								}
								else if (self.value) {
									var array = self.$services.page.getValue(self.value, self.field.name);
									console.log("value is", self.value, JSON.stringify(self.value, null, 2), self.field.name, array,self.value[self.field.name.trim()]);
									if (array) {
										var keyField = self.field.resultKeyField;
										if (keyField == null) {
											keyField = "key";
										}
										var current = array.filter(function(y) {
											return y[keyField] == name;
										})[0];
										if (current) {
											var valueField = self.field.resultValueField;
											if (valueField == null) {
												valueField = "value";
											}
											value = current[valueField];
										}
									}
								}
								var optional = self.field.optionalField ? x[self.field.optionalField] : true;
								var placeholder = self.field.placeholderField ? x[self.field.placeholderField] : null;
								var result = {
									type: type == null ? "string" : type,
									name: name == null ? "unnamed" + nameCounter++ : name,
									label: label == null ? (name == null ? "Unnamed" : name) : label,
									value: value,
									optional: optional,
									placeholder: placeholder
								}
								console.log("calculated placeholder", placeholder);
								if (value != null) {
									self.value[result.name] = value;
								}
								// can map additional stuff like required, pattern,...
								Object.keys(list[key]).map(function(additional) {
									if (additional != self.field.typeField && additional != self.field.nameField && additional != self.field.labelField&& additional != self.field.valueField) {
										result[additional] = list[key][additional];
									}
								});
								return result;
							}));
							self.fields.forEach(function(field) {
								self.updateField(field, field.value);
							})
						}
					});
				}
			});
		}
	},
	methods: {
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		},
		updateField: function(field, newValue) {
			if (this.value[this.field.name] == null) {
				Vue.set(this.value, this.field.name, []);
			}
			var key = this.field.resultKeyField;
			if (key == null) {
				key = "key";
			}
			var value = this.field.resultValueField;
			if (value == null) {
				value = "value";
			}
			var existing = this.value[this.field.name].filter(function(x) { return x[key] == field.name })[0];
			if (existing == null) {
				var entry = {};
				entry[key] = field.name;
				entry[value] = newValue;
				this.value[this.field.name].push(entry);
			}
			else {
				existing[value] = newValue;
			}
		}
	}
});


// TODO: for simple lists: generate a new page-form-configure-single entity but with isList not filled in

Vue.component("page-form-list-input-dynamic-configure", {
	template: "<div><n-form-text v-model='field.buttonAddClass' placeholder='primary' label='Button Add Class'/><n-form-text v-if='false' v-model='field.buttonRemoveClass' placeholder='secondary' label='Button Remove Class'/></div>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		}
	}
});

Vue.component("page-form-list-input-dynamic", {
	template: "<n-form-section ref='form' class='dynamic-input'>"
					+ "		<div class='dynamic-input-contents' v-if='currentValue'>"
					+ "			<div v-for='i in Object.keys(currentValue)' class='dynamic-input-iteration'>"
					+ "				<template v-if='isSimpleList()'>"
					+ "					<page-form-field :key=\"field.name + '_value' + i\" :field='getSimpleField()'"
					+ "						v-model='currentValue[i]'"
					+ "						:schema='getSchemaFor()'"
					+ "						@input=\"$emit('changed')\""
					+ "						:timeout='timeout'"
					+ "						:page='page'"
					+ "						:cell='cell'/>"
					+ "				</template>"
					+ "				<template v-else>"
					//+ "					<n-form-section v-for='key in Object.keys(value[name ? name : field.name][i])' "
					+ "					<div v-for='key in getChildren()' "
					+ "							v-if=\"getField(field.name + '.' + key)\" >"
					+ "						<component v-if=\"getProvidedListComponent(field.name + '.' + key) != null\""
					+ "							:is=\"getProvidedListComponent(field.name + '.' + key)\""
					+ "							:value='currentValue[i]'"
					+ "							:page='page'"
					+ "							:cell='cell'"
					+ "							:edit='edit'"
					// once we are recursively editing lists, we are nesting them in the correct place, don't use global names
					+ "							:name='key'"
					+ "							:field=\"getField(field.name + '.' + key)\""
					+ "							@changed=\"$emit('changed')\""
					+ "							:timeout='cell.state.immediate ? 600 : 0'"
					+ "							:schema=\"getSchemaFor(key)\""
					+ "							:class=\"getField(field.name + '.' + key).group\"/>"
					+ "						<page-form-field v-else :key=\"field.name + '_value' + i + '_' + key\" :field=\"getField(field.name + '.' + key)\"" 
					+ "							:schema=\"getSchemaFor(key)\" v-model='currentValue[i][key]'"
					+ "							@input=\"$emit('changed')\""
					+ "							:timeout='timeout'"
					+ "							:page='page'"
					+ "							:cell='cell'"
					+ "							:class=\"getField(field.name + '.' + key).group\"/>"
					+ "					</div>"
					+ "				</template><span class='fa fa-times' @click='currentValue.splice(i, 1)'></span>"
					+ "		<button v-if='false' :class=\"field.buttonRemoveClass ? field.buttonRemoveClass : 'secondary'\" @click='currentValue.splice(i, 1)'>%{Remove} {{field.label ? $services.page.translate(field.label) : field.name}}</button>"
					+ "	</div>"
					+ "</div>"
					+ "<div class='dynamic-input-actions'>"
					+ "		<button :class=\"field.buttonAddClass ? field.buttonAddClass : 'primary'\" @click='addInstanceOfField'>%{Add} {{field.label ? $services.page.translate(field.label) : field.name}}</button>"
					+ "</div>"
				+ "</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		edit: {
			type: Boolean,
			required: false
		},
		name: {
			type: String,
			required: false
		}
	},
	computed: {
		// if you have a nested array (say body.fixed.ips)
		// in the past, it would be available under that exact name
		// with changes to the form engine, it could be for example "body.fixed" as a record which contains ips
		// for this reason, we do a slightly more complex lookup for the current value
		currentValue: function() {
			var path = this.name ? this.name : this.field.name;
			var original = path;
			while (path) {
				if (this.value[path]) {
					if (path != original) {
						return this.$services.page.getValue(this.value[path], original.substring(path.length + 1));
					}
					else {
						return this.value[path];
					}
				}
				var index = path.lastIndexOf(".");
				if (index > 0) {
					path = path.substring(0, index);
				}
				else {
					break;
				}
			}
			return null;
		}	
	},
	methods: {
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		},
		// currently we just assume it is a text field, in the to be we can do fancier things
		getSimpleField: function() {
			var field = nabu.utils.objects.clone(this.field);
			field.type = "text";
			return field;
		},
		addInstanceOfField: function() {
			var field = this.field;
			var name = this.name ? this.name : field.name;
			var valueToUse = this.currentValue;
			if (!valueToUse) {
				Vue.set(this.value, name, []);
				valueToUse = this.value[name];
			}
			var schema = this.schema;
			if (schema.items) {
				schema = schema.items;
			}
			var result = null;
			if (schema.properties) {
				result = {};
				Object.keys(schema.properties).map(function(key) {
					result[key] = null;
				});
			}
			valueToUse.push(result);
		},
		getChildren: function() {
			var schema = this.schema;
			if (schema.items) {
				schema = schema.items;
			}
			return Object.keys(schema.properties);
		},
		getProvidedListComponent: function(name) {
			var field = this.getField(name);
			if (!field) {
				return null;
			}
			var type = field.type;
			if (!type) {
				return null;
			}
			var provided = nabu.page.providers("page-form-list-input").filter(function(x) {
				 return x.name == type;
			})[0];
			return provided ? provided.component : null;	
		},
		isSimpleList: function() {
			// if the items consist of properties, they are complex, otherwise they are simple
			return !this.schema.items.properties;	
		},
		getSchemaFor: function(key) {
			// we want a single field in a complex list
			if (key) {
				// we want to pass in the correct required setting
				this.schema.items.properties[key].required = this.schema.items.required && this.schema.items.required.indexOf(key) >= 0;
				return this.schema.items.properties[key];
			}
			// we are using a simple list (e.g. strings)
			else {
				return this.schema.items;
			}
		},
		getField: function(name) {
			for (var i = 0; i < this.cell.state.pages.length; i++) {
				var field = this.cell.state.pages[i].fields.filter(function(x) {
					return x.name == name;
				})[0];
				if (field) {
					return field;
				}
			}
		}
	}
});
Vue.component("page-form-input-checkbox-configure", {
	template: "<div><n-form-switch v-model='field.mustCheck' label='Must Check'/>"
			+ "	<n-form-text v-model='field.info' label='Info Content'/>" 
			+ "	<n-form-switch v-model='field.invert' label='Invert Boolean'/>" 
			+ "	<n-form-text v-model='field.infoIcon' label='Info Icon'/>"
			+ "	<n-form-text v-model='field.before' label='Before Content' :timeout='600'/>"
			+ "	<n-form-text v-model='field.beforeIcon' label='Before Icon' v-if='field.before && false' :timeout='600'/>"
			+ "	<n-form-text v-model='field.after' label='After Content' :timeout='600'/>"
			+ "	<n-form-text v-model='field.afterIcon' label='After Icon' v-if='field.after && false' :timeout='600'/>"
			+ "	<n-page-mapper v-model='field.bindings' :from='availableParameters' :to='[\"item\"]'/>"
			+ "</div>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		}
	},
	created: function() {
		if (!this.field.bindings) {
			Vue.set(this.field, "bindings", {});
		}
	},
	computed: {
		availableParameters: function() {
			return this.$services.page.getAvailableParameters(this.page, this.cell, true);
		}
	}
});

Vue.component("page-form-input-checkbox", {
	template: "<n-form-checkbox ref='form'"
			+ "		:edit='!readOnly'"
			+ "		:schema='schema'"
			+ "		:class=\"getChildComponentClasses('page-form-checkbox')\""
			+ "		:info-icon='field.infoIcon'"
			+ "		:info='field.info ? $services.page.interpret($services.page.translate(field.info), $self) : null'"
			+ "		:required='required'"
			+ "		:must-check='field.mustCheck'"
			+ "		@input=\"function(newValue) { $emit('input', newValue) }\""
			+ "		:label='label'"
			+ "		:item='getItem()'"
			+ "		:value='value'"
			+ "		:timeout='timeout'"
			+ "		:before='field.before ? $services.page.interpret($services.page.translate(field.before), $self) : null'"
			+ "		:after='field.after ? $services.page.interpret($services.page.translate(field.after), $self) : null'"
			+ "		:invert='!!field.invert'"
			+ "		:disabled='disabled'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		childComponents: {
			required: false
		}
	},
	methods: {
		getChildComponents: function() {
			return {
				title: "Form Checkbox",
				name: "page-form-checkbox",
				component: "form-checkbox"
			};
		},
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		},
		getItem: function() {
			if (this.field.bindings && this.field.bindings.item) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return this.$services.page.getBindingValue(pageInstance, this.field.bindings.item, this);
			}
		}
	}
});
Vue.component("page-form-input-enumeration-configure", {
	template: "<n-form-section>"
		+ " 	<n-form-switch v-model='field.showRadioView' label='Show radio visualisation'/>"
		+ " 	<n-form-switch v-model='field.complex' label='Complex Values' v-if='!field.allowCustom'/>"
		+ " 	<n-form-switch v-model='field.icon' v-if='field.showRadioView' label='Icon (instead of radio)'/>"
		+ " 	<n-form-switch v-model='field.iconAlt' v-if='field.showRadioView && field.icon' label='Icon (when not selected)'/>"
		+ " 	<n-form-switch v-if='!field.showRadioView' v-model='field.forceValue' label='Force Any Value' />"
		+ "		<n-form-switch v-if='!field.complex' v-model='field.allowCustom' label='Allow Custom Values'/>"
		+ "		<n-form-combo v-if='field.showRadioView' v-model='field.mustChoose' label='Must choose' :items=\"[true,false]\" />"
			+ "	<n-form-text v-model='field.info' label='Info Content'/>"
			+ "	<n-form-text v-model='field.before' label='Before Content'/>"
			+ "	<n-form-text v-model='field.beforeIcon' label='Before Icon' v-if='field.before'/>"
			+ "	<n-form-text v-model='field.after' label='After Content'/>"
			+ "	<n-form-text v-model='field.afterIcon' label='After Icon' v-if='field.after'/>"
			+ "	<n-form-text v-model='field.suffix' label='Suffix' v-if='!field.suffixIcon'/>"
			+ "	<n-form-text v-model='field.suffixIcon' label='Suffix Icon' v-if='!field.suffix'/>"
		+ "		<div class='is-row is-align-end'><button class='is-button is-size-xsmall is-variant-primary-outline' @click='addEnumeration'><icon name='plus'/><span class='text'>Enumeration</span></button></div>"
		+ "		<div v-if='!field.complex' class='is-column is-spacing-gap-small'><n-form-section class='has-button-close' v-for='i in Object.keys(field.enumerations)' :key=\"field.name + 'enumeration_' + i\">"
		+ "			<n-form-text v-model='field.enumerations[i]'/>"
		+ "			<button class='is-button is-variant-close is-size-small' @click='field.enumerations.splice(i, 1)'><icon name='times'/></button>"
		+ "		</n-form-section></div>"
		+ "		<div v-else class='is-column is-spacing-gap-small'><n-form-section class='is-column is-spacing-medium is-spacing-vertical-top-large is-color-body has-button-close' v-for='i in Object.keys(field.enumerations)' :key=\"field.name + 'enumeration_' + i\">"
		+ "			<n-form-text v-model='field.enumerations[i].key' placeholder='Value' :timeout='600'/>"
		+ "			<n-form-text v-model='field.enumerations[i].value' placeholder='Label' :timeout='600'/>"
		+ "			<button class='is-button is-variant-close is-size-small' @click='field.enumerations.splice(i, 1)'><icon name='times'/></button>"
		+ "		</n-form-section>"
		+ "	</div></n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		}
	},
	created: function() {
		if (!this.field.enumerations) {
			Vue.set(this.field, "enumerations", []);
		}
	},
	methods: {
		addEnumeration: function() {
			if (this.field.complex) {
				this.field.enumerations.push({value:null,key:null});
			}
			else {
				this.field.enumerations.push('');
			}
		}
	},
	watch: {
		'field.complex': function(newValue) {
			if (newValue) {
				Vue.set(this.field, "enumerations", this.field.enumerations.splice(0).map(function(x) {
					if (typeof(x) == "string") {
						return {key:x, value: null};
					}
					else {
						return x;
					}
				}));
			}
			else {
				Vue.set(this.field, "enumerations", this.field.enumerations.splice(0).map(function(x) {
					if (typeof(x) != "string") {
						return x.key;
					}
					else {
						return x;
					}
				}));
			}
		}
	}
});

Vue.component("page-form-input-enumeration", {
	template: "<div><n-form-radio v-if='field.showRadioView' :items='field.enumerations' ref='form'"
			+ "		:edit='!readOnly'"
			+ "		:placeholder='placeholder'"
			+ "		@input=\"function(newValue) { $emit('input', newValue) }\""
			+ "		:formatter='formatter'"
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		:icon='field.icon'"
			+ "		:icon-alt='field.iconAlt'"
			+ "		:description='field.description ? $services.page.translate(field.description) : null'"
			+ "		:description-type='field.descriptionType'"
			+ "		:description-icon='field.descriptionIcon'"
			+ "		:info='field.info ? $services.page.translate(field.info) : null'"
			+ "		:before='field.before ? $services.page.translate(field.before) : null'"
			+ "		:after='field.after ? $services.page.translate(field.after) : null'"
			+ "		:suffix='field.suffixIcon ? $services.page.getIconHtml(field.suffixIcon) : field.suffix'"
			+ "		:schema='schema'"
			+ "		v-bubble:label"
			+ "		:required='required'"
			+ "		:must-choose='field.mustChoose ? $services.page.interpret(field.mustChoose, $self) : null'"
			+ "		:extracter='extracter'"
			+ "		:disabled='disabled'/>"
			+ "<n-form-combo v-else :filter='enumerate' ref='form'"
			+ "		:edit='!readOnly'"
			+ "		:nillable='!field.forceValue'"
			+ "		:placeholder='placeholder'"
			+ "		@input=\"function(newValue) { $emit('input', newValue) }\""
			+ "		:formatter='formatter'"
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		v-bubble:label"
			+ "		v-bubble:blur"
			+ "		:description='field.description ? $services.page.translate(field.description) : null'"
			+ "		:description-type='field.descriptionType'"
			+ "		:description-icon='field.descriptionIcon'"
			+ "		:info='field.info ? $services.page.translate(field.info) : null'"
			+ "		:before='field.before ? $services.page.translate(field.before) : null'"
			+ "		:after='field.after ? $services.page.translate(field.after) : null'"
			+ "		:suffix='field.suffixIcon ? $services.page.getIconHtml(field.suffixIcon) : field.suffix'"
			+ "		:schema='schema'"
			+ "		:required='required'"
			+ "		:extracter='extracter'"			
			+ "		:disabled='disabled'/>"
			+ " </div>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		}
	},
	methods: {
		getChildComponents: function() {
			return [{
				title: "Form combo",
				name: "form-component",
				component: "form-combo"
			}];
		},
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		},
		formatter: function(value) {
			if (typeof(value) == "string") {
				return value;
			}
			else if (value) {
				// probably not used because we already resolve interpretations in the enumerate (?)
				if (value.value) {
					return this.$services.page.interpret(this.$services.page.translate(value.value, this), this);
				}
				else {
					return value.key;
				}
			}
		},
		extracter: function(value) {
			if (typeof(value) == "string") {
				return value;
			}
			else if (value) {
				if (value.key) {
					return this.$services.page.interpret(value.key, this);
				}
				else {
					return value.value;
				}
			}
		},
		enumerate: function(value) {
			var self = this;
			var result = this.field.enumerations.map(function(x) {
				if(typeof(x) == "string"){
					return "" + (x && x.indexOf("=") == 0 ? self.$services.page.interpret(x, self) : x);
				}
				else {
					x = nabu.utils.objects.clone(x);
					x.value = "" + (x && x.value && x.value.indexOf("=") == 0 ? self.$services.page.interpret(x.value, self) : x.value);
					return x;
				}
			}).filter(function(x) {
				if(typeof(x) == "string"){
					return !value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				}
				else {
					return !value || x.value.toLowerCase().indexOf(value.toLowerCase()) >= 0;
				}
			});
			if (this.field.allowCustom && result.indexOf(value) < 0) {
				result.unshift(value);
			}
			return result;
		}
	}
});
Vue.component("page-form-input-enumeration-array-configure", {
	template: "<n-form-section class='enumeration'>"
			+ " 	<n-form-switch v-model='field.disableTyping' label='Disable typing'/>"
			+ " 	<n-form-switch v-model='field.showRadioView' v-if='!field.showCheckboxView' label='Show radio visualisation'/>"
			+ " 	<n-form-switch v-model='field.showCheckboxView' v-if='!field.showRadioView && supportsMultiple' label='Show checkbox visualisation (allows multiselect)'/>"
			+ " 	<n-form-switch v-model='field.addEmptyState' label='Add empty state'/>"
			+ "		<n-form-text v-model='field.emptyValue' label='Empty text'/>"
			+ " 	<n-form-text v-if='!!field.addEmptyState' v-model='field.emptyState' label='Empty state text'/>"
			+ "		<n-form-text v-if='field.showRadioView' v-model='field.mustChoose' label='Must choose' placeholder='=true' allow-typing='true' />"
			+ "		<n-form-combo v-model='field.enumerationArray'"
			+ "			label='Enumeration Array'"
			+ "			:filter='getEnumerationArrays'/>"
			+ " 	<n-form-ace v-if='field.enumerationArray' label='Filter' v-model='field.filter'/>"
			+ "		<n-form-switch v-model='field.enumerationArrayLabelComplex' label='Complex Enumeration Label'/>"
			+ "		<n-form-combo v-if='field.enumerationArray && !field.enumerationArrayLabelComplex' v-model='field.enumerationArrayLabel' label='Enumeration Label'"
			+ "			:filter='function() { return getEnumerationFields(field.enumerationArray) }'/>"
			+ "		<n-form-switch v-model='field.enumerationArrayPrettyLabelComplex' label='Complex Pretty Enumeration Label'/>"
			+ "		<n-form-combo v-if='field.enumerationArray && !field.enumerationArrayPrettyLabelComplex' v-model='field.enumerationArrayPrettyLabel' label='Pretty enumeration Label'"
			+ "			:filter='function() { return getEnumerationFields(field.enumerationArray) }'/>"
			+ "		<n-form-text v-model='field.complexPrettyLabel' label='The complex pretty label' v-if='field.enumerationArrayPrettyLabelComplex'/>"
			+ "		<n-form-combo v-if='field.enumerationArray' v-model='field.enumerationArrayValue' label='Enumeration Value'"
			+ "			:filter='function() { return getEnumerationFields(field.enumerationArray) }' info='If nothing is selected, the entire document becomes the value'/>"
			+ "		<n-form-text v-model='field.complexLabel' label='The complex text label' v-if='field.enumerationArrayLabelComplex'/>"
			+ "		<typography-variable-replacer v-if='field.enumerationArrayLabelComplex && field.complexLabel' :content='field.complexLabel' :page='page' :container='field' :keys='getEnumerationFields(field.enumerationArray)' />"
			+ "		<typography-variable-replacer v-if='field.enumerationArrayPrettyLabelComplex && field.complexPrettyLabel' :content='field.complexPrettyLabel' :page='page' :container='field' :keys='getEnumerationFields(field.enumerationArray)' />"
			+ "		<n-form-combo v-if='field.enumerationArray' :filter='function() { return getEnumerationFields(field.enumerationArray) }' v-model='field.enumerationCachingKey' label='Enumeration Caching Key'/>"    
			+ "		<n-page-mapper v-model='field.bindings' :from='availableParameters' :to='[\"validator\"]'/>"
			+ "</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		}
	},
	created: function() {
		this.normalize(this.field);
	},
	computed: {
		availableParameters: function() {
			return this.$services.page.getAvailableParameters(this.page, this.cell, true);
		},
		supportsMultiple: function() {
			if (this.cell.state.name) {
				// this currently only works for page-based form fields
				// in v2, all form fields "should" be page based though?
				// only exception so far is inline form components in a data table
				var result = this.$services.page.getPageParameters(this.page);
				//var result = this.$services.page.getAvailableParameters(this.page, this.cell, true);
				var name = this.cell.state.name;
				if (name.indexOf("page.") == 0) {
					name = name.substring("page.".length);
				}
				var childDefinition = this.$services.page.getChildDefinition(result, name);
				return childDefinition ? childDefinition.type == "array" : false;
			}
			return false;
		}
	},
	methods: {
		normalize: function(field) {
			if (!field.bindings) {
				Vue.set(field, "bindings", {});
			}
		},
		enumerationFilter: function(value) {
			var providers = nabu.page.providers("page-enumerate").map(function(x) { return x.name });
			if (value) {
				providers = providers.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			providers.sort();
			return providers;
		},
		getEnumerationArrays: function(name) {
			var self = this;
			return this.$services.page.getAllArrays(this.page, this.cell.id).filter(function(x) {
				return !name || x.toLowerCase().indexOf(name.toLowerCase()) >= 0;
			});
		},
		getEnumerationFields: function(array) {
			var properties = {};
			var available = null;
			var variable = null;
			var rest = null;
			if (this.field.enumerationArray.indexOf("parent.") == 0) {
				var self = this;
				variable = this.field.enumerationArray.substring("parent.".length);
				var parentPage = this.$services.page.pages.filter(function(x) {
					return x.content.name == self.page.content.pageParent;
				})[0];
				if (parentPage != null) {
					//result.parent = this.getPageParameters(parentPage);
					available = this.$services.page.getAllAvailableParameters(parentPage);
				}
				rest = variable.substring(variable.indexOf(".") + 1);
				variable = variable.substring(0, variable.indexOf("."));
			}
			else {
				available = this.$services.page.getAllAvailableParameters(this.page, this.cell);
				variable = this.field.enumerationArray.substring(0, this.field.enumerationArray.indexOf("."));
				rest = this.field.enumerationArray.substring(this.field.enumerationArray.indexOf(".") + 1);
			}
			if (available[variable]) {
				var childDefinition = this.$services.page.getChildDefinition(available[variable], rest);
				if (childDefinition) {
					nabu.utils.objects.merge(properties, childDefinition.items.properties);
				}
			}
			return this.$services.page.getSimpleKeysFor({properties:properties});
		}
	}
});

// removed content from the n-form-radio as was defined for the neo project
// it does not appear to add anything of value, if something does not work, this should be checked first
// The code in question: ><template slot='label' scope='props'><label @click='props.select(props.value); $event.stopPropagation()' class='n-form-label' v-content='enumerationFormatter(props.value)'></label></template></n-form-radio
Vue.component("page-form-input-enumeration-array", {
	template: ""
			+ " <n-form-checkbox-list v-if='field.showCheckboxView' :items='enumerationFilterAny(null)' ref='form'"
			+ "		:edit='!readOnly'"
			+ "		:placeholder='placeholder'"
			+ "		v-bubble:input"
			+ "		:formatter='enumerationFormatter'"
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		v-bubble:label"
			+ "		:schema='schema'"
			+ "		:description='field.description ? $services.page.translate(field.description) : null'"
			+ "		:descriptionType='field.descriptionType'"
			+ "		:descriptionIcon='field.descriptionIcon'"
			+ "		:required='required'"
			+ "		:extracter='enumerationExtracter'"
			+ "		:disabled='disabled'/>"
			+ "<n-form-radio v-else-if='field.showRadioView'"
			+ "		:items='enumerationFilterAny(null)'"
			+ "		ref='form'"
			+ "		:edit='!readOnly'"
			+ "		:placeholder='placeholder'"
			+ "		v-bubble:input"
			+ "		:label='label ? $services.page.interpret(label, $self) : null'"
			+ "		:value='value'"
			+ "		:description='field.description ? $services.page.translate(field.description) : null'"
			+ "		:description-type='field.descriptionType'"
			+ "		:description-icon='field.descriptionIcon'"
			+ "		:schema='schema'"
			+ "		v-bubble:label"
			+ "		:required='required'"
			+ "		:must-choose='field.mustChoose ? $services.page.interpret(field.mustChoose, $self) : null'"
			+ "		:formatter='enumerationFormatter'"
			+ "		:extracter='enumerationExtracter'"
			+ "		:disabled='disabled'/>"
			+ "<n-form-combo ref='form' v-else"
			+ "		:filter='enumerationFilter'"
			+ "		:pretty-formatter='enumerationPrettyFormatter'"
			+ "		:formatter='enumerationFormatter'"
			+ " 	:extracter='enumerationExtracter'"
			+ "		:edit='!readOnly'"
			+ "		:required='required'"
			+ "		:placeholder='placeholder'"
			+ "		v-bubble:input"
			+ "		v-bubble:label"
			+ "		:timeout='600'"
			+ "		:empty-value='field.emptyValue'"
			+ "		:label='label ? $services.page.interpret(label, $self) : null'"
			+ "		:value='value'"
			+ "		:allow-typing='!field.disableTyping'"		
			+ "		:validator='getValidator()'"
			+ "		:description='field.description ? $services.page.translate(field.description) : null'"
			+ "		:description-type='field.descriptionType'"
			+ "		:description-icon='field.descriptionIcon'"
			+ "		:schema='schema'"
			+ "		:disabled='disabled'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		}
	},
	data: function() {
		return {
			provider: null
		}
	},
	methods: {
		getChildComponents: function() {
			return [{
				title: "Form combo",
				name: "form-component",
				component: "form-combo"
			}];
		},
		enumerationFilter: function(value) {
			var values = this.enumerationFilterAny(value);
			return values;
		},
		enumerationFilterAny: function(value) {
			if (this.field.enumerationArray) {
				var self = this;
				var pageInstance = self.$services.page.getPageInstance(self.page, self);
				var pageArray = pageInstance.get(this.field.enumerationArray);
				var array = [];
				if (pageArray && pageArray.length) {
					nabu.utils.arrays.merge(array, pageArray);
				}
				if (this.field.filter) {
					array = array.filter(function(x) {
						return self.$services.page.isCondition(self.field.filter, x, self);
					})
				}
					
				if (array && array.length) {
					
					if (this.field.addEmptyState == true && this.field.emptyState != null) {
						// create empty object
						var empty = {}
						if (this.field.enumerationArrayValue) {
							empty[this.field.enumerationArrayValue] = null;
							empty['emptyState'] = true;
						}
						
						var emptyInArray = array.filter(function(x) {
							return x.emptyState == true;	
						});
						if (emptyInArray != null && emptyInArray.length == 0) {
							array.push(empty);
						}
					}
					
					if (!value) {
						return array;
					}
					else {
						return array.filter(function(x) {
							if (self.field.enumerationArrayLabel != null) {
								var label = x[self.field.enumerationArrayLabel];
								if (label && label.toLowerCase && label.toLowerCase().indexOf(value.toLowerCase()) >= 0) {
									return true;
								}
							}
							if (self.field.enumerationArrayValue != null) {
								var label = x[self.field.enumerationArrayValue];
								if (label && label.toLowerCase && label.toLowerCase().indexOf(value.toLowerCase()) >= 0) {
									return true;
								}
							}
						});
					}
				}
			}
			return [];
		},
		enumerationPrettyFormatter: function(value) {
			if (value == null) {
				return null;
			}
			if (value && value.emptyState == true && this.field.addEmptyState == true && !!this.field.emptyState) {
				return this.$services.page.interpret(this.$services.page.translate(this.field.emptyState), this);
			}
			else if (this.field.enumerationArrayPrettyLabelComplex) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return !this.field.complexPrettyLabel ? this.field.complexPrettyLabel : this.$services.typography.replaceVariables(pageInstance, this.field, this.field.complexPrettyLabel, this.$services.q.reject(), value);
			}
			else if (this.field.enumerationArrayPrettyLabel) {
				return value[this.field.enumerationArrayPrettyLabel];
			}
			else {
				return this.enumerationFormatter(value);
			}
		},
		enumerationFormatter: function(value) {
			if (value == null) {
				return null;
			}
			if (value && value.emptyState == true && this.field.addEmptyState == true && !!this.field.emptyState) {
				return this.$services.page.interpret(this.$services.page.translate(this.field.emptyState), this);
			}
			else if (this.field.enumerationArrayLabelComplex) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return !this.field.complexLabel ? this.field.complexLabel : this.$services.typography.replaceVariables(pageInstance, this.field, this.field.complexLabel, this.$services.q.reject(), value);
			}
			// we want complex labels
			else if (this.field.enumerationArrayLabelComplex) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				var storageId = "enumerate." + this.field.enumerationOperation + "." + value[this.field.enumerationOperationValue];
				if (this.field.enumerationCachingKey) {
					storageId += "." + value[this.field.enumerationCachingKey];
				}
				storageId = storageId.replace(/\./g, "_");
				
				if (pageInstance.retrieve(storageId) != null) {
					var retrieved = pageInstance.retrieve(storageId);
					return retrieved;
				}
				var self = this;
				pageInstance.store(storageId, "");
				
				setTimeout(function() {
					var parameters = nabu.utils.objects.deepClone({
						page: self.page,
						cell: {state: self.field},
						edit: false,
						data: value,
						label: false,
						fieldsName: "enumerationFields"
					});
					var onUpdate = function() {
						
						var content = null;
						if (self.field.enumerationArrayLabelComplex) {
							content = component.$el.innerHTML;
						}
						else {
							content = component.$el.innerHTML.replace(/<[^>]+>/g, "");
						}
						if (pageInstance.retrieve(storageId) != content) {
							pageInstance.store(storageId, content);
						}
					};
					var component = new nabu.page.views.PageFields({ propsData: parameters, updated: onUpdate, ready: onUpdate });
					component.$mount();
				}, 1);
				return pageInstance.retrieve(storageId);
			}
			else if (this.field.enumerationFormatter) {
				return this.field.enumerationFormatter(value);
			}
			else if (this.field.enumerationArrayLabel) {
				return value[this.field.enumerationArrayLabel];
			}
			else {
				return value;
			}
		},
		enumerationExtracter: function(value) {
			if (value == null) {
				return null;
			}
			else if (this.field.enumerationArrayValue) {
				return value[this.field.enumerationArrayValue];
			}
			else {
				return value;
			}
		},
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		},
		getValidator: function() {
			if (this.field.bindings && this.field.bindings.validator) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return this.$services.page.getBindingValue(pageInstance, this.field.bindings.validator, this);
			}
		}
	}
});

		
		
		
// allow complex formatting (e.g. multiple fields etc)
// can also allow complex extraction, though unlikely necessary

Vue.component("page-form-input-enumeration-operation-configure", {
	template: "<n-form-section class='enumeration'>"
			+ "		<n-form-combo v-model='field.enumerationOperation'"
			+ "			label='Enumeration Operation'"
			+ "			:filter='getEnumerationServices'/>"
			+ "		<n-page-mapper v-if='field.enumerationOperation && hasMappableEnumerationParameters(field)'"
			+ "			v-model='field.enumerationOperationBinding'"
			+ "			:from='availableParameters'"
			+ "			:to='getMappableEnumerationParameters(field)'/>"
			+ "		<n-form-combo v-if='field.enumerationOperation' :filter='function() { return getEnumerationFields(field.enumerationOperation) }' v-model='field.enumerationCachingKey' label='Enumeration Caching Key'/>"    
			+ "		<n-form-switch v-model='field.enumerationOperationLabelComplex' label='Complex Enumeration Label'/>"
			+ "		<n-form-combo v-if='field.enumerationOperation && !field.enumerationOperationLabelComplex' v-model='field.enumerationOperationLabel' label='Enumeration Label'"
			+ "			:filter='function() { return getEnumerationFields(field.enumerationOperation) }'/>"
			+ "		<n-form-combo v-if='field.enumerationOperation' v-model='field.enumerationOperationValue' label='Enumeration Value'"
			+ "			:filter='function() { return getEnumerationFields(field.enumerationOperation) }' info='If nothing is selected, the entire document becomes the value'/>"
			+ "		<n-form-combo v-if='field.enumerationOperation' v-model='field.enumerationOperationQuery' label='Enumeration Query'"
			+ "			:filter='function() { return getEnumerationParameters(field.enumerationOperation) }'/>"
			+ "		<n-form-combo v-if='field.enumerationOperation && field.enumerationOperationValue' :filter='function() { return getEnumerationParameters(field.enumerationOperation) }' v-model='field.enumerationOperationResolve' label='Resolve Field'/>"
			+ "		<n-form-text v-model='field.complexLabel' label='The complex text label' v-if='field.enumerationOperation && field.enumerationOperationLabelComplex'/>"
			+ "		<typography-variable-replacer v-if='field.enumerationOperation && field.enumerationOperationLabelComplex && field.complexLabel' :content='field.complexLabel' :page='page' :container='field' :keys='getEnumerationFields(field.enumerationOperation)' />"
			+ "		<n-form-text v-if=\"field.visualisation != 'radio'\" v-model='field.emptyValue' label='Empty Value Text'/>"
			+ "		<n-form-text v-if=\"field.visualisation != 'radio'\" v-model='field.calculatingValue' label='Calculating Value Text' info='The text to show while the result is being calculated'/>"
			+ "		<n-form-text v-if=\"field.visualisation != 'radio'\" v-model='field.resetValue' label='Reset Value Text' info='The text to show to reset the current value'/>"
			+ "		<n-form-text v-if=\"field.visualisation == 'combo'\" v-model='field.selectAllValue' label='Select all value' info='The text to show to select all values or deselectt all'/>"
			+ "		<n-form-switch v-if=\"field.visualisation == 'combo'\" v-model='field.useCheckbox' label='Add checkboxes'/>"
			+ "		<n-form-switch v-if=\"field.visualisation == 'combo'\" v-model='field.showTags' label='Show tags'/>"
			+ "		<n-form-text v-if=\"field.visualisation == 'combo'\" v-model='field.maxAmountOfTags' label='Max amount of tags visible' placeholder='3' after='Set to 0 to show all tags'/>"
			+ "		<n-form-switch v-if=\"field.visualisation == 'combo'\" v-model='field.showAmount' label='Show amount'/>"
			+ " 	<n-form-switch :invert='true' v-if=\"field.visualisation != 'radio'\" v-model='field.allowTyping' label='Disable typing' after='Can the user type to search?'/>"
			+ " 	<n-form-switch v-model='field.readOnly' label='Read only' after='Read only mode means the form element is replaced with a readable version'/>"
			+ " 	<n-form-switch v-if='field.showRadioView' v-model='field.showRadioView' label='Show radio visualisation'/>"
			+ " 	<n-form-switch v-model='field.selectFirstIfEmpty' label='Select the first value if none has been selected yet'/>"
			+ "		<n-form-text v-if='field.showRadioView' v-model='field.mustChoose' label='Must choose' allow-typing='true' />"
			+ "		<n-form-combo :items=\"['combo', 'combo-with-labels', 'radio']\" label='Visualisation' v-model='field.visualisation'/>"
			+ "		<n-form-text v-model='field.info' label='Info Content'/>"
			+ "		<n-form-text v-model='field.before' label='Before Content'/>"
			+ "		<n-form-text v-model='field.beforeIcon' label='Before Icon' v-if='field.before'/>"
			+ "		<n-form-text v-model='field.after' label='After Content'/>"
			+ "		<n-form-text v-model='field.afterIcon' label='After Icon' v-if='field.after'/>"
			+ "		<n-form-text v-model='field.suffix' label='Suffix' v-if='!field.suffixIcon'/>"
			+ "		<n-form-text v-model='field.suffixIcon' label='Suffix Icon' v-if='!field.suffix'/>"
			+ "		<n-page-mapper v-model='field.bindings' :from='availableParameters' v-if='false' :to='[\"validator\"]'/>"
			+ "</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		},
		possibleFields: {
			type: Array,
			required: false,
			default: function() { return [] }
		}
	},
	created: function() {
		if (!this.field.enumerationProvider) {
			Vue.set(this.field, "enumerationProvider", null);
		}
		if (this.field.showRadioView) {
			this.field.visualisation = "radio";
			delete this.field.showRadioView;
		}
		// backwards compatibility
		else if (!this.field.hasOwnProperty("visualisation")) {
			this.field.visualisation = "combo-with-labels";	
		}
		this.normalize(this.field);
	},
	computed: {
		availableParameters: function() {
			var result = this.$services.page.getAvailableParameters(this.page, this.cell, true);
			if (this.possibleFields.length > 0) {
				result["record"] = {properties:{}};
				this.possibleFields.forEach(function(x) {
					result.record.properties[x] = {type:"string"};	
				});
			}
			return result;
		}
	},
	methods: {
		searchPossible: function(value) {
			return this.possibleFields.filter(function(x) {
				return !value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
			});
		},
		enumerationFilter: function(value) {
			var providers = nabu.page.providers("page-enumerate").map(function(x) { return x.name });
			if (value) {
				providers = providers.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			providers.sort();
			return providers;
		},
		normalize: function(field) {
			if (!field.enumerationOperation) {
				Vue.set(field, "enumerationOperation", null);
			}
			if (!field.enumerationOperationLabel) {
				Vue.set(field, "enumerationOperationLabel", null);
			}
			if (!field.enumerationOperationValue) {
				Vue.set(field, "enumerationOperationValue", null);
			}
			if (!field.enumerationOperationQuery) {
				Vue.set(field, "enumerationOperationQuery", null);
			}
			if (!field.enumerationOperationBinding) {
				Vue.set(field, "enumerationOperationBinding", {});
			}
		},
		// copy/pasted from the table getOperations
		getEnumerationServices: function(name) {
			var self = this;
			return this.$services.page.getOperations(function(operation) {
				// must be a get
				var isAllowed = operation.method.toLowerCase() == "get"
					// and contain the name fragment (if any)
					&& (!name || operation.id.toLowerCase().indexOf(name.toLowerCase()) >= 0)
					// must have _a_ response
					&& operation.responses["200"];
				// we also need at least _a_ complex array in the results
				if (isAllowed) {
					var schema = operation.responses["200"] ? operation.responses["200"].schema : null;
					if (schema) {
						var definition = self.$services.swagger.definition(schema["$ref"]);
						// now we need a child in the definition that is a record array
						// TODO: we currently don't actually check for a complex array, just any array, could be an array of strings...
						isAllowed = false;
						if (definition.properties) {
							Object.keys(definition.properties).map(function(field) {
								if (definition.properties[field].type == "array") {
									isAllowed = true;
								}
							});
						}
					}
				}
				return isAllowed;
			}).map(function(x) {
				 return x.id;
			});	
		},
		getEnumerationFields: function(operationId) {
			var fields = [];
			if (this.$services.swagger.operations[operationId]) {
				var resolved = this.$services.swagger.resolve(this.$services.swagger.operations[operationId].responses["200"]);
				Object.keys(resolved.schema.properties).map(function(property) {
					if (resolved.schema.properties[property].type == "array") {
						nabu.utils.arrays.merge(fields, Object.keys(resolved.schema.properties[property].items.properties));
					}
				});
			}
			return fields;
		},
		getEnumerationParameters: function(operationId) {
			var parameters = this.$services.swagger.operations[operationId].parameters;
			return parameters ? parameters.map(function(x) { return x.name }) : [];
		},
		getMappableEnumerationParameters: function(field) {
			var result = {
				properties: {}
			};
			if (this.$services.swagger.operations[field.enumerationOperation]) {
				Object.keys(this.$services.page.getInputBindings(this.$services.swagger.operations[field.enumerationOperation])).map(function(key) {
					if (key != field.enumerationOperationQuery) {
						result.properties[key] = {
							type: "string"
						}
					}
				});
				result.properties["$serviceContext"] = {
					type: "string"
				}
			}
			return result;
		},
		hasMappableEnumerationParameters: function(field) {
			var amount = Object.keys(this.getMappableEnumerationParameters(field).properties).length;
			return amount > 0;
		}
	}
});

Vue.component("page-form-input-enumeration-operation", {
	template: ""
			+ "<n-form-radio v-if=\"field.showRadioView || field.visualisation == 'radio'\""
			+ "		:items='resolvedItems'"
			+ "		ref='form'"
			+ "		:edit='!readOnly'"
			+ "		:placeholder='placeholder'"
			+ "		@input=\"function(newValue) { $emit('input', newValue) }\""
			+ "		:label='label ? $services.page.interpret(label, $self) : null'"
			+ "		:value='value'"
			+ "		:description='field.description ? $services.page.translate(field.description) : null'"
			+ "		:description-type='field.descriptionType'"
			+ "		:description-icon='field.descriptionIcon'"
			+ "		:schema='schema'"
			+ "		v-bubble:label"
			+ "		:required='required'"
			+ "		:must-choose='field.mustChoose ? $services.page.interpret(field.mustChoose, $self) : null'"
			+ "		:formatter='enumerationFormatter'"
			+ "		:extracter='enumerationExtracter'"
			+ "		:disabled='disabled'/>"
			+ "<n-form-combo v-else ref='form' :filter='enumerationFilter' :formatter='enumerationFormatter' :extracter='enumerationExtracter' :resolver='enumerationResolver'"
			+ "		:combo-type=\"field.visualisation == 'combo' ? 'n-input-combo2' : 'n-input-combo'\""
			+ "		:edit='!readOnly'"
			+ "		:placeholder='placeholder'"
			+ "		@input=\"function(newValue, label, rawValue, selectedLabel) { $emit('input', newValue, label, rawValue, selectedLabel) }\""
			+ "		v-bubble:label"
			+ "		:timeout='600'"
			+ "		v-bubble:blur"
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		:required='required'"
			+ "		:allow-typing='field.allowTyping'"
			+ "		:empty-value='field.emptyValue ? $services.page.translate($services.page.interpret(field.emptyValue)) : null'"
			+ "		:calculating-value='field.calculatingValue ? $services.page.translate($services.page.interpret(field.calculatingValue)) : null'"
			+ "		:reset-value='field.resetValue ? $services.page.translate($services.page.interpret(field.resetValue)) : null'"
			+ "		:info='field.info ? $services.page.translate(field.info) : null'"
			+ "		:before='field.before ? $services.page.translate(field.before) : null'"
			+ "		:after='field.after ? $services.page.translate(field.after) : null'"
			+ "		:suffix='field.suffixIcon ? $services.page.getIconHtml(field.suffixIcon) : field.suffix'"
			+ "		:validator='getValidator()'"
			+ "		:description='field.description ? $services.page.translate(field.description) : null'"
			+ "		:description-type='field.descriptionType'"
			+ "		:description-icon='field.descriptionIcon'"
			+ "		:schema='schema'"
			+ "		:disabled='disabled'"
			+ "		:select-all-value='field.selectAllValue ? $services.page.translate($services.page.interpret(field.selectAllValue)) : null'"
			+ "		:use-checkbox='field.useCheckbox'"
			+ "		:show-tags='field.showTags'"
			+ "		:show-amount='field.showAmount'"
			+ "		:max-amount-of-tags='field.maxAmountOfTags'"
			+ "		/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		parentValue: {
			type: Object,
			required: false
		}
	},
	data: function() {
		return {
			provider: null,
			resolvedItems: []
		}
	},
	created: function() {
		if (Object.keys(this.field).length == 0) {
			// if we have no configuration at all yet, set visualisation to "new" combo
			Vue.set(this.field, "visualisation", "combo");
		}
		if (this.field.showRadioView) {
			var self = this;
			this.enumerationFilterAny(null, false).then(function(x) {
				nabu.utils.arrays.merge(self.resolvedItems, x);
			});
		}
	},
	methods: {
		getChildComponents: function() {
			return [{
				title: "Form combo",
				name: "form-component",
				component: "form-combo"
			}];
		},
		// enumerationOperation: null,
		// enumerationFormatter
		// enumerationOperationLabel: null,
		// enumerationOperationValue: null,
		// enumerationOperationQuery: null,
		// enumerationOperationBinding: {}
		enumerationFilter: function(value) {
			return this.enumerationFilterAny(value, false);
		},
		// if we set the "asResolve", we are actually resolving the existing value, so for example if you have an ID already
		// and you want to resolve it to the full object so you can get the correct label to show, it will be called with the resolve id
		// the query is used to find _new_ values
		enumerationFilterAny: function(value, asResolve) {
			if (!this.field.enumerationOperation) {
				return [];
			}
			var parameters = {
				limit: 20
			};
			if (!asResolve && this.field.enumerationOperationQuery) {
				parameters[this.field.enumerationOperationQuery] = value;
			}
			else if (asResolve && this.field.enumerationOperationResolve) {
				parameters[this.field.enumerationOperationResolve] = value;
			}
			var self = this;
			// map any additional bindings
			var pageInstance = self.$services.page.getPageInstance(self.page, self);
			if (this.field.enumerationOperationBinding) {
				Object.keys(this.field.enumerationOperationBinding).map(function(key) {
					// if the binding is not set, we don't want to overwrite any parameters that are already there (e.g. the resolve field)
					if (self.field.enumerationOperationBinding[key] != null) {
						var target = parameters;
						var parts = key.split(".");
						for (var i = 0; i < parts.length - 1; i++) {
							if (!target[parts[i]]) {
								target[parts[i]] = {};
							}
							target = target[parts[i]];
						}
						if (self.field.enumerationOperationBinding[key].indexOf("record.") == 0) {
							target[parts[parts.length - 1]] = self.$services.page.getValue(self.parentValue, self.field.enumerationOperationBinding[key].substring("record.".length));
						}
						else {
							target[parts[parts.length - 1]] = self.$services.page.getBindingValue(pageInstance, self.field.enumerationOperationBinding[key], self);
						}
					}
				});
			}
			if (!parameters["$serviceContext"]) {
				parameters["$serviceContext"] = pageInstance.getServiceContext();
			}
			return this.$services.swagger.execute(this.field.enumerationOperation, parameters, function(response) {
				var result = null;
				if (response) {
					Object.keys(response).map(function(key) {
						if (response[key] instanceof Array) {
							result = response[key];
							if (self.field.selectFirstIfEmpty && self.value == null && result && result.length > 0) {
								self.$emit("input", self.enumerationExtracter(result[0]));
							}
						}
					});
				}
				return result ? result : [];
			});
		},
		enumerationResolver: function(value) {
			if (this.field.enumerationOperationResolve && this.field.enumerationOperationValue) {
				return this.enumerationFilterAny(value, true);
			}
			return value;
		},
		enumerationFormatter: function(value) {
			if (value == null) {
				return null;
			}
			else if (this.field.enumerationOperationLabelComplex) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return !this.field.complexLabel ? this.field.complexLabel : this.$services.typography.replaceVariables(pageInstance, this.field, this.field.complexLabel, this.$services.q.reject(), value);
			}
			else if (this.field.enumerationFormatter) {
				return this.field.enumerationFormatter(value);
			}
			else if (this.field.enumerationOperationLabel) {
				return value[this.field.enumerationOperationLabel];
			}
			else {
				return value;
			}
		},
		enumerationExtracter: function(value) {
			if (value == null) {
				return null;
			}
			else if (this.field.enumerationOperationValue) {
				return value[this.field.enumerationOperationValue];
			}
			else {
				return value;
			}
		},
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		},
		getValidator: function() {
			if (this.field.bindings && this.field.bindings.validator) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return this.$services.page.getBindingValue(pageInstance, this.field.bindings.validator, this);
			}
		}
	}
});


Vue.component("page-form-input-page-configure", {
	template: "<div/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		}
	}
});

Vue.component("page-form-input-page", {
	template: "<n-form-page ref='form' :timeout='timeout' :value='value' @input=\"function(value) { $emit('input', value) }\" :schema='schema'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		}
	},
	methods: {
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		}
	}
});
Vue.component("page-form-input-slider-configure", {
	template: "<n-form-section>"
		+ "	<n-form-text v-model='field.minimum' label='Minimum' :required='true' type='number'/>"
		+ "	<n-form-text v-model='field.maximum' label='Maximum' :required='true' type='number'/>"
		+ "</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		}
	},
	created: function() {
		if (!this.field.textType) {
			Vue.set(this.field, "textType", null);
		}
	}
});

Vue.component("page-form-input-slider", {
	template: "<n-form-text type='range' ref='form'"
			+ "		:edit='!readOnly'"
			+ "		:minimum='field.minimum ? parseInt(field.minimum) : 0'"
			+ "		:maximum='field.maximum ? parseInt(field.maximum) : 100'"
			+ "		:schema='schema'"
			+ "		@input=\"function(newValue) { $emit('input', newValue) }\""
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		:timeout='timeout'"
			+ "		:disabled='disabled'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		}
	},
	computed: {
		textType: function() {
			return this.field.textType ? this.field.textType : 'text';
		}
	},
	methods: {
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		}
	}
});
Vue.component("page-form-input-enumeration-provider-configure", {
	template: "<n-form-section><n-form-combo v-model='field.enumerationProvider' :filter='enumerationFilter' label='Enumeration Provider'/>"
		+ " 	<n-form-switch v-model='field.showRadioView' v-if='!field.showCheckboxView' label='Show radio visualisation'/>"
		+ " 	<n-form-switch v-model='field.showCheckboxView' v-if='!field.showRadioView && supportsMultiple' label='Show checkbox visualisation (allows multiselect)'/>"
		+ "		<n-form-text v-if='!field.showRadioView' v-model='field.emptyValue' label='Empty Value Text'/>"
		+ "		<n-form-text v-if='!field.showRadioView' v-model='field.resetValue' label='Reset Value Text' info='The text to show to reset the current value'/>"
		+ " 	<n-form-switch v-if='!field.showRadioView' v-model='field.readOnly' label='Read only' />"
		+ "	<n-form-combo v-if='valueOptions' :items='valueOptions' v-model='field.enumerationProviderValue' label='Value Field'/>"
		+ "	<n-form-combo v-if='labelOptions' :items='labelOptions' v-model='field.enumerationProviderLabel' label='Label Field'/>"
		+ "</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		}
	},
	created: function() {
		if (!this.field.enumerationProvider) {
			Vue.set(this.field, "enumerationProvider", null);
		}
	},
	computed: {
		supportsMultiple: function() {
			if (this.cell.state.name) {
				// this currently only works for page-based form fields
				// in v2, all form fields "should" be page based though?
				// only exception so far is inline form components in a data table
				var result = this.$services.page.getPageParameters(this.page);
				//var result = this.$services.page.getAvailableParameters(this.page, this.cell, true);
				var name = this.cell.state.name;
				if (name.indexOf("page.") == 0) {
					name = name.substring("page.".length);
				}
				var childDefinition = this.$services.page.getChildDefinition(result, name);
				return childDefinition ? childDefinition.type == "array" : false;
			}
			return false;
		},
		valueOptions: function() {
			if (this.field.enumerationProvider != null) {
				var self = this;
				var providers = nabu.page.providers("page-enumerate").map(function(x) { return x.name });
				var provider = nabu.page.providers("page-enumerate").filter(function(x) { return x.name == self.field.enumerationProvider })[0];
				if (provider && provider.values) {
					return provider.values;
				}
			}
			return null;
		},
		labelOptions: function() {
			if (this.field.enumerationProvider != null) {
				var self = this;
				var providers = nabu.page.providers("page-enumerate").map(function(x) { return x.name });
				var provider = nabu.page.providers("page-enumerate").filter(function(x) { return x.name == self.field.enumerationProvider })[0];
				if (provider && provider.labels) {
					return provider.labels;
				}
			}
			return null;
		},
	},
	methods: {
		enumerationFilter: function(value) {
			var providers = nabu.page.providers("page-enumerate").map(function(x) { return x.name });
			if (value) {
				providers = providers.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			providers.sort();
			return providers;
		}
	}
});

Vue.component("page-form-input-enumeration-provider", {
	template: "<div>"
			+ " <n-form-checkbox-list v-if='field.showCheckboxView' :items='enumerationFilter()' ref='form'"
			+ "		:edit='!readOnly'"
			+ "		:placeholder='placeholder'"
			+ "		v-bubble:input"
			+ "		:formatter='enumerationFormatter'"
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		v-bubble:label"
			+ "		:schema='schema'"
			+ "		:description='field.description ? $services.page.translate(field.description) : null'"
			+ "		:descriptionType='field.descriptionType'"
			+ "		:descriptionIcon='field.descriptionIcon'"
			+ "		:required='required'"
			+ "		:extracter='enumerationExtracter'"
			+ "		:disabled='disabled'/>"
			+ "	<n-form-radio v-else-if='field.showRadioView' :items='enumerationFilter()' ref='form'"
			+ "		:edit='!readOnly'"
			+ "		:placeholder='placeholder'"
			+ "		v-bubble:input"
			+ "		:formatter='enumerationFormatter'"
			+ "		:label='label'"
			+ "		:name='name'"
			+ "		:value='value'"
			+ "		v-bubble:label"
			+ "		:schema='schema'"
			+ "		:description='field.description ? $services.page.translate(field.description) : null'"
			+ "		:descriptionType='field.descriptionType'"
			+ "		:descriptionIcon='field.descriptionIcon'"
			+ "		:required='required'"
			+ "		:extracter='enumerationExtracter'"
			+ "		:disabled='disabled'/>"
			+ " <n-form-combo v-else ref='form' :filter='enumerationFilter' :formatter='enumerationFormatter' :extracter='enumerationExtracter'"
			+ "		:edit='!readOnly'"
			+ "		:placeholder='placeholder'"
			+ "		:required='required'"
			+ "		v-bubble:label"
			+ "		v-bubble:blur"
			+ "		v-bubble:input"
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		:description='field.description'"
			+ "		:description-type='field.descriptionType'"
			+ "		:description-icon='field.descriptionIcon'"
			+ "		:schema='schema'"
			+ "		:allow-typing='!field.readOnly'"
			+ "		:empty-value='field.emptyValue ? $services.page.translate($services.page.interpret(field.emptyValue)) : null'"
			+ "		:calculating-value='field.calculatingValue ? $services.page.translate($services.page.interpret(field.calculatingValue)) : null'"
			+ "		:reset-value='field.resetValue ? $services.page.translate($services.page.interpret(field.resetValue)) : null'"
			+ "		:disabled='disabled'/></div>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		name: {
			type: String,
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		}
	},
	data: function() {
		return {
			provider: null
		}
	},
	created: function() {
		this.provider = this.getProvider();
	},
	methods: {
		getChildComponents: function() {
			return [{
				title: "Form combo",
				name: "form-component",
				component: "form-combo"
			}];
		},
		getProvider: function() {
			if (this.field.enumerationProvider) {
				var self = this;
				return nabu.page.providers("page-enumerate").filter(function(x) { return x.name == self.field.enumerationProvider })[0];
			}
			return null;
		},
		enumerationFilter: function(value) {
			var provider = this.provider;
			if (provider) {
				var values = provider.enumerate();
				var self = this;
				if (value) {
					values = values.filter(function(x) {
						var formatted = self.enumerationFormatter(x);
						return formatted.toLowerCase().indexOf(value.toLowerCase()) >= 0;
					});
				}
				// the sorting can conflict with explicit sorting you want to manage from the outside
				// additionally, it can cause an infinite render loop
				/*
				values.sort(function(a, b) {
					var valueA = self.enumerationFormatter(a);
					var valueB = self.enumerationFormatter(b);
					return valueA ? valueA.localeCompare(valueB) : (valueB ? -1 : 0);
				});
				*/
				return values;
			}
			else {
				return [];
			}
		},
		enumerationFormatter: function(value) {
			var provider = this.provider;
			if (value && this.field.enumerationProviderLabel) {
				return value[this.field.enumerationProviderLabel];
			}
			else if (value && provider && provider.label) {
				return value[provider.label];
			}
			return value;
		},
		enumerationExtracter: function(value) {
			var provider = this.provider;
			if (value && this.field.enumerationProviderValue) {
				return value[this.field.enumerationProviderValue];
			}
			else if (value && provider && provider.value) {
				return value[provider.value];
			}
			return value;
		},
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		}
	}
});
Vue.component("page-form-input-validate-custom-configure", {
	template: "<div><custom-validator-edit :page='page' :cell='cellClone'/><div>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		}
	},
	computed: {
		cellClone: function() {
			var cellClone = nabu.utils.objects.clone(this.cell);
			cellClone.state = this.field;
			return cellClone;
		}
	}
})


Vue.component("page-form-input-validate-custom", {
	template: "<div><custom-validator :cell='cellClone' :page='page' /></div>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		}
	},
	computed: {
		cellClone: function() {
			var cellClone = nabu.utils.objects.clone(this.cell);
			cellClone.state = this.field;
			return cellClone;
		}
	}	
});

Vue.component("page-form-input-text-configure", {
	template: "<div><h2 class='section-title'>Text field</h2><div class='is-column is-spacing-medium'><n-form-combo v-model='field.textType' label='Text Type' :items=\"['text', 'area', 'range', 'number', 'color', 'email', 'tel', 'password', 'url', 'time', 'date', 'datetime-local', 'month', 'week']\"/>"
		+ "	<n-form-switch v-model='field.trim' label='Trim value' />"
		+ "	<n-form-text v-model='field.regexLabel' label='Regex Label' :timeout='600'/>"
		+ "	<n-form-text v-model='field.regex' label='Regex' :timeout='600'/>"
		+ "	<n-form-text v-model='field.minLength' label='Min Length' :timeout='600'/>"
		+ "	<n-form-text v-model='field.maxLength' label='Max Length' :timeout='600'/>"
		+ "	<n-form-switch v-model='field.showLength' label='Show Length' v-if='field.maxLength'/>"
		+ "	<n-form-switch v-model='field.showCustomSpinner' label='Use custom spinners' v-if=\"field.textType == 'number'\"/>"
		+ "	<n-form-text v-model='field.info' label='Info Content' :timeout='600'/>"
		+ "	<n-form-text v-model='field.before' label='Before Content' :timeout='600'/>"
		+ "	<n-form-text v-model='field.beforeIcon' label='Before Icon' v-if='field.before && false' :timeout='600'/>"
		+ "	<n-form-text v-model='field.after' label='After Content' :timeout='600'/>"
		+ "	<n-form-text v-model='field.afterIcon' label='After Icon' v-if='field.after && false' :timeout='600'/>"
		+ "	<n-form-text v-model='field.prefix' label='Prefix' :timeout='600'/>"
		+ "	<n-form-text v-model='field.prefixIcon' label='Prefix Icon' :timeout='600'/>"
		+ "	<n-form-text v-model='field.suffix' label='Suffix' :timeout='600'/>"
		+ "	<n-form-text v-model='field.suffixIcon' label='Suffix Icon' :timeout='600'/>"
		+ "	<n-form-text v-model='field.minimum' label='Minimum' v-if=\"field.textType == 'range' || field.textType == 'number'\" :timeout='600'/>"
		+ "	<n-form-text v-model='field.maximum' label='Maximum' v-if=\"field.textType == 'range' || field.textType == 'number'\" :timeout='600'/>"
		+ "	<n-form-text v-model='field.step' label='Step' v-if=\"field.textType == 'range' || field.textType == 'number'\" :timeout='600'/>"
		+ "	<n-form-ace v-model='field.formatter' label='Formatter' :timeout='600' after='You can format the value that exists in the page for display (and edit) purposes for the user'/>"
		+ "	<n-form-ace v-model='field.parser' label='Parser' :timeout='600' after='You can parse the user-inputted value into something else to be stored in the page'/>"
		+ "	<n-page-mapper v-model='field.bindings' :from='availableParameters' :to='[\"validator\"]'/>"
		+ "</div></div>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		}
	},
	created: function() {
		if (!this.field.textType) {
			Vue.set(this.field, "textType", null);
		}
		if (!this.field.bindings) {
			Vue.set(this.field, "bindings", {});
		}
	},
	computed: {
		availableParameters: function() {
			return this.$services.page.getAvailableParameters(this.page, this.cell, true);
		}
	}
});

Vue.component("page-form-input-text", {
	template: "<n-form-text :type='textType' ref='form'"
			+ "		:trim='field.trim'"
			+ "		:class=\"{'has-suffix-icon': !!field.suffixIcon, 'has-suffix': !!field.suffix }\""
			+ "		:edit='!readOnly'"
			+ "		:placeholder='$services.page.interpret($services.page.translate(placeholder), $self)'"
			+ "		:max-length='field.maxLength ? field.maxLength : null'"
			+ "		:min-length='field.minLength ? field.minLength : null'"
			+ "		:schema='schema'"
			+ "		:pattern-comment='field.regexLabel ? $services.page.translate(field.regexLabel) : null'"
			+ "		@input=\"function(newValue) { $emit('input', newValue) }\""
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		:pattern='field.regex'"
			+ "		v-bubble:blur"
			+ "		:required='required'"
			+ "		:validator='getValidator()'"
			+ "		:info='field.info ? $services.page.interpret($services.page.translate(field.info), $self) : null'"
			+ "		:before='field.before ? $services.page.interpret($services.page.translate(field.before), $self) : null'"
			+ "		:after='field.after ? $services.page.interpret($services.page.translate(field.after), $self) : null'"
			+ "		:prefix='field.prefix ? $services.page.translate(field.prefix) : field.prefix'"
			+ "		:suffix='field.suffix ? $services.page.translate(field.suffix) : field.suffix'"
			+ "		:prefix-icon='field.prefixIcon'"
			+ "		:suffix-icon='field.suffixIcon'"
			+ "		:minimum='field.minimum ? parseFloat($services.page.interpret(field.minimum, $self)) : null'"
			+ "		:maximum='field.maximum ? parseFloat($services.page.interpret(field.maximum, $self)) : null'"
			+ "		:step='field.step ? parseFloat($services.page.interpret(field.step, $self)) : null'"
			+ "		:name='field.name'"
			+ "		:timeout='timeout'"
			+ "		v-show='!hidden'"
			+ "		:show-custom-spinner='field.showCustomSpinner'"
			+ "		:formatter='getFormatter()'"
			+ "		:parser='getParser()'"
			+ "		:disabled='disabled'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		codes: {
			required: false
		},
		hidden: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	computed: {
		allCodes: function() {
			var codes = [];
			if (this.field.codes) {
				nabu.utils.arrays.merge(codes, this.field.codes);
			}
			if (this.codes) {
				nabu.utils.arrays.merge(codes, this.codes);
			}
			var result = {};
			var self = this;
			codes.forEach(function(code) {
				result[code.code] = self.$services.page.translate(code.title);
			});
			return result;
		},
		textType: function() {
			return this.field.textType ? this.field.textType : 'text';
		}
	},
	methods: {
		getFormatter: function() {
			if (!this.field.formatter) {
				return null;
			}	
			var self = this;
			return function(value) {
				return self.$services.page.eval(self.field.formatter, value, self);
			};
		},
		getParser: function() {
			if (!this.field.parser) {
				return null;
			}	
			var self = this;
			return function(value) {
				return self.$services.page.eval(self.field.parser, value, self);
			};
		},
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		},
		getValidator: function() {
			if (this.field.bindings && this.field.bindings.validator) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return this.$services.page.getBindingValue(pageInstance, this.field.bindings.validator, this);
			}
		}
	}
});


Vue.component("page-form-input-hidden", {
	template: "<page-form-input-text :cell='cell' :page='page' :field='field' :value='value' :label='label' :timeout='timeout' "
		+ ":disabled='disabled' :schema='schema' :read-only='readOnly' :placeholder='placeholder' :codes='codes' :hidden='true'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		codes: {
			required: false
		}
	}
});

Vue.component("page-form-input-ace-configure", {
	template: "<n-form-section><n-form-combo v-model='field.textType' label='Text Type' :items=\"['text', 'area', 'range', 'number', 'color', 'email', 'password']\"/>"
		+ "	<n-form-text v-model='field.info' label='Info Content' :timeout='600'/>"
		+ "	<n-form-text v-model='field.before' label='Before Content' :timeout='600'/>"
		+ "	<n-form-text v-model='field.beforeIcon' label='Before Icon' v-if='field.before && false' :timeout='600'/>"
		+ "	<n-form-text v-model='field.after' label='After Content' :timeout='600'/>"
		+ "	<n-form-text v-model='field.afterIcon' label='After Icon' v-if='field.after && false' :timeout='600'/>"
		+ "	<n-form-text v-model='field.prefix' label='Prefix' :timeout='600'/>"
		+ "	<n-form-text v-model='field.prefixIcon' label='Prefix Icon' :timeout='600'/>"
		+ "	<n-form-text v-model='field.suffix' label='Suffix' :timeout='600'/>"
		+ "	<n-form-text v-model='field.suffixIcon' label='Suffix Icon' :timeout='600'/>"
		+ "	<n-form-text v-model='field.mode' label='Mode' :timeout='600'/>"
		+ "</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		}
	},
	created: function() {
		if (!this.field.textType) {
			Vue.set(this.field, "textType", null);
		}
		if (!this.field.bindings) {
			Vue.set(this.field, "bindings", {});
		}
	},
	computed: {
		availableParameters: function() {
			return this.$services.page.getAvailableParameters(this.page, this.cell, true);
		}
	}
});

Vue.component("page-form-input-ace", {
	template: "<n-form-ace :mode='field.mode' ref='form'"
			+ "		:class=\"{'has-suffix-icon': !!field.suffixIcon, 'has-suffix': !!field.suffix }\""
			+ "		:edit='!readOnly'"
			+ "		:placeholder='$services.page.interpret($services.page.translate(placeholder), $self)'"
			+ "		:schema='schema'"
			+ "		@input=\"function(newValue) { $emit('input', newValue) }\""
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		v-bubble:blur"
			+ "		:required='required'"
			+ "		:info='field.info ? $services.page.interpret($services.page.translate(field.info), $self) : null'"
			+ "		:before='field.before ? $services.page.interpret($services.page.translate(field.before), $self) : null'"
			+ "		:after='field.after ? $services.page.interpret($services.page.translate(field.after), $self) : null'"
			+ "		:prefix='field.prefix ? $services.page.translate(field.prefix) : field.prefix'"
			+ "		:suffix='field.suffix ? $services.page.translate(field.suffix) : field.suffix'"
			+ "		:prefix-icon='field.prefixIcon'"
			+ "		:suffix-icon='field.suffixIcon'"
			+ "		:name='field.name'"
			+ "		:timeout='timeout'"
			+ "		v-show='!hidden'"
			+ "		:disabled='disabled'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		codes: {
			required: false
		},
		hidden: {
			type: Boolean,
			required: false,
			default: false
		}
	},
	computed: {
		allCodes: function() {
			var codes = [];
			if (this.field.codes) {
				nabu.utils.arrays.merge(codes, this.field.codes);
			}
			if (this.codes) {
				nabu.utils.arrays.merge(codes, this.codes);
			}
			var result = {};
			var self = this;
			codes.forEach(function(code) {
				result[code.code] = self.$services.page.translate(code.title);
			});
			return result;
		},
		textType: function() {
			return this.field.textType ? this.field.textType : 'text';
		}
	},
	methods: {
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		}
	}
});


// by default no regex because we can/want to set it in the backend
Vue.component("page-form-input-password-configure", {
	template: "<n-form-section>"
		+ "	<n-form-text v-model='field.info' label='Info Content'/>"
		+ "	<n-form-text v-model='field.before' label='Before Content'/>"
		+ "	<n-form-text v-model='field.after' label='After Content'/>"
		+ "	<n-form-text v-model='field.repeatLabel' label='Label for password repeat'/>"
		+ "	<n-form-text v-model='field.repeatPlaceholder' label='Placeholder for password repeat'/>"
		+ "	<n-form-text v-model='field.regex' label='Security Regex'/>"
		+ "	<n-form-text v-model='field.regexLabel' label='Regex Label' placholder='%{validation::The password should be at least 8 characters long and contain one capital, one lowercase letter and a number}'/>"
		+ "	<n-form-text v-model='field.forgotLabel' label='Forgot Password Label'/>"
		+ "	<n-form-combo v-model='field.forgotRoute' :filter='$services.page.filterRoutes' label='Forgot Password Route'/>"
		+ "</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		}
	}
});

Vue.component("page-form-input-password", {
	template: "<n-form-section ref='form'><n-form-text type='password'"
			+ "		:edit='!readOnly'"
			+ "		:placeholder='placeholder'"
			+ "		:schema='schema'"
			+ "		:pattern-comment='$services.page.translate(regexLabel)'" 
			+ "		:pattern='field.regex'"
			+ "		@input=\"function(newValue) { $emit('input', newValue) }\""
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		:info='field.info ? $services.page.translate(field.info) : null'"
			+ "		:before='field.before ? $services.page.translate(field.before) : null'"
			+ "		:after='field.after ? $services.page.translate(field.after) : null'"
			+ "		:suffix='field.suffixIcon ? $services.page.getIconHtml(field.suffixIcon) : field.suffix'"
			+ "		:timeout='timeout'"
			+ "		name='new-password'"
			+ "		autocomplete='new-password'"
			+ "		:disabled='disabled'/>"
			+ "	<n-form-text type='password' v-if='field.repeatLabel && !readOnly'"
			+ "		:placeholder='field.repeatPlaceholder ? $services.page.translate(field.repeatPlaceholder) : placeholder'"
			+ "		:required='true'"
			+ "		:label='$services.page.translate(field.repeatLabel)'"
			+ "		v-model='repeat'"
			+ "		:info='field.info ? $services.page.translate(field.info) : null'"
			+ "		:before='field.before ? $services.page.translate(field.before) : null'"
			+ "		:after='field.after ? $services.page.translate(field.after) : null'"
			+ "		:suffix='field.suffixIcon ? $services.page.getIconHtml(field.suffixIcon) : field.suffix'"
			+ "		:timeout='timeout'"
			+ "		:validator='validatePassword'"
			+ "		name='confirm-password'"
			+ "		autocomplete='new-password'"
			+ "		:disabled='disabled'/>"
			+ "	<a class='forgot-password-link' v-route='{alias:field.forgotRoute}' v-if='field.forgotRoute && !readOnly'>{{ field.forgotLabel ? $services.page.translate(field.forgotLabel) : '%{default::Forgot your password?}' }}</a>"
			+ "</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		}
	},
	computed: {
		regexLabel: function() {
			return this.field.regexLabel != null && this.field.regexLabel != "" 
				? this.$services.page.interpret(this.field.regexLabel, this)
				: null;
		}
	},
	created: function() {
		console.log("regex is", this.field.regex);	
	},
	data: function() {
		return {
			repeat: null
		}
	},
	methods: {
		validate: function(soft) {
			var messages = this.$refs.form.validate(soft);
			return messages;
		},
		validatePassword: function(password2) {
			var messages = [];
			if (this.value != password2) {
				messages.push({
					soft: true,
					code: "same",
					severity: "error",
					title: "%{validation::The two passwords don't match}"
				});
			}
			return messages;
		},
	}
});
Vue.component("page-form-input-file-configure", {
	template: "<div class='input-file-configure'>"
		+ "		<h2 class='section-title'>File upload</h2>"
		+ "		<div class='is-column is-spacing-medium'>"
		// ignore body as this presumes a pure binary upload, we use headers then
		+ "<n-form-text label='Label drop' v-model='field.dropLabel' :timeout='600'/>"
		+ "<n-form-text label='Label browse' v-model='field.browseLabel' :timeout='600'/>"
		+ "<n-form-text label='Icon browse' v-model='field.browseIcon' :timeout='600'/>"
		+ "<n-form-text label='Max file size (bytes)' v-model='field.maxFileSize' :timeout='600'/>"
		+ "<n-form-switch label='Show selected files' v-model='field.visualizeFileNames'/>"
		+ "<n-form-text v-if='field.visualizeFileNames' label='Delete icon' v-model='field.deleteIcon' :timeout='600'/>"
		+ "	<n-form-section v-for='i in Object.keys(field.fileTypes)' class='list-row'>"
		+ "		<n-form-text v-model='field.fileTypes[i]' label='File Type' placeholder='image/*' :timeout='600'/>"
		+ "		<span @click='field.fileTypes.splice(i)' class='fa fa-times'></span>"
		+ "</n-form-section>"
		+ "		<div class='is-row is-align-end'>"
		+ "			<button class='is-button is-variant-primary-outline is-size-xsmall' @click=\"field.fileTypes ? field.fileTypes.push(null) : $window.Vue.set(field, 'fileTypes', [null])\"><span class='fa fa-plus'></span>Filetype</button>"
		+ "		</div>"
		+ "<n-form-combo v-if=\"field.name && field.name != 'body'\" v-model='field.contentType' label='Field to store content type' :items='possibleFields'/>"
		+ "<n-form-combo v-if=\"field.name && field.name != 'body'\" v-model='field.fileName' label='Field to store file name' :items='possibleFields'/>"
		+ "</div></div>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		},
		possibleFields: {
			type: Array,
			required: false,
			default: function() { return [] }
		}
	},
	created: function() {
		if (!this.field.fileTypes) {
			Vue.set(this.field, "fileTypes", []);
		}
	}
});

Vue.component("page-form-input-file", {
	template: "<n-form-file :types='field.fileTypes' ref='form' :amount='1'"
			+ "		:edit='!readOnly'"
			+ "		:schema='schema'"
			+ "		@change='changed'"
			+ "		:label='label'"
			+ "		:value='files'"
			+ "		:name='field.name'"
			+ " 	:drop-label='field.dropLabel ? $services.page.translate(field.dropLabel) : null'"
			+ " 	:browse-label='field.browseLabel ? $services.page.translate(field.browseLabel) : null'"
			+ " 	:browse-icon='field.browseIcon'"
			+ " 	:visualize-file-names='field.visualizeFileNames'"
			+ " 	:delete-icon='field.deleteIcon'"
			+ "		:button-class=\"getChildComponentClasses('file-upload-button')\""
			+ "		:info='field.info ? $services.page.interpret($services.page.translate(field.info), $self) : null'"
			+ "		:before='field.before ? $services.page.interpret($services.page.translate(field.before), $self) : null'"
			+ "		:after='field.after ? $services.page.interpret($services.page.translate(field.after), $self) : null'"
			+ "		:prefix='field.prefix ? $services.page.translate(field.prefix) : field.prefix'"
			+ "		:file-name-class=\"getChildComponentClasses('file-upload-name')\""
			+ "		:file-name-container-class=\"getChildComponentClasses('file-upload-name-container')\""
			+ "		:file-name-row-class=\"getChildComponentClasses('file-upload-name-row')\""
			+ "		:file-name-delete-class=\"getChildComponentClasses('file-upload-name-delete')\""
			+ "		:timeout='timeout'"
			+ "		:max-file-size='field.maxFileSize ? parseInt(field.maxFileSize) : null'"
			+ "		:disabled='disabled'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		childComponents: {
			required: false
		}
	},
	data: function() {
		return {
			files: []
		}
	},
	// restore the previous state (if any)
	created: function() {
		if (this.value instanceof File) {
			this.files.push(this.value);
		}
		console.log("child components", this.childComponents);
	},
	computed: {
		textType: function() {
			return this.field.textType ? this.field.textType : 'text';
		}
	},
	methods: {
		getChildComponents: function() {
			return [{
				title: "Upload button",
				name: "file-upload-button",
				component: "button"
			}, {
				title: "File Name List",
				name: "file-upload-name-container",
				component: "column"
			}, {
				title: "File Name Container",
				name: "file-upload-name-row",
				component: "row"
			}, {
				title: "File Name",
				name: "file-upload-name",
				component: "content"
			}, {
				title: "File Name Delete Button",
				name: "file-upload-delete-button",
				component: "button"
			}];
		},
		changed: function(newValue) {
			var file = newValue && newValue.length ? newValue[0] : null;
			if (this.field.contentType) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				pageInstance.set(this.field.contentType, file ? file.type : null);
			}
			if (this.field.fileName) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				pageInstance.set(this.field.fileName, file ? file.name : null);
			}
			// only emit this _after_ we set the previous
			// otherwise forms with "submit on change" might trigger before the above values are set
			this.$emit("input", file);
		},
		validate: function(soft) {
			var messages = [];
			var mandatory = nabu.utils.vue.form.mandatory(this);
			if (mandatory && files.length < 1) {
				messages.push({
					soft: true,
					severity: "error",
					code: "required",
					title: "%{validation:The value is required}",
					priority: 0,
					values: {
						actual: false,
						expected: true
					},
					context: []
				});
			}
			return messages;
		}
	}
});
Vue.component("page-form-input-static-image-configure", {
	template: "<n-form-section><n-form-text v-model='field.imagePath' label='Image Path'/><n-form-text v-model='field.webApplicationId' label='Web Application Id'/></n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		}
	},
	created: function() {
		if (!this.field.imagePath) {
			Vue.set(this.field, "imagePath", "images")
		}
	}
});

Vue.component("page-form-input-static-image", {
	template: "<div class='page-form-input-static-image n-form-component'><label class='n-form-label' v-if='label'>{{label}}</label><div class='image-content'><img v-if='value' :src=\"(field.webApplicationId ? '' : '/') + value\"/>"
		+ "<n-input-file v-if='!readOnly' v-model='files' @change='upload' :types=\"['image']\"/></div></div>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		}
	},
	data: function() {
		return {
			files: []
		}
	},
	methods: {
		upload: function() {
			var self = this;
			this.$services.swagger.execute("nabu.web.page.core.rest.resource.create", {
				webApplicationId: this.$services.page.interpret(this.field.webApplicationId, this),
				path: this.$services.page.interpret(this.field.imagePath, this), 
				body: this.files[0] 
			}).then(function(result) {
				self.files.splice(0, self.files.length);
				self.$emit("input", this.field.webApplicationId ? result.path : result.relativePath);
			});
		},
	}
});

Vue.component("page-form-input-richtext-configure", {
	template: "<n-form-section><n-form-switch v-model='field.cleanStyle' label='Clean style on paste'/><n-form-switch v-model='field.supportLinkType' label='Support Link Types'/></n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		}
	}
});

Vue.component("page-form-input-richtext", {
	template: "<n-form-richtext :disabled='disabled' :support-link-type='field.supportLinkType' :label='label' :timeout='timeout' :edit='!readOnly' ref='form' :value='value' @input=\"function(value) { $emit('input', value) }\" :schema='schema' :clean-style='field.cleanStyle' :placeholder='cell.state.placeholder'"
			+ "		:before='field.before ? $services.page.interpret($services.page.translate(field.before), $self) : null'"
			+ "		:after='field.after ? $services.page.interpret($services.page.translate(field.after), $self) : null'"
			+ "		:translator='$services.page.translate'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		}
	},
	methods: {
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		}
	}
});
Vue.component("page-form-input-switch-configure", {
	template: "<div>"
		+ "	<n-form-switch v-model='field.invert' label='Invert Boolean'/>"
		+ "	<n-form-text v-model='field.before' label='Before Content' :timeout='600'/>"
		+ "	<n-form-text v-model='field.beforeIcon' label='Before Icon' v-if='field.before && false' :timeout='600'/>"
		+ "	<n-form-text v-model='field.after' label='After Content' :timeout='600'/>"
		+ "	<n-form-text v-model='field.afterIcon' label='After Icon' v-if='field.after && false' :timeout='600'/>"
		+ "</div>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		}
	}
});

Vue.component("page-form-input-switch", {
	template: "<n-form-switch ref='form'"
			+ "		:edit='!readOnly'"
			+ "		:required='required'"
			+ "		:schema='schema'"
			+ "		:class=\"getChildComponentClasses('page-form-switch')\""
			+ "		@input=\"function(newValue) { $emit('input', newValue) }\""
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		:before='field.before ? $services.page.interpret($services.page.translate(field.before), $self) : null'"
			+ "		:after='field.after ? $services.page.interpret($services.page.translate(field.after), $self) : null'"
			+ "		:timeout='timeout'"
			+ "		:invert='!!field.invert'"
			+ "		:disabled='disabled'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		childComponents: {
			required: false
		}
	},
	methods: {
		getChildComponents: function() {
			return {
				title: "Form Switch",
				name: "page-form-switch",
				component: "form-switch"
			};
		},
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		}
	}
});
Vue.component("page-form-input-date-configure", {
	template: "<div><h2 class='section-title'>Date field</h2><div class='is-column is-spacing-medium'>"
		+ "	<n-form-switch v-model='field.yearsDropdown' label='Show years in dropdown'/>"
		+ "	<n-form-switch v-model='field.includeHours' label='Include hours?'/>"
		+ "	<n-form-switch v-model='field.includeMinutes' label='Include minutes?' v-if='field.includeHours'/>"
		+ "	<n-form-switch v-model='field.includeSeconds' label='Include seconds?' v-if='field.includeHours && field.includeMinutes'/>"
		+ "	<n-form-switch v-model='field.localTime' label='Use local time' v-if='field.includeHours'/>"
		+ "	<n-form-switch v-model='field.isTimestamp' label='Is a timestamp in milliseconds?' v-if='!field.isSecondsTimestamp'/>"
		+ "	<n-form-switch v-model='field.isSecondsTimestamp' label='Is a timestamp in seconds?' v-if='!field.isTimestamp'/>"
		+ "	<n-form-text v-model='field.regexLabel' label='Regex label'/>"
		+ "	<n-form-text v-model='field.dateFormat' label='Date Format'/>"
		+ "	<n-form-text v-model='field.info' label='Info Content' :timeout='600'/>"
		+ "	<n-form-text v-model='field.before' label='Before Content' :timeout='600'/>"
		+ "	<n-form-text v-model='field.after' label='After Content' :timeout='600'/>"
		+ "	<n-form-text v-model='field.suffix' label='Suffix' v-if='!field.suffixIcon' :timeout='600'/>"
		+ "	<n-form-text v-model='field.suffixIcon' label='Suffix Icon' v-if='!field.suffix' :timeout='600'/>"
		+ "	<n-form-ace v-model='field.allowFunction' label='Allow function' :timeout='600'/>"
		+ "	<n-form-text v-model='field.yearsFrom' label='List years from (e.g. -18)' :timeout='600'/>"
		+ "	<n-form-text v-model='field.yearsTo' label='List years until (e.g. 18)' :timeout='600'/>"
		+ "	<n-page-mapper v-model='field.bindings' :from='availableParameters' :to='field.dateFormat ? [\"allow\", \"default\"] : [\"allow\", \"default\",\"formatter\",\"parser\"]'/>"
		+ "</div></div>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		}
	},
	created: function () {
		if (!this.field.bindings) {
			Vue.set(this.field, "bindings", {});
		}
	},
	computed: {
		availableParameters: function() {
			return this.$services.page.getAvailableParameters(this.page, this.cell, true);
		}
	}
});

Vue.component("page-form-input-date", {
	template: "<n-form-date ref='form'"
			+ "		:placeholder='placeholder'"
			+ "		:edit='!readOnly'"
			+ "		:schema='schema'"
			+ "		v-bubble:label"
			+ "		v-bubble:input"
			+ "		:local-time='field.localTime'"
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		:default='getDefault()'"
			+ "		:timeout='timeout'"
			+ "		v-bubble:blur"
			+ "		:allow='getAllow()'"
			+ "		:info='field.info ? $services.page.interpret($services.page.translate(field.info), $self) : null'"
			+ "		:before='field.before ? $services.page.translate(field.before) : null'"
			+ "		:after='field.after ? $services.page.translate(field.after) : null'"
			+ "		:suffix='field.suffixIcon ? $services.page.getIconHtml(field.suffixIcon) : field.suffix'"
			+ "		:years-dropdown='field.yearsDropdown'"
			+ "		:include-hours='field.includeHours'"
			+ "		:pattern-comment='$services.page.translate(field.regexLabel)'"
			+ "		:include-minutes='field.includeHours && field.includeMinutes'"
			+ "		:include-seconds='field.includeHours && field.includeMinutes && field.includeSeconds'"
			+ "		:years-from='parseInteger(field.yearsFrom)'"
			+ "		:years-to='parseInteger(field.yearsTo)'"
			+ "		:timestamp='field.isTimestamp'"
			+ "		:seconds-timestamp='field.isSecondsTimestamp'"
			+ "		:required='required'"
			+ "		:formatter='getFormatter()'"
			+ "		:parser='getParser()'"
			+ "		:translator='$services.page.translate'"
			+ "		:disabled='disabled'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		}
	},
	methods: {
		parseInteger: function(value) {
			var result = null;
			if (value != null) {
				result = this.$services.page.interpret(value);
			}	
			if (result != null) {
				return parseInt(result);
			}
		},
		getDefault: function() {
			if (this.field.bindings && this.field.bindings.default) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return this.$services.page.getBindingValue(pageInstance, this.field.bindings.default, this);
			}
		},
		getAllow: function () {
			if (this.field.allowFunction) {
				return this.$services.page.eval(this.field.allowFunction, {}, this, null, true);
			}
			if (this.field.bindings && this.field.bindings.allow) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return this.$services.page.getBindingValue(pageInstance, this.field.bindings.allow, this);
			}
		},
		getParser: function () {
			if (this.field.dateFormat) {
				var self = this;
				return function(date) {
					var parsed = null;
					if (date instanceof Date) {
						return date;
					}
					if (date) {
						// we split both the date value and the format on word boundaries
						var format = self.field.dateFormat.split(/\b/g);
						var parts = date.split(/\b/g);
						// if it is not correct, we just return null, we only return a date once we know what you typed
						if (format.length != parts.length) {
							return null;
						}
						var day = 1, month = 0, year = new Date().getFullYear(), hour = 0, minute = 0, second = 0, millisecond = 0;
						for (var i = 0; i < parts.length; i++) {
							// we are parsing the day
							if (format[i].match(/^[d]+$/)) {
								day = parseInt(parts[i]);
							}
							else if (format[i].match(/^[M]+$/)) {
								// is 0-based in javascript
								month = parseInt(parts[i]) - 1;
							}
							else if (format[i].match(/^[y]+$/)) {
								year = parseInt(parts[i]);
								if (format[i].length == 2) {
									year += new Date().getFullYear() - (new Date().getFullYear() % 100);
								}
							}
							else if (format[i].match(/^[H]+$/)) {
								hour = parseInt(parts[i]);
							}
							else if (format[i].match(/^[m]+$/)) {
								minute = parseInt(parts[i]);
							}
							else if (format[i].match(/^[s]+$/)) {
								second = parseInt(parts[i]);
							}
							else if (format[i].match(/^[S]+$/)) {
								millisecond = parseInt(parts[i]);
							}
						}
						return new Date(year, month, day, hour, minute, second, millisecond);
					}
					return parsed;
				}
			}
			else if (this.field.bindings && this.field.bindings.parser) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return this.$services.page.getBindingValue(pageInstance, this.field.bindings.parser, this);
			}
		},
		getFormatter: function () {
			if (this.field.dateFormat) {
				var self = this;
				return function(date) {
					return date ? self.$services.formatter.date(date, self.field.dateFormat) : null;
				}
			}
			else if (this.field.bindings && this.field.bindings.formatter) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return this.$services.page.getBindingValue(pageInstance, this.field.bindings.formatter, this);
			}
		},
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		}
	}
});
Vue.component("page-form-input-date-picker-configure", {
	template: "<n-form-section>"
		+ "	<n-form-text v-model='field.minimumOffset' label='Minimum Offset' info='In days, the closest point in time that should be supported (can be negative)'/>"
		+ "	<n-form-text v-model='field.maximumOffset' label='Maximum Offset' info='In days, the furthest point in time that should be supported (can be negative)'/>"
		+ "	<n-form-text v-model='field.description' label='Description'/>"
		+ "	<n-form-switch v-model='field.allowPartial' label='Allow partial values' info='Allow partial values to be set (e.g. only year). If enabled, auto format is enabled as well.'/>"
		+ "	<n-form-switch v-model='field.autoFormat' v-if='!field.allowPartial' label='Auto format' info='The format is deduced from the requested fields, being gYear, gYearMonth or date'/>"
		+ "	<n-form-switch v-model='field.hideMonth' label='Show month' :invert='true' info='Show the month'/>"
		+ "	<n-form-switch v-model='field.hideDay' label='Show day' v-if='!field.hideMonth' :invert='true' info='Show the day'/>"
		+ "	<n-form-text v-model='field.placeholderYear' label='Place holder year'/>"
		+ "	<n-form-text v-model='field.placeholderMonth' v-if='!field.hideMonth' label='Place holder month'/>"
		+ "	<n-form-text v-model='field.placeholderDay' v-if='!field.hideDay && !field.hideMonth' label='Place holder day'/>"
		+ "	<n-page-mapper v-model='field.bindings' :from='availableParameters' :to='[\"allow\", \"default\", \"notBefore\", \"notAfter\"]'/>"
		+ "</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		}
	},
	created: function () {
		if (!this.field.bindings) {
			Vue.set(this.field, "bindings", {});
		}
	},
	computed: {
		availableParameters: function() {
			return this.$services.page.getAvailableParameters(this.page, this.cell, true);
		}
	}
});

Vue.component("page-form-input-date-picker", {
	template: "<n-form-date-picker ref='form'"
			+ "		:description='field.description ? $services.page.translate(field.description) : null'"
			+ "		:placeholder='placeholder'"
			+ "		:edit='!readOnly'"
			+ "		:schema='schema'"
			+ "		:fields='fields'"
			+ "		:allow-partial='field.allowPartial'"
			+ "		:auto-format='field.autoFormat || field.allowPartial'"
			+ "		:placeholder-year='field.placeholderYear ? $services.page.translate(field.placeholderYear) : null'"
			+ "		:placeholder-month='field.placeholderMonth ? $services.page.translate(field.placeholderMonth) : null'"
			+ "		:placeholder-day='field.placeholderDay ? $services.page.translate(field.placeholderDay) : null'"
			+ "		:not-before='getNotBefore()'"
			+ "		:not-after='getNotAfter()'"
			+ "		v-bubble:label"
			+ "		:minimum-offset='field.minimumOffset'"
			+ "		:maximum-offset='field.maximumOffset'"
			+ "		@input=\"function(newValue) { $emit('input', newValue) }\""
			+ "		:label='field.label ? $services.page.translate(field.label) : null'"
			+ "		:value='value'"
			+ "		:default='getDefault()'"
			+ "		:required='required'"
			+ "		:timeout='timeout'"
			+ "		:description='field.description ? $services.page.translate(field.description) : null'"
			+ "		:description-type='field.descriptionType'"
			+ "		:description-icon='field.descriptionIcon'"
			+ "		:allow='getAllow()'"
			+ "		v-bubble:blur"
			+ "		:include-hours='field.includeHours'"
			+ "		:pattern-comment='$services.page.translate(field.regexLabel)'"
			+ "		:include-minutes='field.includeHours && field.includeMinutes'"
			+ "		:include-seconds='field.includeHours && field.includeMinutes && field.includeSeconds'"
			+ "		:timestamp='field.isTimestamp'"
			+ "		:seconds-timestamp='field.isSecondsTimestamp'"
			+ "		:disabled='disabled'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		required: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		}
	},
	computed: {
		fields: function() {
			var fields = ["year"];
			if (!this.field.hideMonth) {
				fields.push("month");
			}
			if (!this.field.hideDay) {
				fields.push("day");
			}
			return fields;
		}	
	},
	methods: {
		getDefault: function() {
			if (this.field.bindings && this.field.bindings.default) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return this.$services.page.getBindingValue(pageInstance, this.field.bindings.default, this);
			}
		},
		getAllow: function () {
			if (this.field.bindings && this.field.bindings.allow) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return this.$services.page.getBindingValue(pageInstance, this.field.bindings.allow, this);
			}
		},
		getNotBefore: function () {
			if (this.field.bindings && this.field.bindings.notBefore) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return this.$services.page.getBindingValue(pageInstance, this.field.bindings.notBefore, this);
			}
		},
		getNotAfter: function () {
			if (this.field.bindings && this.field.bindings.getNotAfter) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				return this.$services.page.getBindingValue(pageInstance, this.field.bindings.getNotAfter, this);
			}
		},
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		}
	}
});
Vue.component("page-form-input-location-configure", {
	template: "<n-form-section>"
		+ "	<n-form-text v-model='field.countryRestriction' label='Country limitation (two letter code, comma separated)'/>"
		+ "	<n-form-combo v-model='field.latitude' label='Latitude Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.longitude' label='Longitude Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.country' label='Country Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.countryCode' label='Country Code Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.region' label='Region Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.province' label='Province Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.city' label='City Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.postCode' label='Post Code Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.street' label='Street Field' :filter='getKeys'/>"
		+ "	<n-form-switch v-model='field.streetIncludeNumber' label='Include Street Number' v-if='field.street && !field.streetNumber'/>"
		+ "	<n-form-combo v-model='field.streetNumber' label='Street Number Field' :filter='getKeys' v-if='!field.streetIncludeNumber'/>"
		+ "	<n-form-combo v-model='field.formatted' label='Fully Formatted Address Field' :filter='getKeys'/>"
		+ " <n-form-switch v-model='field.allowVague' label='Allow Vague Addresses'/>"
		+ " <n-form-switch v-model='field.required' label='Required'/>"
		+ "</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		},
		possibleFields: {
			type: Array,
			required: false,
			default: function() { return [] }
		}
	},
	created: function() {
		if (!this.field.textType) {
			Vue.set(this.field, "textType", null);
		}
	},
	methods: {
		getKeys: function(value) {
			return this.possibleFields.filter(function(x) {
				return !value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
			})
		}
	}
});

Vue.component("page-form-input-location", {
	template: "<n-form-location ref='form'"
			+ "		:edit='!readOnly'"
			+ "		:placeholder='placeholder'"
			+ "		:schema='schema'"
			+ "		v-bubble:label"
			+ "		:required='field.required'"
			+ "		@input=\"function(newValue) { $emit('input', newValue) }\""
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		:name='field.name'"
			+ "		:timeout='timeout'"
			+ "     :latitude='field.latitude'"
			+ "     :longitude='field.longitude'"
			+ "     :country='field.country'"
			+ "     :country-code='field.countryCode'"
			+ "     :province='field.province'"
			+ "     :region='field.region'"
			+ "     :city='field.city'"
			+ "     :post-code='field.postCode'"
			+ "     :street='field.street'"
			+ "     :street-include-number='field.streetIncludeNumber'"
			+ "     :street-number='field.streetNumber'"
			+ "     :formatted='field.formatted'"
			+ "		:country-restriction='field.countryRestriction'"
			+ "     :allow-vague='field.allowVague'"
			+ "		:disabled='disabled'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schema: {
			type: Object,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		}
	},
	methods: {
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		}
	}
});
Vue.component("page-form-input-address-configure", {
	template: "<n-form-section>"
		+ "	<n-form-text v-model='field.countryRestriction' label='Country limitation (two letter code, comma separated)'/>"
		+ "	<n-form-combo v-model='field.latitude' label='Latitude Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.longitude' label='Longitude Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.country' label='Country Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.countryCode' label='Country Code Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.city' label='City Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.postCode' label='Post Code Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.street' label='Street Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.additional' label='Additional Field' :filter='getKeys'/>"
		+ "	<n-form-combo v-model='field.streetNumber' label='Street Number Field' :filter='getKeys' v-if='!field.streetIncludeNumber'/>"
		+ "	<n-form-text v-model='field.countryLabel' label='Country Label' />"
		+ "	<n-form-text v-model='field.cityLabel' label='City Label' />"
		+ "	<n-form-text v-model='field.postCodeLabel' label='Postcode Label' />"
		+ "	<n-form-text v-model='field.streetLabel' label='Street Label' />"
		+ "	<n-form-text v-model='field.streetNumberLabel' label='Street Number Label' />"
		+ "	<n-form-text v-model='field.additionalLabel' label='Additional Label' />"
		+ "</n-form-section>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		// the fragment this image is in
		field: {
			type: Object,
			required: true
		},
		possibleFields: {
			type: Array,
			required: false,
			default: function() { return [] }
		}
	},
	created: function() {
		if (!this.field.textType) {
			Vue.set(this.field, "textType", null);
		}
	},
	methods: {
		getKeys: function(value) {
			return this.possibleFields.filter(function(x) {
				return !value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
			})
		}
	}
});

Vue.component("page-form-input-address", {
	template: "<n-form-address ref='form'"
			+ "		:edit='!readOnly'"
			+ "		:placeholder='placeholder'"
			+ "		:schema-resolver='schemaResolver'"
			+ "		v-bubble:label"
			+ "		v-bubble:changed"
			+ "		@input=\"function(newValue) { $emit('input', newValue) }\""
			+ "		:label='label'"
			+ "		:value='value'"
			+ "		:description='field.description ? $services.page.translate(field.description) : null'"
			+ "		:description-type='field.descriptionType'"
			+ "		:description-icon='field.descriptionIcon'"
			+ "		:name='field.name'"
			+ "		:timeout='timeout ? timeout : 400'"
			+ "     :latitude='field.latitude'"
			+ "     :longitude='field.longitude'"
			+ "     :country='field.country'"
			+ "     :country-code='field.countryCode'"
			+ "     :city='field.city'"
			+ "     :post-code='field.postCode'"
			+ "     :street='field.street'"
			+ "     :street-number='field.streetNumber'"
			+ "     :additional='field.additional'"
			+ "     :country-label='$services.page.translate(field.countryLabel)'"
			+ "     :city-label='$services.page.translate(field.cityLabel)'"
			+ "     :post-code-label='$services.page.translate(field.postCodeLabel)'"
			+ "     :street-label='$services.page.translate(field.streetLabel)'"
			+ "     :street-number-label='$services.page.translate(field.streetNumberLabel)'"
			+ "     :additional-label='$services.page.translate(field.additionalLabel)'"
			+ "		:country-restriction='field.countryRestriction'"
			+ "		:disabled='disabled'/>",
	props: {
		cell: {
			type: Object,
			required: true
		},
		page: {
			type: Object,
			required: true
		},
		field: {
			type: Object,
			required: true
		},
		value: {
			required: true
		},
		label: {
			type: String,
			required: false
		},
		timeout: {
			required: false
		},
		disabled: {
			type: Boolean,
			required: false
		},
		schemaResolver: {
			type: Function,
			required: false
		},
		readOnly: {
			type: Boolean,
			required: false
		},
		placeholder: {
			type: String,
			required: false
		}
	},
	methods: {
		validate: function(soft) {
			return this.$refs.form.validate(soft);
		}
	}
});
// a lot of this is copy paste from the enumeration operation
Vue.component("page-format-resolver", {
	props: {
		page: {
			type: Object,
			required: true
		},
		cell: {
			type: Object,
			required: true
		},
		fragment: {
			type: Object,
			required: true
		},
		keys: {
			type: Array,
			required: false
		}
	},
	created: function() {
		if (!this.fragment.resolveOperationBinding) {
			Vue.set(this.fragment, "resolveOperationBinding", {});
		}
	},
	template: "<n-form-section class='enumeration'>"
		+ "		<n-form-combo v-model='fragment.resolveOperation'"
		+ "			label='Resolve Operation'"
		+ "			:filter='getEnumerationServices'/>"
		+ "		<n-form-switch v-model='fragment.resolveOperationLabelComplex' label='Complex Enumeration Label'/>"
		+ "		<n-form-combo v-if='fragment.resolveOperation && !fragment.resolveOperationLabelComplex' v-model='fragment.resolveOperationLabel' label='Result Label Field'"
		+ "			:filter='function() { return getEnumerationFields(fragment.resolveOperation) }'/>"
		+ "		<n-form-combo v-if='fragment.resolveOperation' v-model='fragment.resolveOperationId' label='Result Id Field'"
		+ "			:filter='function() { return getEnumerationFields(fragment.resolveOperation) }'/>"
		+ "		<n-form-combo v-if='fragment.resolveOperation' v-model='fragment.resolveOperationIds' label='Input Ids Field'"
		+ "			:filter='function() { return getEnumerationParameters(fragment.resolveOperation) }'/>"
		+ "		<n-form-text v-model='fragment.complexLabel' label='The complex text label' v-if='fragment.resolveOperation && fragment.resolveOperationLabelComplex'/>"
		+ "		<typography-variable-replacer v-if='fragment.resolveOperation && fragment.resolveOperationLabelComplex && fragment.complexLabel' :content='fragment.complexLabel' :page='page' :container='fragment' :keys='getEnumerationFields(fragment.resolveOperation)' />"
		+ "		<n-page-mapper v-if='fragment.resolveOperation && hasMappableEnumerationParameters(fragment)'"
		+ "			v-model='fragment.resolveOperationBinding'"
		+ "			:from='availableParameters'"
		+ "			:to='getMappableEnumerationParameters(fragment)'/>"
		+ "</n-form-section>",
	computed: {
		availableParameters: function() {
			var result = this.$services.page.getAvailableParameters(this.page, this.cell);
			// deprecated in v2?
			if (this.keys && false) {
				var record = {properties:{}}
				this.keys.forEach(function(key) {
					record.properties[key] = {type: "string"}
				});
				result.record = record;
			}
			return result;
		}
	},
	methods: {
		// copy/pasted from the table getOperations
		getEnumerationServices: function(name) {
			var self = this;
			return this.$services.page.getOperations(function(operation) {
				// must be a get
				var isAllowed = operation.method.toLowerCase() == "get"
					// and contain the name fragment (if any)
					&& (!name || operation.id.toLowerCase().indexOf(name.toLowerCase()) >= 0)
					// must have _a_ response
					&& operation.responses["200"];
				// we also need at least _a_ complex array in the results
				if (isAllowed) {
					var schema = operation.responses["200"] ? operation.responses["200"].schema : null;
					if (schema) {
						var definition = self.$services.swagger.definition(schema["$ref"]);
						// now we need a child in the definition that is a record array
						// TODO: we currently don't actually check for a complex array, just any array, could be an array of strings...
						isAllowed = false;
						if (definition.properties) {
							Object.keys(definition.properties).map(function(field) {
								if (definition.properties[field].type == "array") {
									isAllowed = true;
								}
							});
						}
					}
				}
				return isAllowed;
			}).map(function(x) {
				 return x.id;
			});	
		},
		getEnumerationFields: function(operationId) {
			var fields = [];
			if (this.$services.swagger.operations[operationId]) {
				var resolved = this.$services.swagger.resolve(this.$services.swagger.operations[operationId].responses["200"]);
				Object.keys(resolved.schema.properties).map(function(property) {
					if (resolved.schema.properties[property].type == "array") {
						nabu.utils.arrays.merge(fields, Object.keys(resolved.schema.properties[property].items.properties));
					}
				});
			}
			return fields;
		},
		getEnumerationParameters: function(operationId) {
			var parameters = this.$services.swagger.operations[operationId].parameters;
			return parameters ? parameters.map(function(x) { return x.name }) : [];
		},
		getMappableEnumerationParameters: function(field) {
			var result = {
				properties: {}
			};
			Object.keys(this.$services.page.getInputBindings(this.$services.swagger.operations[field.resolveOperation])).map(function(key) {
				if (key != field.resolveOperationIds) {
					result.properties[key] = {
						type: "string"
					}
				}
			});
//			result.properties["$serviceContext"] = {
//				type: "string"
//			};
			return result;
		},
		hasMappableEnumerationParameters: function(field) {
			var amount = Object.keys(this.getMappableEnumerationParameters(field).properties).length;
			return amount > 0;
		}
	}
});
Vue.view("default-login", {
	priority: -50,
	alias: "login",
	url: "/login",
	props: {
		route: {
			type: String,
			required: false,
			default: "home"
		},
		url: {
			type: String,
			required: false
		}
	},
	data: function() {
		return {
			username: null,
			password: null,
			// remember will (in the future) be a security-driven choice in the backend
			// the user has little knowledge of what this exactly means with regards to user experience
			// instead he needs to explicitly log out if he wants to be forgotten
			remember: true,
			working: false,
			valid: false,
			messages: []
		};
	},
	methods: {
		login: function() {
			if (this.validate(true)) {
				this.messages.splice(0, this.messages.length);
				this.working = true;
				var self = this;
				return this.$services.user.login(this.username, this.password, this.remember).then(
					function(result) {
						if (result && result.challengeType) {
							// the result should contain a token and a challenge type at this point
							self.$services.router.route("login-challenge", result);
						}
						else if (self.url) {
							window.location.href = self.url;
						}
						else {
							self.$services.router.route(self.route);
						}
						self.working = false;
					},
					function(error) {
						self.messages.push({
							title: self.$services.page.translate("%{default::Login failed}"),
							severity: "error"
						})
						self.working = false;
					});
			}
		},
		validate: function(hard) {
			var messages = this.$refs.form.validate(!hard);
			this.valid = messages.length == 0;
			return this.valid;
		}
	}
});
Vue.view("default-challenge", {
	priority: -50,
	alias: "login-challenge",
	url: "/login/challenge",
	props: {
		route: {
			type: String,
			required: false,
			default: "home"
		},
		url: {
			type: String,
			required: false
		},
		challengeType: {
			type: String,
			required: false
		},
		token: {
			type: String,
			required: true
		},
		remember: {
			type: Boolean,
			required: false,
			default: true
		}
	},
	data: function() {
		return {
			challenge: null,
			working: false,
			valid: false,
			messages: []
		};
	},
	methods: {
		login: function() {
			if (this.validate(true)) {
				this.messages.splice(0, this.messages.length);
				this.working = true;
				var self = this;
				return this.$services.user.login(this.token, this.challenge, this.remember, this.challengeType).then(
					function(result) {
						// we might chain challenges (?)
						if (result && result.challengeType) {
							// the result should contain a token and a challenge type at this point
							self.$services.router.route("login-challenge", result);
						}
						else if (self.url) {
							window.location.href = self.url;
						}
						else {
							self.$services.router.route(self.route);
						}
						self.working = false;
					},
					function(error) {
						self.messages.push({
							title: self.$services.page.translate("%{default::Login failed}"),
							severity: "error"
						})
						self.working = false;
					});
			}
		},
		validate: function(hard) {
			var messages = this.$refs.form.validate(!hard);
			this.valid = messages.length == 0;
			return this.valid;
		}
	}
});
Vue.view("default-error", {
	priority: -50,
	alias: "error",
	url: "/error",
	props: {
		icon: {
			type: String,
			default: "times"
		},
		title: {
			type: String,
			default: "%{default::A problem has occurred!}"
		},
		message: {
			type: String,
			default: "%{default::Sorry, your action could not be completed.}"
		},
		recover: {
			type: String,
			default: "%{default::Return to the&nbsp;<a class='is-color-link' v-route:home>home page</a>.}"
		},
		errorId: {
			type: String
		}
	}
});
Vue.view("default-unknown", {
	priority: -50,
	alias: "unknown",
	url: "/unknown",
	props: {
		message: {
			type: String,
			default: "%{default::Sorry, the page you were looking for could not be found.}"
		},
		recover: {
			type: String,
			default: "%{default::Return to the&nbsp;<a class='is-color-link' v-route:home>home page</a>.}"
		}
	}
});
// https://jsfiddle.net/Linusborg/mfqjk5hm/
// https://github.com/vuejs/vue/issues/7431
// try to avoid wrapper elements when inserting html
// not entirely sure if this is still responsive?
Vue.component('html-fragment', {
	functional: true,
	props: {
		html: {
			type: String, 
			required: true
		}
	},
	render: function(h, ctx) {
		return new Vue({
			beforeCreate: function() { this.$createElement = h }, // not necessary, but cleaner imho
			template: "<div>" + ctx.props.html + "</div>"
		}).$mount()._vnode.children;
	}
});

window.addEventListener("load", function() {
	application.bootstrap(function($services) {
		
		$services.router.register({
			alias: "pages",
			enter: function(parameters) {
				return new nabu.page.views.Pages({propsData:parameters});
			},
			url: "/pages"
		});
		
		$services.router.register({
			alias: "home",
			enter: function(parameters) {
				// if you have not overridden this alias (home) but you have added a route at "/", let's look for that
				// it takes presedence over the pages here
				var hasHomeRoute = $services.router.router.findRoute(application && application.configuration ? application.configuration.root : "/");
				// it must not have the alias home, to prevent circular refreshes etc
				if (hasHomeRoute && hasHomeRoute.route && hasHomeRoute.route.alias != "home") {
					setTimeout(function() {
						console.log("routing to", hasHomeRoute);
						$services.router.route(hasHomeRoute.route.alias);
					}, 1);
				}
				else {
					return new nabu.page.views.Pages({propsData:parameters});
				}
			},
			priority: -5,
			url: "/"
		});
		
		$services.router.register({
			alias: "page-code",
			enter: function(parameters) {
				return new nabu.page.views.Code({propsData: parameters});
			}
		});
		
		$services.router.register({
			alias: "impersonate",
			priority: -10,
			url: "/impersonate",
			query: ["userId"],
			enter: function(parameters) {
				if (parameters.userId) {
					$services.user.impersonate(parameters.userId).then(function() {
						$services.router.route("home");
					}, function() {
						$services.router.route("error", {message:"Failed to impersonate"});
					})
				}
			}
		});
		
		$services.router.register({
			alias: "page-fields",
			enter: function(parameters) {
				return new nabu.page.views.PageFields({propsData: parameters});
			},
			category: "Content",
			name: "Fields",
			description: "Display a number of fields.",
			icon: "page/core/images/page-fields.svg"
		});
		$services.router.register({
			alias: "page-fields-table",
			enter: function(parameters) {
				return new nabu.page.views.PageFieldsTable({propsData: parameters});
			}
		});
	
		$services.router.register({
			alias: "page-actions",
			enter: function(parameters) {
				return new nabu.page.views.PageActions({propsData: parameters});
			},
			icon: "page/core/images/buttons.svg",
			description: "Actions is a generic combination of buttons to form a menu, tabs,...",
			name: "Actions",
			category: "Interactive",
			query: ["active"]
		});
		
		$services.router.register({
			alias: "page-form",
			enter: function(parameters) {
				var component = Vue.component("page-form");
				return new component({propsData: parameters});
			},
			//name: "Form",
			//category: "Form",
			//description: "This is a form container that encapsulates simple forms",
			//icon: "page/core/images/form.svg",
			accept: function(type, value) {
				return false;
				if (type == "operation") {
					var operation = $services.swagger.operations[value];
					return (operation.method.toLowerCase() == "put" || operation.method.toLowerCase() == "post" || operation.method.toLowerCase() == "patch");         
				}
			},
			initialize: function(type, value, component, cell, row, pageInstance) {
				cell.state.operation = value;
				
				// we need to this auto-update the bindings, not ideal...but for now
				var operation = $services.swagger.operations[value];
				component.updateOperation(operation);
				
				component.generateForm();
				
				var name = $services.page.guessNameFromOperation(value);
				
				// remove the last bit, for example if we have demo.rest.company.create, we want to find an operation
				// that starts with demo.rest.company, for example "demo.rest.company.list"
				var shared = value.replace(/\.[^.]+$/, "");
				var getDataComponent = function(rows) {
					for (var i = 0; i < rows.length; i++) {
						if (rows[i].cells) {
							for (var j = 0; j < rows[i].cells.length; j++) {
								var cell = rows[i].cells[j];
								// do a minimalistic check
								if (cell.alias && cell.alias.indexOf("data-") == 0 && cell.state.operation) {
									if (cell.state.operation.indexOf(shared) == 0) {
										return cell;
									}
								}
								if (cell.rows) {
									var dataComponent = getDataComponent(cell.rows);
									if (dataComponent != null) {
										return dataComponent;
									}
								}
							}
						}
					}
					return null;
				}
				
				var page = pageInstance.page;
				// we scan the current page to see if there is a data component where we can add an event
				if (page.content.rows) {
					var dataComponent = getDataComponent(page.content.rows);
					if (dataComponent != null) {
						nabu.utils.vue.confirm({message:"Do you want to add this form to the existing data cell?"}).then(function() {
							if (name != null) {
								name = name.substring(0, 1).toUpperCase() + name.substring(1);
							}
							// we want the form in a prompt
							cell.target = "prompt";
							
							var operation = $services.swagger.operations[value];
							if (!dataComponent.state.actions) {
								Vue.set(dataComponent.state, "actions", []);
							}
							if (operation.method.toLowerCase() == "post") {
								if (name != null) {
									cell.state.title = "%" + "{Create " + name + "}";
								}
								// make sure we send out a created event once done
								cell.state.event = "created" + (name ? name : "");
								cell.state.ok = "Create";
								// trigger on this create
								cell.on = "create" + (name ? name : "");
								cell.hideMode = "event";
								// push an action to the datacomponent
								dataComponent.state.actions.push({
									name: "create" + (name ? name : ""),
									global: true,
									label: "%" + "{Create}",
									type: "button",
									class: "primary"
								});
								if (!dataComponent.state.refreshOn) {
									Vue.set(dataComponent.state, "refreshOn", []);
								}
								// make sure we refresh on create
								dataComponent.state.refreshOn.push("created" + (name ? name : ""));
							}
							else if (operation.method.toLowerCase() == "put" || operation.method.toLowerCase() == "patch") {
								if (name != null) {
									cell.state.title = "%" + "{Update " + name + "}";
								}
								// make sure we synchronize changes so we don't need to refresh
								cell.state.synchronize = true;
								cell.state.event = "updated" + (name ? name : "");
								cell.state.ok = "Update";
								// trigger on this create
								cell.on = "update" + (name ? name : "");
								cell.hideMode = "event";
								// push an action to the datacomponent
								dataComponent.state.actions.push({
									name: "update" + (name ? name : ""),
									global: false,
									icon: "fa-pencil-alt",
									type: "button",
									class: "inline"
								});
								// reset events
								pageInstance.resetEvents();
								// allow for some time to stabilize events etc so we have correct definitions
								// not very clean, i know...
								setTimeout(function() {
									// generate automapping of fields
									component.autoMapFrom = cell.on;
									component.automap();
								}, 300);
							}
						});
					}
				}
			}
		});
		
		$services.router.register({
			alias: "page-youtube",
			enter: function(parameters) {
				return new nabu.page.views.Youtube({propsData: parameters});
			}
		});
		
		$services.router.register({
			alias: "page-skeleton-email",
			enter: function(parameters) {
				return new nabu.page.skeletons.Email({propsData: parameters});
			}
		});
		
		// form routes
		$services.router.register({
			alias: "page-form-text",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-input-text";
				cloneParameters.configurationComponent = "page-form-input-text-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "text",
			category: "Form",
			name: "Text",
			description: "An input field for plain text",
			icon: "page/core/images/form-text.svg"
		});
		$services.router.register({
			alias: "page-form-ace",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-input-ace";
				cloneParameters.configurationComponent = "page-form-input-ace-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "ace",
			category: "Form",
			name: "Ace",
			description: "An ace editor",
			icon: "page/core/images/form-text.svg"
		});
		$services.router.register({
			alias: "page-form-hidden",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-input-hidden";
				cloneParameters.configurationComponent = "page-form-input-text-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "hidden",
			category: "Form",
			name: "Hidden",
			description: "An input field with hidden content",
			icon: "page/core/images/form-text.svg"
		});
		$services.router.register({
			alias: "page-form-checkbox",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-input-checkbox";
				cloneParameters.configurationComponent = "page-form-input-checkbox-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "checkbox",
			category: "Form",
			name: "Checkbox",
			description: "A checkbox that allows you to toggle boolean values",
			icon: "page/core/images/form-checkbox.svg"
		});
		$services.router.register({
			alias: "page-form-enumeration-operation",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-input-enumeration-operation";
				cloneParameters.configurationComponent = "page-form-input-enumeration-operation-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "enumerationOperation",
			category: "Form",
			name: "Enumeration (Operation)",
			description: "An enumeration based on an operation",
			icon: "page/core/images/enumeration.png"
		});
		$services.router.register({
			alias: "page-form-enumeration-array",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-input-enumeration-array";
				cloneParameters.configurationComponent = "page-form-input-enumeration-array-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "enumerationArray",
			category: "Form",
			name: "Enumeration (Array)",
			description: "An enumeration based on an array",
			icon: "page/core/images/enumeration.png"
		});
		$services.router.register({
			alias: "page-form-enumeration-provider",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-input-enumeration-provider";
				cloneParameters.configurationComponent = "page-form-input-enumeration-provider-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "enumerationProvider",
			category: "Form",
			name: "Enumeration (Provider)",
			description: "An enumeration based on a data provider",
			icon: "page/core/images/enumeration.png"
		});
		$services.router.register({
			alias: "page-form-enumeration",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-input-enumeration";
				cloneParameters.configurationComponent = "page-form-input-enumeration-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "enumeration",
			category: "Form",
			name: "Enumeration (Basic)",
			description: "An enumeration based on fixed values",
			icon: "page/core/images/enumeration.png"
		});
		$services.router.register({
			alias: "page-form-date",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-input-date";
				cloneParameters.configurationComponent = "page-form-input-date-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "date",
			category: "Form",
			name: "Date",
			description: "A date component with a calendar dropdown",
			icon: "page/core/images/form-date.svg"
		});
		$services.router.register({
			alias: "page-form-switch",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-input-switch";
				cloneParameters.configurationComponent = "page-form-input-switch-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "switch",
			category: "Form",
			name: "Switch",
			description: "The switch component is a variant on the checkbox to toggle booleans",
			icon: "page/core/images/form-switch.svg"
		});
		$services.router.register({
			alias: "page-form-password",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-input-password";
				cloneParameters.configurationComponent = "page-form-input-password-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "password",
			category: "Form",
			name: "Password",
			description: "The password component allows for entering the same password twice to verify it",
			icon: "page/core/images/form-password.svg"
		});
		$services.router.register({
			alias: "page-form-richtext",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-input-richtext";
				cloneParameters.configurationComponent = "page-form-input-richtext-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "richtext",
			category: "Form",
			name: "Rich Text",
			description: "This input component allows you to capture rich text from the user",
			icon: "modules/richtext/logo.svg"
		});
		$services.router.register({
			alias: "page-form-file",
			enter: function(parameters) {
				// do not modify parameters directly, this may lead to rerendering issues
				var cloneParameters = {};
				nabu.utils.objects.merge(cloneParameters, parameters);
				cloneParameters.formComponent = "page-form-input-file";
				cloneParameters.configurationComponent = "page-form-input-file-configure";
				return new nabu.page.views.FormComponent({propsData: cloneParameters});
			},
			form: "file",
			category: "Form",
			name: "File",
			description: "Upload a file to a REST service with a stream as input",
			icon: "file"
		});
		
		// fragment providers
		nabu.page.provide("page-field-fragment", { 
			component: "page-field-fragment-data", 
			configure: "page-field-fragment-data-configure", 
			name: "data",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-field-fragment", { 
			component: "page-field-fragment-text", 
			configure: "page-field-fragment-text-configure", 
			name: "text",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-field-fragment", { 
			component: "page-field-fragment-image", 
			configure: "page-field-fragment-image-configure", 
			name: "image",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-field-fragment", { 
			component: "page-field-fragment-richtext", 
			configure: "page-field-fragment-richtext-configure", 
			name: "richtext",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-field-fragment", { 
			component: "page-field-fragment-javascript", 
			configure: "page-field-fragment-javascript-configure", 
			name: "javascript",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-field-fragment", { 
			component: "page-field-fragment-form", 
			configure: "page-field-fragment-form-configure", 
			name: "form",
			editable: true,
			namespace: "nabu.page"
		});
		
		// form providers
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-richtext", 
			configure: "page-form-input-richtext-configure", 
			name: "richtext",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-page", 
			configure: "page-form-input-page-configure", 
			name: "page",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-text", 
			configure: "page-form-input-text-configure", 
			name: "text",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-hidden", 
			configure: "page-form-input-text-configure", 
			name: "hidden",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-password", 
			configure: "page-form-input-password-configure", 
			name: "password",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-slider", 
			configure: "page-form-input-slider-configure", 
			name: "slider",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-date", 
			configure: "page-form-input-date-configure", 
			name: "date",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-date-picker", 
			configure: "page-form-input-date-picker-configure", 
			name: "date-picker",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-switch", 
			configure: "page-form-input-switch-configure", 
			name: "switch",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-checkbox", 
			configure: "page-form-input-checkbox-configure", 
			name: "checkbox",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-enumeration", 
			configure: "page-form-input-enumeration-configure", 
			name: "enumeration",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-enumeration-provider", 
			configure: "page-form-input-enumeration-provider-configure", 
			name: "enumeration-provider",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-enumeration-operation", 
			configure: "page-form-input-enumeration-operation-configure", 
			name: "enumeration-operation",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-enumeration-array",
			configure: "page-form-input-enumeration-array-configure", 
			name: "enumeration-array",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-static-image", 
			configure: "page-form-input-static-image-configure", 
			name: "static-image",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-file", 
			configure: "page-form-input-file-configure", 
			name: "file",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-location", 
			configure: "page-form-input-location-configure", 
			name: "location",
			namespace: "google",
			multipleFields: true
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-address", 
			configure: "page-form-input-address-configure", 
			name: "address",
			namespace: "google",
			multipleFields: true
		});
		nabu.page.provide("page-form-input", { 
			component: "page-form-input-validate-custom", 
			configure: "page-form-input-validate-custom-configure",
			name: "validate",
			namespace: "nabu.page",
			multipleFields: true
		});	
		
		// form list providers
		nabu.page.provide("page-form-list-input", { 
			component: "page-form-list-input-dynamic", 
			configure: "page-form-list-input-dynamic-configure", 
			name: "dynamic",
			namespace: "nabu.page"
		});
		nabu.page.provide("page-form-list-input", { 
			component: "page-form-list-input-predefined", 
			configure: "page-form-list-input-predefined-configure", 
			name: "predefined",
			namespace: "nabu.page"
		});
		
		nabu.page.provide("page-generator", {
			name: "Table Button",
			description: "Add as a delete button to an existing table",
			icon: "th",
			accept: function(type, content) {
				return type == "operation" && $services.swagger.operations[content] && $services.swagger.operations[content].method && $services.swagger.operations[content].method.toLowerCase() == "delete";
			},
			initialize: function(type, content, pageInstance, rowGenerator, cellGenerator) {
				var operation = $services.swagger.operations[content];
				var name = $services.page.guessNameFromOperation(content);
				var rawName = name;
				if (name != null) {
					name = name.substring(0, 1).toUpperCase() + name.substring(1);
				}
				var page = pageInstance.page;
				// remove the last bit, for example if we have demo.rest.company.create, we want to find an operation
				// that starts with demo.rest.company, for example "demo.rest.company.list"
				var shared = content.replace(/\.[^.]+$/, "");
				var getDataComponent = function(targets) {
					for (var i = 0; i < targets.length; i++) {
						var target = targets[i];
						// do a minimalistic check
						if (target.renderer == "repeat" && target.repeat && target.repeat.operation) {
							if (target.repeat.operation.indexOf(shared) == 0) {
								return [target];
							}
						}
						if (target.rows) {
							var dataComponent = getDataComponent(target.rows);
							if (dataComponent != null) {
								dataComponent.push(target);
								return dataComponent;
							}
						}
						else if (target.cells) {
							var dataComponent = getDataComponent(target.cells);
							if (dataComponent != null) {
								dataComponent.push(target);
								return dataComponent;
							}
						}
					}
					return null;
				}
				var dataComponent = getDataComponent(page.content.rows);
				// we are looking for a repeat within a table renderer
				// and it must not have a slot header or footer (if you for some reason put a repeat on that...?)
				if (dataComponent != null && dataComponent.length >= 2 && dataComponent[1].renderer == "table" && ["header", "footer"].indexOf(dataComponent[0].rendererSlot) < 0) {
					var table = dataComponent[1];
					var repeat = dataComponent[0];
					nabu.utils.vue.confirm({message:"Do you want to add a delete button to the existing table?"}).then(function() {
						// find a repeat column that has the name "Local Actions"
						var buttons = repeat.cells.filter(function(x) {
							return x.name && x.name.toLowerCase() == "local actions";
						})[0];
						
						if (!buttons) {
							buttons = cellGenerator(repeat);
							buttons.name = "Local actions";
							// if we add a new column for the buttons, we also need to add it to the header
							var headers = table.rows.filter(function(x) {
								return x.rendererSlot == "header";
							});
							headers.forEach(function(x) {
								var cell = cellGenerator(x);
								cell.name = "Local actions header";
							});
							
							// by default we generate no header content
							// and we set the borders to be disabled on the local actions, that gives it a floaty feeling
							application.services.page.normalizeAris(pageInstance.page, buttons, "cell", [{name:"table-column"}]);
							buttons.aris.components["table-column"].options.push("border_none");
							buttons.aris.components["table-column"].modifiers.push("small");
						}
						var buttonRow = null;
						// if we don't have a row yet, add it
						if (buttons.rows.length == 0) {
							buttonRow = rowGenerator(buttons);
							application.services.page.normalizeAris(pageInstance.page, buttonRow, "row");
							buttonRow.aris.components["page-row"].options.push("gap_small");
							buttonRow.aris.components["page-row"].options.push("wrap_none");
						}
						else {
							buttonRow = buttons.rows[0];
						}
						
						var buttonCell = cellGenerator(buttonRow);
						
						var eventName = "update" + (name ? name : "");
						buttonCell.name = "Delete" + (name ? " " + name : "");
						application.services.page.normalizeAris(pageInstance.page, buttonCell, "cell");
						application.services.page.normalizeAris(pageInstance.page, buttonCell, "cell", [{name:"page-button"}]);
						//buttonCell.aris.components["page-button"].options.push("size_small");
						//buttonCell.aris.components["page-button"].options.push("border_none");
						buttonCell.aris.components["page-button"].variant = "ghost";
						buttonCell.aris.components["page-button"].modifiers.push("danger");
						if (rawName) {
							buttonCell.analysisId = "delete-" + rawName;
						}
						
						buttonCell.alias = "page-button";
						var idField = operation.parameters ? operation.parameters.filter(function(x) {
							return x.name.toLowerCase().indexOf("id") >= 0;
						}).map(function(x) { return x.name })[0] : null;
						var bindings = {};
						if (idField) {
							bindings[idField] = repeat.runtimeAlias + ".record.id";
						}
						buttonCell.state = {
							// no label
							content: null,
							icon: "times"
						}
						buttonCell.triggers = [{
							trigger: "activate",
							actions: [{
								type: "confirmation",
								confirmation: "%" + "{Are you sure you want to delete this entry?}"
							}, {
								type: "operation",
								operation: content,
								bindings: bindings
							}, {
								type: "action",
								action: "refresh",
								actionTarget: repeat.id,
								bindings: {}
							}]
						}]
					});
				}
			}
		});
		
		// -------------------------- generators
		nabu.page.provide("page-generator", {
			name: "Table",
			description: "Generate a table",
			icon: "th",
			accept: function(type, content) {
				return type == "operation" && application.services.page.getArrayOperations().filter(function(x){
					return x.id == content;
				}).length > 0;
			},
			initialize: function(type, content, pageInstance, rowGenerator, cellGenerator) {
				var generator = nabu.page.providers("page-generator").filter(function(x) {
					return x.name.toLowerCase() == "table";
				})[0];
				
				var searchTableRenderer = function(target) {
					if (target.renderer == "table") {
						return target;
					}
					else if (target.cells) {
						return target.cells.filter(function(x) {
							return !!searchTableRenderer(x);
						})[0];
					}
					else if (target.rows) {
						return target.rows.filter(function(x) {
							return !!searchTableRenderer(x);
						})[0];
					}
				}
				
				var availableTemplates = application.services.page.templates.filter(function(x) {
					var content = JSON.parse(x.content);
					return !!searchTableRenderer(content.content);
					/*
					return content.type == "page-cell"
						&& content.content.renderer == "table";
					*/
				});
				
				var name = $services.page.guessNameFromOperation(content);
				if (name != null) {
					name = name.substring(0, 1).toUpperCase() + name.substring(1);
				}
				
				var applyTemplate = function(template) {
					// row at the root of the page
					var row = rowGenerator();
					var root = null;
					if (template.type == "row") {
						root = row;
						application.services.page.normalizeAris(pageInstance.page, row, "row");
						row.name = "Cards";
						row.aris.components["page-row"].variant = "cards";
						var cellContainer = cellGenerator(row);
						cellContainer.name = "Card";
						application.services.page.normalizeAris(pageInstance.page, cellContainer, "cell");
						cellContainer.aris.components["page-column"].variant = "card";
						cellContainer.aris.components["page-column"].options.push("fill_normal");
						root = rowGenerator(cellContainer);
					}
					else {
						// the cell that contains the actual form
						// we use a cell because you might want to show it in a popup etc
						root = cellGenerator(row);
					}
					var templateContent = JSON.parse(template.content).content;
					application.services.page.renumber(pageInstance.page, templateContent);
					// do a reactive merge
					Object.keys(templateContent).forEach(function(key) {
						Vue.set(root, key, templateContent[key]);
					});
					
					var tableTitle = null;
					var tableHeader = null;
					var tableBody = null;
					var tableFilters = null;
					var tableTags = null;

					var search = function(target) {
						if (target.name && target.name.toLowerCase() == "table title") {
							tableTitle = target;	
						}
						if (target.name && target.name.toLowerCase() == "table filters") {
							tableFilters = target;
						}
						if (target.name && target.name.toLowerCase() == "table tags") {
							tableTags = target;
						}
						if (target.renderer == "repeat" && ["header", "footer"].indexOf(target.rendererSlot) < 0) {
							tableBody = target;
						}
						// in a typical scenario the "last" header row is the one that has the most granular columns that likely match the data columns
						// so we don't want to target all headers, just the last one if there are multiple
						if (target.rendererSlot == "header") {
							tableHeader = target;
						}
						if (target.cells) {
							target.cells.forEach(search);
						}
						else if (target.rows) {
							target.rows.forEach(search);
						}
					};
					search(root);
					
					//root.renderer = "table";
					root.name = name + " Table";
					
					if (tableTitle) {
						// this assumes some kind of typography that stores the data in the "content" field or a component compliant with that layout
						tableTitle.state.content = "%" + "{" + name + "}";
					}
					
					var repeatName = "repeat" + name;
					var pickResult = null;
					
					if (tableBody) {
						// not a thing (yet?)
						//tableBody.repeat.repeatType = "operation";
						tableBody.repeat.operation = content;
						tableBody.repeat.loadingPlaceholder = "%" + "{Loading...}";
						tableBody.repeat.emptyPlaceholder = "%" + "{No data available}";
						// by default we allow selection
						tableBody.repeat.selectable = true;
						// and we want to change our content based on the bound input
						tableBody.repeat.enableParameterWatching = true;
						tableBody.runtimeAlias = repeatName;
						tableBody.name = "Table Body " + name;
						pickResult = generator.generateFields(type, content, pageInstance, root, tableBody, tableHeader, rowGenerator, cellGenerator);
					}
					else {
						pickResult = application.services.q.resolve({});
					}
					
					pickResult.then(function(x) {
						if (x.repeatName) {
							repeatName = x.repeatName;
							tableBody.runtimeAlias = x.repeatName;	
						}
						var operation = $services.swagger.operations[content];
						var blacklist = ["limit", "offset", "orderBy", "id", "$serviceContext"];
						if (operation["x-temporary-secret"]) {
							blacklist.push(operation["x-temporary-secret"]);
						}
						if (operation["x-temporary-id"]) {
							blacklist.push(operation["x-temporary-id"]);
						}
						if (tableFilters && operation) {
							var row = tableFilters.cells ? tableFilters : rowGenerator(tableFilters);
							if (operation.parameters) {
								var formGenerator = nabu.page.providers("page-generator").filter(function(x) {
									return x.name.toLowerCase() == "form";
								})[0];
								formGenerator.generateFields("operation", content, pageInstance, repeatName + ".filter", row, rowGenerator, cellGenerator,
									blacklist, 600);
								
								// for search, we want a placeholder instead of label and (at least for text input) a search icon suffix
								row.cells.forEach(function(cell) {
									cell.state.placeholder = cell.state.label == "%" + "{Q}" ? "%" + "{Search}" : cell.state.label;
									cell.state.label = null;
									if (cell.alias == "page-form-text") {
										cell.state.suffixIcon = "search";
									}
								});
							}
						}
						
						if (tableTags) {
							var row = tableTags.cells ? tableTags : rowGenerator(tableTags);
							var tagTemplates = row.cells.filter(function(x) {
								return x.alias == "page-tag";
							});
							// remove them
							tagTemplates.forEach(function(x) {
								row.cells.splice(row.cells.indexOf(x), 1);
							});
							// if there are already cells in the row of the type "page-tag", we remove them
							// they are assumed to be a template of what you want to do with the styling
							if (operation.parameters) {
								operation.parameters.forEach(function(x) {
									if (blacklist.indexOf(x.name) < 0) {
										var cell = cellGenerator(row);
										cell.alias = "page-tag";
										cell.state.field = repeatName + ".filter." + x.name;
										cell.state.content = x.name == "q" ? "%" + "{Search}" : "%" + "{" + x.name.substring(0, 1).toUpperCase() + x.name.substring(1).replace(/([A-Z]+)/g, " $1") + "}";
										
										if (tagTemplates.length == 0) {
											application.services.page.normalizeAris(pageInstance.page, cell, "cell");
											// not rendered yet so we can't read it "live"
											application.services.page.normalizeAris(pageInstance.page, cell, "cell", [{name:"page-tag"}]);
											var options = cell.aris.components["page-tag"].options;
											cell.aris.components["page-tag"].variant = "primary-dark-outline";
											options.push("direction_reverse");
											options.push("decoration_emphasis");
										}
										else {
											cell.aris = tagTemplates[0].aris;
										}
									}
								});
							}
						}
					})
					
				}
				
				if (availableTemplates.length == 0) {
					nabu.utils.vue.confirm({message:"There are no applicable table templates available, add at least one to generate a table"});
					return;
				}
				// just apply it
				else if (availableTemplates.length == 1) {
					applyTemplate(availableTemplates[0]);
				}
				else {
					var selector = Vue.component("page-components-selector");
					nabu.utils.vue.prompt(function() {
						return new selector({propsData: {
							components: availableTemplates
						}});
					}).then(function(chosen) {
						applyTemplate(chosen);
					});
				}
			},
			generateFields: function(type, content, pageInstance, root, body, header, rowGenerator, cellGenerator) {
				var definition = null;
				if (type == "operation") {
					definition = application.services.page.getSwaggerOperationOutputDefinition(content);
					var arrays = application.services.page.getArrays(definition);
					var childDefinition = application.services.page.getChildDefinition(definition, arrays[0]);
					definition = childDefinition && childDefinition.items && childDefinition.items ? childDefinition.items : {};
				}
				else if (type == "array") {
					var pageParameters = null;
					throw "Not implemented page parameter resolving yet";
					var childDefinition = application.services.page.getChildDefinition({properties:pageParameters}, content);
					definition = childDefinition && childDefinition.items && childDefinition.items ? childDefinition.items : {};
				}
				var sortTemplates = header == null ? [] : header.cells.filter(function(x) {
					return x.alias == "page-button-sort";
				});
				// remove from the header
				sortTemplates.forEach(function(x) {
					header.cells.splice(header.cells.indexOf(x), 1);
				});
				var keys = application.services.page.getSimpleKeysFor(definition);
				
				var pickResult = {
					fields: [],
					repeatName: null
				};
				var promise = application.services.q.defer();
				new nabu.utils.vue.prompt(function() {
					var component = Vue.component("data-field-picker");
					return new component({
						propsData: {
							value: pickResult,
							fields: keys
						}
					});
				}).then(function() {
					var repeatName = pickResult.repeatName ? pickResult.repeatName : body.runtimeAlias;
					pickResult.fields.forEach(function(key) {
						// we don't generate a field for the id by default
						if (key != "id") {
							var name = key.replace(/^.*\.([^.]+)$/, "$1");
							var cell = cellGenerator(body);
							var child = application.services.page.getChildDefinition(definition, key);
							cell.alias = "typography-fragment";
							cell.state.content = "{" + name + "}";
							Vue.set(cell.state, "fragments", {});
							Vue.set(cell.state.fragments, name, {
								key: null,
								format: null
							});
							
							cell.state.fragments[name].key = repeatName + ".record." + key;
							
							// set an optional empty thing for mobile rendering
							application.services.page.normalizeAris(pageInstance.page, cell, "cell");
							cell.aris.components["table-column"].modifiers.push("empty");
							cell.aris.components["table-column"].conditions["empty"] = "$value(\"" + repeatName + ".record." + key + "\") == null";
							
							// try to find a more specific alias
							if (child) {
								if (child.type == "integer") {
									cell.state.fragments[name].format = "number";
								}
								else if (child.type == "boolean") {
									cell.state.fragments[name].format = "checkbox";
								}
								else if (child.format && child.format.indexOf("date") >= 0) {
									cell.state.fragments[name].format = "date";
								}
								else if (child.format == "uuid") {
									cell.state.fragments[name].format = "resolve";
									var generator = nabu.page.providers("page-generator").filter(function(x) {
										return x.name.toLowerCase() == "form";
									})[0];
									var operationId = generator.guessListServiceForField(name);
									if (operationId) {
										cell.state.fragments[name].resolveOperation = operationId;
										// we assume some reasonable defaults
										cell.state.fragments[name].resolveOperationId = "id";
										// TODO: verify that there IS a field name, if not, take the first string field or fall back to the id
										cell.state.fragments[name].resolveOperationLabel = "name";
									}
									else {
										cell.state.fragments[name].resolveOperation = "nabu.cms.core.rest.masterdata.entry.resolve";
										cell.state.fragments[name].resolveOperationId = "id";
										cell.state.fragments[name].resolveOperationLabel = "label";
										cell.state.fragments[name].resolveOperationIds = "entryId";
									}
								}
							}
							//cell.name = application.services.page.prettify(name);
							
							var headerCell = cellGenerator(header);
							// names are automatically generated from the content these days
							//headerCell.name = cell.name;
							
							//headerCell.alias = "typography-fragment";
							headerCell.alias = "page-button-sort";
							headerCell.state.content = "%" + "{" + application.services.page.prettify(name) + "}";
							headerCell.state.sortFields = [{
								name: name
							}];
							headerCell.state.target = body.id;
							
							if (sortTemplates.length == 0) {
								application.services.page.normalizeAris(pageInstance.page, headerCell, "cell");
								// not rendered yet so we can't read it "live"
								application.services.page.normalizeAris(pageInstance.page, headerCell, "cell", [{name:"page-button-sort"}]);
								var options = headerCell.aris.components["page-button-sort"].options;
								options.push("direction_reverse");
								headerCell.aris.components["page-button-sort"].variant = "ghost";
							}
							else {
								headerCell.aris = sortTemplates[0].aris;
							}
						}
					});
					promise.resolve(pickResult);
				}, function() {
					// even if you add no fields, we continue generation
					promise.resolve(pickResult);
				});
				return promise;
			}
		});
		nabu.page.provide("page-generator", {
			name: "Form",
			description: "Generates a form that calls this operation",
			icon: "page/core/images/form.svg",
			accept: function(type, content) {
				if (type == "operation") {
					var operation = $services.swagger.operations[content];
					return (operation.method.toLowerCase() == "put" || operation.method.toLowerCase() == "post" || operation.method.toLowerCase() == "patch");
				}
			},
			automap: function(target, pageInstance, mapFrom) {
				var parameters = application.services.page.getAllAvailableParameters(pageInstance.page, pageInstance);
				var source = application.services.page.getChildDefinition({properties:parameters}, mapFrom);
				var definition = null;
				if (target.form.formType == "operation") {
					definition = application.services.page.getSwaggerOperationInputDefinition(target.form.operation);
				}
				else if (target.form.formType == "array") {
					var pageParameters = null;
					throw "Not implemented page parameter resolving yet";
					var childDefinition = application.services.page.getChildDefinition({properties:pageParameters}, target.form.array);
					definition = childDefinition && childDefinition.items && childDefinition.items ? childDefinition.items : {};
				}
				else if (target.form.formType == "function") {
					definition = application.services.page.getFunctionInput(target.form.function);
				}
				var sourceKeys = application.services.page.getSimpleKeysFor(source);
				var keys = application.services.page.getSimpleKeysFor(definition);
				if (!target.rendererBindings) {
					Vue.set(target, "rendererBindings", {});
				}
				
				// we want to optimize a form update to use the full record -> body mapping if possible
				// the assumption is we are working with an update event that emits the full record, and the form matches that record structure
				// currently we don't validate that the structures match, we just generate it like that
				// in the future we can do further checks or ask the user what they want to generate
				var hasBodyMapping = false;
				// we actually don't split out the non-simple keys so we can't check explicitly for body itself, only for its children
				var hasBodyKey = keys.filter(function(x) { return x.indexOf("body.") == 0 }).length > 0;
				// if we have a body to map to, check if we have a record to map from
				if (hasBodyKey) {
					var recordIndex = sourceKeys.indexOf(mapFrom + ".record");
					var hasRecordKey = sourceKeys.filter(function(x) { return x.indexOf("record.") == 0 }).length > 0;
					if (hasRecordKey) {
						hasBodyMapping = true;
						target.rendererBindings["body"] = mapFrom + ".record";
					}
				}
				
				keys.forEach(function(key) {
					// check that it is not mapped to the body
					var skipMapping = hasBodyMapping && key.indexOf("body.") == 0;
					// if we don't have a binding yet, try to find one in the source
					if (target.rendererBindings[key] == null && !skipMapping) {
						var name = key.replace(/^.*\.([^.]+)$/, "$1");
						var match = sourceKeys.filter(function(x) {
							// ends with...
							return x.length > name.length && x.indexOf("." + name) == x.length - name.length - 1;
						})[0];
						if (match) {
							Vue.set(target.rendererBindings, key, mapFrom + "." + match);
						}
					}
				});
			},
			guessListServiceForField: function(name) {
				name = name.replace(/^.*\.([^.]+)$/, "$1");
				name = name.replace(/^([^.]+)Id$/, "$1");
				return Object.keys(application.services.swagger.operations).filter(function(operationId) {
					return operationId.indexOf("." + name + ".") >= 0 && operationId.indexOf(".list") == operationId.length - ".list".length;
				})[0];
			},
			generateFields: function(type, content, pageInstance, runtimeAlias, fields, rowGenerator, cellGenerator, blacklist, timeout) {
				// if it is not a row, add it as a row
				if (!fields.cells) {
					fields = rowGenerator(fields);
				}
				var definition = null;
				if (type == "operation") {
					definition = application.services.page.getSwaggerOperationInputDefinition(content);
				}
				else if (type == "array") {
					var pageParameters = null;
					throw "Not implemented page parameter resolving yet";
					var childDefinition = application.services.page.getChildDefinition({properties:pageParameters}, content);
					definition = childDefinition && childDefinition.items && childDefinition.items ? childDefinition.items : {};
				}
				else if (type == "function") {
					definition = application.services.page.getFunctionInput(content);
				}
				
				var generator = nabu.page.providers("page-generator").filter(function(x) {
					return x.name.toLowerCase() == "form";
				})[0];
				
				
				var keys = application.services.page.getSimpleKeysFor(definition);
				keys.forEach(function(key) {
					// we don't generate a field for the id by default
					// this should only be available in updates mostly unless you have weird naming conventions
					if (!blacklist || blacklist.indexOf(key) < 0) {
						var cell = cellGenerator(fields);
						var child = application.services.page.getChildDefinition(definition, key);
						cell.alias = "page-form-text";
						// try to find a more specific alias
						if (child) {
							if (child.type == "integer") {
								cell.state.textType = "number";
							}
							else if (child.type == "boolean") {
								cell.alias = "page-form-switch";
							}
							else if (child.format && child.format.indexOf("date") >= 0) {
								cell.alias = "page-form-date";
							}
							else if (child.format == "uuid") {
								cell.alias = "page-form-enumeration-operation";
								var operationId = generator.guessListServiceForField(key);
								if (operationId) {
									cell.state.enumerationOperation = operationId;
									// we assume some reasonable defaults
									cell.state.enumerationOperationValue = "id";
									cell.state.enumerationOperationLabel = "name";
								}
							}
							// if we see a "password" field, use that type
							else if (key.toLowerCase().indexOf("password") >= 0) {
								cell.alias = "page-form-password";
							}
						}
						cell.state.name = runtimeAlias + "." + key;
						var cellName = application.services.page.prettify(key.replace(/^.*\.([^.]+)$/, "$1"));
						//cell.name = cellName;
						cell.state.label = "%" + "{" + cellName + "}";
						if (timeout) {
							cell.state.timeout = timeout;
						}
					}
				});
			},
			// generate into a cell or row
			generate: function(type, content, pageInstance, root, rowGenerator, cellGenerator) {
				var generator = nabu.page.providers("page-generator").filter(function(x) {
					return x.name.toLowerCase() == "form";
				})[0];
				
				var operation = $services.swagger.operations[content];
				var name = $services.page.guessNameFromOperation(content);
				var rawName = name;
				if (name != null) {
					name = name.substring(0, 1).toUpperCase() + name.substring(1);
				}
				
				// we must find the cells that contain the things we want to configure
				var formTitle = null;
				var buttonSubmit = null;
				var buttonCancel = null;
				var buttonClose = null;
				var formFields = null;
				var search = function(target) {
					if (target.name) {
						if (target.name.toLowerCase() == "form title") {
							formTitle = target;	
						}
						else if (target.name.toLowerCase() == "submit button") {
							buttonSubmit = target;
						}
						else if (target.name.toLowerCase() == "cancel button") {
							buttonCancel = target;
						}
						else if (target.name.toLowerCase() == "close button") {
							buttonCancel = target;
						}
						else if (target.name.toLowerCase() == "form fields") {
							formFields = target;
						}
					}
					if (target.cells) {
						target.cells.forEach(search);
					}
					else if (target.rows) {
						target.rows.forEach(search);
					}
				};
				search(root);
				
				root.renderer = "form";
				root.form = {
					formType: "operation",
					operation: content
				};
				
				var title = (name ? name : "");
				if (operation.method.toLowerCase() == "post") {
					root.runtimeAlias = "formCreate" + title;
					title = "Create " + title;
					if (buttonSubmit) {
						buttonSubmit.state.content = "%" + "{Create}";
					}
					if (rawName) {
						root.analysisId = "create-" + rawName;
					}
				}
				else if (operation.method.toLowerCase() == "delete") {
					root.runtimeAlias = "formDelete" + title;
					title = "Delete " + title;
					if (buttonSubmit) {
						buttonSubmit.state.content = "%" + "{Remove}";
					}
					if (rawName) {
						root.analysisId = "delete-" + rawName;
					}
				}
				else {
					root.runtimeAlias = "formUpdate" + title;
					title = "Update " + title;
					if (buttonSubmit) {
						buttonSubmit.state.content = "%" + "{Update}";
					}
					if (rawName) {
						root.analysisId = "update-" + rawName;
					}
				}
				// set the root name if there isn't one yet
				if (root.name == null) {
					root.name = title + "Form";
				}
				
				if (formTitle != null ){
					formTitle.state.content = "%" + "{" + title + "}";
				}
				
				// generate the fields for this form
				// this is likely to be reused later in other settings!
				generator.generateFields(type, content, pageInstance, root.runtimeAlias, formFields, rowGenerator, cellGenerator, ["id", "$serviceContext"]);
				
				// update the submit button so it triggers the submit
				if (buttonSubmit) {
					// use root triggers
					if (!buttonSubmit.triggers) {
						buttonSubmit.triggers = [];
					}
					if (buttonSubmit.triggers.length == 0) {
						buttonSubmit.triggers.push({
							trigger: "activate",
							closeEvent: true,
							actions: []
						})
					}
					var trigger = buttonSubmit.triggers[0];
					var submit = trigger.actions.filter(function(x) { return x.action == "submit" })[0];
					// if we don't have a submit action yet, add it
					if (!submit) {
						trigger.actions.push({
							type: "action",
							actionTarget: root.id,
							action: "submit",
							bindings: {}
						})
					}
					// otherwise, update the id to be in sync
					else {
						submit.actionTarget = root.id;
					}
					trigger.closeEvent = true;
				}

				// remove the last bit, for example if we have demo.rest.company.create, we want to find an operation
				// that starts with demo.rest.company, for example "demo.rest.company.list"
				var shared = content.replace(/\.[^.]+$/, "");
				var getDataComponent = function(targets) {
					for (var i = 0; i < targets.length; i++) {
						var target = targets[i];
						// do a minimalistic check
						if (target.renderer == "repeat" && target.repeat && target.repeat.operation) {
							if (target.repeat.operation.indexOf(shared) == 0) {
								return [target];
							}
						}
						if (target.rows) {
							var dataComponent = getDataComponent(target.rows);
							if (dataComponent != null) {
								dataComponent.push(target);
								return dataComponent;
							}
						}
						else if (target.cells) {
							var dataComponent = getDataComponent(target.cells);
							if (dataComponent != null) {
								dataComponent.push(target);
								return dataComponent;
							}
						}
					}
					return null;
				}
				
				// we scan the current page to see if there is a data component where we can add something
				var page = pageInstance.page;
				if (page.content.rows) {
					var dataComponent = getDataComponent(page.content.rows);
					// we are looking for a repeat within a table renderer
					// and it must not have a slot header or footer (if you for some reason put a repeat on that...?)
					if (dataComponent != null && dataComponent.length >= 2 && dataComponent[1].renderer == "table" && ["header", "footer"].indexOf(dataComponent[0].rendererSlot) < 0) {
						var table = dataComponent[1];
						var repeat = dataComponent[0];
						nabu.utils.vue.confirm({message:"Do you want to add this form to the existing table?"}).then(function() {
							var eventName = null;

							var buttonCell = null;
							
							if (operation.method.toLowerCase() == "post") {
								var tableTemplateRoot = application.services.page.getTemplateRoot(page, table, true);
								var findGlobalActions = function(target) {
									var result = null;
									if (target.name && target.name.toLowerCase() == "global actions") {
										result = target;
									}
									else if (target.cells) {
										target.cells.forEach(function(x) {
											if (!result) {
												result = findGlobalActions(x);
											}
										});
									}
									else if (target.rows) {
										target.rows.forEach(function(x) {
											if (!result) {
												result = findGlobalActions(x);
											}
										});
									}
									return result;
								}
								// find a footer child that has the name "Global Actions"
								/*
								var buttons = table.rows.filter(function(x) {
									return x.name.toLowerCase() == "global actions";
								})[0];
								*/
								buttons = findGlobalActions(tableTemplateRoot);
								console.log("finding global actions", tableTemplateRoot, buttons);
								if (!buttons) {
									buttons = rowGenerator(table);
								}
								eventName = "create" + (name ? name : "");
								buttonCell = cellGenerator(buttons);

								buttonCell.name = "Create" + (name ? " " + name : "");
								
								application.services.page.normalizeAris(pageInstance.page, buttonCell, "cell", [{name:"page-button"}]);
								buttonCell.aris.components["page-button"].variant = "primary";
								
								// make sure we send out a created event once done
/*								dataComponent.state.actions.push({
									name: "create" + (name ? name : ""),
									global: true,
									label: "%" + "{Create}",
									type: "button",
									class: "primary"
								});
								if (!dataComponent.state.refreshOn) {
									Vue.set(dataComponent.state, "refreshOn", []);
								}
								// make sure we refresh on create
								dataComponent.state.refreshOn.push("created" + (name ? name : ""));*/
							}
							else if (operation.method.toLowerCase() == "put" || operation.method.toLowerCase() == "patch") {
								// find a repeat column that has the name "Local Actions"
								var buttons = repeat.cells.filter(function(x) {
									return x.name && x.name.toLowerCase() == "local actions";
								})[0];
								
								if (!buttons) {
									buttons = cellGenerator(repeat);
									buttons.name = "Local actions";
									// if we add a new column for the buttons, we also need to add it to the header
									var headers = table.rows.filter(function(x) {
										return x.rendererSlot == "header";
									});
									headers.forEach(function(x) {
										var cell = cellGenerator(x);
										cell.name = "Local actions header";
										// render _something_
										cell.alias = "typography-fragment";
									});
									
									// by default we generate no header content
									// and we set the borders to be disabled on the local actions, that gives it a floaty feeling
									application.services.page.normalizeAris(pageInstance.page, buttons, "cell", [{name:"table-column"}]);
									//buttons.aris.components["table-column"].options.push("border_none");
									//buttons.aris.components["table-column"].modifiers.push("small");
									buttons.aris.components["table-column"].variant = "local-actions";
								}
								var buttonRow = null;
								// if we don't have a row yet, add it
								if (buttons.rows.length == 0) {
									buttonRow = rowGenerator(buttons);
									application.services.page.normalizeAris(pageInstance.page, buttonRow, "row");
									//buttonRow.aris.components["page-row"].options.push("gap_small");
									//buttonRow.aris.components["page-row"].options.push("wrap_none");
								}
								else {
									buttonRow = buttons.rows[0];
								}
								
								buttonCell = cellGenerator(buttonRow);
								
								eventName = "update" + (name ? name : "");
								buttonCell.name = "Update" + (name ? " " + name : "");
								application.services.page.normalizeAris(pageInstance.page, buttonCell, "cell");
								application.services.page.normalizeAris(pageInstance.page, buttonCell, "cell", [{name:"page-button"}]);
//								buttonCell.aris.components["page-button"].options.push("size_small");
								buttonCell.aris.components["page-button"].variant = "ghost";
								root.form.synchronize = true;
								
								if (table.aris.components["table"].modifiers.indexOf("has-local-actions") < 0) {
									table.aris.components["table"].modifiers.push("has-local-actions");
								}
								
								// make sure we synchronize changes so we don't need to refresh
								// allow for some time to stabilize events etc so we have correct definitions
								// not very clean, i know...
								if (formFields) {
									setTimeout(function() {
										// generate an automatic mapping for the inputs
										generator.automap(root, pageInstance, eventName);
									}, 300);
								}
							}
							
							// when creating (or deleting), we want to do a refresh
							// because of potential (and likely) paging, we can't simply add the result (even if we got it back)
							if (buttonSubmit && operation.method.toLowerCase() == "post") {
								buttonSubmit.triggers[0].actions.push({
									type: "action",
									action: "refresh",
									actionTarget: repeat.id,
									bindings: {}
								});
							}
							
							if (eventName) {
								root.on = eventName;
								if (!root.state) {
									root.state = {};
								}
								root.state.hideMode = "event";
								// we want the form in a prompt
								root.target = "prompt";
								
								// reset events so it gets picked up
								pageInstance.resetEvents();
							}
							
							if (buttonCell) {
								buttonCell.alias = "page-button";
								buttonCell.state = {
									content: operation.method.toLowerCase() == "post" ? "%" + "{Create}" : null,
									icon: operation.method.toLowerCase() == "post" ? "plus" : "pencil-alt",
								}
								buttonCell.triggers = [{
									trigger: "activate",
									actions: [{
										type: "event",
										event: {
											name: eventName,
											eventFields: []
										}
									}]
								}];
								// we do need to add the current record
								if (operation.method.toLowerCase() == "put" || operation.method.toLowerCase() == "patch") {
									var action = buttonCell.triggers[0].actions[0];
									action.event.eventFields.push({
										name: "record",
										stateValue: repeat.runtimeAlias + ".record"
									});
								}
							}
						});
					}
				}
			},
			initialize: function(type, content, pageInstance, rowGenerator, cellGenerator) {
				var generator = nabu.page.providers("page-generator").filter(function(x) {
					return x.name.toLowerCase() == "form";
				})[0];
				
				
				// TODO: we check all the available templates for forms
				// there should be at least one that is distributed with the core
				// if there is only one, we use immediately, otherwise we let the user choose which templates to use
				// we inject the templates and expect certain cells (with certain names) to be present where we inject stuff
				
				var availableTemplates = application.services.page.templates.filter(function(x) {
					var content = JSON.parse(x.content);
					// in this case we always work cell based
					return content.type == "page-cell"
						&& content.content.renderer == "form";
				});
				
				var applyTemplate = function(template) {
					// row at the root of the page
					var row = rowGenerator();
					// the cell that contains the actual form
					// we use a cell because you might want to show it in a popup etc
					var root = cellGenerator(row);
					var templateContent = JSON.parse(template.content).content;
					application.services.page.renumber(pageInstance.page, templateContent);
					// do a reactive merge
					Object.keys(templateContent).forEach(function(key) {
						Vue.set(root, key, templateContent[key]);
					});
					generator.generate(type, content, pageInstance, root, rowGenerator, cellGenerator);
				}
				
				if (availableTemplates.length == 0) {
					nabu.utils.vue.confirm({message:"There are no applicable form templates available, add at least one to generate a form"});
					return;
				}
				// just apply it
				else if (availableTemplates.length == 1) {
					applyTemplate(availableTemplates[0]);
				}
				else {
					var selector = Vue.component("page-components-selector");
					nabu.utils.vue.prompt(function() {
						return new selector({propsData: {
							components: availableTemplates
						}});
					}).then(function(chosen) {
						applyTemplate(chosen);
					});
				}
				
			}
		});
		
		// renderers, not used up to this point, specification has been made much more powerful
		/*
		nabu.page.provide("page-renderer", {
			name: "slider",
			component: "page-renderer-slider",
			type: "row",
			properties: ["group", "tag"]
		});
		*/
		
		nabu.page.provide("page-type", {
			name: "email",
			pageTag: "e-root",
			rowTag: "e-row",
			cellTag: "e-columns"
		});
		
		// functions
		nabu.page.provide("page-function", {
			id: "page.setAcceptedCookies",
			async: false,
			implementation: function(input, $services, $value, resolve, reject) {
				// we are expecting an object where each key is a boolean true or false
				// alternatively an array is also good
				// if true, the cookie is accepted, if not, it isn't
				var object = input.cookieObject;
				var accepted = [];
				if (object instanceof Array) {
					nabu.utils.arrays.merge(accepted, object);
				}
				else if (object) {
					Object.keys(object).forEach(function(key) {
						if (object[key]) {
							accepted.push(key);
						}
					});
				}
				$services.page.acceptCookies(accepted);
			},
			inputs: [{
				"name": "cookieObject",
				"required": true
			}]
		});
		
		nabu.page.provide("page-icon", {
			name: "Font Awesome",
			html: function(icon, additionalCss) {
				// if you don't include the fa-prefix (of any kind, like fas etc)
				// we assume you want to remain agnostic of the fa prefix and readd it
				// the chance for collission is low and can still be addressed using css
				return "<span class='icon fa " + icon + (additionalCss ? " " + additionalCss : "") + (icon.indexOf("fa") != 0 ? " fa-" + icon : "") + "'></span>";
			},
			priority: -1,
			allowOther: true,
			icons: []
		});
		
		nabu.page.provide("page-format", {
			html: true,
			name: "markdown",
			namespace: "nabu",
			skipCompile: false,
			skipSanitize: false,
			format: function(value, fragment, page, cell, record, updater) {
				if (nabu.formatters && nabu.formatters.markdown) {
					nabu.formatters.markdown.syntaxProviders.form = function(content, parameters) {
						return "<n-form-text v-model='value' label='" + content + "'/><div>test</div>";
					}
					var blocks = nabu.formatters.markdown.parse(value);
					var parameters = {};
					var self = this;
					parameters.tagUrl = "http://google.com?q=";
					parameters.variables = {
						right: "left"
					}
					var result = nabu.formatters.markdown.asHtml(blocks, parameters);
					// if we have promises, we need to do some retroactive resolving
					if (Object.keys(result.promises).length > 0) {
						// we wait until at least this is rendered (just in case we have fast resolving promises)
						Vue.nextTick(function() {
							nabu.formatters.markdown.replacePromises(result.promises);
						})
					}
					return "<article class='is-article'>" + result.content + "</article>";
				}
				return value;
			}
		});
		
		nabu.page.provide("page-format", {
			html: true,
			name: "icon",
			namespace: "nabu",
			skipCompile: false,
			skipSanitize: false,
			format: function(value, fragment, page, cell, record, updater) {
				return value ? "<icon name='" + value + "'/>" : null;
			}
		});
		
		nabu.page.provide("page-format", {
			html: true,
			name: "code",
			namespace: "nabu",
			skipCompile: false,
			skipSanitize: false,
			format: function(value, fragment, page, cell, record, updater) {
				if (nabu.formatters && nabu.formatters.markdown) {
					var format = fragment.codeFormat ? fragment.codeFormat : "";
					nabu.formatters.markdown.syntaxProviders.form = function(content, parameters) {
						return "<n-form-text v-model='value' label='" + content + "'/><div>test</div>";
					}
					var blocks = nabu.formatters.markdown.parse("```" + format + "\n" + value + "\n```");
					var parameters = {};
					var self = this;
					parameters.tagUrl = "http://google.com?q=";
					parameters.variables = {
						right: "left"
					}
					var result = nabu.formatters.markdown.asHtml(blocks, parameters);
					// if we have promises, we need to do some retroactive resolving
					if (Object.keys(result.promises).length > 0) {
						// we wait until at least this is rendered (just in case we have fast resolving promises)
						Vue.nextTick(function() {
							nabu.formatters.markdown.replacePromises(result.promises);
						})
					}
					return "<article class='is-article'>" + result.content + "</article>";
				}
				return value;
			},
			configure: "page-format-code-configure"
		});
		Vue.component("page-format-code-configure", {
			props: {
				page: {
					type: Object,
					required: true
				},
				cell: {
					type: Object,
					required: true
				},
				fragment: {
					type: Object,
					required: true
				}
			},
			template: "<div><n-form-combo v-model='fragment.codeFormat' label='Code format' :items=\"['xml', 'json', 'css', 'sql', 'glue', 'java', 'javascript', 'python']\"/></div>"
		});
		
		
		// formatters
		nabu.page.provide("page-format", {
			format: function(id, fragment, page, cell, record, updater) {
				var properties = {};
				var self = this;
				var pageInstance = $services.page.getPageInstance(page, this);
				if (fragment && fragment.resolveOperationBinding) {
					properties = {};
					Object.keys(fragment.resolveOperationBinding).map(function(key) {
						if (fragment.resolveOperationBinding[key]) {
							// looking inside the current record
							if (fragment.resolveOperationBinding[key].indexOf("record.") == 0) {
								properties[key] = record ? $services.page.getValue(record, fragment.resolveOperationBinding[key].substring("record.".length)) : null;
							}
							else {
								var bindingValue = $services.page.getBindingValue(pageInstance, fragment.resolveOperationBinding[key]);
								properties[key] = bindingValue;
							}
						}
					});
				}
				if (!properties["$serviceContext"]) {
					properties["$serviceContext"] = pageInstance.getServiceContext();
				}
				var result = $services.pageResolver.resolve(fragment.resolveOperation, fragment.resolveOperationIds, fragment.resolveOperationId, id, properties);
				if (result && fragment.resolveOperationLabelComplex) {
					return !fragment.complexLabel ? fragment.complexLabel : $services.typography.replaceVariables(pageInstance, fragment, fragment.complexLabel, $services.q.reject(), result);
				}
				else {
					return result && fragment.resolveOperationLabel ? result[fragment.resolveOperationLabel] : result;
				}
			},
			skipCompile: true,
			html: true,
			configure: "page-format-resolver",
			name: "resolve",
			namespace: "nabu.page"
		});
		
		nabu.page.provide("page-format", {
			format: function(value) {
				try {
					var page = new nabu.page.views.Page({
						propsData: {
							embedded: true,
							page: {
								name: "dynamic-page-" + application.services.page.counter++,
								content: application.services.page.normalize(value ? JSON.parse(value) : {})
							}
						}
					});
					return page.$mount().$el;
				}
				catch (exception) {
					return null;
				}
			},
			html: true,
			skipCompile: true,
			name: "page",
			namespace: "nabu.page"
		});
		
		nabu.page.provide("page-format", {
			format: function(value) {
				return "<a ref='noopener noreferrer nofollow' href='tel:" + value + "'>" + value + "</a>";
			},
			html: true,
			skipCompile: true,
			name: "phone",
			namespace: "nabu.page"
		});
		
		nabu.page.provide("page-format", {
			format: function(value) {
				return "<a ref='noopener noreferrer nofollow' href='mailto:" + value + "'>" + value + "</a>";
			},
			html: true,
			skipCompile: true,
			name: "email",
			namespace: "nabu.page"
		});
		
		Vue.component("page-percentage-slider-configurator", {
			props: {
				page: {
					type: Object,
					required: true
				},
				cell: {
					type: Object,
					required: true
				},
				fragment: {
					type: Object,
					required: true
				}
			},
			template: "<div><n-form-switch v-model='fragment.percentageReverse' label='Reverse percentage'/><n-form-switch v-model='fragment.percentageSmallRange' label='Is [0-1] range' /><n-form-text v-model='fragment.round' label='Round Number'/></div>"
		});
			
		nabu.page.provide("page-format", {
			format: function(value, fragment, page, cell) {
				if (fragment && fragment.percentageSmallRange && value) {
					value *= 100;
				}
				if (fragment && fragment.percentageReverse && value != null) {
					value = 100 - value;
				}
				if (fragment && fragment.round && value != null) {
					value = parseFloat($services.formatter.number(value, parseInt(fragment.round)));
				}
				// make sure it ends up within the range, otherwise we can't display it well
				// it seems that if you set a negative number, it just takes Math.abs()?
				if (value < 0) {
					value = 0;
				}
				if (value > 100) {
					value = 100;
				}
				return "<input disabled='true' type='range' value='" + value + "' minimum='0' step='1' maximum='100' :value='" + value + "'/>";
			},
			html: true,
			skipCompile: false,
			name: "percentage-slider",
			configure: "page-percentage-slider-configurator",
			namespace: "nabu.page"
		});
		
		return $services.$register({
			page: nabu.page.services.Page,
			pageResolver: nabu.page.services.PageResolver,
			resizer: nabu.page.services.Resizer,
			formatter: nabu.page.services.Formatter
		});
	});
	
});
let DragDropTouch;
(function (DragDropTouch_1) {
    'use strict';
    /**
     * Object used to hold the data that is being dragged during drag and drop operations.
     *
     * It may hold one or more data items of different types. For more information about
     * drag and drop operations and data transfer objects, see
     * <a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer">HTML Drag and Drop API</a>.
     *
     * This object is created automatically by the @see:DragDropTouch singleton and is
     * accessible through the @see:dataTransfer property of all drag events.
     */
    let DataTransfer = (function () {
        function DataTransfer() {
            this._dropEffect = 'move';
            this._effectAllowed = 'all';
            this._data = {};
        }
        Object.defineProperty(DataTransfer.prototype, "dropEffect", {
            /**
             * Gets or sets the type of drag-and-drop operation currently selected.
             * The value must be 'none',  'copy',  'link', or 'move'.
             */
            get: function () {
                return this._dropEffect;
            },
            set: function (value) {
                this._dropEffect = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DataTransfer.prototype, "effectAllowed", {
            /**
             * Gets or sets the types of operations that are possible.
             * Must be one of 'none', 'copy', 'copyLink', 'copyMove', 'link',
             * 'linkMove', 'move', 'all' or 'uninitialized'.
             */
            get: function () {
                return this._effectAllowed;
            },
            set: function (value) {
                this._effectAllowed = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DataTransfer.prototype, "types", {
            /**
             * Gets an array of strings giving the formats that were set in the @see:dragstart event.
             */
            get: function () {
                return Object.keys(this._data);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Removes the data associated with a given type.
         *
         * The type argument is optional. If the type is empty or not specified, the data
         * associated with all types is removed. If data for the specified type does not exist,
         * or the data transfer contains no data, this method will have no effect.
         *
         * @param type Type of data to remove.
         */
        DataTransfer.prototype.clearData = function (type) {
            if (type !== null) {
                delete this._data[type.toLowerCase()];
            }
            else {
                this._data = {};
            }
        };
        /**
         * Retrieves the data for a given type, or an empty string if data for that type does
         * not exist or the data transfer contains no data.
         *
         * @param type Type of data to retrieve.
         */
        DataTransfer.prototype.getData = function (type) {
            let lcType = type.toLowerCase(),
                data = this._data[lcType];
            if (lcType === "text" && data == null) {
                data = this._data["text/plain"]; // getData("text") also gets ("text/plain")
            }
            return data || "";
        };
        /**
         * Set the data for a given type.
         *
         * For a list of recommended drag types, please see
         * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Recommended_Drag_Types.
         *
         * @param type Type of data to add.
         * @param value Data to add.
         */
        DataTransfer.prototype.setData = function (type, value) {
            this._data[type.toLowerCase()] = value;
        };
        /**
         * Set the image to be used for dragging if a custom one is desired.
         *
         * @param img An image element to use as the drag feedback image.
         * @param offsetX The horizontal offset within the image.
         * @param offsetY The vertical offset within the image.
         */
        DataTransfer.prototype.setDragImage = function (img, offsetX, offsetY) {
            let ddt = DragDropTouch._instance;
            ddt._imgCustom = img;
            ddt._imgOffset = { x: offsetX, y: offsetY };
        };
        return DataTransfer;
    }());
    DragDropTouch_1.DataTransfer = DataTransfer;
    /**
     * Defines a class that adds support for touch-based HTML5 drag/drop operations.
     *
     * The @see:DragDropTouch class listens to touch events and raises the
     * appropriate HTML5 drag/drop events as if the events had been caused
     * by mouse actions.
     *
     * The purpose of this class is to enable using existing, standard HTML5
     * drag/drop code on mobile devices running IOS or Android.
     *
     * To use, include the DragDropTouch.js file on the page. The class will
     * automatically start monitoring touch events and will raise the HTML5
     * drag drop events (dragstart, dragenter, dragleave, drop, dragend) which
     * should be handled by the application.
     *
     * For details and examples on HTML drag and drop, see
     * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Drag_operations.
     */
    let DragDropTouch = (function () {
        /**
         * Initializes the single instance of the @see:DragDropTouch class.
         */
        function DragDropTouch() {
            this._lastClick = 0;
            // enforce singleton pattern
            if (DragDropTouch._instance) {
                throw 'DragDropTouch instance already created.';
            }
            // detect passive event support
            // https://github.com/Modernizr/Modernizr/issues/1894
            let supportsPassive = false;
            document.addEventListener('test', function () { }, {
                get passive() {
                    supportsPassive = true;
                    return true;
                }
            });
            // listen to touch events
            if (navigator.maxTouchPoints) {
                let d = document, 
                    ts = this._touchstart.bind(this), 
                    tm = this._touchmove.bind(this), 
                    te = this._touchend.bind(this), 
                    opt = supportsPassive ? { passive: false, capture: false } : false;
                d.addEventListener('touchstart', ts, opt);
                d.addEventListener('touchmove', tm, opt);
                d.addEventListener('touchend', te);
                d.addEventListener('touchcancel', te);
            }
        }
        /**
         * Gets a reference to the @see:DragDropTouch singleton.
         */
        DragDropTouch.getInstance = function () {
            return DragDropTouch._instance;
        };
        // ** event handlers
        DragDropTouch.prototype._touchstart = function (e) {
            let _this = this;
            if (this._shouldHandle(e)) {
                // clear all variables
                this._reset();
                // get nearest draggable element
                let src = this._closestDraggable(e.target);
                if (src) {
                    // give caller a chance to handle the hover/move events
                    if (!this._dispatchEvent(e, 'mousemove', e.target) &&
                        !this._dispatchEvent(e, 'mousedown', e.target)) {
                        // get ready to start dragging
                        this._dragSource = src;
                        this._ptDown = this._getPoint(e);
                        this._lastTouch = e;

                        // do not prevent default (so input elements keep working)
                        //e.preventDefault();

                        // show context menu if the user hasn't started dragging after a while
                        setTimeout(function () {
                            if (_this._dragSource === src && _this._img === null) {
                                if (_this._dispatchEvent(e, 'contextmenu', src)) {
                                    _this._reset();
                                }
                            }
                        }, DragDropTouch._CTXMENU);
                        if (DragDropTouch._ISPRESSHOLDMODE) {
                            this._pressHoldInterval = setTimeout(function () {
                                _this._isDragEnabled = true;
                                _this._touchmove(e);
                            }, DragDropTouch._PRESSHOLDAWAIT);
                        }
                    }
                }
            }
        };
        DragDropTouch.prototype._touchmove = function (e) {
            if (this._shouldCancelPressHoldMove(e)) {
              this._reset();
              return;
            }
            if (this._shouldHandleMove(e) || this._shouldHandlePressHoldMove(e)) {
                // see if target wants to handle move
                let target = this._getTarget(e);
                if (this._dispatchEvent(e, 'mousemove', target)) {
                    this._lastTouch = e;
                    e.preventDefault();
                    return;
                }
                // start dragging
                if (this._dragSource && !this._img && this._shouldStartDragging(e)) {
                    if (this._dispatchEvent(this._lastTouch, 'dragstart', this._dragSource)) {
                        // target canceled the drag event
                        this._dragSource = null;
                        return;
                    }
                    this._createImage(e);
                    this._dispatchEvent(e, 'dragenter', target);
                }
                // continue dragging
                if (this._img) {
                    this._lastTouch = e;
                    e.preventDefault(); // prevent scrolling
                    this._dispatchEvent(e, 'drag', this._dragSource);
                    if (target !== this._lastTarget) {
                        this._dispatchEvent(this._lastTouch, 'dragleave', this._lastTarget);
                        this._dispatchEvent(e, 'dragenter', target);
                        this._lastTarget = target;
                    }
                    this._moveImage(e);
                    this._isDropZone = this._dispatchEvent(e, 'dragover', target);
                }
            }
        };
        DragDropTouch.prototype._touchend = function (e) {
            if (this._shouldHandle(e)) {
                // see if target wants to handle up
                if (this._dispatchEvent(this._lastTouch, 'mouseup', e.target)) {
                    e.preventDefault();
                    return;
                }
                // user clicked the element but didn't drag, so clear the source and simulate a click
                if (!this._img) {
                    this._dragSource = null;
                    this._dispatchEvent(this._lastTouch, 'click', e.target);
                    this._lastClick = Date.now();
                }
                // finish dragging
                this._destroyImage();
                if (this._dragSource) {
                    if (e.type.indexOf('cancel') < 0 && this._isDropZone) {
                        this._dispatchEvent(this._lastTouch, 'drop', this._lastTarget);
                    }
                    this._dispatchEvent(this._lastTouch, 'dragend', this._dragSource);
                    this._reset();
                }
            }
        };
        // ** utilities
        // ignore events that have been handled or that involve more than one touch
        DragDropTouch.prototype._shouldHandle = function (e) {
            return e &&
                !e.defaultPrevented &&
                e.touches && e.touches.length < 2;
        };

        // use regular condition outside of press & hold mode
        DragDropTouch.prototype._shouldHandleMove = function (e) {
          return !DragDropTouch._ISPRESSHOLDMODE && this._shouldHandle(e);
        };

        // allow to handle moves that involve many touches for press & hold
        DragDropTouch.prototype._shouldHandlePressHoldMove = function (e) {
          return DragDropTouch._ISPRESSHOLDMODE &&
              this._isDragEnabled && e && e.touches && e.touches.length;
        };

        // reset data if user drags without pressing & holding
        DragDropTouch.prototype._shouldCancelPressHoldMove = function (e) {
          return DragDropTouch._ISPRESSHOLDMODE && !this._isDragEnabled &&
              this._getDelta(e) > DragDropTouch._PRESSHOLDMARGIN;
        };

        // start dragging when specified delta is detected
        DragDropTouch.prototype._shouldStartDragging = function (e) {
            let delta = this._getDelta(e);
            return delta > DragDropTouch._THRESHOLD ||
                (DragDropTouch._ISPRESSHOLDMODE && delta >= DragDropTouch._PRESSHOLDTHRESHOLD);
        }

        // clear all members
        DragDropTouch.prototype._reset = function () {
            this._destroyImage();
            this._dragSource = null;
            this._lastTouch = null;
            this._lastTarget = null;
            this._ptDown = null;
            this._isDragEnabled = false;
            this._isDropZone = false;
            this._dataTransfer = new DataTransfer();
            clearInterval(this._pressHoldInterval);
        };
        // get point for a touch event
        DragDropTouch.prototype._getPoint = function (e, page) {
            if (e && e.touches) {
                e = e.touches[0];
            }
            return { x: page ? e.pageX : e.clientX, y: page ? e.pageY : e.clientY };
        };
        // get distance between the current touch event and the first one
        DragDropTouch.prototype._getDelta = function (e) {
            if (DragDropTouch._ISPRESSHOLDMODE && !this._ptDown) { return 0; }
            let p = this._getPoint(e);
            return Math.abs(p.x - this._ptDown.x) + Math.abs(p.y - this._ptDown.y);
        };
        // get the element at a given touch event
        DragDropTouch.prototype._getTarget = function (e) {
            let pt = this._getPoint(e),
                el = document.elementFromPoint(pt.x, pt.y);
            while (el && getComputedStyle(el).pointerEvents == 'none') {
                el = el.parentElement;
            }
            return el;
        };
        // create drag image from source element
        DragDropTouch.prototype._createImage = function (e) {
            // just in case...
            if (this._img) {
                this._destroyImage();
            }
            // create drag image from custom element or drag source
            let src = this._imgCustom || this._dragSource;
            this._img = src.cloneNode(true);
            this._copyStyle(src, this._img);
            this._img.style.top = this._img.style.left = '-9999px';
            // if creating from drag source, apply offset and opacity
            if (!this._imgCustom) {
                let rc = src.getBoundingClientRect(),
                    pt = this._getPoint(e);
                this._imgOffset = { x: pt.x - rc.left, y: pt.y - rc.top };
                this._img.style.opacity = DragDropTouch._OPACITY.toString();
            }
            // add image to document
            this._moveImage(e);
            document.body.appendChild(this._img);
        };
        // dispose of drag image element
        DragDropTouch.prototype._destroyImage = function () {
            if (this._img && this._img.parentElement) {
                this._img.parentElement.removeChild(this._img);
            }
            this._img = null;
            this._imgCustom = null;
        };
        // move the drag image element
        DragDropTouch.prototype._moveImage = function (e) {
            let _this = this;
            requestAnimationFrame(function () {
                if (_this._img) {
                    let pt = _this._getPoint(e, true),
                        s = _this._img.style;
                    s.position = 'absolute';
                    s.pointerEvents = 'none';
                    s.zIndex = '999999';
                    s.left = Math.round(pt.x - _this._imgOffset.x) + 'px';
                    s.top = Math.round(pt.y - _this._imgOffset.y) + 'px';
                }
            });
        };
        // copy properties from an object to another
        DragDropTouch.prototype._copyProps = function (dst, src, props) {
            for (let i = 0; i < props.length; i++) {
                let p = props[i];
                dst[p] = src[p];
            }
        };
        DragDropTouch.prototype._copyStyle = function (src, dst) {
            // remove potentially troublesome attributes
            DragDropTouch._rmvAtts.forEach(function (att) {
                dst.removeAttribute(att);
            });
            // copy canvas content
            if (src instanceof HTMLCanvasElement) {
                let cSrc = src,
                    cDst = dst;
                cDst.width = cSrc.width;
                cDst.height = cSrc.height;
                cDst.getContext('2d').drawImage(cSrc, 0, 0);
            }
            // copy style (without transitions)
            let cs = getComputedStyle(src);
            for (let i = 0; i < cs.length; i++) {
                let key = cs[i];
                if (key.indexOf('transition') < 0) {
                    dst.style[key] = cs[key];
                }
            }
            dst.style.pointerEvents = 'none';
            // and repeat for all children
            for (let i = 0; i < src.children.length; i++) {
                this._copyStyle(src.children[i], dst.children[i]);
            }
        };
        // compute missing offset or layer property for an event
        DragDropTouch.prototype._setOffsetAndLayerProps = function (e, target) {
            let rect = undefined;
            if (e.offsetX === undefined) {
                rect = target.getBoundingClientRect();
                e.offsetX = e.clientX - rect.x;
                e.offsetY = e.clientY - rect.y;
            }
            if (e.layerX === undefined) {
                rect = rect || target.getBoundingClientRect();
                e.layerX = e.pageX - rect.left;
                e.layerY = e.pageY - rect.top;
            }
        }
        DragDropTouch.prototype._dispatchEvent = function (e, type, target) {
            if (e && target) {
                //let evt = document.createEvent('Event'), t = e.touches ? e.touches[0] : e; // deprecated
                //evt.initEvent(type, true, true); // deprecated
                let evt = new Event(type, { bubbles: true, cancelable: true }),
                    touch = e.touches ? e.touches[0] : e;
                evt.button = 0;
                evt.which = evt.buttons = 1;
                this._copyProps(evt, e, DragDropTouch._kbdProps);
                this._copyProps(evt, touch, DragDropTouch._ptProps);
                this._setOffsetAndLayerProps(evt, target);
                evt.dataTransfer = this._dataTransfer;
                target.dispatchEvent(evt);
                return evt.defaultPrevented;
            }
            return false;
        };
        // gets an element's closest draggable ancestor
        // <img> and <a> elements are draggable by default
        DragDropTouch.prototype._closestDraggable = function (e) {
            for (; e; e = e.parentElement) {
                if (/*e.hasAttribute('draggable') &&*/ e.draggable) {
                    return e;
                }
            }
            return null;
        };
        return DragDropTouch;
    }());
    /*private*/ DragDropTouch._instance = new DragDropTouch(); // singleton
    // constants
    DragDropTouch._THRESHOLD = 5; // pixels to move before drag starts
    DragDropTouch._OPACITY = 0.5; // drag image opacity
    DragDropTouch._DBLCLICK = 500; // max ms between clicks in a double click
    DragDropTouch._CTXMENU = 900; // ms to hold before raising 'contextmenu' event
    DragDropTouch._ISPRESSHOLDMODE = false; // decides of press & hold mode presence
    DragDropTouch._PRESSHOLDAWAIT = 400; // ms to wait before press & hold is detected
    DragDropTouch._PRESSHOLDMARGIN = 25; // pixels that finger might shiver while pressing
    DragDropTouch._PRESSHOLDTHRESHOLD = 0; // pixels to move before drag starts
    // copy styles/attributes from drag source to drag image element
    DragDropTouch._rmvAtts = 'id,class,style,draggable'.split(',');
    // synthesize and dispatch an event
    // returns true if the event has been handled (e.preventDefault == true)
    DragDropTouch._kbdProps = 'altKey,ctrlKey,metaKey,shiftKey'.split(',');
    DragDropTouch._ptProps = 'pageX,pageY,clientX,clientY,screenX,screenY,offsetX,offsetY'.split(',');
    DragDropTouch_1.DragDropTouch = DragDropTouch;
})(DragDropTouch || (DragDropTouch = {}));


// source located at: https://github.com/privatenumber/vue-frag
// compiled located at: https://unpkg.com/vue-frag@1.4.3/dist/frag.js
// compiled is missing explicit directive and component declartions (added at bottom here)
(function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, 
    global.Frag = factory());
})(this, (function() {
    "use strict";
    var $placeholder = Symbol();
    var $fakeParent = Symbol();
    var $nextSiblingPatched = Symbol();
    var $childNodesPatched = Symbol();
    var isFrag = function isFrag(node) {
        return "frag" in node;
    };
    var parentNodeDescriptor = {
        get: function get() {
            return this[$fakeParent] || this.parentElement;
        },
        configurable: true
    };
    var patchParentNode = function patchParentNode(node, fakeParent) {
        if ($fakeParent in node) {
            return;
        }
        node[$fakeParent] = fakeParent;
        Object.defineProperty(node, "parentNode", parentNodeDescriptor);
    };
    var nextSiblingDescriptor = {
        get: function get() {
            var childNodes = this.parentNode.childNodes;
            var index = childNodes.indexOf(this);
            if (index > -1) {
                return childNodes[index + 1] || null;
            }
            return null;
        }
    };
    var patchNextSibling = function patchNextSibling(node) {
        if ($nextSiblingPatched in node) {
            return;
        }
        node[$nextSiblingPatched] = true;
        Object.defineProperty(node, "nextSibling", nextSiblingDescriptor);
    };
    var getTopFragment = function getTopFragment(node, fromParent) {
        while (node.parentNode !== fromParent) {
            var _node = node, parentNode = _node.parentNode;
            if (parentNode) {
                node = parentNode;
            }
        }
        return node;
    };
    var getChildNodes;
    var getChildNodesWithFragments = function getChildNodesWithFragments(node) {
        if (!getChildNodes) {
            var _childNodesDescriptor = Object.getOwnPropertyDescriptor(Node.prototype, "childNodes");
            getChildNodes = _childNodesDescriptor.get;
        }
        var realChildNodes = getChildNodes.apply(node);
        var childNodes = Array.from(realChildNodes).map((function(childNode) {
            return getTopFragment(childNode, node);
        }));
        return childNodes.filter((function(childNode, index) {
            return childNode !== childNodes[index - 1];
        }));
    };
    var childNodesDescriptor = {
        get: function get() {
            return this.frag || getChildNodesWithFragments(this);
        }
    };
    var firstChildDescriptor = {
        get: function get() {
            return this.childNodes[0] || null;
        }
    };
    function hasChildNodes() {
        return this.childNodes.length > 0;
    }
    var patchChildNodes = function patchChildNodes(node) {
        if ($childNodesPatched in node) {
            return;
        }
        node[$childNodesPatched] = true;
        Object.defineProperties(node, {
            childNodes: childNodesDescriptor,
            firstChild: firstChildDescriptor
        });
        node.hasChildNodes = hasChildNodes;
    };
    function before() {
        var _this$frag$;
        (_this$frag$ = this.frag[0]).before.apply(_this$frag$, arguments);
    }
    function remove() {
        var frag = this.frag;
        var removed = frag.splice(0, frag.length);
        removed.forEach((function(node) {
            node.remove();
        }));
    }
    var getFragmentLeafNodes = function getFragmentLeafNodes(children) {
        var _Array$prototype;
        return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, children.map((function(childNode) {
            return isFrag(childNode) ? getFragmentLeafNodes(childNode.frag) : childNode;
        })));
    };
    var addPlaceholder = function addPlaceholder(node, insertBeforeNode) {
        var placeholder = node[$placeholder];
        insertBeforeNode.before(placeholder);
        patchParentNode(placeholder, node);
        node.frag.unshift(placeholder);
    };
    function removeChild(node) {
        if (isFrag(this)) {
            var hasChildInFragment = this.frag.indexOf(node);
            if (hasChildInFragment > -1) {
                var _this$frag$splice = this.frag.splice(hasChildInFragment, 1), removedNode = _this$frag$splice[0];
                if (this.frag.length === 0) {
                    addPlaceholder(this, removedNode);
                }
                node.remove();
            }
        } else {
            var children = getChildNodesWithFragments(this);
            var hasChild = children.indexOf(node);
            if (hasChild > -1) {
                node.remove();
            }
        }
        return node;
    }
    function insertBefore(insertNode, insertBeforeNode) {
        var _this = this;
        var insertNodes = insertNode.frag || [ insertNode ];
        
        // CUSTOM PATCH: by default "adding" children to something that is already rendered will result in randomized order
        // this prevents the randomized ordering:
		var isAlreadyInserted = insertNodes.every(function(n) {
			return n[$fakeParent] === _this;
		});
		if (isAlreadyInserted) {
			insertNodes.forEach(function(node) {
				if (node !== insertBeforeNode) {
					_this.removeChild(node);
				}
			});
		}
		// end custom patch
        
        if (isFrag(this)) {
        	// DISABLED FOR CUSTOM PATCH
            //if (insertNode[$fakeParent] === this && insertNode.parentElement) {
            //    return insertNode;
            //}
            var _frag = this.frag;
            if (insertBeforeNode) {
                var index = _frag.indexOf(insertBeforeNode);
                if (index > -1) {
                    _frag.splice.apply(_frag, [ index, 0 ].concat(insertNodes));
                    insertBeforeNode.before.apply(insertBeforeNode, insertNodes);
                }
            } else {
                var _lastNode = _frag[_frag.length - 1];
                _frag.push.apply(_frag, insertNodes);
                _lastNode.after.apply(_lastNode, insertNodes);
            }
            removePlaceholder(this);
        } else if (insertBeforeNode) {
            if (this.childNodes.includes(insertBeforeNode)) {
                insertBeforeNode.before.apply(insertBeforeNode, insertNodes);
            }
        } else {
            this.append.apply(this, insertNodes);
        }
        insertNodes.forEach((function(node) {
            patchParentNode(node, _this);
        }));
        var lastNode = insertNodes[insertNodes.length - 1];
        patchNextSibling(lastNode);
        return insertNode;
    }
    function appendChild(node) {
        if (node[$fakeParent] === this && node.parentElement) {
            return node;
        }
        var frag = this.frag;
        var lastChild = frag[frag.length - 1];
        lastChild.after(node);
        patchParentNode(node, this);
        removePlaceholder(this);
        frag.push(node);
        return node;
    }
    var removePlaceholder = function removePlaceholder(node) {
        var placeholder = node[$placeholder];
        if (node.frag[0] === placeholder) {
            node.frag.shift();
            placeholder.remove();
        }
    };
    var innerHTMLDescriptor = {
        set: function set(htmlString) {
            var _this2 = this;
            if (this.frag[0] !== this[$placeholder]) {
                this.frag.slice().forEach((function(child) {
                    return _this2.removeChild(child);
                }));
            }
            if (htmlString) {
                var domify = document.createElement("div");
                domify.innerHTML = htmlString;
                Array.from(domify.childNodes).forEach((function(node) {
                    _this2.appendChild(node);
                }));
            }
        },
        get: function get() {
            return "";
        }
    };
    var frag = {
        inserted: function inserted(element) {
            var parentNode = element.parentNode, nextSibling = element.nextSibling, previousSibling = element.previousSibling;
            var childNodes = Array.from(element.childNodes);
            var placeholder = document.createComment("");
            if (childNodes.length === 0) {
                childNodes.push(placeholder);
            }
            element.frag = childNodes;
            element[$placeholder] = placeholder;
            var fragment = document.createDocumentFragment();
            fragment.append.apply(fragment, getFragmentLeafNodes(childNodes));
            element.replaceWith(fragment);
            childNodes.forEach((function(node) {
                patchParentNode(node, element);
                patchNextSibling(node);
            }));
            patchChildNodes(element);
            Object.assign(element, {
                remove: remove,
                appendChild: appendChild,
                insertBefore: insertBefore,
                removeChild: removeChild,
                before: before
            });
            Object.defineProperty(element, "innerHTML", innerHTMLDescriptor);
            if (parentNode) {
                Object.assign(parentNode, {
                    removeChild: removeChild,
                    insertBefore: insertBefore
                });
                patchParentNode(element, parentNode);
                patchChildNodes(parentNode);
            }
            if (nextSibling) {
                patchNextSibling(element);
            }
            if (previousSibling) {
                patchNextSibling(previousSibling);
            }
        },
        unbind: function unbind(element) {
            element.remove();
        }
    };
    var Fragment = {
        name: "Fragment",
        directives: {
            frag: frag
        },
        render: function render(h) {
            return h("div", {
                directives: [ {
                    name: "frag"
                } ]
            }, this.$slots["default"]);
        }
    };
    frag.Fragment = Fragment;
    return frag;
}));



Vue.directive('fragment', Frag);
//Vue.component('fragment', Frag);






nabu.page.provide("page-renderer", {
	title: "Form",
	name: "form",
	type: ["row", "cell"],
	component: "renderer-form",
	configuration: "renderer-form-configure",
	getTriggers: function(target, pageInstance, $services) {
		var triggers = {};
		triggers.update = {
			type: "object"
		}
		return triggers;
	},
	// can inject state into the page so we can manipulate it
	getState: function(container, page, pageParameters, $services) {
		if (container.form) {
			var result;
			if (container.form.array && container.form.formType == "array") {
				var array = container.form.array;
				if (array.indexOf("page.") == 0) {
					array = array.substring("page.".length);
				}
				var childDefinition = $services.page.getChildDefinition({properties:pageParameters}, array);
				result = childDefinition && childDefinition.items && childDefinition.items ? childDefinition.items : {};
			}
			else if (container.form.operation && container.form.formType == "operation") {
				var operationId = container.form.operation;
				result = application.services.page.getSwaggerOperationInputDefinition(operationId);
			}
			else if (container.form.formType == "function" && container.form.function) {
				result = $services.page.getFunctionInput(container.form.function);
			}
			else {
				result = {};
			}
			if (!result.properties) {
				result.properties = {};
			}
			result.properties.readOnly = {
				type: "boolean"
			};
			if (container.form.fields) {
				container.form.fields.forEach(function(x) {
					var definition = x.type ? $services.swagger.resolve(x.type) : null;
					if (definition) {
						result.properties[x.name] = {
							type: "object",
							properties:definition.properties
						}
					}
					else {
						result.properties[x.name] = {
							type: x.type ? x.type : "string"
						}
					}
				});
			}
			if (container.form.translatable) {
				result.properties.language = {
					type: "string"
				};
				result.properties.translations = {
					type: "array",
					items: {
						properties: {
							language: {
								type: "string"
							},
							name: {
								type: "string"
							},
							translation: {
								type: "string"
							}
						}
					}
				}
			}
			return result;
		}
		else {
			return {};
		}
	},
	// can emit events
	// e.g. a success event for form submit
	// an error event
	// a submit event (with the input state)
	getEvents: function(container) {
		var result = {};
		if (container.form) {
			var operationId = container.form.operation;
			if (operationId) {
				if (container.form.submitEvent) {
					result[container.form.submitEvent] = application.services.page.getSwaggerOperationInputDefinition(operationId);
				}
				if (container.form.successEvent) {
					result[container.form.successEvent] = application.services.page.getSwaggerOperationOutputDefinition(operationId);
				}
			}
		}
		return result;
	},
	// return the child components in play for the given container
	// these can be added to the list of stuff to style
	getChildComponents: function(container) {
		return [{
			title: "Form",
			name: "form",
			component: "form"
		}, {
			title: "Form Container",
			name: "form-container",
			component: "form-section"
		}];
	},
	// TODO: add the output definition!
	getActions: function(container) {
		var actions = [];
		actions.push({
			title: "Validate",
			name: "validate"
		});
		if (container && container.form && (container.form.operation || container.form.function || (container.form.fields && container.form.fields.length > 0))) {
			var output = null;
			if (container.form.operation && container.form.formType == "operation") {
				var operationId = container.form.operation;
				output = application.services.page.getSwaggerOperationOutputDefinition(operationId);
			}
			actions.push({
				title: "Submit",
				name: "submit",
				input: {
					skipValidate: {
						type: "boolean"
					}
				},
				output: output,
				errors: ["submit", "validate"]
			});
		}
		actions.push({
			title: "Toggle Readonly",
			name: "toggle-readonly"
		});
		if (container && container.form && container.form.translatable) {
			actions.push({
				title: "Switch Language",
				name: "switch-language",
				input: {
					language: {
						type: "string"
					}
				}
			});	
		}
		return actions;
	}
});


Vue.component("renderer-form", {
	template: "#renderer-form",
	mixins: [nabu.page.mixins.renderer],
	props: {
		page: {
			type: Object,
			required: true
		},
		// the target (cell or row)
		target: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		// whether or not we are in edit mode (we can do things slightly different)
		edit: {
			type: Boolean,
			required: false
		}
	},
	created: function() {
		var self = this;
		// initialize the read only
		Vue.set(this.state, "readOnly", this.target.form && this.target.form.readOnly);
		if (this.target.form && this.target.form.translatable) {
			Vue.set(this.state, "language", null);
			Vue.set(this.state, "translations", []);
		}
		this.mergeParameters();
		if (this.target.form && this.target.form.noInlineErrors) {
			this.mode = null;
		}
		else {
			this.mode = "component";
		}
		// if we have a form on an operation, we likely have a "body" in our state
		// we want to be able to pass that around by reference
		if (this.target.form && this.target.form.formType == "operation" && this.state.body == null) {
			Vue.set(this.state, "body", {});
		}
	},
	mounted: function() {
		// trigger a submit
		if (this.target.form && this.target.form.triggerEvent) {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			
			var self = this;
			this.subscriptions.push(pageInstance.subscribe(this.target.form.triggerEvent, function() {
				// always fire the submit if available
				if (self.target.form.submitEvent) {
					pageInstance.emit(self.target.form.submitEvent, self.state);
				}
			}));
		}
	},
	data: function() {
		return {
			messages: [],
			state: {},
			subscriptions: [],
			mode: null
		}
	},
	methods: {
		mergeParameters: function() {
			var self = this;
			if (this.parameters) {
				// we want to make sure something actually changed, otherwise we might reset pending changes!
				if (this.target.form.enableParameterWatching) {
					var stringified = JSON.stringify(this.parameters);
					if (this.lastParameters != null) {
						if (stringified == this.lastParameters) {
							return;
						}
					}
					this.lastParameters = stringified;
				}
				Object.keys(this.parameters).forEach(function(key) {
					if (!self.target.form.bindingByReference) {
						Vue.set(self.state, key, self.$services.page.smartClone(self.parameters[key]));
					}
					else {
						Vue.set(self.state, key, self.parameters[key]);
					}
					//Vue.set(self.state, key, !self.target.form.bindingByReference ? JSON.parse(JSON.stringify(self.parameters[key])) : self.parameters[key]);
					//Vue.set(self.state, key, self.parameters[key]);
				});
			}
		},
		getRuntimeState: function() {
			return this.state;		
		},
		update: function() {
			this.$services.triggerable.trigger(this.target, "update", {}, this);
			if (this.target.form.submitOnChange) {
				this.submit();
			}
		},
		submit: function() {
			var self = this;
			this.messages.splice(0);
			var errorHandler = function(error) {
				self.error = "Form submission failed";
				// if we get an XMLHTTPResponse thingy, parse it
				if (error && error.responseText) {
					error = JSON.parse(error.responseText);
				}
				// we get a (hopefully) standardized event back
				if (error) {
					// we nog longer use code but have switched to type
					if (!error.code) {
						error.code = error.type;
					}
					if (!error.code) {
						error.code = "HTTP-" + (error.status != null ? error.status : 500);
					}
					try {
						if (self.target.form.errorEvent) {
							var pageInstance = self.$services.page.getPageInstance(self.page, self);
							pageInstance.emit(self.target.form.errorEvent, error);
						}
						var codes = self.target.form.codes ? self.target.form.codes : [];
						var applicableCode = codes.filter(function(x) { return x.code == error.code })[0];
						var translated = applicableCode 
							? self.$services.page.translate(applicableCode.title)
							: self.$services.page.translateErrorCode(error.code, error.title ? error.title : error.message);
						self.error = translated;
						self.messages.push({
							type: "request",
							severity: "error",
							title: translated,
							code: error.code
						})
					}
					catch (exception) {
						self.messages.push({
							type: "request",
							severity: "error",
							title: self.$services.page.translateErrorCode(error.status ? "HTTP-" + error.status : "HTTP-500")
						})
					}
				}
				else {
					self.messages.push({
						type: "request",
						severity: "error",
						title: self.$services.page.translateErrorCode("HTTP-500")
					});
				}
				self.doingIt = false;
				stop(self.error);
			};
			
			var context = null;
			if (this.target.form.formType == "operation") {
				context = this.target.form.operation;
			}
			else if (this.target.form.formType == "array") {
				context = this.target.form.array;
			}
			else if (this.target.form.formType == "function") {
				context = this.target.form.function;
			}
			else {
				context = this.page.content.name;
			}
			self.$services.analysis.push({
				event: "submit",
				category: "form",
				component: self.target.analysisId ? self.target.analysisId : "form-" + self.target.id,
				context: context,
				page: self.$services.page.getRootPage(self.$services.page.getPageInstance(self.page, self)).page.content.name,
				data: {
					formType: this.target.form.formType
				}
			});
			
			// do an operation call
			if (this.target.form.operation && this.target.form.formType == "operation") {
				// anything that is not a get should be autologged for analysis
				try {
					var cloned = nabu.utils.objects.clone(this.state);
					if (!cloned["$serviceContext"]) {
						var pageInstance = this.$services.page.getPageInstance(this.page, this);
						cloned["$serviceContext"] = pageInstance.getServiceContext();
					}
					// TODO: test first
					//cloned = this.$services.page.nullify(cloned);
					return this.$services.swagger.execute(this.target.form.operation, cloned).then(function(result) {
						// synchronize the changes back to the binding if relevant
						if (self.target.form.synchronize) {
							self.$services.page.applyRendererParameters(self.$services.page.getPageInstance(self.page, self), self.target, self.state);
						}
					}, errorHandler);
				}
				catch (exception) {
					console.error("Can not submit form", exception);
					return self.$services.q.reject(exception);
				}
			}
			else if (this.target.form.array && this.target.form.formType == "array") {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				var current = pageInstance.get(this.target.form.array);
				if (current == null) {
					pageInstance.set(this.target.form.array, []);
					current = pageInstance.get(this.target.form.array);
				}
				current.push(this.state);
				// synchronize the changes back to the binding if relevant
				if (self.target.form.synchronize) {
					self.$services.page.applyRendererParameters(self.$services.page.getPageInstance(self.page, self), self.target, self.state);
				}
			}
			else if (this.target.form.function && this.target.form.formType == "function") {
				var func = this.$services.page.getRunnableFunction(this.target.form.function);
				if (!func) {
					throw "Could not find function: " + this.target.form.function; 
				}
				var promise = this.$services.q.defer();
				var result = this.$services.page.runFunction(func, this.state, this, promise);
				
				// synchronize the changes back to the binding if relevant
				if (self.target.form.synchronize) {
					promise.then(function(x) {
						self.$services.page.applyRendererParameters(self.$services.page.getPageInstance(self.page, self), self.target, self.state);
					})
				}
				
				promise.then(function(){}, errorHandler);
				
				// not yet used
				if (this.target.form.functionOutputEvent && false) {
					var def = this.$services.page.getFunctionDefinition(this.target.form.function);
					var pageInstance = this.$services.page.getPageInstance(this.page, this);
					if (def.async) {
						promise.then(function(asyncResult) {
							pageInstance.emit(self.target.form.functionOutputEvent, asyncResult ? asyncResult : {});
						});
					}
					else {
						pageInstance.emit(this.target.form.functionOutputEvent, result ? result : {});
					}
				}
				return promise;
			}
			else if (this.target.form.fields && this.target.form.fields.length && this.target.form.formType == "page") {
				this.$services.page.applyRendererParameters(this.$services.page.getPageInstance(this.page, this), this.target, this.state);
			}
		},
		runAction: function(name, input) {
			var self = this;
			if (name == "submit") {
				var promise = this.$services.q.defer();
				var validationPromise = null;
				if (input && input.skipValidate) {
					validationPromise = this.$services.q.resolve();
				}
				else {
					validationPromise = this.runAction("validate");
				}
				validationPromise.then(function() {
					var result = self.submit();
					if (result && result.then) {
						result.then(promise, function(error) {
							promise.reject({errorType: "submit", error: error});
						});
					}
					else {
						promise.resolve();
					}
				}, function(error) {
					self.$services.triggerable.trigger(self.target, "validate:error", {}, self);
					promise.reject({errorType: "validate", error: error});
				});
				return promise;
			}
			else if (name == "validate") {
				// you can set a custom component group to only validate those particular elements?
				var componentGroup = this.target.form.componentGroup ? this.target.form.componentGroup : "form";
				var promises = [];
				var messages = [];
				var codes = self.target.form.codes ? self.target.form.codes : [];
				this.$el.querySelectorAll("[component-group='" + componentGroup + "']").forEach(function(x) {
					var result = x.__vue__.validate();
					
					// we likely have the codes on the "wrapper" component
					// vue can render multiple components on the same $el (e.g. if the root of a component is another component)
					// this is the case for form components in the page, so we likely find it in the parent
					var localCodes = null;
					var component = x.__vue__;
					while (component && !localCodes) {
						localCodes = component.codes;
						component = component.$parent;
						if (!component || component.$el != x) {
							break;
						}
					}
					if (!localCodes) {
						localCodes = [];
					}
					//var localCodes = x.__vue__.codes ? x.__vue__.codes : (x.__vue__.$parent && x.__vue__.$parent.codes ? x.__vue__.$parent.codes : []);
					
					var allCodes = [];
					// the LAST hit wins, so we want the most specific one to win...
					nabu.utils.arrays.merge(allCodes, codes);
					nabu.utils.arrays.merge(allCodes, localCodes);
					
					// we want to clone them so we don't update the original by reference
					// then we want to interpret them!
					var allCodes = allCodes.map(function(x) {
						var cloned = JSON.parse(JSON.stringify(x));
						cloned.title = self.$services.page.translate(self.$services.page.interpret(cloned.title, self));
						return cloned;
					});
					
					var translateMessages = function(messages) {
						messages.forEach(function(message) {
							message.title = self.$services.page.translate(message.title);
						});
					};
					
					// these are currently not compatible with the all() promises bundler... :(
					if (result && result.then) {
						var localPromise = self.$services.q.defer();
						promises.push(localPromise);
						result.then(function(x) {
							nabu.utils.vue.form.rewriteCodes(x, allCodes);
							nabu.utils.arrays.merge(messages, x);
							translateMessages(x);
							localPromise.resolve(x);
						}, localPromise);
					}
					else if (result instanceof Array) {
						nabu.utils.vue.form.rewriteCodes(result, allCodes);	
						nabu.utils.arrays.merge(messages, result);
						translateMessages(messages);
					}
				});
				var promise = this.$services.q.defer();
				this.$services.q.all(promises).then(function() {
					if (messages.length == 0) {
						promise.resolve();
					}
					else {
						promise.reject({errorType: "validate", messages: messages});
					}
				}, promise);
				return promise;
			}
			else if (name == "toggle-readonly") {
				// you can set a custom component group to only validate those particular elements?
				var componentGroup = this.target.form.componentGroup ? this.target.form.componentGroup : "form";
				this.$el.querySelectorAll("[component-group='" + componentGroup + "']").forEach(function(x) {
					var component = x.__vue__;
					while (component) {
						if (Object.keys(component).indexOf("editable") >= 0) {
							component.editable = !component.editable;
							break;
						}
						else {
							component = component.$parent;
						}
					}
				});
				this.state.readOnly = !this.state.readOnly;
			}
			else if (name == "switch-language") {
				// you can set a custom component group to only validate those particular elements?
				var componentGroup = this.target.form.componentGroup ? this.target.form.componentGroup : "form";
				this.state.language = input ? input.language : null;
				this.$el.querySelectorAll("[component-group='" + componentGroup + "']").forEach(function(x) {
					var component = x.__vue__;
					while (component) {
						if (Object.keys(component).indexOf("language") >= 0) {
							component.language = self.state.language;
							break;
						}
						else {
							component = component.$parent;
						}
					}
				});
			}
		}
	},
	watch: {
		parameters: {
			deep: true,
			handler: function() {
				if (this.target.form.enableParameterWatching) {
					this.mergeParameters();
				}
			}
		}
	}
});
 
Vue.component("renderer-form-configure", {
	template: "#renderer-form-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		// the target (cell or row)
		target: {
			type: Object,
			required: true
		}
	},
	created: function() {
		// normalize
		if (!this.target.form) {
			Vue.set(this.target, "form", {});
		}
		if (!this.target.form.bindings) {
			Vue.set(this.target.form, "bindings", {});
		}
		if (!this.target.form.fields) {
			Vue.set(this.target.form, "fields", []);
		}
	},
	computed: {
		definition: function() {
			
		}
	},
	methods: {
		getOperations: function(name) {
			var self = this;
			return this.$services.page.getOperations(function(operation) {
				// must be a put, post, patch or delete
				return (operation.method.toLowerCase() == "put" || operation.method.toLowerCase() == "post" || operation.method.toLowerCase() == "delete" || operation.method.toLowerCase() == "patch")
					// and contain the name fragment (if any)
					&& (!name || operation.id.toLowerCase().indexOf(name.toLowerCase()) >= 0);
			});
		},
		getParameterTypes: function(value) {
			var types = ['string', 'boolean', 'number', 'integer'];
			nabu.utils.arrays.merge(types, Object.keys(this.$services.swagger.swagger.definitions));
			if (value) {
				types = types.filter(function(x) { return x.toLowerCase().indexOf(value.toLowerCase()) >= 0 });
			}
			return types;
		},
	}
});
nabu.page.provide("page-renderer", {
	title: "Collapsible",
	name: "collapsible",
	type: ["row", "cell"],
	component: "page-collapsible",
	configuration: "page-collapsible-configure",
	// can emit events
	// e.g. a success event for form submit
	// an error event
	// a submit event (with the input state)
	getEvents: function(container) {
		var result = {};
		// TODO: we could emit an event when toggled?
		return result;
	},
	// return the child components in play for the given container
	// these can be added to the list of stuff to style
	getChildComponents: function(container) {
		return [{
			title: "Collapsible Container"	,
			name: "collapsible",
			component: "collapsible"
		}, {
			title: "Title",
			name: "typography",
			component: "content"
		}];
	}
});

Vue.component("page-collapsible", {
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		target: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	template: "#page-collapsible",
	data: function () {
		return {
			show: false,
			loading: false,
			toggleable: true
		}
	},
	computed: {
		iconOpen: function() {
			return this.target.collapsible && this.target.collapsible.iconOpen ? this.target.collapsible.iconOpen  : 'chevron-up';
		},
		iconClosed: function() {
			return this.target.collapsible && this.target.collapsible.iconClosed ? this.target.collapsible.iconClosed  : 'chevron-down';
		}
	},
	created: function() {
		if (this.target.collapsible.startOpen) {
			this.show = true;
		}
	},
	methods: {
		toggle: function($event) {
			var self = this;
			var closeRest = function() {
				if (self.target.collapsible.closeSiblings) {
					self.$parent.$children.forEach(function(child) {
						if (child.toggle && child.$el.classList.contains("is-collapsible"))	{
							if (child.show) {
								child.toggle();
							}
						}
					});
				}
			}
			if (this.toggleable) {
				if (!this.show) {
					if (this.load) {
						this.loading = true;
						var self = this;
						this.load().then(function() {
							closeRest();
							self.show = true;
							self.loading = false;
							self.$emit("show", self);
						}, function() {
							self.show = false;
							self.loading = false;
							self.$emit("hide", self);
						});
					}
					else {
						closeRest();
						this.show = true;
						this.$emit("show", this);
					}
				}
				else {
					this.show = false;
					this.$emit("hide", this);
				}
				if (this.target.collapsible.stopPropagation && $event) {
					$event.stopPropagation();
					$event.preventDefault();
				}
			}
		},
		checkPrevent: function($event) {
			if (this.target.collapsible.stopPropagation && $event) {
				$event.stopPropagation();
				$event.preventDefault();
			}
		}
	}
});

Vue.component("page-collapsible-configure", {
	template: "#page-collapsible-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		},
		target: {
			type: Object,
			required: true
		},
		edit: {
			type: Boolean,
			required: true
		}
	},
	created: function() {
		if (!this.target.collapsible) {
			Vue.set(this.target, "collapsible", {});
		}
	}
});
nabu.page.provide("page-renderer", {
	title: "Menu",
	name: "menu",
	type: ["row", "cell"],
	component: "renderer-menu",
	configuration: "renderer-menu-configure",
	// can emit events
	// e.g. a success event for form submit
	// an error event
	// a submit event (with the input state)
	getEvents: function(container) {
		var result = {};
		if (container.state && nabu.page.event.getName(container.state, "handledEvent") != null) {
			var type = nabu.page.event.getType(container.state, "handledEvent");
			/* not yet?
			if (type.properties && Object.keys(type.properties).length == 0 && container.on) {
				type = container.on;
			}
			*/
			result[nabu.page.event.getName(container.state, "handledEvent")] = type;
		}
		return result;
	},
	// through the generic "click" trigger, you can already trigger on selecting something in the menu
	getTriggers: function(target, pageInstance, $services) {
		var triggers = {};
		if (target && target.state && target.state.collapsible) {
			triggers.collapse = {
				type: "object"
			}
			triggers.expand = {
				type: "object"
			}
		}
		return triggers;
	},
	// return the child components in play for the given container
	// these can be added to the list of stuff to style
	getChildComponents: function(container) {
		return [{
			title: "Menu",
			name: "renderer-menu",
			component: "menu"
		}];
	},
	getState: function(container, page, pageParameters, $services) {
		var result = {};
		if (container && container.state && container.state.collapsible) {
			result.collapsed = {
				type: "boolean"
			};
		}
		return {properties:result};
	},
	getActions: function(target, pageInstance, $services) {
		var actions = [];
		if (target && target.state && target.state.collapsible) {
			var action = {
				title: "Toggle Collapse",
				name: "toggle-collapse",
				input: {
					collapsed: {
						type: "boolean"
					}
				},
				output: {
				}
			};
			actions.push(action);
		}
		return actions;
	},
	getSlots: function(target) {
		return ["collapsed", "expanded"];
	}
});


Vue.component("renderer-menu", {
	template: "#renderer-menu",
	mixins: [nabu.page.mixins.renderer],
	data: function() {
		return {
			created: false,
			state: {
				collapsed: null
			}
		}
	},
	props: {
		page: {
			type: Object,
			required: true
		},
		// the target (cell or row)
		target: {
			type: Object,
			required: true
		},
		// whether or not we are in edit mode (we can do things slightly different)
		edit: {
			type: Boolean,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		}
	},
	created: function() {
		this.resetToInitialCollapse();
		this.created = true;
	},
	methods: {
		getPotentialStates: function() {
			return ["collapsed"];
		},
		getCurrentStates: function() {
			var states = [];
			if (this.state.collapsed && !this.edit) {
				states.push("collapsed");
			}
			if (this.$parent) {
				nabu.utils.arrays.merge(states, this.$parent.getCurrentStates())
			}
			return states;
		},
		autoclose: function() {
			if (this.target && this.target.state && this.target.state.collapsible) {
				this.resetToInitialCollapse();
			}
		},
		expand: function() {
			if (this.target && this.target.state && this.target.state.collapsible && this.target.state.expandOnHover && !this.edit) {
				this.state.collapsed = false;
			}	
		},
		collapse: function() {
			if (this.target && this.target.state && this.target.state.collapsible && this.target.state.expandOnHover && !this.edit) {
				this.resetToInitialCollapse();
			}	
		},
		runAction: function(action, value) {
			if (action == "toggle-collapse") {
				var collapsed = value && value.collapsed != null ? value.collapsed : !this.state.collapsed;
				// if the menu is collapsed and this differs from the _default_ state of the menu, the user has done this explicitly, save it
				if (collapsed && !this.getInitialCollapse()) {
					localStorage.setItem(this.page.content.name + "-menu-" + this.target.id + "-collapsed", collapsed);
				}
				// otherwise, reset to normal behavior
				else {
					localStorage.removeItem(this.page.content.name + "-menu-" + this.target.id + "-collapsed");
				}
				if (!collapsed) {
					this.state.collapsed = collapsed;
				}
				// if not collapsing, reset to original
				else {
					// actions are usually explicitly driven by the user
					// this means he might want to explicitly collapse a menu bar that should otherwise be open
					this.resetToInitialCollapse();
				}
			}
		},
		getInitialCollapse: function() {
			var collapsed;
			if (this.target.state.initialCollapsed) {
				collapsed = this.$services.page.isCondition(this.target.state.initialCollapsed, {}, this);
			}
			else {
				collapsed = this.$services.page.device("<=", "tablet");
			}
			return collapsed;
		},
		resetToInitialCollapse: function() {
			if (this.target && this.target.state && this.target.state.collapsible) {
				var collapsed = localStorage.getItem(this.page.content.name + "-menu-" + this.target.id + "-collapsed");
				if (collapsed == null) {
					collapsed = this.getInitialCollapse();
				}
				// string storage
				else {
					collapsed = collapsed === true || collapsed === "true";
				}
				// we switch to numeric to explicitly be different from "true" and "false" which may be set by the user
				this.state.collapsed = collapsed == true ? 1 : 0;
			}
		},
		getRuntimeState: function() {
			return this.state;	
		},
		handle: function() {
			if (this.target && this.target.state && this.target.state.collapsible) {
				// we reset to the initial
				this.resetToInitialCollapse();
			}
			if (nabu.page.event.getName(this.target.state, "handledEvent")) {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				// if you have routed away, it may no longer be available
				if (pageInstance) {
					pageInstance.emit(
						nabu.page.event.getName(this.target.state, "handledEvent"),
						nabu.page.event.getInstance(this.target.state, "handledEvent", this.page, this)
					);
				}
			}
		}
	},
	watch: {
		'state.collapsed': function(newValue) {
			if (this.created) {
				if (newValue) {
					this.$services.triggerable.untrigger(this.target, "expand", {}, this);
					this.$services.triggerable.trigger(this.target, "collapse", {}, this);
				}
				else {
					this.$services.triggerable.untrigger(this.target, "collapse", {}, this);
					this.$services.triggerable.trigger(this.target, "expand", {}, this);
				}
			}
		}
	}
});

Vue.component("renderer-menu-configure", {
	template: "#renderer-menu-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		// the target (cell or row)
		target: {
			type: Object,
			required: true
		},
		// whether or not we are in edit mode (we can do things slightly different)
		edit: {
			type: Boolean,
			required: false
		}
	},
	created: function() {
		if (!this.target.state) {
			Vue.set(this.target, "state", {});
		}
	}
});
/*
# Repeat providers

Fields:

- name: a logical name
- title: a human readable name

Methods:

- getDefinition(container): get the record definition for the given container
- getActions(target, pageInstance, $services): get all the available actions
- getSpecifications(target): get all the specifications
- loadData(target, state, page, append): load the required data for the given target
	note that you get the full state of the repeat, so you can modify the records and the paging as needed
	it should return a promise
- configurator: the name of the component that can be used for configuration

*/


// TODO: currently we repeat the content within, not the cell/row itself
// it seems more natural to repeat the thing the renderer is _on_ rather than the content?

// TODO: when in edit mode, still load the _first_ instance and set it as state in the local page
// this will allow for visual editing

// the components and functionalities are built around state in a page
// however, the problem in a loop is that, depending on the iteration, we have different state
// this different state can not co-exist at the root of the page, only one thing can be true at a time
// apart from a massive refactor in how state is accessed, the other solution is to create temporary pages
// if we have an array called "mydata.myarray" in the current page
// and we want to repeat over that _and_ keep the data responsive, we need to have a reference-copy of the entry
// because in our example the array is nested, we "could" mock an empty mydata and put in an iteration instead of an array
// however, than you can't access any other data in the mydata object (because its a mock)
// we could do more complex mocking but this seems contrived
// another option is to have you set a "local" variable e.g. myInstance which we make available in the variables of the temporary page


// we don't need to specifically define the events
// if you define an event inside a repeat (e.g. a button), it will already exist in the page and be known
// all we need to do is make sure we shuttle the events from our page fragments to this page


// TO BE CHECKED: if we expose all the operation parameters as a filter
// and you can bind to the state
// why do we need operation binding? do we need it? it seems redundant
nabu.page.provide("page-renderer", {
	title: "Repeat",
	name: "repeat",
	type: ["row", "cell"],
	component: "renderer-repeat",
	configuration: "renderer-repeat-configure",
	getTriggers: function(target, pageInstance, $services) {
		// this ONLY works if you set a runtime alias which is not the cleanest way
		// but it is (currently) the only way to really get the definition
		// the problem in getState is when we depend on OTHER definitions to define ourselves (e.g. when doing the array)
		// for this reason we added the pageParameters workaround, but it is fragile at best
		// anyway, the repeat WITHOUT a runtime alias is quite useless as you can't bind to any data anyway
		// we do know however that there is a select, and we want you to be able to configure it immediately
		// so if we can't resolve the state yet (no runtime alias), we already expose the trigger without any data
		var triggers = {};
		var parameters = null;
		if (pageInstance && target && target.runtimeAlias && target.repeat && target.repeat.selectable) {
			// we need the definition for this
			parameters = $services.page.getAllAvailableParameters(pageInstance.page);
			// sometimes the record does not exist because the definition can not be found (e.g. you have removed the operation)
			if (parameters[target.runtimeAlias] && parameters[target.runtimeAlias].properties.record) {
				triggers.select = {
					items: {
						type: "array",
						items: {
							type: "object",
							properties: parameters[target.runtimeAlias].properties.record.properties
						}
					}
				};
				// we want to trigger on deselect so we can for example show a placeholder
				triggers.deselect = {
				};
			}
			else {
				console.error("Could not get trigger because we could not find the definition for: " + target.runtimeAlias);
			}
		}
		if (pageInstance && target && target.runtimeAlias && target.repeat) {
			parameters = $services.page.getAllAvailableParameters(pageInstance.page);
			// sometimes the record does not exist because the definition can not be found (e.g. you have removed the operation)
			if (parameters[target.runtimeAlias] && parameters[target.runtimeAlias].properties.record) {
				// this can be triggered by embedded form components that will emit the update
				triggers.update = {
					type: "object",
					properties: parameters[target.runtimeAlias].properties.record.properties
				};
			}
		}
		if (parameters) {
			triggers.load = {
				type: "array",
				items: {
					properties: parameters[target.runtimeAlias].properties.record.properties
				}
			};
		}
		return triggers;
	},
	getState: function(container, page, pageParameters, $services) {
		var result = {};
		if (container.repeat) {
			result["recordIndex"] = {type: "int64"};
			if ((container.repeat.type == "operation" || container.repeat.type == null) && container.repeat.operation) {
				var operation = $services.swagger.operations[container.repeat.operation];
				if (operation && operation.responses && operation.responses["200"] && operation.responses["200"].schema) {
					var properties = {};
					var definition = $services.swagger.resolve(operation.responses["200"].schema);
					var arrays = $services.page.getArrays(definition);
					if (arrays.length > 0) {
						var childDefinition = $services.page.getChildDefinition(definition, arrays[0]);
						if (childDefinition && childDefinition.items && childDefinition.items.properties) {
							nabu.utils.objects.merge(properties, childDefinition.items.properties);
						}
					}
					if (definition.properties) {
						Object.keys(definition.properties).map(function(field) {
							if (definition.properties[field].type == "array") {
								var items = definition.properties[field].items;
								if (items.properties) {
									nabu.utils.objects.merge(properties, items.properties);
								}
							}
						});
					}
					result.record = {properties:properties};
					result.records = {type: "array", items: {type:"object",properties:result.record.properties}};	
					if (container.repeat.raw) {
						result.raw = definition;
					}
					
					var filters = {};
					// we also want to expose the parameters as input
					var parameters = operation.parameters;
					if (parameters) {
						parameters.forEach(function(x) {
							// reserved!
							if (x.name != "record") {
								filters[x.name] = x;
							}
						});
					}
					result.filter = {properties:filters};
//					result["$serviceContext"] = {
//						type: "string"
//					}
				}
			}
			else if ((container.repeat.type == "array" || container.repeat.type == null) && container.repeat.array) {
				var record = {};
				var available = pageParameters;
				var arrayName = container.repeat.array;
				var definition = $services.page.getChildDefinition({properties:available}, arrayName);
				if (!definition && arrayName.indexOf("page.") == 0) {
					definition = $services.page.getChildDefinition({properties:available}, arrayName.substring("page.".length));
				}
				if (definition && definition.items && definition.items.properties) {
					nabu.utils.objects.merge(record, definition.items.properties);
				}
				result.record = {properties:record};
				result.records = {type: "array", items: {properties:record}};

				// sometimes an array is actually at the page level (e.g. external) so we can't just strip out page
				/*
				var record = {};
				var available = pageParameters;
				var arrayName = container.repeat.array;
				if (arrayName.indexOf("page.") == 0) {
					arrayName = arrayName.substring("page.".length);
				}
				var indexOfDot = arrayName.indexOf(".");
				var variable = indexOfDot < 0 ? arrayName : arrayName.substring(0, indexOfDot);
				var rest = indexOfDot < 0 ? null : arrayName.substring(indexOfDot + 1);
				if (available[variable]) {
					// we can have root arrays rather than part of something else
					// for example from a multiselect event
					if (!rest) {
						if (available[variable].items && available[variable].items.properties) {
							nabu.utils.objects.merge(record, available[variable].items.properties);
						}
					}
					else {
						var childDefinition = $services.page.getChildDefinition(available[variable], rest);
						if (childDefinition) {
							nabu.utils.objects.merge(record, childDefinition.items.properties);
						}
					}
				}
				result.record = {properties:record};
				result.records = {type: "array", items: {properties:record}};
				*/
			}
			// check if there is a provider for this repeat
			else {
				nabu.page.providers("page-repeat").forEach(function(provider) {
					if (provider.name == container.repeat.type) {
						result.record = {properties:provider.getDefinition(container)};
						result.records = {type: "array", items: result.record};
					}
				})
			}
			if (result.record && container.repeat.selectable) {
				result["selected"] = {
					type: "array",
					items: {
						type: "object",
						properties: result.record.properties
					}
				}
			}
			// the records array contains the filtered values, we want to add an option to get all the records as well
			if (result.records && container.repeat.arrayFilter) {
				result.allRecords = result.records;
			}
			
			// TODO: not yet finished!
			if (container.repeat.localVariables && container.repeat.localVariables.length) {
				var local = {};
				container.repeat.localVariables.forEach(function(single) {
					if (single.name) {
						var schema = null; 
						if (single.template) {
							var templateValue = $services.page.eval(single.template);
							if (templateValue) {
								schema = $services.page.getSchemaFromObject(templateValue);
							}
						}
						else if (single.definition) {
							schema = $services.swagger.resolve(single.definition);
						}
						else {
							schema = {
								type: "string"
							}
						}
						if (schema) {
							if (single.isArray) {
								local[single.name] = {
									type: "array",
									items: schema
								}
							}
							else {
								local[single.name] = schema;
							}
						}
					}
				})
				result.local = {
					properties: local
				}
			}
		}
		return {properties:result};
	},
	getSlots: function(target) {
		var slots = ["empty", "loading", "appendLoading"];
		if (target.repeat && target.repeat.customSlots && target.repeat.customSlots.length) {
			nabu.utils.arrays.merge(slots, target.repeat.customSlots.map(function(x) { return x.name }));
		}
		return slots;
	},
	getChildComponents: function(target) {
		return [{
			title: "Repeat Content",
			name: "repeat-content",
			component: target.rows ? "row" : "column"
		}, {
			title: "Repeat Message",
			name: "repeat-message",
			component: target.rows ? "row" : "column"
		}, {
			title: "Repeat Empty Message",
			name: "repeat-empty",
			component: target.rows ? "row" : "column"
		}, {
			title: "Repeat Loading Message",
			name: "repeat-loading",
			component: target.rows ? "row" : "column"
		}];
	},
	getActions: function(target, pageInstance, $services) {
		var actions = [];
		// can only refresh if there is an operation
		if (target.repeat && target.repeat.operation) {
			var action = {
				title: "Refresh",
				name: "refresh",
				input: {
				},
				output: {
				}
			};
			// check if we are browseable
			var renderer = nabu.page.providers("page-renderer").filter(function(x) { return x.name == "repeat" })[0];
			if (renderer && renderer.getSpecifications(target).indexOf("pageable") >= 0) {
				// usually you refresh because something changed/was added/removed/...
				// in that case, the page you are on is unlikely to have the current details
				// so you want to reset the page count to 0
				// however, sometimes you want to refresh because some internal state was updated on the current page (e.g. task reprocessing)
				action.input.retainOffset = {
					type: "boolean"
				};
			}
			actions.push(action);
		}
		else if (target.repeat) {
			var provider = nabu.page.providers("page-repeat").filter(function(provider) {
				return provider.name == target.repeat.type;
			})[0];
			if (provider && provider.getActions) {
				nabu.utils.arrays.merge(provider.getActions(target, pageInstance, $services));
			}
		}
		if (pageInstance && target && target.runtimeAlias && target.repeat && target.repeat.selectable) {
			// we need the definition for this
			var parameters = $services.page.getAllAvailableParameters(pageInstance.page);
			// sometimes the record does not exist because the definition can not be found (e.g. you have removed the operation)
			if (parameters[target.runtimeAlias] && parameters[target.runtimeAlias].properties.record) {
				var action = {
					title: "Select",
					name: "select",
					input: {
						items: {
							type: "array",
							items: {
								type: "object",
								properties: parameters[target.runtimeAlias].properties.record.properties
							}
						},
						append: {
							type: "boolean"
						}
					},
					output: {}
				};
				actions.push(action);
			}
			else {
				console.error("Could not add select action because the definition could not be found for: " + target.runtimeAlias);
			}
		}
		if (target.repeat && target.repeat.customSlots && target.repeat.customSlots.length) {
			var action = {
				title: "Toggle Slot",
				name: "toggle-slot",
				input: {
					// the name of the slot we want to toggle
					slot: {
						type: "string"
					},
					// the index we want to toggle
					index: {
						type: "int64"
					},
					// if not filled in we toggle, otherwise we explicitly show or hide
					show: {
						type: "boolean"
					}
				},
				output: {}
			};
			actions.push(action);
		}
		return actions;
	},
	getSpecifications: function(target) {
		// TODO: check that it is an operation _and_ it has limit/offset capabilities
		//return [];
		var specifications = [];
		if (target.repeat && (target.repeat.type == "operation" || target.repeat.type == null) && target.repeat.operation) {
			var operation = application.services.swagger.operations[target.repeat.operation];
			if (operation) {
				var parameters = operation.parameters.map(function(x) { return x.name });
				if (parameters.indexOf("limit") >= 0 && parameters.indexOf("offset") >= 0) {
					specifications.push("pageable");
					specifications.push("browseable");
				}
				if (parameters.indexOf("orderBy") >= 0) {
					specifications.push("orderable");
				}
			}
		}
		else if (target.repeat) {
			var provider = nabu.page.providers("page-repeat").filter(function(provider) {
				return provider.name == target.repeat.type;
			})[0];
			if (provider && provider.getSpecifications) {
				nabu.utils.arrays.merge(provider.getSpecifications(target));
			}
		}
		return specifications;
		//return ["pageable", "browseable"];
	}
});

var $$rendererInstanceCounter = 0;
Vue.component("renderer-repeat", {
	template: "#renderer-repeat",
	mixins: [nabu.page.mixins.renderer],
	props: {
		page: {
			type: Object,
			required: true
		},
		// the target (cell or row)
		target: {
			type: Object,
			required: true
		},
		parameters: {
			type: Object,
			required: false
		},
		// whether or not we are in edit mode (we can do things slightly different)
		edit: {
			type: Boolean,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		}
	},
	data: function() {
		return {
			loadPromise: null,
			destroyed: false,
			repeatTimer: null,
			created: false,
			loadCounter: 0,
			// the instance counter is used to manage our pages on the router
			instanceCounter: $$rendererInstanceCounter++,
			loading: false,
			// when loading new data you want to append, we don't want to show the full load indicator but a small append load indicator
			appendLoading: false,
			fragmentPage: null,
			// each slot has its own page
			fragmentPages: {},
			// position counter to make each record unique
			position: 0,
			lastParameters: null,
			lastFilter: null,
			// for each custom slot (key), we have an array of active indexes
			activatedSlots: {},
			// the state in the original page, this can be used to write stuff like "limit" etc to
			// note that the "record" will not actually be in this
			state: {
				raw: {},
				// the selected
				selected: [],
				order: {
					by: []
				},
				filter: {},
				records: [],
				allRecords: [],
				// if we don't define the fields AND we don't use Vue.set to update them, they are not reactive!
				paging: {
					current: 0,
					total: 0,
					pageSize: 0,
					rowOffset: 0,
					totalRowCount: 0
				}
			}
		}
	},
	/*
	render: function(f) {
		console.log("rendering repeat", f);
		console.log("slots are", this.$slots);
		return f("div2", this.$slots.default);
	},
	*/
	created: function() {
		// the parameters that we pass in contain the bound values
		var self = this;
		
		// first map the default order by, we might overwrite it with the input mappings
		if (this.target.repeat && this.target.repeat.defaultOrderBy) {
			nabu.utils.arrays.merge(this.state.order.by, this.target.repeat.defaultOrderBy.map(function(x) {
				return x.name + " " + (x.direction ? x.direction : "asc") + (x.nulls ? " " + x.nulls : "");
			}));
		}
		
		// the problem is, we want to do an initial load always
		// however, by the act of modifying the state if you have bindings, we trigger the watcher for state.filter which will also do a reload
		// so we want behavior that if we don't do any state mappings, we do an initial load
		// if a filter change comes in because of initial mapping, we ignore it
		this.mergeParameters();
		
		if (this.target.repeat && this.target.repeat.customSlots && this.target.repeat.customSlots.length) {
			this.target.repeat.customSlots.forEach(function(slot) {
				Vue.set(self.activatedSlots, slot.name, []);
			});
		}
		
		this.loadPages();
		
		this.watchArray();
		
		// initialize so it includes all the external bound parameters
		this.lastFilter = JSON.stringify(this.normalizeParametersForComparison(this.state.filter));
		// note that this is NOT an activate, we can not stop the rendering until the call is done
		// in the future we could add a "working" icon or a placeholder logic
		if (!this.target.repeat || !this.target.repeat.waitForPageLoad) {
			this.loadData();
		}
		
		if (this.target.repeat && this.target.repeat.localVariables) {
			this.target.repeat.localVariables.forEach(function(variable) {
				// initialize as null
				Vue.set(self.state.local, variable.name, null);
			})
		}
	},
	mounted: function() {

	},
	computed: {
		alias: function() {
			return "fragment-renderer-repeat-" + this.instanceCounter;
		},
		operationParameters: function() {
			var parameters = {};
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			var self = this;
			if (this.target.repeat && this.target.repeat.bindings) {
				Object.keys(this.target.repeat.bindings).map(function(name) {
					if (self.target.repeat.bindings[name]) {
						var value = self.$services.page.getBindingValue(pageInstance, self.target.repeat.bindings[name], self);
						if (value != null && typeof(value) != "undefined") {
							parameters[name] = value;
						}
					}
				});
			}
			return parameters;
		}
	},
	watch: {
		'$services.page.stable': function(stable) {
			if (stable && !this.created && this.target.repeat && this.target.repeat.waitForPageLoad) {
				var self = this;
				Vue.nextTick(function() {
					// if you toggle the "stable" requirement, it is very likely you want to change settings like the filter
					// because we haven't actually loaded the data yet, we can safely update the filter here to reflect what we will load
					self.lastFilter = JSON.stringify(self.normalizeParametersForComparison(self.state.filter));
					self.created = true;
					self.loadData();
				});
			}	
		},
		'$services.page.editing': function(editing) {
			// if we leave edit mode, the stable boolean is not triggered, use the edit boolean to achieve the same result
			if (!editing && !this.created && this.target.repeat && this.target.repeat.waitForPageLoad) {
				this.created = true;
				this.loadData();
			}	
		},
		// the parameters that are passed in by the page are calculated against the global state maintained in "variables"
		// by doing a loadData, we update the state in the repeat which is exposed globally as well in the variables
		// even though the actual parameter values are not changed, the container that holds them, has been so this triggers a recalculate of parameters at the page level
		// which in turn triggers this watcher, which triggers a load, which triggers this watcher etc....
		// the only way to break this cycle is to check if anything _actually_ changed
		parameters: {
			deep: true,
			handler: function(newValue, oldValue) {
				var newParameters = JSON.stringify(this.normalizeParametersForComparison(newValue));
				if (this.lastParameters != newParameters && this.created && this.target.repeat.enableParameterWatching) {
					this.mergeParameters();
					this.loadData();
				}
				this.lastParameters = newParameters;
			}
		},
		// we don't want to watch paging, it is the output
		operationParameters: function() {
			this.loadData();	
		},
		"state.filter": {
			deep: true,
			handler: function(newValue) {
				if (this.created) {
					var newFilter = JSON.stringify(this.normalizeParametersForComparison(newValue));
					if (this.lastFilter != newFilter) {
						this.loadData();
					}
					this.lastFilter = newFilter;
				}
			}
		},
		// if we have changed the order by, rerun it!
		// same however as with filters, not if it's an initial one
		"state.order.by": function() {
			if (this.created) {
				this.loadData();
			}
		}
	},
	beforeDestroy: function() {
		this.destroyed = true;
		this.unloadPages();
		if (this.repeatTimer) {
			clearTimeout(this.repeatTimer);
		}
	},
	methods: {
		// TODO: suppose you have a form inside the repeat, its state is _always_ localized to the repeat and should not be pushed to the parent page
		// recognizing this localized state requires inspection in the page of all cells/rows and should be limited to runtime aliases
		// currently the state _is_ upstreamed but should be kept in sync, you can not however have two separate repeat instances pushing the same state
		// if this becomes necessary, do a recursive check and cache the results to blacklist upstreaming those values
		
		// inside the repeat (e.g. when creating more complex cards) we may want to alter state on the page that has nothing to do with the repeat
		// however we don't want to only alter the state of our own fragmented page because that will not feed back into the rest of the page and unrelated components
		// a repeat only has a localized (non-similar) state its own repeat stuff
		// for everything else, it should have an up to date copy of the state (ASSUMPTION!)
		// an initial set is just to get the fragment page up and running and does not need to be propagated
		// for nested repeats: they only push to their own parent which in turn should know whether or not it can push the change further on
		repeatSetter: function(instance, name, value, label, initial) {
			// initial sets are never propagated
			if (initial || !instance.fragmentParent || (this.target.runtimeAlias && (name == this.target.runtimeAlias || "page." + name == this.target.runtimeAlias || name.indexOf(this.target.runtimeAlias + ".") == 0 || name.indexOf("page." + this.target.runtimeAlias + ".") == 0))) {
				instance.internalSet(name, value, label);
			}
			else {
				// we _also_ need it locally
				// it is not yet clear why, but previously it was _always_ set locally, so only the upstreaming is new
				instance.internalSet(name, value, label);
				instance.fragmentParent.set(name, value, label);
			}
		},
		collapseAllSlots: function() {
			var self = this;
			Object.keys(this.activatedSlots).forEach(function(slot) {
				self.activatedSlots[slot].splice(0);
			});
		},
		getAdditionalSlots: function(index) {
			var result = [];
			var self = this;
			Object.keys(this.activatedSlots).forEach(function(slot) {
				if (self.activatedSlots[slot].indexOf(index) >= 0) {
					result.push(slot);
				}
			})
			return result;
		},
		normalizeParametersForComparison: function(parameters) {
			var cloned = JSON.parse(JSON.stringify(parameters));
			var normalize = function(object) {
				Object.keys(object).forEach(function(key) {
					var value = object[key];
					if (value == null) {
						delete object[key];
					}
					// empty arrays are removed
					else if (value instanceof Array && value.length == 0) {
						delete object[key];
					}
					// empty strings are removed
					else if (value === "") {
						delete object[key];
					}
					else if (typeof(value) == "object") {
						normalize(value);
					}
				})
			}
			normalize(cloned);
			return cloned;
		},
		update: function(record, value, label, field) {
			return this.$services.triggerable.trigger(this.target, "update", record, this);
		},
		mergeParameters: function() {
			var self = this;
			this.created = false;
			var stateModified = false;
			var blacklist = ["records", "paging"];
			
			// in the past we based our merging off of the parameters that were passed in
			// but these are always objects, so if you bind "filter.limit", you pass in a full filter object with one param: limit
			// null values were ignored which means you could never "unset" a value from the outside
			
			// currently, IF you have input watching enabled, you should make sure the internal state and the outside state are "in sync"
			// otherwise suppose you map 2 fields
			// 1 field is updated internally, then the other is updated externally
			// due to the external update, we map back both values
			// the only way to prevent a reset on that first internal value is to diff the bound values with the previous value
			// we _could_ do that but currently we want to see if it is not better to keep that state in sync
			// for instance when using tags to delete a filter value, don't delete the filter value itself, but the outside source that is bound
			// if you have a filter search field, bind it to the outside source, not directly the filter itself
			// alternatively you could disable input watching and work on your own state
			// if a usecase arises where this is not possible, we can add diffing against the previous bound value and only update if the outside source was actually changed
			
			//var pageInstance = this.$services.page.getPageInstance(this.page, this);
			Object.keys(this.target.rendererBindings).forEach(function(key) {
				// if we have a binding for it, check it!
				if (self.target.rendererBindings[key]) {
					//self.$services.page.setValue(self.state, key, self.$services.page.getBindingValue(pageInstance, self.target.rendererBindings[key], self));
					// we do assume the values to be available in the bound parameters, preventing the need of an additional lookup
					var currValue = self.$services.page.getValue(self.state, key);
					var newValue = self.$services.page.getValue(self.parameters, key);
					if (currValue != newValue) {
						self.$services.page.setValue(self.state, key, newValue);
						stateModified = true;
					}
				}
			});
			return stateModified;
			// the old stuff!
			/*
			// these are objects like "filters", "orderBy" etc
			Object.keys(this.parameters).forEach(function(key) {
				// we want to _merge_ the filter, not just overwrite it!
				if (key == "filter") {
					var filter = self.parameters[key];
					var filterKeys = [];
					if (filter) {
						filterKeys = Object.keys(filter)
						filterKeys.forEach(function(filterKey) {
							Vue.set(self.state.filter, filterKey, filter[filterKey]);
						});
					}
				}
				else if (blacklist.indexOf(key) < 0 && self.parameters[key] != null && self.state[key] != self.parameters[key]) {
					Vue.set(self.state, key, self.parameters[key]);
					stateModified = true;
				}
			});
			return stateModified;
			*/
		},
		getOrderByFields: function() {
			var result = [];
			if (this.target.repeat && this.target.repeat.operation) {
				var operation = this.$services.swagger.operation(this.target.repeat.operation);	
				var self = this;
				if (operation && operation.parameters) {
					var orderBy = operation.parameters.filter(function(x) {
						return x.name == "orderBy";
					})[0];
					// if we have an order by field, we can order by all the outputs (by default)
					if (orderBy && operation.responses["200"] && operation.responses["200"].schema) {
						var definition = self.$services.swagger.resolve(operation.responses["200"].schema);
						var arrays = self.$services.page.getArrays(definition);
						if (arrays.length > 0) {
							var childDefinition = self.$services.page.getChildDefinition(definition, arrays[0]);
							if (childDefinition && childDefinition.items && childDefinition.items.properties) {
								nabu.utils.arrays.merge(result, Object.keys(childDefinition.items.properties));
							}
						}
					}
				}
			}
			return result;
		},
		getCounter: function() {
			return this.$services.page.pageCounter++;
		},
		getPageType: function() {
			var self = this;
			var pageType = null;
//			var path = this.$services.page.getTargetPath(this.page.content, this.target.id);
			var path = this.$services.page.getTargetPath(this.getRootPage().page.content, this.target.id);
			path.reverse();
			if (this.parameters.pageType) {
				pageType = this.parameters.pageType;
			}
			else {
				// we check if there is a renderer in the path to this repeat
				// if so, that renderer can modify how we render the pages (e.g. a table)
				path.forEach(function(x) {
					if (x.renderer && !pageType) {
						var renderer = self.$services.page.getRenderer(x.renderer);
						if (renderer && renderer.getPageType) {
							pageType = renderer.getPageType(x);
						}
					}
				})
			}
			// @2025-06-06: this can concatenate into "undefined-child" if the parent has no explicit page type
			// it is unclear exactly why we want a unique page type for each child? styling perhaps? yes, table renderer uses this!
			// anyway, disabled the original code and made it smarter
			//if (pageType == null) {
			//	pageType = this.page.content.pageType + "-child";
			//}
			// we take the parent page type and add "-child" to it
			// if you keep nesting, we keep adding -child
			if (pageType == null && this.page.content.pageType) {
				pageType = this.page.content.pageType + "-child";
			}
			// this breaks EVERYTHING with regards to tables etc
			//else {
			//	pageType = "page";
			//}
			return {
				pageType: pageType,
				path: path
			};
		},
		getRootPage: function() {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			while (pageInstance.fragmentParent) {
				pageInstance = pageInstance.fragmentParent;
			}
			return pageInstance;
		},
		getCellClasses: function() {
			var self = this;
			var component = null;
			var pageType = this.getPageType();
			if (pageType.pageType) {
				var provider = nabu.page.providers("page-type").filter(function(x) {
					return x.name == pageType.pageType;
				})[0];
				if (provider && this.target.rows && provider.cellComponent instanceof Function) {
					component = provider.cellComponent(this.target, pageType.path, this.page);
				}
				else if (provider && this.target.rows && provider.cellComponent) {
					component = provider.cellComponent;
				}
			}
			if (!component) {
				component = "page-column";
			}
			var result = ["is-" + component];
			nabu.utils.arrays.merge(result, this.getChildComponentClasses(component));
			return result;
		},
		getComponentClassesForEdit: function() {
			var result = [];
			if (this.getComponent() == "div") {
				// we have a plain row
				if (this.target.cells) {
					result.push("page-row");
					result.push("is-page-row");
				}
				else {
					result.push("page-column");
					result.push("is-page-column");
				}
			}
			return result;
		},
		getComponentClassesForMessage: function() {
			var result = [];
			if (this.getMessageComponent() == "div") {
				// we have a plain row
				if (this.target.cells) {
					result.push("page-row");
					result.push("is-page-row");
				}
				else {
					result.push("page-column");
					result.push("is-page-column");
				}
			}
			return result;
		},
		getComponent: function() {
			var self = this;
			var pageType = this.getPageType();
			var componentType = null;
			if (pageType.pageType) {
				var provider = nabu.page.providers("page-type").filter(function(x) {
					return x.name == pageType.pageType;
				})[0];
				if (provider && this.target.rows && provider.cellTag instanceof Function) {
					componentType = provider.cellTag(null, this.target, null, this.edit, pageType.path, this.page);
				}
				else if (provider && this.target.rows && provider.cellTag) {
					componentType = provider.cellTag;
				}
				// if we are a row, check if we have a celltag
				else if (provider && this.target.cells && provider.rowTag instanceof Function) {
					componentType = provider.rowTag(this.target, null, this.edit, pageType.path, this.page);
				}
				else if (provider && this.target.cells && provider.rowTag) {
					componentType = provider.rowTag;
				}
			}
			return componentType ? componentType : "div";
		},
		getMessageComponent: function() {
			var self = this;
			var pageType = this.getPageType();
			if (pageType.pageType) {
				var provider = nabu.page.providers("page-type").filter(function(x) {
					return x.name == pageType.pageType;
				})[0];
				if (provider && provider.messageTag instanceof Function) {
					return provider.messageTag(this.target);
				}
				else if (provider && provider.messageTag) {
					return provider.messageTag;
				}
				// if we are a cell, check if we have a celltag
				else if (provider && this.target.rows && provider.cellTag instanceof Function) {
					return provider.cellTag(null, this.target);
				}
				else if (provider && this.target.rows && provider.cellTag) {
					return provider.cellTag;
				}
				// if we are a row, check if we have a celltag
				else if (provider && this.target.cells && provider.rowTag instanceof Function) {
					return provider.rowTag(this.target);
				}
				else if (provider && this.target.cells && provider.rowTag) {
					return provider.rowTag;
				}
			}
			return "div";
		},
		onDragStart: function(event, record) {
			var name = this.target.repeat.dragName ? this.target.repeat.dragName : "default";
			this.$services.page.setDragData(event, "data-" + name, JSON.stringify(record));
		},
		watchArray: function() {
			if (this.target.repeat && this.target.repeat.array) {
				var self = this;
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				// if we are accessing parent state, we need to watch that
				// in theory it could come from _any_ parent. realistically for now we are just checking the direct parent
				if (this.target.repeat.array.indexOf("parent.") == 0) {
					var parentPage = this.$services.page.pages.filter(function(x) {
						return x.content.name == self.page.content.pageParent;
					})[0];
					if (parentPage != null) {
						//result.parent = this.getPageParameters(parentPage);
						pageInstance = this.$services.page.getPageInstance(parentPage, pageInstance);
					}
				}
				var targetArray = this.target.repeat.array;
				if (targetArray.indexOf("parent.") == 0) {
					targetArray = targetArray.substring("parent.".length);
				}
				var current = pageInstance.get(targetArray);
				// if it doesn't exist yet, keep an eye on the page state
				// we tried to be more specific and watch direct parents but this _somehow_ failed
				if (current == null) {
					var unwatch = pageInstance.$watch("variables", function(newValue) {
						var result = pageInstance.get(targetArray);
						if (result != null) {
							self.loadData();
							unwatch();
							self.watchArray();
						}
					}, {deep: true});
				}
				else {
					var stringified = JSON.stringify(current);
					if (targetArray.indexOf("page.") == 0) {
						targetArray = targetArray.substring("page.".length);
					}
					var watchKey = "variables." + targetArray;
					var unwatch = pageInstance.$watch(watchKey, function(newValue) {
						if (JSON.stringify(pageInstance.get(targetArray)) != stringified) {
							self.loadData();
							unwatch();
							// may have unset to null, changed to a different array,...
							self.watchArray();
						}
					}, {deep: true});
				}
			}
		},
		// TODO: allow the user to choose their own key in the record
		getKey: function(record) {
			if (record && record.id) {
				return record.id;
			}
			// sometimes we have arrays of uuids
			else if (record && typeof(record) == "string") {
				return record;
			}
			else if (record && record.hasOwnProperty("$position")) {
				return record["$position"];
			}
			else {
				return this.state.records.indexOf(record);
			}
		},
		handleClick: function(event, record) {
			if (this.target.repeat && this.target.repeat.selectable && !this.target.repeat.disableMouseSelection) {
				this.runAction("select", {
					items: [record],
					append: event.ctrlKey || event.metaKey || this.target.repeat.alwaysMultiselect
				});
			}
		},
		runAction: function(action, value) {
			var self = this;
			if (action == "jump-page") {
				return this.loadData(value.page);
			}
			else if (action == "previous-page") {
				if (this.state.paging.current) {
					this.loadData(this.state.paging.current - 1);
				}
			}
			else if (action == "next-page") {
				if (this.state.paging.current < this.state.paging.total - 1) {
					return this.loadData(this.state.paging.current + 1);
				}
			}
			else if (action == "refresh") {
				var retainOffset = value && value.retainOffset;
				return this.loadData(retainOffset ? this.state.paging.current : 0);
			}
			else if (action == "list-available") {
				return this.$services.q.resolve({available: this.getOrderByFields()});
			}
			else if (action == "order-by") {
				if (!value.append) {
					this.state.order.by.splice(0);
				}
				if (value.by) {
					// for example "name desc". we want a list of all the fields involved, e.g. "name" so we can remove any other mentions of this field
					value.by.map(function(x) {
						return x.replace(/[\s]+.*$/, "");
					}).forEach(function(field) {
						var toRemove = self.state.order.by.filter(function(x) {
							return x == field || x.indexOf(field + " ") == 0;
						});
						toRemove.forEach(function(x) {
							self.state.order.by.splice(self.state.order.by.indexOf(x), 1);
						});
					});
					// you can explicitly set "name none" to UNSET an order by
					this.state.order.by.unshift.apply(this.state.order.by, value.by.filter(function(x) {
						return x.indexOf(" none") < 0;
					}));
				}
			}
			else if (action == "select") {
				if (this.target.repeat && this.target.repeat.selectable) {
					if (!value.append || !this.target.repeat.multiSelectable) {
						this.state.selected.splice(0);
					}
					if (value.items) {
						value.items.forEach(function(item) {
							// if we have already selected the item, don't add it again
							if (self.state.selected.indexOf(item) < 0) {
								self.state.selected.push(item);
							}
							// otherwise, if we are selecting only one item and you have append mode on, we actually remove it, because it acts as a toggle
							else if (value.append && value.items.length == 1) {
								self.state.selected.splice(self.state.selected.indexOf(item), 1);
							}
						})
					}
					if (this.state.selected.length) {
						return this.$services.triggerable.trigger(this.target, "select", this.state.selected, this);
					}
					else {
						this.unselectAll();
						return this.$services.q.resolve();
					}
				}
			}
			else if (action == "toggle-slot") {
				var customSlot = this.target.repeat.customSlots.filter(function(x) {
					return x.name == value.slot;
				})[0];
				// invalid slot name or invalid index
				if (!customSlot || value.index == null) {
					return this.$services.q.reject();
				}
				var recordIndex = parseInt(value.index);
				var currentIndex = this.activatedSlots[customSlot.name].indexOf(recordIndex);
				// if we have no explicit show, we just toggle
				var show = value.show == null ? currentIndex < 0 : value.show;
				// no specific action, we just toggle
				if (show) {
					if (currentIndex < 0) {
						if (customSlot.singleOpen) {
							this.activatedSlots[customSlot.name].splice(0);
						}
						this.activatedSlots[customSlot.name].push(recordIndex);
					}
				}
				else if (currentIndex >= 0) {
					this.activatedSlots[customSlot.name].splice(currentIndex, 1);
				}
				return this.$services.q.resolve();
			}
			return this.$services.q.reject();
		},
		unselectAll: function() {
			this.state.selected.splice(0);
			this.$services.triggerable.untrigger(this.target, "select", this);
			// trigger deselect
			this.$services.triggerable.trigger(this.target, "deselect", this);
		},
		getRuntimeState: function() {
			return this.state;	
		},
		getPageInstance: function() {
			return this.$services.page.getPageInstance(this.page, this);
		},
		getParameters: function(record) {
			var result = {};
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			// whatever parameters we passed to the parent page are likely expected to the in the repeated page as well (?)
			// not true, we want the _state_ of the parent page, but this may be due to rest calls etc, we don't want to replay that
			// nabu.utils.objects.merge(result, pageInstance.parameters);
			//nabu.utils.objects.merge(result, this.getVariables());
			// we don't want to pass the entire state as parameters because this causes the repeats to be rerendered if anything changes
			if (this.target.runtimeAlias) {
				result[this.target.runtimeAlias] = {
					// in the fragmented page we want to allow you to update the filter
					// this should work because it is all linked by reference?
					filter: this.state.filter,
					record:record, 
					recordIndex: this.state.records.indexOf(record), 
					records: this.state.records, 
					allRecords: this.state.allRecords
				};
			}
			return result;
		},
		getVariables: function() {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			return pageInstance.variables;
		},
		unloadPages: function() {
			// unload default
			this.unloadPage();	
			var self = this;
			if (this.target.repeat && this.target.repeat.customSlots && this.target.repeat.customSlots.length) {
				this.target.repeat.customSlots.forEach(function(slot) {
					self.unloadPage(slot.name);
				})
			}
		},
		unloadPage: function(slot) {
			this.$services.router.unregister(this.alias + (slot ? "-" + slot : ""));
		},
		beforeMount: function(component) {
			this.mapVariables(component);
		},
		mapVariables: function(target) {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			var self = this;
			Object.keys(pageInstance.variables).forEach(function(key) {
				// not interested in changes to itself
				if (key != self.target.runtimeAlias) {
					if (target.set) {
						if (target.variables[key] != pageInstance.variables[key]) {
							target.set(key, pageInstance.variables[key]);
						}
					}
					else {
						if (target[key] != pageInstance.variables[key]) {
							Vue.set(target, key, pageInstance.variables[key]);
						}
					}
				}
			});
		},
		mounted: function(component) {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			// TODO: subscribe to all events and emit them to this page
			component.$on("hook:beforeDestroy", function() {
				console.debug("Destroying repeated fragmented page");
			});
			// we don't need to explicitly unsubscribe? once the page gets destroyed, its gone anyway
			component.subscribe("$any", function(name, value) {
				if (name != "$load") {
					pageInstance.emit(name, value);
				}
			});
			var self = this;
			// map variables initially to the parameters
			// this _somehow_ breaks reactivity on the page
//						mapVariables(parameters);
			// we want to keep the variables up to date without having the route-render continuously rerender the page
			var unwatch = pageInstance.$watch("variables", function() {
				if (component) {
					self.mapVariables(component);
				}
			}, {deep: true});
			
			component.$on("hook:beforeDestroy", function() {
				unwatch();
			});
			
			// instantiate the local variables if necessary
			if (this.target.repeat.localVariables && this.target.runtimeAlias) {
				this.target.repeat.localVariables.forEach(function(variable) {
					if (variable.defaultValue && variable.name) {
						self.$services.page.setValue(component.variables, self.target.runtimeAlias + ".local." + variable.name, self.$services.page.eval(variable.defaultValue, component.variables, component));
						//Vue.set(component.variables, self.target.runtimeAlias + ".local." + variable.name, self.$services.page.eval(variable.defaultValue, component.variables, component));
					}
				});
			}
		},
		uniquify: function() {
			var self = this;
			// make sure we have the highest before we start
			// if for example we pass in an array from outside, it might already have a position
			this.state.records.forEach(function(record) {
				if (record.hasOwnProperty("$position") && record.$position >= self.position) {
					self.position = record.$position + 1;
				}
			});
			this.state.records.forEach(function(record) {
				if (!record.hasOwnProperty("$position") && typeof(record) != "string" && !(record instanceof String)) {
					record["$position"] = self.position++;
				}
			});
		},
		lazyLoad: function(record) {
			if (this.lazyPromise == null && this.state.paging && this.target.repeat.scrollLoad && this.state.paging.current != null) {
				var next = this.state.paging.current + 1;
				if (this.state.paging.total != null && this.state.paging.total != 0 && this.state.paging.current >= this.state.paging.total - 1) {
					return false;
				}
				var index = this.state.records.indexOf(record);
				// if we are in the final 10% of the table, try to load more
				if (index >= Math.floor(this.state.records.length * 0.9)) {
					this.lazyPromise = this.loadData(next, true);
					var self = this;
					this.lazyPromise.then(function() {
						self.lazyPromise = null;
					}, function() {
						self.lazyPromise = null;
					});
				}
			}
		},
		// in the future we can add a "load more" event support, we then listen to that event and load more data, this means we want to append
		// currently we don't do anything special with limit and offset, you can fill them in in the bindings if you want
		// we will just do the call as a whole, assuming it is a limited service result
		// in the future we can hide the limit/offset inputs and instead expose them as state so you can directly write to them (?)
		loadData: function(page, append) {
			this.loadCounter++;
			var self = this;
			this.collapseAllSlots();
			if (self.repeatTimer) {
				clearTimeout(self.repeatTimer);
				self.repeatTimer = null;
			}
			// trigger an unselect
			if (this.state.selected.length > 0) {
				this.unselectAll();
			}
			// abort the previous promise if it still ongoing
			if (this.loadPromise && this.loadPromise.abort) {
				this.loadPromise.abort();
			}
			this.loadPromise = null;
			// we want to call an operation
			if (this.target.repeat && (this.target.repeat.type == "operation" || this.target.repeat.type == null) && this.target.repeat.operation) {
				var parameters = {}
				nabu.utils.objects.merge(parameters, this.operationParameters);
				// local state variables win from passed in ones!
				if (this.state.filter) {
					Object.keys(this.state.filter).forEach(function(key) {
						// someone might still attempt to write to record?
						// by default the state has no keys
						// any key available is explicitly written by the user, so even a null value is an active decision
						if (key != "record") {
							parameters[key] = self.state.filter[key];
						}
					});
				}
				if (this.state.order.by.length) {
					parameters["orderBy"] = this.state.order.by;
				}
				// if we want to load a certain page, we need a limit
				if (page != null) {
					if (parameters.limit == null) {
						parameters.limit = 10;
					}
					parameters.offset = parameters.limit * page;
				}
				if (this.state["$serviceContext"]) {
					parameters["$serviceContext"] = this.state["$serviceContext"];
				}
				else {
					parameters["$serviceContext"] = this.$services.page.getPageInstance(this.page, this).getServiceContext();
				}
				if (!append) {
					// don't set loading if appending, this will disrupt visualization
					this.loading = true;
					self.state.records.splice(0);
					self.state.allRecords.splice(0);
				}
				else {
					this.appendLoading = true;
				}
				this.loadPromise = this.$services.swagger.execute(this.target.repeat.operation, parameters).then(function(list) {
					Object.keys(self.state.raw).forEach(function(x) {
						Vue.set(self.state.raw, x, null);
					});
					if (!append) {
						self.state.records.splice(0);
						self.state.allRecords.splice(0);
					}
					if (list) {
						Object.keys(list).forEach(function(x) {
							Vue.set(self.state.raw, x, list[x]);
						});
						
						var arrayField = Object.keys(self.$services.data.getArrayOutputField(self.target.repeat.operation))[0];
						var arrayFound = false;
						var findArray = function(root) {
							var array = root[arrayField];
							if (array == null) {
								array = [];
							}
							arrayFound = true;
							
							// enrich with position
							array.forEach(function(x, i) {
								if (x) {
									x.$position = self.position++;
								}
							});
							
							nabu.utils.arrays.merge(self.state.allRecords, array);
							if (self.target.repeat.arrayFilter) {
								nabu.utils.arrays.merge(self.state.records, 
									array.filter(function(x) {
										var $value = function(value, literal) {
											if (value == "records") {
												return array;
											}
											else if (value == "record") {
												return x;
											}
											else {
												return self.$value(value, literal);
											}
										}
										return self.$services.page.isCondition(self.target.repeat.arrayFilter, x, self, $value);
									})
								);
							}
							else {
								nabu.utils.arrays.merge(self.state.records, array);
							}
							
							/*
							// old resolving based on dynamically finding the first array!
							Object.keys(root).forEach(function(field) {
								if (root[field] instanceof Array && !arrayFound) {
									root[field].forEach(function(x, i) {
										if (x) {
											x.$position = self.position++;
										}
									});
									nabu.utils.arrays.merge(self.state.allRecords, root[field]);
									if (self.target.repeat.arrayFilter) {
										nabu.utils.arrays.merge(self.state.records, 
											root[field].filter(function(x) {
												var $value = function(value, literal) {
													if (value == "records") {
														return root[field]
													}
													else if (value == "record") {
														return x;
													}
													else {
														return self.$value(value, literal);
													}
												}
												return self.$services.page.isCondition(self.target.repeat.arrayFilter, x, self, $value);
											})
										);
									}
									else {
										nabu.utils.arrays.merge(self.state.records, root[field]);
									}
									arrayFound = true;
								}
								if (!arrayFound && typeof(root[field]) === "object" && root[field] != null) {
									findArray(root[field]);
								}
							});
							*/
						}
						findArray(list);
						
						var pageFound = false;
						var findPage = function(root) {
							Object.keys(root).forEach(function(field) {
								// check if we have an object that has the necessary information
								if (typeof(root[field]) === "object" && root[field] != null && !pageFound) {
									// these are the two fields we use and map, check if they exist
									if (root[field].current != null && root[field].total != null) {
										nabu.utils.objects.merge(self.state.paging, root[field]);
										pageFound = true;
									}
									// recurse
									if (!pageFound) {
										findPage(root[field]);
									}
								}
							});
						}
						findPage(list);
					}
					self.uniquify();
					self.loading = false;
					self.appendLoading = false;
					self.created = true;
					// only repeat if we are not yet destroyed
					if (self.target.repeat.refreshInterval && !self.destroyed) {
						self.repeatTimer = setTimeout(function() {
							self.loadData(page)
						}, self.target.repeat.refreshInterval);
					}
				}, function(error) {
					// TODO: what in case of error?
					self.loading = false;
					self.appendLoading = false;
					self.created = true;
				})
			}
			else if (this.target.repeat && (this.target.repeat.type == "array" || this.target.repeat.type == null) && this.target.repeat.array) {
				if (!append) {
					this.state.records.splice(0);
					this.state.allRecords.splice(0);
				}
				var result = this.$services.page.getPageInstance(this.page, this).get(this.target.repeat.array);

				if (result) {
					nabu.utils.arrays.merge(this.state.allRecords, result);
					if (this.target.repeat.arrayFilter) {
						result = result.filter(function(x) {
							var $value = function(value, literal) {
								if (value == "records") {
									return result;
								}
								else if (value == "record") {
									return x;
								}
								else {
									return self.$value(value, literal);
								}
							}
							return self.$services.page.isCondition(self.target.repeat.arrayFilter, x, self, $value);
						});
					}
					nabu.utils.arrays.merge(this.state.records, result);
				}
				self.uniquify();
				self.created = true;
				this.loadPromise = this.$services.q.resolve(result);
			}
			else {
				var provider = nabu.page.providers("page-repeat").filter(function(provider) {
					return provider.name == self.target.repeat.type;
				})[0];
				if (provider && provider.loadData) {
					this.loadPromise = provider.loadData(self.target, self.state, page, append);
				}
			}
			if (this.loadPromise && this.loadPromise.then) {
				this.loadPromise.then(function() {
					return self.$services.triggerable.trigger(self.target, "load", self.state.records, self);
				})
			}
			return this.loadPromise;
		},
		loadPages: function() {
			// the "default" slot page
			this.loadPage();
			var self = this;
			if (this.target.repeat && this.target.repeat.customSlots && this.target.repeat.customSlots.length) {
				this.target.repeat.customSlots.forEach(function(slot) {
					self.loadPage(slot.name);
				})
			}
		},
		// create a custom route for rendering
		loadPage: function(slot) {
			var pageInstance = this.$services.page.getPageInstance(this.page, this);
			
			this.unloadPage(slot);
			if (this.target.runtimeAlias) {
				var content = {
					"rows": [],
					"counter": 1,
					"variables": [],
					"query": [],
					"actions": [],
					"class": null,
					"initial": false,
					"menuX": 0,
					"menuY": 0,
					"states": [],
					"category": "Other Category",
					"slow": false,
					"name": this.alias + (slot ? "-" + slot : ""),
					"parameters": [],
					"readOnly": true,
					"pageType": this.getPageType().pageType,
					// you can optimze the rows by throwing away the page wrapper
					// currently this also throws away edit mode so we can only globally enable this once we have moved the editing outside of the page!
					// no longer needed, vue was complaining about two roots so made an optimized derivative component
					"optimizeRows": false
					// TODO: should be recursive, currently we can only go up one parent
					// aimed at matrices atm
//					"fragmentParentContent": pageInstance.fragmentParent ? pageInstance.fragmentParent.page.content : pageInstance.page.content
				};
				// add our local value
				content.parameters.push({
					name: this.target.runtimeAlias,
					// we can be more specific about the type, not sure if it is necessary though
					type: 'string',
					format: null,
					default: null,
					global: false,
					// we can listen to events and take a value from them to update the current value
					// e.g. we could update a search parameter if you select something
					listeners: []
				});
				var slotFilter = function(x) {
					return (!slot && !x.rendererSlot) || (slot == x.rendererSlot);
				}
				// we have a row, just push it to the rows
				if (this.target.rows) {
					nabu.utils.arrays.merge(content.rows, this.target.rows.filter(slotFilter));
					content.repeatType = "cell";
				}
				// we have a cell
				else if (this.target.cells) {
					content.repeatType = "row";
					var row = {
						// use an id that definitely does not collide with the content
						id: this.target.id,
						state: {},
						cells: [],
						class: null,
						customId: null,
						instances: {},
						condition: null,
						direction: null,
						align: null,
						on: null,
						collapsed: false,
						name: null,
						// the renderer slot needs to be repeated, it is likely for a parent renderer
						rendererSlot: this.target.rendererSlot,
						styleVariables: this.target.styleVariables
					};
					// inherit triggers
					// we want to be able to do it contextually
					row.triggers = this.target.triggers;
					nabu.utils.arrays.merge(row.cells, this.target.cells.filter(slotFilter));
					content.rows.push(row);
				}
				var page = {
					name: content.name,
					content: content
				}
				if (slot) {
					this.fragmentPages[slot] = page;
				}
				else {
					this.fragmentPage = page;
				}
				var self = this;
				// @2025-04-18: not used anymore...?
				var route = {
					alias: page.name,
					enter: function(parameters, mask) {
						var mapVariables = function(target) {
							Object.keys(pageInstance.variables).forEach(function(key) {
								// not interested in changes to itself
								if (key != self.target.runtimeAlias) {
									if (target.set) {
										if (target.variables[key] != pageInstance.variables[key]) {
											target.set(key, pageInstance.variables[key]);
										}
									}
									else {
										if (target[key] != pageInstance.variables[key]) {
											Vue.set(target, key, pageInstance.variables[key]);
										}
									}
								}
							});
						}
						
						// map variables initially to the parameters
						// this _somehow_ breaks reactivity on the page
//						mapVariables(parameters);
						
						var newPage = null;
						// we want to keep the variables up to date without having the route-render continuously rerender the page
						var unwatch = pageInstance.$watch("variables", function() {
							if (newPage) {
								mapVariables(newPage);
							}
						}, {deep: true});
						newPage = new nabu.page.views.Page({template: "n-page-optimized", propsData: {
							page: page, 
							parameters: parameters, 
							stopRerender: parameters ? parameters.stopRerender : false, 
							pageInstanceId: self.$services.page.pageCounter++, 
							masked: mask 
						}, beforeDestroy: function() {
							unwatch();
						// the sweet spot to make sure rules etc are initialized correctly but not to interrupt other things
						}, beforeMount: function() {
							mapVariables(this);
						}});
						return newPage;
					},
					// yes it's a page, but we don't want it treated as such
					isPage: false,
					initial: false,
					properties: page.content.properties ? page.content.properties : []
				};
				this.$services.router.register(route);
			}
		}
	}
});


Vue.component("renderer-repeat-configure", {
	template: "#renderer-repeat-configure",
	props: {
		page: {
			type: Object,
			required: true
		},
		// the target (cell or row)
		target: {
			type: Object,
			required: true
		},
		// whether or not we are in edit mode (we can do things slightly different)
		edit: {
			type: Boolean,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		}
	},
	created: function() {
		if (!this.target.repeat) {
			Vue.set(this.target, "repeat", {});
		}
		if (!this.target.repeat.bindings) {
			Vue.set(this.target.repeat, "bindings", {});
		}	
		if (!this.target.repeat.defaultOrderBy) {
			Vue.set(this.target.repeat, "defaultOrderBy", []);
		}
		if (!this.target.repeat.type) {
			if (this.target.repeat.operation) {
				Vue.set(this.target.repeat, "type", "operation");
			}
			else if (this.target.repeat.array) {
				Vue.set(this.target.repeat, "type", "array");
			}
		}
		if (!this.target.repeat.customSlots) {
			Vue.set(this.target.repeat, "customSlots", []);
		}
		if (!this.target.repeat.localVariables) {
			Vue.set(this.target.repeat, "localVariables", []);
		}
	},
	computed: {
		operationParameters: function() {
			var result = [];
			if (this.target.repeat && this.target.repeat.operation) {
				// could be an invalid operation?
				if (this.$services.swagger.operations[this.target.repeat.operation]) {
					var parameters = this.$services.swagger.operations[this.target.repeat.operation].parameters;
					if (parameters) {
						nabu.utils.arrays.merge(result, parameters.map(function(x) { return x.name }));
					}
				}
			}
			return result;
		}
	},
	methods: {
		getRepeatTypes: function(value) {
			var types = [];
			types.push({
				name: "operation",
				title: "The return value of a REST call"
			});
			types.push({
				name: "array",
				title: "The values available in an array"
			});
			nabu.utils.arrays.merge(types, nabu.page.providers("page-repeat"));
			if (value) {
				types = types.filter(function(x) {
					return (x.name && x.name.toLowerCase().indexOf(value.toLowerCase()) >= 0)
						|| (x.title && x.title.toLowerCase().indexOf(value.toLowerCase()) >= 0)
				})
			}
			return types;
		},
		getRepeatConfigurator: function() {
			var self = this;
			if (this.target.repeat.type && this.target.repeat.type != "operation" && this.target.repeat.type != "array") {
				var type = nabu.page.providers("page-repeat").filter(function(x) {
					return x.name == self.target.repeat.type;
				})[0];
				return type ? type.configurator : null;
			}	
		},
		getOrderByFields: function(value) {
			var result = [];
			if (this.target.repeat && this.target.repeat.operation) {
				var operation = this.$services.swagger.operation(this.target.repeat.operation);	
				var self = this;
				if (operation && operation.parameters) {
					var orderBy = operation.parameters.filter(function(x) {
						return x.name == "orderBy";
					})[0];
					// if we have an order by field, we can order by all the outputs (by default)
					if (orderBy && operation.responses["200"] && operation.responses["200"].schema) {
						var definition = self.$services.swagger.resolve(operation.responses["200"].schema);
						var arrays = self.$services.page.getArrays(definition);
						if (arrays.length > 0) {
							var childDefinition = self.$services.page.getChildDefinition(definition, arrays[0]);
							if (childDefinition && childDefinition.items && childDefinition.items.properties) {
								nabu.utils.arrays.merge(result, Object.keys(childDefinition.items.properties));
							}
						}
					}
				}
			}
			return result.filter(function(x) {
				return !value || x.toLowerCase().indexOf(value.toLowerCase()) >= 0;
			});
		}
	}
}); 
// considerations:
// colspans
// rowspans (for row grouping)
// tbody, tr, td correct elements

nabu.page.provide("page-type", {
	name: "table-page",
	rowTag: function(row, depth, editing, reversePath, page) {
		if (row.rendererSlot == "body") {
			return "tbody";
		}
		// if we have a row that is set to "body", the cells inside it become the table rows
		// at that point the rows inside that cell become the "td"
		else if (reversePath.length >= 3 && reversePath[2].rendererSlot == "body") {
			return "renderer-table-body-cell";
		}
		// it must be inside the table, this goes for header, footer & body, for example for body depth:
		// <column> <repeat> <table>
		var isRow = reversePath.length >= 2 && reversePath[1].renderer == "table";
		// in a repeat (e.g. the body), you are in a page fragment
		// to be a valid cell INSIDE a table, you need at least 3 levels
		// the repeat spins off a fragment page with the correct page type (e.g. table), but not the necessary depth
		isRow |= reversePath.length == 1;
		if (isRow) {
			// if the repeat type is CELL, we assume that you have a repeat inside the header!
			// this means you have a singular header row (no repeat) and within that a cell that has a repeat
			// the repeat has to be ON this cell though, not some faraway parent cell
			if (page.content.repeatType == "cell" && row.repeat) {
				return "th";
			}
			return "tr";
		}
		else {
			return null;
		}
	},
	cellTag: function(row, cell, depth, editing, reversePath, page) {
		// we are repeating in the header (or footer) a cell, the row is already tagged as a cell, we don't need this here
		// note that the repeat has to be ON this cell though
		if (page.content.repeatType == "cell" && cell.repeat) {
			return null;
		}
		// if we are inside a body repeat, we need a tr
		else if (reversePath.length >= 2 && reversePath[1].rendererSlot == "body") {
			return "tr";
		}
		// it must be inside the table, this goes for header, footer & body, for example for body depth:
		// <column> <repeat> <table>
		var isColumn = reversePath.length >= 3 && reversePath[2].renderer == "table";
		// in a repeat (e.g. the body), you are in a page fragment
		// to be a valid cell INSIDE a table, you need at least 3 levels
		// the repeat spins off a fragment page with the correct page type (e.g. table), but not the necessary depth
		isColumn |= reversePath.length == 2;
		var isHeader = isColumn && reversePath.length >= 2 && reversePath[1].rendererSlot == "header";
		if (isHeader) {
			return "renderer-table-header-cell";
		}
		else if (isColumn) {
			return "renderer-table-body-cell";
		}
		else {
			return null;
		}
	},
	repeatTag: function(target) {
		return "tbody";
	},
	cellComponent: function(cell, reversePath, page) {
		// see above
		if (page.content.repeatType == "cell" && cell.repeat) {
			return null;
		}
		// if we are inside a body repeat, we need a tr
		else if (reversePath.length >= 2 && reversePath[1].rendererSlot == "body") {
			return "table-row";
		}
		var isColumn = reversePath.length >= 3 && reversePath[2].renderer == "table";
		isColumn |= reversePath.length == 2;
		return isColumn ? "table-column" : null;
	},
	rowComponent: function(cell, reversePath, page) {
		var isRow = reversePath.length >= 2 && reversePath[1].renderer == "table";
		isRow |= reversePath.length == 1;
		if (isRow && page.content.repeatType == "cell") {
			return "table-column";
		}
		else if (reversePath.length >= 3 && reversePath[2].rendererSlot == "body") {
			return "table-column";
		}
		return isRow ? "table-row" : null;
	},
	repeatComponent: function(target) {
		return "table-body"
	},
	messageTag: function(target) {
		return "renderer-table-message";
	}
});

// 1-deep, we assume you have a dynamic repeat WITHIN the repeat of your body
// note that nested repeats in headers and footers are not supported atm
nabu.page.provide("page-type", {
	name: "table-page-child",
	rowTag: function(row, depth, editing, reversePath) {
		//return reversePath.length == 1 ? "td" : null;	
	},
	rowComponent: function(cell, reversePath) {
		//return reversePath.length == 1 ? "table-column" : null;	
	}
});

// table should expose action to "order by" (takes a list)
// we can use click events on the columns to trigger an action on the table to order by
// the orderby should also be exposed as state? we can check if a certain field is ordered by and in which direction
// we can use this to conditionally render the sort icon

nabu.page.provide("page-renderer", {
	title: "Table",
	name: "table",
	type: ["cell"],
	component: "renderer-table",
	configuration: "renderer-table-configure",
	cssComponent: "table",
	getChildComponents: function(target) {
		return [{
			title: "Table",
			name: "table",
			component: "table"
		}];
	},
	getPageType: function(target) {
		return "table-page";
	},
	getSlots: function(target) {
		return ["header", "body", "footer"];
	},
	// cells can have colspans!
	getChildConfig: function(target, child, reversePath) {
		if (child.rows) {
			return "renderer-table-cell-configure";
		}
		else if (child.cells && reversePath.length >= 3 && reversePath[2].rendererSlot == "body") {
			return "renderer-table-cell-configure";
		}
	}
});


Vue.component("renderer-table", {
	template: "#renderer-table",
	props: {
		page: {
			type: Object,
			required: true
		},
		// the target (cell or row)
		target: {
			type: Object,
			required: true
		},
		// whether or not we are in edit mode (we can do things slightly different)
		edit: {
			type: Boolean,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		}
	},
	methods: {
		hasDefaultElements: function() {
			var children = this.target.rows ? this.target.rows : this.target.cells;
			return children && children.filter(function(x) {
				return !x.rendererSlot;
			}).length > 0;
		}
	}
});


Vue.component("renderer-table-configure", {
	template: "#renderer-table-configure"	
});

Vue.component("renderer-table-cell-configure", {
	template: "#renderer-table-cell-configure",
	props: {
		cell: {
			type: Object
		},
		row: {
			type: Object
		},
		page: {
			type: Object
		}
	},
	data: function() {
		return {
			target: null
		}
	},
	created: function() {
		if (this.cell) {
			this.target = this.cell;
		}
		else if (this.row) {
			this.target = this.row;
		}
		if (this.target && !this.target.table) {
			Vue.set(this.target, "table", {});
		}
	}
});

Vue.component("renderer-table-message", {
	template: "#renderer-table-message",
	props: {
		target: {
			type: Object
		},
		page: {
			type: Object
		}
	}
});


Vue.component("renderer-table-body-cell", {
	template: "#renderer-table-body-cell",
	props: {
		target: {
			type: Object
		},
		page: {
			type: Object
		}
	},
	data: function() {
		return {
			elementPromise: null
		}
	},
	created: function() {
		this.elementPromise = this.$services.q.defer();
	},
	ready: function() {
		this.elementPromise.resolve(this.$el);
	},
	computed: {
		// TODO: if colspan is 0, calculate the amount of columns!
		colspan: function() {
			return this.target && this.target.table ? this.target.table.colspan : null;
		},
		label: function() {
			if (this.target && this.target.table && this.target.table.embeddedLabel) {
				return this.$services.page.interpret(this.$services.page.translate(this.target.table.embeddedLabel), this)
			}
			else {
				var pageInstance = this.$services.page.getPageInstance(this.page, this);
				var originalPageInstance = pageInstance;
				// we are in the body, which is (presumably) a repeat
				// if so, we are in a fragment page that does not have full overview of the content
				// let's check the fragment parent for the real content
				// note that this does not work with nested repeats...(yet)
				pageInstance = this.$services.page.getRootPage(pageInstance);
/*				if (pageInstance.fragmentParent) {
					pageInstance = pageInstance.fragmentParent;
				}*/
				var path = this.$services.page.getTargetPath(pageInstance.page.content, this.target.id);
				// the parent should be the body repeat
				// the grandparent should be the table
				if (path.length >= 2) {
					var table = path[path.length - 3];
					// TODO: not yet for repeating tbody setups
					if (!table.rows) {
						return null;
					}
					var headerRow = table.rows.filter(function(x) {
						return x.rendererSlot == "header";
					})[0];
					// only proceed if we have a header row to look at					
					if (headerRow) {
						// calculate the correct colspan for ourselves
						var parent = path[path.length - 2];
						var ourIndex = parent.cells.indexOf(path[path.length - 1]);
						var colspan = 0;
						for (var i = 0; i <= ourIndex; i++) {
							if (parent.cells[i].table && parent.cells[i].table.colspan) {
								colspan += parseInt(parent.cells[i].table.colspan);
							}
							else {
								colspan++;
							}
						}
						var headerColspan = 0;
						var cellToUse = null;
						// check the cell that corresponds to this colspan
						for (var i = 0; i < headerRow.cells.length; i++) {
							if (headerRow.cells[i].table && headerRow.cells[i].table.colspan) {
								headerColspan += parseInt(headerRow.cells[i].table.colspan);
							}
							else {
								headerColspan++;
							}
							// as long as our colspan is OK, we set this cell
							if (headerColspan <= colspan) {
								cellToUse = headerRow.cells[i];
							}
							else {
								break;
							}
						}
						// we need a cell
						if (cellToUse) {
							// we want a typography-enabled content
							if (cellToUse.state.content) {
								return this.$services.typography.replaceVariables(originalPageInstance, cellToUse.state, cellToUse.state.content, this.elementPromise);
							}
						}
					}
				}
			}
			return null;
		}
	}
});


Vue.component("renderer-table-header-cell", {
	template: "#renderer-table-header-cell",
	props: {
		target: {
			type: Object
		},
		page: {
			type: Object
		}
	},
	computed: {
		colspan: function() {
			return this.target && this.target.table ? this.target.table.colspan : null;
		}
	}
});


Vue.component("data-field-picker", {
	template: "#data-field-picker",
	props: {
		value: {
			type: Array,
			required: true
		},
		fields: {
			type: Array,
			required: true
		}
	},
	data: function() {
		return {
			result: []
		}	
	},
	computed: {
		allChecked: function() {
			return this.result.filter(function(x) {
				return !x.checked
			}).length == 0;
		}
	},
	created: function() {
		nabu.utils.arrays.merge(this.result, this.fields.map(function(x) {
			return {
				name: x,
				checked: true
			}
		}));
		console.log("fields are", this.result);
	},
	methods: {
		checkAll: function() {
			this.result.forEach(function(x) {
				x.checked = true;
			});
		},
		uncheckAll: function() {
			this.result.forEach(function(x) {
				x.checked = false;
			});
		},
		upAll: function(field) {
			var index = this.result.indexOf(field);
			if (index > 0) {
				this.result.splice(index, 1);
				this.result.unshift(field);	
			}
		},
		up: function(field) {
			var index = this.result.indexOf(field);
			if (index > 0) {
				this.result.splice(index, 1);
				this.result.splice(index - 1, 0, field);
			}
		},
		down: function(field) {
			var index = this.result.indexOf(field);
			if (index < this.result.length - 1) {
				this.result.splice(index, 1);
				this.result.splice(index + 1, 0, field);
			}
		},
		downAll: function(field) {
			var index = this.result.indexOf(field);
			if (index < this.result.length - 1) {
				this.result.splice(index, 1);
				this.result.splice(this.result.length - 1, 0, field);
			}
		}
	},
	watch: {
		result: {
			deep: true,
			handler: function() {
				this.value.fields.splice(0);
				nabu.utils.arrays.merge(this.value.fields, this.result.filter(function(x) {
					return x.checked
				}).map(function (x){
					return x.name
				}));
			}
		}
	}
})
// to be pageable we must be able to determine which page you are on
// and be able to jump to a random page

nabu.page.provide("page-specification", {
	name: "pageable",
	state: {
		paging: {
			properties: {
				// current page
				current: {
					type: "int64"
				},
				// the total amount of pages
				total: {
					type: "int64"
				},
				// how many items on a page
				pageSize: {
					type: "int64"
				},
				// the offset in rows
				rowOffset: {
					type: "int64"
				},
				// total amount of rows available
				totalRowCount: {
					type: "int64"
				}
			}
		}
	},
	actions: [{
		title: "Jump to page",
		name: "jump-page",
		input: {
			page: {
				type: "int64"
			}
		},
		// we could do a separate call, but especially when using dedicated buttons
		// it is much easier to combine this into a single call
		// the records are not useful at this point to be returned anyway
		output: {
			// current page
			current: {
				type: "int64"
			},
			// the total amount of pages
			total: {
				type: "int64"
			},
			// how many items on a page
			pageSize: {
				type: "int64"
			},
			// the offset in rows
			rowOffset: {
				type: "int64"
			},
			// total amount of rows available
			totalRowCount: {
				type: "int64"
			}
		}
	}, {
		title: "Get Paging",
		name: "get-paging",
		input: {},
		// the naming is not very clear, but at least it is inline with the backend...
		output: {
			// current page
			current: {
				type: "int64"
			},
			// the total amount of pages
			total: {
				type: "int64"
			},
			// how many items on a page
			pageSize: {
				type: "int64"
			},
			// the offset in rows
			rowOffset: {
				type: "int64"
			},
			// total amount of rows available
			totalRowCount: {
				type: "int64"
			}
		}
	}]
});
// unlike pageable where we know the amount of pages and can do random jumps
// with browseable we can only go forward and back a page
// when going forward we can choose to append the data (in a load-more scenario)
// they SHOULD return a promise simply to indicate when they are done (the actual value is undefined)
nabu.page.provide("page-specification", {
	name: "browseable",
	actions: [{
		title: "Next Page",
		name: "next-page",
		input: {
			append: {
				type: "boolean"
			}
		},
		output: {
			// can we go further?
			hasMore: {
				type: "boolean"
			}
		}
	}, {
		title: "Previous Page", 
		name: "previous-page",
		input: {},
		output: {
			// can we go back further?
			hasMore: {
				type: "boolean"
			}
		}
	}]
});
// to be pageable we must be able to determine which page you are on
// and be able to jump to a random page

nabu.page.provide("page-specification", {
	name: "orderable",
	state: {
		order: {
			properties: {
				by: {
					type: "array",
					items: {
						type: "string"
					}
				}
			}
		}
	},
	actions: [{
		title: "Order By",
		name: "order-by",
		// order by a set of field or fields
		// for instance: name asc, created desc
		input: {
			by: {
				type: "array",
				items: {
					type: "string"
				}
			},
			// by default only the new order by is applied
			// but you can also combine it with the existing order by
			append: {
				type: "boolean"
			}
		}
	}, {
		title: "List available fields",
		name: "list-available",
		output: {
			available: {
				type: "array",
				items: {
					type: "string"
				}
			}
		}
	}]
});


if (!application) { var application = {} }

application.configuration = {
	scheme: {
		http: "http",
		ws: "ws"
	},
	url: "unavailable",
	host: "unavailable",
	root: "unavailable",
	cookiePath: "unavailable",
	mobile: navigator.userAgent.toLowerCase().indexOf("mobi") >= 0,
	development: false,
	applicationLanguage: "unavailable",
	requestEnrichers: [],
	interpretValues: true,
	// if you always want the user to be logged in, the swagger will redirect to the login if the remember fails
	alwaysLogIn: false
};

if (application.configuration.root == "unavailable") {
	var base = document.head.querySelector("base");
	application.configuration.root = base ? base.getAttribute("href") : "/";
}

application.views = {};
application.components = {};
application.definitions = {};
// a list of loaders that need to be run once the application has been initialized
application.loaders = [];

application.bootstrap = function(handler) {
	// we have already started the services bus, immediately execute the handler
	if (application.services) {
		handler(application.services);
	}
	// add it to the list of other things to be executed
	else {
		application.loaders.push(handler);
	}
};
application.initialize = function() {
	application.services = new nabu.services.ServiceManager({
		mixin: function(services) {
			Vue.mixin({
				// inject some services for use
				computed: {
					$configuration: function() { return application.configuration },
					$services: function() { return services },
					$views: function() { return application.views },
					$application: function() { return application }
				}
			});	
		},
		q: nabu.services.Q,
		cookies: nabu.services.Cookies,
		swagger: application.definitions.Swagger,
		loader: function loader($services) {
			this.$initialize = function() {
				return function(element, clazz) {
					nabu.utils.elements.clear(element);
					var span = document.createElement("span");
					span.setAttribute("class", "n-icon n-icon-spinner fa spinner" + (clazz ? " " + clazz : ""));
					span.setAttribute("style", "display: block; text-align: center");
					element.appendChild(span);
					return span;
				}
			}	
		},
		router: function router($services) {
			this.$initialize = function() {
				return new nabu.services.VueRouter({
					useParents: true,
					useProps: true,
					useHash: false,
					unknown: function(alias, parameters, anchor) {
						return $services.router.get("notFound");
					},
					authorizer: function(anchor, newRoute, newParameters) {
						var rolesToCheck = null;
						
						// if the page is login, we always allow it
						// if we would conclude that you can't access it, we would need to redirect to...login?
						// this ends up routing endlessly
						if (newRoute.alias == "login") {
							return true;
						}
						
						// we want to check not only the roles on the target page, but also the parents
						// this allows you to set for instance a $user requirement on a skeleton
						var toCheck = newRoute;
						while (toCheck) {
							if (toCheck.roles) {
								// if we have no role restrictions yet, just use them
								if (rolesToCheck == null) {
									rolesToCheck = toCheck.roles;
								}
								// otherwise, we need to find the common roles
								else {
									rolesToCheck = rolesToCheck.filter(function(x) {
										return toCheck.roles.indexOf(x) >= 0;
									});
								}
							}
							// if we have parents, also check their roles
							if (toCheck.parent) {
								toCheck = $services.router.get(toCheck.parent);
							}
							else {
								break;
							}
						}
						
						if (rolesToCheck && rolesToCheck.length >= 1 && $services.user) {
							if (rolesToCheck.indexOf("$guest") < 0 && !$services.user.loggedIn) {
								$services.vue.attemptedRoute.alias = newRoute.alias;
								$services.vue.attemptedRoute.parameters = newParameters;
								// put it in local storage for later use
								localStorage.setItem("redirect-to", window.location.toString());
								return {
									alias: "login",
									mask: true
								}
							}
							else if ($services.user.hasRole) {
								var hasRole = false;
								for (var i = 0; i < rolesToCheck.length; i++) {
									if ($services.user.hasRole(rolesToCheck[i])) {
										hasRole = true;
										break;
									}
								}
								if (!hasRole) {
									return {
										alias: "home"
									}
								}
							}
							else if (rolesToCheck.indexOf("$user") < 0 && $services.user.loggedIn) {
								return {
									alias: "home"
								}
							}
						}
						if (newRoute.actions && newRoute.actions.length >= 1 && $services.user && $services.user.hasAction) {
							var hasAction = false;
							for (var i = 0; i < newRoute.actions.length; i++) {
								if ($services.user.hasAction(newRoute.actions[i])) {
									hasAction = true;
									break;
								}
							}
							if (!hasAction) {
								return {
									alias: $services.user.loggedIn ? "home" : "login"
								}
							}
						}
					},
					chosen: function(anchor, newRoute, newParameters) {
						if (anchor && (newRoute.slow || (newParameters != null && newParameters.slow))) {
							
							nabu.utils.vue.render({
								target: anchor,
								content: "<div class='page-loader-inline-container'><div class='page-loader'></div></div>"
							});
						}	
					},
					enter: function(anchor, newRoute, newParameters, newRouteReturn, mask) {
						if (!mask && newRoute.url) {
							// keep previous state so we know where we came from
							$services.vue.previousRoute = $services.vue.lastRoute;
							$services.vue.route = newRoute.alias;
							$services.vue.parameters = newParameters;
							$services.page.chosenRoute = newRoute.alias;
							$services.vue.lastRoute = newRoute;
							// reset scroll
							// document.body.scrollTop = 0;
							window.scrollTo(0, 0);
						}
					}
				});
			}
		},
		vue: function vue() {
			this.$initialize = function() {
				return new Vue({
					el: "body",
					data: function() {
						return {
							route: null,
							parameters: null,
							lastRoute: null,
							attemptedRoute: {}
						}
					},
					methods: {
						updateUrlParameter: function(key, value) {
							if (this.lastRoute != null) {
								var parameters = this.lastRoute.parameters ? nabu.utils.objects.clone(this.lastRoute.parameters) : {};
								parameters[key] = value;
								var url = this.$services.router.router.template(this.lastRoute.alias, parameters);
								// only update if we have _some_ url
								if (url) {
									this.$services.router.router.updateUrl(
										this.lastRoute.alias,
										url,
										parameters,
										this.lastRoute.query);
								}
							}
						}
					}
				});
			}
		},
		routes: application.routes,
		loaders: function($services) {
			this.$initialize = function() {
				var promises = [];
				for (var i = 0; i < application.loaders.length; i++) {
					var result = application.loaders[i]($services);
					if (result && result.then) {
						promises.push(result);
					}
				}
				return $services.q.all(promises);
			}
		}
	});
	return application.services.$initialize();
};
if (!application) { var application = {}; }

application.routes = function($services) {
	// example route
	/*
	$services.router.register({
		alias: "home",
		enter: function() {
			return new Vue.component("home")();
		},
		url: "/"
	});
	*/
}
if (!application) { var application = {} };
if (!application.definitions) { application.definitions = {} }

application.definitions.Swagger = function($services) {
	
	var swaggerPath = (application && application.configuration ? application.configuration.root : "/") + "swagger.json";
	
	this.$initialize = function() {
		var promise = $services.q.defer();
		var service = new nabu.services.SwaggerClient({
			remember: function() {
				if ($services.user && $services.user.remember) {
					return $services.user.remember().then(function() {
						// do nothing extra on success
					}, function() {
						if (application.configuration.alwaysLogIn) {
							// on failure, we want to reroute to the login page, there are very few ways to recover properly
							setTimeout(function() {
								$services.router.route("login");
							}, 1);
						}
					});
				}
				else {
					var promise = $services.q.defer();
					promise.reject();
					return promise;
				}
			},
			parseError: true
		});
		promise.stage(service);
		
		nabu.utils.ajax({
			cache: true,
			url: swaggerPath,
			bearer: $services.user != null ? $services.user.bearer : null
		}).then(function(response) {
			service.loadDefinition(response.responseText);
			service.$clear = function() {
				return nabu.utils.ajax({
					url: swaggerPath,
					bearer: $services.user != null ? $services.user.bearer : null
				}).then(function(response) {
					service.loadDefinition(response.responseText);	
				});
			}
			promise.resolve(service);
		}, function(error) {
			promise.reject(error);	
		});
		return promise;
	}
}
window.addEventListener("load", function() {
	application.bootstrap(function($services) {
		if (nabu && nabu.page && nabu.page.provide) {
			nabu.page.provide("page-function", {
				id: "cms.login",
				async: true,
				implementation: function(input, $services, $value, resolve, reject) {
					$services.user.login(input.username, input.password, input.remember, input.type, true).then(resolve, reject);
				},
				inputs: [{
					"name": "username",
					"required": true,
					"type": "string"
				}, {
					"name": "password",
					"required": true,
					"type": "string"
				}, {
					"name": "remember",
					"type": "boolean"
				}, {
					"name": "type",
					"type": "string"
				}],
				outputs: [{
					"name": "challengeType",
					"required": false,
					"type": "string"
				}, {
					"name": "token",
					"required": false,
					"type": "string"
				}]
			});
			nabu.page.provide("page-function", {
				id: "cms.logout",
				async: true,
				implementation: function(input, $services, $value, resolve, reject) {
					var promise = $services.user.logout();
					if (input.route) {
						var route = function() {
							setTimeout(function() {
								$services.router.route(input.route);
							}, 1);
						}
						if (input.routeImmediately == true || input.routeImmediately == "true") {
							route();
						}
						else {
							promise.then(route, route);
						}
					}
					promise.then(resolve, reject);
				},
				inputs: [{
					"name": "route",
					"required": false,
					"type": "string"
				}, {
					"name": "routeImmediately",
					"required": false,
					"type": "string"
				}]
			});
			nabu.page.provide("page-function", {
				id: "cms.changeLanguage",
				async: false,
				implementation: function(input, $services, $value) {
					$services.language.current = input.language;
				},
				inputs: [{
					"name": "language",
					"required": true,
					"type": "string"
				}]
			});
			nabu.page.provide("page-function", {
				id: "cms.revoke",
				async: true,
				inputs: [{
					"name": "deviceId",
					"required": false,
					"type": "array",
					"items": {
						"type": "string"
					}
				}]
			});
		}
	});
});
Vue.service("user", {
	services: ["q", "swagger"],
	data: function() {
		return {
			id: null,
			language: null,
			roles: ["$guest"],
			allowedPermissions: [],
			disallowedPermissions: [],
			permissions: [],
			contextualRoles: {},
			application: "moduleWeb.site.application",
			remembering: false,
			canTimer: null,
			// permissions we want to check
			permissionsToCheck: [],
			permissionsBeingChecked: [],
			permissionCheckPromise: null,
			// check if we are already waiting for the swagger call
			batchWaiting: false,
			// the promise while checking
			permissionBeingCheckedPromise: null,
			// we keep track of the token here
			// almost all calls go through the swagger client, which already has the bearer
			// some calls however (like loading the swagger file itself) bypass the swagger client
			bearer: null,
			// keep track of ltp tokens
			ltpStorage: {}
		}
	},
	computed: {
		loggedIn: function() {
			return this.bearer != null;
		},
		normalizedPermissions: function() {
			return this.permissions.map(function(x) {
				var parts = x.split(":");	
				// only the name
				if (parts.length == 1) {
					parts = ["default", "$global", parts[0]];
				}
				// context + name
				else if (parts.length == 2) {
					parts = ["default", parts[0], parts[1]];
				}
				return parts;
			});
		}
	},
	// always try to remember the user
	activate: function(done) {
		this.remember().then(function() {
			done();
		}, function() {
			done();
		})	
	},
	methods: {
		// calculate a download url
		// when downloading a file, we don't have control over the headers being sent
		// this means we can't set a bearer token
		// if the service does not allow anonymous access, we must pass some credentials in the url
		// we can't use the token we already have because it is not authorized for this use
		// instead we want a one time use password that can be used specifically to call this service
		downloadUrl: function(operationId, parameters, reusable) {
			var promise = this.$services.q.defer();
			var self = this;
			var operation = this.$services.swagger.operations[operationId];
			if (operation) {
				var correlationId = null;
				// if we don't have these markings, we can't use otp
				if (operation["x-temporary-id"] && operation["x-temporary-secret"]) {
					if (reusable) {
						this.ltp(operationId).then(function(result) {
							if (result.authenticationId) {
								var cloned = {};
								nabu.utils.objects.merge(cloned, parameters);
								cloned[operation["x-temporary-id"]] = result.authenticationId;
								cloned[operation["x-temporary-secret"]] = result.secret;
								promise.resolve(self.$services.swagger.parameters(operationId, cloned).url);
							}
							else {
								promise.reject();
							}
						});
					}
					else {
						if (operation["x-temporary-correlation-id"]) {
							correlationId = parameters[operation["x-temporary-correlation-id"]];
						}
						this.$services.swagger.execute("nabu.cms.core.v2.security.web.otp", {
							serviceId: operationId,
							correlationId: correlationId
						}).then(function(result) {
							if (result.authenticationId) {
								var cloned = {};
								nabu.utils.objects.merge(cloned, parameters);
								cloned[operation["x-temporary-id"]] = result.authenticationId;
								cloned[operation["x-temporary-secret"]] = result.secret;
								promise.resolve(self.$services.swagger.parameters(operationId, cloned).url);
							}
							else {
								promise.reject();
							}
						}, promise);
					}
				}
				// just resolve it without anything special
				else {
					promise.resolve(self.$services.swagger.parameters(operationId, parameters).url);
				}
			}
			else {
				promise.reject();
			}
			return promise;
		},
		loadCan: function(permissions) {
			var self = this;
			nabu.utils.arrays.merge(self.permissionsToCheck, permissions);
			if (self.canTimer) {
				clearTimeout(self.canTimer);
				self.canTimer = null;
			}
			if (self.permissionsToCheck.length) {
				if (!self.permissionCheckPromise) {
					self.permissionCheckPromise = this.$services.q.defer();
				}
				var waitAndGo = function() {
					self.canTimer = setTimeout(function() {
						self.batchWaiting = false;
						self.permissionBeingCheckedPromise = self.permissionCheckPromise;
						self.permissionCheckPromise = null;
						nabu.utils.arrays.merge(self.permissionsBeingChecked, self.permissionsToCheck.splice(0));
						if (self.permissionsBeingChecked.length) {
							self.$services.swagger.execute("nabu.cms.core.v2.security.shared.can", {
								body: {
									permissions: self.permissionsBeingChecked
								}
							}).then(function(result) {
								self.permissionsBeingChecked.splice(0);
								if (result.allowed) {
									nabu.utils.arrays.merge(self.allowedPermissions, result.allowed);
								}
								if (result.disallowed) {
									nabu.utils.arrays.merge(self.disallowedPermissions, result.disallowed);
								}
								self.permissionBeingCheckedPromise.resolve(result);
								self.permissionBeingCheckedPromise = null;
							}, function(error) {
								self.permissionsBeingChecked.splice(0);
								self.permissionBeingCheckedPromise.reject(error);
								self.permissionBeingCheckedPromise = null;
							});
						}
						else {
							self.permissionBeingCheckedPromise.resolve();
							self.permissionBeingCheckedPromise = null;
						}
					}, 50);
				}
				// if we are already doing a can check, wait until it returns so we don't have parallel checks
				if (self.permissionBeingCheckedPromise) {
					if (!self.batchWaiting) {
						self.permissionBeingCheckedPromise.then(waitAndGo, waitAndGo);
						self.batchWaiting = true;
					}
				}
				else {
					waitAndGo();
				}
				return this.permissionCheckPromise;
			}
			else {
				return this.$services.q.resolve();
			}
		},
		cant: function(permission, context, serviceContext) {
			var promise = this.$services.q.defer();
			this.can(permission, context, serviceContext).then(function(allowed) {
				promise.reject(allowed);
			}, function(disallowed) {
				promise.resolve(disallowed);
			})
			return promise;
		},
		// checks one or more permissions
		// you can send an object or an array of objects where each object has:
		// - context: e.g. the node id
		// - name: the permission name
		// you can also send "name" as the first parameter and context as the second
		can: function(permission, context, serviceContext, cachedOnly) {
			var self = this;
			var sameServiceContext = function(a, b) {
				if (a == null) {
					a = "default";
				}
				if (b == null) {
					b = "default";
				}
				return a == b;
			}
			// allow string based parameters
			if (typeof(permission) == "string") {
				permission = {
					name: permission,
					context: context,
					serviceContext: serviceContext
				};
			}
			if (permission != null) {
				if (!(permission instanceof Array)) {
					permission = [permission];
				}
				var calculateKey = function(permission) {
					return (permission.name ? permission.name : "no-name") + "::"
						+ (permission.context ? permission.context : "no-context") + "::"
						+ (permission.serviceContext ? permission.serviceContext : "default");
				}
				
				// remove doubles from the requested permissions
				if (permission.length > 1) {
					var uniquePermissions = {};
					permission.forEach(function(x) {
						var key = calculateKey(x);
						uniquePermissions[key] = x;
					});
					permission = Object.values(uniquePermissions);
				}
				
				// if we want to check permissions
				if (permission.length) {
					var allowed = [];
					var disallowed = [];
					// first check the already resolved permissions, we might be able to send back an answer immediately
					
					// we check the disallowed first because if _any_ requested are disallowed, the promise is rejected
					this.disallowedPermissions.forEach(function(cache) {
						for (var i = 0; i < permission.length; i++) {
							var toCheck = permission[i];
							if (sameServiceContext(cache.serviceContext, toCheck.serviceContext) && cache.name == toCheck.name && cache.context == toCheck.context) {
								disallowed.push(toCheck);
								permission.splice(i, 1);
								break;
							}
						}
					});
					if (disallowed.length) {
						return this.$services.q.reject(disallowed);
					}
					// check if any are known to be allowed
					if (permission.length) {
						this.allowedPermissions.forEach(function(cache) {
							for (var i = 0; i < permission.length; i++) {
								var toCheck = permission[i];
								if (sameServiceContext(cache.serviceContext, toCheck.serviceContext) && cache.name == toCheck.name && cache.context == toCheck.context) {
									allowed.push(toCheck);
									permission.splice(i, 1);
									break;
								}
							}
						});
					}
					// if we get here and no permissions remain, we assume you are allowed
					if (!permission.length) {
						return this.$services.q.resolve(allowed);
					}
					// we need to do a rest call to check them
					else if (!cachedOnly) {
						// we need to check that the permission is not already queued for checking or actually being checked right now
						if (this.permissionCheckPromise) {
							var keysToCheck = this.permissionsToCheck.map(function(x) {
								return calculateKey(x);
							});
							var permissionsInToCheck = permission.filter(function(x) {
								return keysToCheck.indexOf(calculateKey(x)) >= 0;
							});
							// if there are permissions in the current promise, we wait for that one, even if it is not all permissions
							// other permission checks might be chained later
							if (permissionsInToCheck.length) {
								var promise = this.$services.q.defer();
								this.permissionCheckPromise.then(function() {
									// recheck the permission now that it has been persisted
									self.can(permission)
										.then(promise, promise);
								}, promise);
								return promise;
							}
						}
						if (this.permissionBeingCheckedPromise) {
							var keysBeingChecked = this.permissionsBeingChecked.map(function(x) {
								return calculateKey(x);
							});
							var permissionsInBeingChecked = permission.filter(function(x) {
								return keysBeingChecked.indexOf(calculateKey(x)) >= 0;
							});
							if (permissionsInBeingChecked.length) {
								var promise = this.$services.q.defer();
								this.permissionBeingCheckedPromise.then(function() {
									// recheck the permission now that it has been persisted
									self.can(permission)
										.then(promise, promise);
								}, promise);
								return promise;
							}
						}
						
						var promise = this.$services.q.defer();
						// any actually resolved permissions are rechecked only against the cache
						this.loadCan(permission).then(function() {
							// recheck the permission now that it has been persisted
							self.can(permission, null, null, true)
								.then(promise, promise);
						}, promise);
						return promise;
					}
				}
			}
			// nothing to resolve
			return this.$services.q.reject();
		},
		// get a valid ltp for an operation
		ltp: function(operationId) {
			var promise = this.$services.q.defer();
			// currently hardcoded, at some point configurable
			var maxDuration = "P1D";
			var minDuration = "PT12H";
			var date = new Date();
			if (this.ltpStorage[operationId]) {
				var useUntil = nabu.utils.dates.addDuration(minDuration, this.ltpStorage[operationId].requested);
				if (useUntil.getTime() >= date.getTime()) {
					this.ltpStorage[operationId].promise.then(promise);
					return promise;
				}
			}
			var self = this;
			this.ltpStorage[operationId] = {
				requested: date,
				promise: this.$services.swagger.execute("nabu.cms.core.v2.security.web.ltp", {
						serviceId: operationId,
						duration: maxDuration
					}).then(function(x) {
						if (x && x.authenticationId) {
							self.ltpStorage[operationId].authorization = x;
							promise.resolve(x);
						}
						else {
							promise.reject();
						}
					}, promise)
			}
			return promise;
		},
		addContextualRoles: function(context, role) {
			if (!this.contextualRoles[context]) {
				Vue.set(this.contextualRoles, context, []);
			}
			var self = this;
			if (!(role instanceof Array)) {
				role = [role];
			}
			role.forEach(function(x) {
				if (self.contextualRoles[context].indexOf(x) < 0) {
					self.contextualRoles[context].push(x);
				}
			});
		},
		impersonate: function(userId) {
			var promise = this.$services.q.defer();
			var self = this;
			this.$services.swagger.execute("nabu.cms.core.v2.security.web.impersonate", {userId: userId}).then(function(result) {
				if (result) {
					self.bearer = null;
					self.$services.swagger.bearer = null;
					self.roles.splice(0);
					self.permissions.splice(0);
					if (result) {
						self.bearer = result.token;
						// set the bearer token for the swagger client if we have a jwt token
						self.$services.swagger.bearer = result.token;
						self.language = result.language;
						if (result.roles) {
							nabu.utils.arrays.merge(self.roles, result.roles);
						}
						if (result.permissions) {
							nabu.utils.arrays.merge(self.permissions, result.permissions);
						}
					}
					self.$services.$clear().then(function() {
						promise.resolve(result);
					}, promise);
				}
				else {
					promise.reject();
				}
			}, promise);
			return promise;
		},
		revoke: function(deviceId) {
			var parameters = {};
			if (deviceId) {
				parameters.deviceId = deviceId instanceof Array ? deviceId : [deviceId];
			}
			return this.$services.swagger.execute("nabu.cms.core.v2.security.web.revoke", parameters);
		},
		login: function(username, password, remember, type, attemptRedirect) {
			var self = this;
			var promise = this.$services.q.defer();
			// if we are logged in, unset the swagger bearer so we can make the call without being logged in
			// this is more expedient than triggering a logout immediately
			// if the new login fails however, we do want to trigger a logout to get everything set up correctly
			if (this.loggedIn) {
				self.$services.swagger.bearer = null;
			}
			this.$services.swagger.execute("nabu.cms.core.v2.security.web.login", { 
				body: {
					authenticationId: username,
					secret: password,
					type: type ? type : "password"
				},
				remember: remember ? remember : false,
				$$skipRemember: true
			}).then(function(result) {
				// if we received a challenge, we need to continue
				if (result && result.challengeType) {
					promise.resolve(result);
					return;
				}
				
				self.bearer = null;
				self.$services.swagger.bearer = null;
				self.roles.splice(0);
				self.permissions.splice(0);
				if (result) {
					self.bearer = result.token;
					// set the bearer token for the swagger client if we have a jwt token
					self.$services.swagger.bearer = result.token;
					self.language = result.language;
					if (result.roles) {
						nabu.utils.arrays.merge(self.roles, result.roles);
					}
					if (result.permissions) {
						nabu.utils.arrays.merge(self.permissions, result.permissions);
					}
				}
				self.$services.$clear().then(function() {
					promise.resolve(result);
				}, promise);
				if (attemptRedirect) {
					var url = localStorage.getItem("redirect-to");
					if (url) {
						localStorage.removeItem("redirect-to");
						var redirected = false;
						if (self.$services.router && self.$services.router.router && self.$services.router.router.findRoute) {
							var current = null;
							// we want to try to do an internal redirect rather than triggering a full browser redirect
							var parsed = new URL(url);
							// check for actual data route
							if (self.$services.router.router.useHash) {
								current = self.$services.router.router.findRoute(parsed.hash && parsed.hash.length > 1 ? parsed.hash.substring(1) : "/");
							}
							else {
								current = self.$services.router.router.findRoute(self.$services.router.router.localizeUrl(parsed.pathname ? parsed.pathname + parsed.search : "/"));
							}
							if (current && current.route && current.route.alias) {
								// we only support parents at this point
								if (self.$services.router.router.useParents) {
									redirected = true;
									self.$services.router.router.route(current.route.alias, current.parameters);
								}
							}
						}
						if (!redirected) {
							window.location = url;
						}
					}
					else {
						self.$services.router.route("home");
					}
				}
			}, function(error) {
				if (self.loggedIn) {
					self.$services.swagger.bearer = self.bearer;
					self.logout();
				}
				promise.reject(error);
				// better to feed it back to the user in situ!
				//if (attemptRedirect) {
				//	self.$services.router.route("error", {message: "Could not log in"});
				//}
			});
			return promise;
		},
		logout: function() {
			var self = this;
			var promise = this.$services.q.defer();
			this.$services.swagger.execute("nabu.cms.core.v2.security.web.logout", {$$skipRemember: true}).then(function(result) {
				self.bearer = null;
				self.roles.splice(0);
				self.permissions.splice(0);
				self.allowedPermissions.splice(0);
				self.disallowedPermissions.splice(0);
				if (result && result.roles) {
					nabu.utils.arrays.merge(self.roles, result.roles);
				}
				if (result && result.permissions) {
					nabu.utils.arrays.merge(self.permissions, result.permissions);
				}
				self.$services.swagger.bearer = null;
				self.language = null;
				// clear anything that might have stored up data
				self.$services.$clear().then(function() {
					promise.resolve();
				}, promise);
			}, promise);
			return promise;
		},
		remember: function() {
			var self = this;
			// @2024-06-29
			// if we were logged in but are triggering the remember, our token probably expired
			// the likelihood that our actual security rules changed at around the same time are small
			// so we actually skip the clear routine because it is pretty heavy
			var wasLoggedIn = self.bearer != null;
			var promise = this.$services.q.defer();
			if (this.remembering) {
				promise.reject();
			}
			else {
				this.remembering = true;
				// the remember can be triggered for two reasons:
				// initial startup, the application wants to check if the server knows who you are, but more importantly: the frontend doesn't know yet
				// the user walks away from his desk or the server is rebooted or the user gets directed to another server in the cluster and it doesn't know who you are
				// however, the frontend does, if the remember returns the same information we already knew, don't $clear() everything, nothing has actually changed
				this.$services.swagger.execute("nabu.cms.core.v2.security.web.remember", {$$skipRemember: true}).then(function(result) {
					if (result) {
						self.bearer = result.token;
						// set the bearer token for the swagger client if we have a jwt token
						self.$services.swagger.bearer = result.token;
						self.language = result.language;
						self.roles.splice(0);
						self.permissions.splice(0);
						if (result.roles) {
							nabu.utils.arrays.merge(self.roles, result.roles);
						}
						if (result.permissions) {
							nabu.utils.arrays.merge(self.permissions, result.permissions);
						}
						// only do a clear if we actually got remembered, otherwise nothing likely changed!
						if (result.token) {
							if (!wasLoggedIn) {
								self.$services.$clear().then(function() {
									promise.resolve(result);
									self.remembering = false;
								}, promise);
							}
							else {
								promise.resolve(result);
								self.remembering = false;
							}
						}
						else {
							promise.reject(result);
							self.remembering = false;
						}
					}
					else {
						promise.reject(result);
						self.remembering = false;
					}
				}, function(error) {
					// we don't trigger a clear, the remember failed so you are presumably still not logged in
					promise.reject(error);
					self.remembering = false;
				});
			}
			return promise;
		},
		hasContextualRole: function(context) {
			if (this.contextualRoles[context]) {
				for (var i = 1; i < arguments.length; i++) {
					if (this.contextualRoles[context].indexOf(arguments[i]) >= 0) {
						return true;
					}
				}
			}
			return false;
		},
		hasRole: function(role, context) {
			// sometimes you might send an empty role (e.g. when you added a role check but forgot to fill it in)
			if (!role) {
				return true;
			}
			if (role == "$user") {
				return !!this.loggedIn;
			}
			else if (role == "$guest") {
				return !this.loggedIn;
			}
			if (context == "this") {
				context = this.application;
			}
			var fullName = (context ? context + ":" : "") + role;
			return this.roles.indexOf(fullName) >= 0;
		},
		hasPermission: function(action, context, serviceContext) {
			if (context == "this") {
				context = this.application;
			}
			return this.normalizedPermissions.filter(function(permission) {
				return (!serviceContext || permission[0] == serviceContext)
					&& (!context || permission[1] == context)
					&& permission[2] == action;
			}).length > 0;
		},
		hasPermissionInContext: function(context, serviceContext) {
			if (context == "this" || !context) {
				context = this.application;
			}
			return this.normalizedPermissions.filter(function(permission) {
				return permission[1] == context
					&& (!serviceContext || permission[0] == serviceContext);
			}).length > 0;
		},
		hasPermissionInServiceContext: function(serviceContext) {
			if (!serviceContext) {
				serviceContext = "default";
			}
			return this.normalizedPermissions.filter(function(permission) {
				return permission[0] == serviceContext;
			}).length > 0;
		},
		// backwards compatible
		hasPotentialRole: function(role, context) {
			return this.hasRole(role, context);
		},
		// backwards compatible
		hasAction: function(action, context) {
			return this.hasPermission(action, context);
		},
		hasPotentialAction: function(action, context) {
			return this.hasPermission(action, context);
		}
	}
});
Vue.view("cms-login", {
	priority: -100,
	alias: "login",
	url: "/login",
	props: {
		route: {
			type: String,
			required: false,
			default: "home"
		},
		url: {
			type: String,
			required: false
		}
	},
	data: function() {
		return {
			username: null,
			password: null,
			remember: true,
			working: false,
			valid: false,
			messages: []
		};
	},
	methods: {
		login: function() {
			if (this.validate(true)) {
				this.messages.splice(0, this.messages.length);
				this.working = true;
				var self = this;
				return this.$services.user.login(this.username, this.password, this.remember).then(
					function(profile) {
						if (self.url) {
							window.location.href = self.url;
						}
						else {
							self.$services.router.route(self.route);
						}
						self.working = false;
					},
					function(error) {
						self.messages.push({
							title: "Login failed",
							severity: "error"
						})
						self.working = false;
					});
			}
		},
		validate: function(hard) {
			var messages = this.$refs.form.validate(!hard);
			this.valid = messages.length == 0;
			return this.valid;
		}
	}
});
Vue.service("Language", {
	services: ["user", "cookies"],
	optionalServices: ["environment"],
	data: function() {
		return {
			cookieValue: null
		}
	},
	computed: {
		available: function() {
			var self = this;
			var result = [];
			if (this.$services.environment) {
				var languages = this.$services.environment.get("languages");
				if (languages) {
					languages = languages.entries;
				}
				if (languages) {
					// if you are combining it without optimization, we don't want language entries twice
					if (result.length > 0) {
						languages = languages.filter(function(x) {
							var existing = result.filter(function(y) {
								return y.name == x.name
							})[0];
							return !existing;
						});
					}
					languages.forEach(function(x) {
						if (self.$services.translator) {
							x.label = self.$services.translator.translationFor("language", x.name);
						}
					});
					nabu.utils.arrays.merge(result, languages);
				}
			}
			return result;
		},
		names: function() {
			return this.available.map(function(x) { return x.name });
		},
		current: {
			get: function() {
				// we first select the name of the language
				var result = null;
				// if we have a language configured for the user in the backend, that wins
				if (this.$services.user.language && this.names.indexOf(this.$services.user.language) >= 0) {
					result = this.names[this.names.indexOf(this.$services.user.language)];
					// if the cookie does not match the persisted value, update the cookie
					if (this.cookieValue != result) {
						this.$services.cookies.set("language", result, result ? 365 : -1);
						this.cookieValue = result ? result : null;
					}
				}
				else {
					// otherwise we check the local value if any (comes from a cookie)
					if (this.cookieValue && this.names.indexOf(this.cookieValue) >= 0) {
						result = this.cookieValue;
					}
					else {
						// otherwise we check the browser settings
						var language = navigator.language || navigator.userLanguage;
						var languages = language.split(/[\s]*;[\s]*/);
						for (var i = 0; i < languages.length; i++) {
							if (this.names.indexOf(languages[i]) >= 0) {
								result = languages[i];
								break;
							}
							else if (this.names.indexOf(languages[i].replace(/-.*/, "")) >= 0) {
								result = this.names.indexOf(languages[i].replace(/-.*/, ""));
								break;
							}
						}
					}
				}
				// after that we map the name to the object
				for (var i = 0; i < this.available.length; i++) {
					if (this.available[i].name == result) {
						return this.available[i];
					}
				}
				return null;
			},
			set: function(newValue) {
				// can set a string value
				if (typeof(newValue) == "string") {
					newValue = this.available.filter(function(x) {
						return x.name == newValue;
					})[0];
				}
				// first check that it is a valid language (or null)
				// only trigger if the value was actually changed, otherwise we do reloads etc for nothing
				if (newValue == null || this.available.indexOf(newValue) >= 0 && newValue.name != this.$services.user.language) {
					console.log("Switching language switch from '" + this.$services.user.language + "' to '" + (newValue ? newValue.name : "none") + "'");
					
					// must synchronously update this, because the get() is immediately executed again, if only done async it will re-enforce the old value
					this.$services.user.language = newValue ? newValue.name : null;
					// always set it as a cookie so we know your selection if you are not known to the server (yet) for example before the remember kicks in on a dead session
					this.$services.cookies.set("language", newValue ? newValue.name : "none", newValue && newValue.name ? 365 : -1);
					this.cookieValue = newValue ? newValue.name : null;
					
					// if the user is logged in, update his profile
					if (this.$services.user.loggedIn) {
						var self = this;
						this.$services.swagger.execute("nabu.cms.core.rest.user.updateLanguage", { userId: this.$services.user.id, languageId: newValue ? newValue.id : null }).then(function() {
							self.$services.user.language = newValue ? newValue.name : null;
							// force a reload to get the new language
							window.location.reload(true);
						});
					}
					else {
						// force a reload to get the new language
						window.location.reload(true);
					}
				}
			}
		}
	},
	activate: function(done) {
		this.cookieValue = this.$services.cookies.get("language");
		done();
	}
}); 
Vue.service("masterdata", {
	optionalServices: ["translator", "environment"],
	data: function() {
		return {
			masterdata: {
				// ids pending resolution
				idsToResolve: [],
				// the resolution timer
				timer: null,
				// id = record
				resolved: {}
			}
		}	
	},
	activate: function(done) {
		var self = this;
		if (nabu.page && nabu.page.provide) {
			nabu.page.provide("page-enumerate", {
				name: "masterdata-categories",
				enumerate: function() {
					return self.categories;
				},
				label: "name",
				value: "id"
			});
			this.preloaded.map(function(preloaded) {
				nabu.page.provide("page-enumerate", {
					name: "masterdata-category-" + preloaded.name,
					enumerate: function() {
						return preloaded.entries;
					},
					label: "name",
					value: "id",
					values: ["id", "name"],
					//labels: ["name", "label"]
					labels: ["name", "title", "icon"]
				});
			});
		}
		done();
	},
	computed: {
		preloaded: function() {
			var result = [];
			if (this.$services.environment && this.$services.environment.settings
					&& this.$services.environment.settings.data
					&& this.$services.environment.settings.data.masterdata
					&& this.$services.environment.settings.data.masterdata.categories) {
				nabu.utils.arrays.merge(result, this.$services.environment.settings.data.masterdata.categories);
				
				var self = this;
				result.forEach(function(x) {
					if (x.entries) {
						x.entries.forEach(self.labelize);
					}
				});
			}
			return result;
		},
		// there are very few usecases for this listing except perhaps the suggest
		// on the flipside, there is no configuration of which categories you want to expose and simply exposing all by default is too much information
		// for now, in the new version, we will only populate this based on the preloaded categories
		categories: function() {
			var result = [];
			this.preloaded.forEach(function(x) {
				var existing = result.filter(function(y) {
					return y.name == x.name;
				})[0];
				if (!existing) {
					result.push({
						id: x.id,
						name: x.name
					});
				}
			});
			return result;
		},
	},	
	methods: {
		// add a label if it isn't there yet
		labelize: function(entry) {
			if (!entry.label) {
				// pretty printed
				var defaultValue = entry.name.substring(0, 1).toUpperCase()
					+ entry.name.substring(1).replace(/([A-Z]+)/g, " $1").trim();
				// check if we have a translation
				if (this.$services.translator) {
					entry.label = this.$services.translator.translationFor(entry.id, "name", defaultValue);
				}
				// otherwise, just set the default value
				else {
					entry.label = defaultValue;
				}
			}
		},
		// we can only list preloaded categories, use suggest for other categories	
		list: function(name, q) {
			for (var i = 0; i < this.preloaded.length; i++) {
				if (this.preloaded[i].name == name || this.preloaded[i].id == name) {
					return this.preloaded[i].entries == null ? [] : this.preloaded[i].entries.filter(function(x) {
						return !q || x.name.toLowerCase().indexOf(q.toLowerCase()) >= 0;
					});
				}
			}
			return null;
		},
		category: function(name) {
			for (var i = 0; i < this.categories.length; i++) {
				if (this.categories[i].name == name || this.categories[i].id == name) {
					return this.categories[i];
				}
			};
			return null;
		},
		entry: function(category, name) {
			// if we didn't get a name, we must be searching by id
			if (!name) {
				for (var i = 0; i < this.preloaded.length; i++) {
					if (this.preloaded[i].entries) {
						for (var j = 0; j < this.preloaded[i].entries.length; j++) {
							if (this.preloaded[i].entries[j].id == category) {
								return this.preloaded[i].entries[j];
							}
						}
					}
				}
			}
			else {
				for (var i = 0; i < this.preloaded.length; i++) {
					if (this.preloaded[i].name == category || this.preloaded[i].id == category) {
						if (this.preloaded[i].entries) {
							for (var j = 0; j < this.preloaded[i].entries.length; j++) {
								if (this.preloaded[i].entries[j].name == name || this.preloaded[i].entries[j].id == name) {
									return this.preloaded[i].entries[j];
								}
							}
						}
					}
				}
			}
			return null;
		},
		resolve: function(masterdataId, field, serviceContext) {
			if (field == null) {
				field = "title";
			}
			if (!masterdataId || !masterdataId.match(/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}|[0-9a-fA-F]{32}/)) {
				return masterdataId;
			}
			var self = this;
			// check if we already have it
			if (this.masterdata.resolved[masterdataId]) {
				return this.masterdata.resolved[masterdataId][field] ? this.masterdata.resolved[masterdataId][field] : this.masterdata.resolved[masterdataId].name;
			}
			var result = null;
			if (this.preloaded) {
				// check if we have preloaded masterdata
				for (var i = 0; i < this.preloaded.length; i++) {
					if (this.preloaded[i].entries) {
						for (var j = 0; j < this.preloaded[i].entries.length; j++) {
							if (this.preloaded[i].entries[j].id == masterdataId) {
								result = this.preloaded[i].entries[j];
								break;
							}
						}
						if (result != null) {
							break;
						}
					}
				}
			}
			// the resolving function
			var resolve = function() {
				var ids = self.masterdata.idsToResolve.splice(0, self.masterdata.idsToResolve.length);
				if (ids && ids.length) {
					self.masterdata.timer = null;
					self.$services.swagger.execute("nabu.cms.core.v2.masterdata.rest.resolve", { id: ids, "$serviceContext": serviceContext })
						.then(function(result) {
							if (result.results && result.results.length) {
								result.results.forEach(self.labelize);
								for (var i = 0; i < result.results.length; i++) {
									// make sure we have a title because that is what we are returning!
									if (result.results[i].title == null) {
										result.results[i].title = result.results[i].label ? result.results[i].label : result.results[i].name;
									}
									nabu.utils.objects.merge(self.masterdata.resolved[result.results[i].id], result.results[i])
								}
							}
						});
				}
			};
			if (result != null) {
				return result[field] ? result[field] : result.name;
			}
			// if we did not find a result, ask the server
			// add it to the idsToResolve
			if (this.masterdata.idsToResolve.indexOf(masterdataId) < 0) {
				this.masterdata.idsToResolve.push(masterdataId);
				// set a value that can be returned and updated later
				Vue.set(this.masterdata.resolved, masterdataId, {
					id: "",
					title: "",
					label: "",
					name: ""
				});
				// if there is a timer pending, reset it
				if (this.masterdata.timer != null) {
					clearTimeout(this.masterdata.timer);
					this.masterdata.timer = null;
				}
				// set a timeout
				this.masterdata.timer = setTimeout(resolve, 25);
			}
			return this.masterdata.resolved[masterdataId][field];
		}
	}
});
// this can NOT depend on the language service
// for now, the language service is dependent on masterdata
// and masterdata itself is dependent on translator
// that would create a circular dependency
// and it "should" not be necessary...
Vue.service("translator", {
	// wait for environment to resolve so we get the correct language
	services: ["swagger", "environment"],
	data: function() {
		return {
			translations: []
		}
	},
	activate: function(done) {
		this.loadTranslations().then(done, done);
	},
	switchLanguage: function(done) {
		console.log("Switching language");
		// we need to reload all the contexts we currently have
		var contexts = [];
		this.translations.forEach(function(x) {
			if (contexts.indexOf(x.context) < 0) {
				contexts.push(x.context);
			}
		});
		this.loadTranslations(contexts);
	},
	methods: {
		loadTranslations: function(context, clear) {
			var self = this;
			return this.$services.swagger.execute("nabu.cms.core.v2.translation.list", {context: context}).then(function(result) {
				// remove the translations alltogether, in the future we might want to be more specific and only clear the passed in contexts
				if (clear) {
					self.translations.splice(0);
				}
				if (result && result.translations) {
					nabu.utils.arrays.merge(self.translations, result.translations);
				}
			});	
		},
		translationFor: function(context, name, defaultValue) {
			var term = (context ? context + "::" : "") + name;
			var translation = this.translations.filter(function(x) {
				return x.name == term;
			})[0];
			return translation && translation.translation ? translation.translation : (defaultValue ? defaultValue : name);
		},
		translate: function(value, defaultValue) {
			if (value && value.indexOf) {
				while (value.indexOf("%" + "{") >= 0) {
					var start = value.indexOf("%" + "{");
					var depth = 1;
					var end = -1;
					for (var j = start + 2; j < value.length; j++) {
						if (value.charAt(j) == "{") {
							depth++;
						}
						else if (value.charAt(j) == "}") {
							depth--;
							if (depth == 0) {
								end = j;
								break;
							}
						}
					}
					// no end tag
					if (end < 0) {
						break;
					}
					var available = value.substring(start + 2, end);
					// we combine the previous context & name into a single "::" separated string in the translation table as well
					var translation = this.translations.filter(function(x) {
						return x.name == available;
					})[0];
					var translatedString = translation ? translation.translation : null;
					// a provided default
					if (!translatedString && defaultValue) {
						translatedString = defaultValue;
					}
					// the string itself
					if (!translatedString) {
						// anything before the :: is meant to indicate context
						var parts = available.split("::");
						translatedString = parts.length == 1 ? parts[0] : parts[1];
					}
					value = value.substring(0, start) + translatedString + value.substring(end + 1);
				}
			}
			return value;
		}
	}
})
nabu.page.provide("page-settings", {
	name: "oauth2",
	title: "OAuth2",
	route: "page-settings-oauth2",
	icon: "at"
})

Vue.service("oauth2", {
	methods: {
		silentLogin: function(uri) {
			var promise = this.$services.q.defer();
			var login = function(uri) {
				var iframe = document.createElement("iframe");
				iframe.style.display = "none";
				iframe.src = uri;
				iframe.onload = function () {
					console.log("Iframe loaded", iframe.src, iframe);
				};
				document.body.appendChild(iframe);
			}
			this.$services.swagger.execute("nabu.cms.oauth2.client.web.rest.provider.getSilentRedirectUri").then(function(result) {
				if (result && result.uri) {
					login(uri);
				}
				else {
					promise.resolve();
				}
			}, promise);
			return promise;
		}
	}	
});
Vue.view("page-settings-oauth2", {
	
});
Vue.service("testIdentifier", {
	services: ["page", "swagger"],
	data: function() {
		return {
			// whether or not you are inspecting
			inspecting: false,
			// show everything, otherwise we limit to "interesting" stuff
			deep: false,
			lastElement: null
		}
	},
	activate: function(done) {
		// if you can test, enable the identifier
		if (this.$services.page.testable) {
			this.registerListeners();
		}
		done();
	},
	methods: {
		registerListeners: function() {
			var self = this;
			document.addEventListener("keydown", function(event) {
				if (event.key && event.key.toLowerCase() == "i" && event.altKey) {
					console.log("toggline inspection");
					self.inspecting = !self.inspecting;
				}
			});
			document.addEventListener("mouseover", function(event) {
				if (self.inspecting) {
					self.inspect(event.target, event.x, event.y);
				}
			});
		},
		calculateIdentifier: function(element) {
			// if we have an id, that's it!
			if (element.hasAttribute("id")) {
				return "#" + element.getAttribute("id");
			}
			else if (element.hasAttribute("name")) {
				return "[name=\"" + element.getAttribute("name") + "\"]";
			}
			// we take the parent and the tag name + offset
			else {
				// it is 1-based
				var index = 1;
				var sibling = element.previousElementSibling;
				while (sibling) {
					if (sibling.tagName == element.tagName) {
						index++;
					}
					sibling = sibling.previousElementSibling;
				}
				var path = element.tagName.toLowerCase() + ":nth-child(" + index + ")";
				if (element.parentNode) {
					path = this.calculateIdentifier(element.parentNode) + " > " + path;
				}
				return path;
			}
		},
		inspect: function(element, x, y) {
			// make sure we don't trigger multiple times on the same element
			if (element != this.lastElement) {
				this.lastElement = element;
				var div = document.getElementById("element-inspector");
				if (div) {
					if (div.contains(element)) {
						return null;
					}
					div.parentNode.removeChild(div);
				}
				div = document.createElement("div");
				div.setAttribute("id", "element-inspector");
				
				var self = this;
				var interestingElements = ["button", "a", "input", "textarea"];
				while (element) {
					var interesting = element.tagName && interestingElements.indexOf(element.tagName.toLowerCase()) >= 0;
					if (interesting || self.deep) {
						var child = document.createElement("div");
						child.setAttribute("class", "element-inspection");
						div.appendChild(child);
						
						var tag = document.createElement("span");
						tag.setAttribute("class", "element-tag");
						tag.innerHTML = element.tagName.toLowerCase();
						child.appendChild(tag);
						
						var identifier = document.createElement("span");
						identifier.setAttribute("class", "element-identifier");
						identifier.innerHTML = self.calculateIdentifier(element);
						child.appendChild(identifier);
					}
					element = element.parentNode;
				}
				
				if (div.childNodes.length) {
					div.setAttribute("style", "left:" + x + "px;top:" + (y + 1) + "px");
					document.body.appendChild(div);
				}
			}
		}
	}
});
Vue.view("blog-toc", {
	props: {
		content: {
			type: String
		},
		childComponents: {
			type: Object,
			required: false
		}
	},
	computed: {
		headers: function() {
			var parsed = nabu.formatters.markdown.parse(this.content)
				.filter(function(x) {
					if (x.type.match(/^h[0-9]+$/)) {
						x.depth = parseInt(x.type.replace(/h([0-9]+)/, "$1"));
					 	return true;
					}
					return false;
				})
			console.log("headers are", parsed);
			return parsed;
		}
	},
	methods: {
		getChildComponents: function() {
			var childComponents = [{
				title: "Button (h1)",
				name: "toc-button-1",
				component: "button"
			}, {
				title: "Button (h2)",
				name: "toc-button-2",
				component: "button"
			}, {
				title: "Button (h3)",
				name: "toc-button-3",
				component: "button"
			}, {
				title: "Button (h4)",
				name: "toc-button-4",
				component: "button"
			}, {
				title: "Button (h5)",
				name: "toc-button-5",
				component: "button"
			}, {
				title: "Button (h6)",
				name: "toc-button-6",
				component: "button"
			}];
			return childComponents;
		},
		jumpTo: function(header) {
			console.log("jumping to", header);
			var target = document.getElementById(header.linkId);
			var properties = {};
			properties.behavior = "smooth";
			properties.block = "start";
			properties.inline = "nearest";
			target.scrollIntoView(properties);
		}
	}
});
window.addEventListener("load", function() {
	var socket = null;
	var connected = false;
	var stopped = false;
	//var id = new Date().toISOString().replace(/[:.-]+/g, "");
	var id = crypto && crypto.randomUUID ? crypto.randomUUID() : new Date().toISOString().replace(/[:.-]+/g, "");
	var backlog = [];
	var promise = new nabu.utils.promise();

	if (!application.configuration.requestEnrichers) {
		application.configuration.requestEnrichers = [];
	}	
	application.configuration.requestEnrichers.push(function(x) {
		x.headers["Session-Id"] = id;
	});
	
	var start = function() {
		var url = window.location.protocol == "https:" ? "wss" : "ws";
		url += "://";
		url += window.location.hostname;
		if ((window.location.protocol == "https:" && window.location.port != 443) || (window.location.protocol == "http:" && window.location.port != 80)) {
			url += ":" + window.location.port;
		}
		url += "/";
		url += "t/w/e/" + id;
		socket = new WebSocket(url, "analysis");
		// set authenticated to false to start with
		socket.authenticatedBearer = null;
		socket.onopen = function(event) {
			connected = true;
			if (backlog.length > 0) {
				backlog.splice(0).forEach(function(event) {
					socket.send(JSON.stringify(event));
				});
			}
			promise.resolve();
		};
		// if it is remotely closed, we will try again!
		socket.onclose = function(event) {
			console.log("closing!");
			connected = false;
			// don't reconnect if we actually stopped
			if (!stopped) {
				setTimeout(start, 2000);
			}
		};
		socket.onmessage = function(event) {
			// var data = event.data
			console.log("Received message", event.data);
		};
	};
	
	var heartbeat = function() {
		if (connected) {
			socket.send(JSON.stringify({
				timestamp: new Date().toISOString()
			}));
		}
		setTimeout(heartbeat, 15000);
	};
	heartbeat();
	
	var authenticate = function() {
		// get the current bearer
		var bearer = application && application.services && application.services.user ? application.services.user.bearer : null;
		// if we have a bearer and we have not sent it yet or it differs from the one we sent, resend it
		if (bearer && socket && connected && socket.authenticatedBearer != bearer) {
			socket.authenticatedBearer = bearer;
			socket.send(JSON.stringify({
				token: bearer
			}));
		}
		else if (!bearer && socket.authenticatedBearer) {
			socket.authenticatedBearer = null;
			// close without stopping, it will reopen with a clean slate
			socket.close();
		}
	}
	
	nabu.page.provide("page-analysis", {
		name: "webEvent",
		start: start,
		stop: function() {
			stopped = true;
			if (socket != null) {
				socket.close();
			}
		},
		push: function(event) {
			console.log("event is", event);
			authenticate();
			if (connected) {
				event = nabu.utils.objects.clone(event);
				if (event.content != null) {
					event.content = JSON.stringify(event.content);
				}
				if (event.data != null) {
					event.data = JSON.stringify(event.data, null, 2);
				}
				//console.log("sending: ", event);
				socket.send(JSON.stringify(event));
			}
			else {
				backlog.push(event);
			}
		},
		reauthenticate: function() {
			// we close the socket without toggling the stopped
			// that means it will attempt to reconnect
			if (socket != null) {
				socket.close();
			}
		}
	});
});
Vue.view("attachment-uploader", {
	props: {
		attachments: {
			type: Array,
			default: function() {
				// we insert a marker into the array so we know whether it was generated or passed in
				return ["marker"];
			}
		},
		attachmentGroup: {
			type: String
		},
		nodeId: {
			type: String,
			required: true
		},
		edit: {
			type: Boolean,
			required: false
		},
		childComponents: {
			type: Object,
			required: false
		}
	},
	data: function() {
		return {
			uploading: false,
			managed: false,
			files: []
		}
	},
	created: function() {
		if (this.attachments.length == 1 && this.attachments[0] == "marker") {
			this.attachments.splice(0);
			this.managed = true;
		}
		console.log("Attachments are " + (this.managed ? "managed" : "not managed") + " by the component");
		if (this.managed) {
			this.load();
		}
		else {
			this.enrichWithUrl();
		}
	},
	methods: {
		getChildComponents: function() {
			var childComponents = [{
				title: "Image Container",
				name: "attachment-uploader-container",
				component: "row"
			}];
			childComponents.push({
				title: "Image",
				name: "attachment-uploader-image",
				component: "image"
			});
			return childComponents;
		},
		load: function() {
			var self = this;
			this.$services.swagger.execute("nabu.cms.attachment.rest.list", {
				nodeId: this.nodeId,
				group: this.attachmentGroup
			}).then(function(result) {
				if (result.attachments) {
					nabu.utils.arrays.merge(self.attachments, result.attachments);
				}
			})
		},
		upload: function() {
			var self = this;
			this.uploading = true;
			var promises = this.files.splice(0).map(function(file) {
				return self.$services.swagger.execute("nabu.cms.attachment.rest.internal.create", { nodeId: self.nodeId, body: file, group: self.attachmentGroup }).then(function(attachment) {
					console.log("attachment is", attachment);
					if (attachment) {
						self.attachments.push(attachment);
					}
				})
			});
			this.$services.q.all(promises).then(function() {
				self.uploading = false;
			}, function() {
				self.uploading = false;
			})
		},
		enrichWithUrl: function() {
			var self = this;
			self.attachments.forEach(function(attachment) {
				if (!attachment.$url) {
					self.$services.user.downloadUrl("nabu.cms.attachment.rest.internal.get", {
						nodeId: self.nodeId,
						attachmentId: attachment.id
					}, true).then(function(url) {
						Vue.set(attachment, "$url", url);
					})
				}
			});
		},
		deleteAttachment: function(attachment) {
			var uploading = true;
			var self = this;
			this.$services.swagger.execute("nabu.cms.attachment.rest.delete", {
				nodeId: this.nodeId,
				attachmentId: attachment.id
			}).then(function() {
				self.attachments.splice(self.attachments.indexOf(attachment), 1);
				self.uploading = false;
			}, function() {
				self.uploading = false;
			})
		}
	},
	watch: {
		attachments: {
			deep: true,
			handler: function() {
				this.enrichWithUrl();
			}
		}
	}
});
if (!application) { var application = {} }
if (!application.configuration) { application.configuration = {}; }

Vue.service("environment", {
	services: ["swagger", "user"],
	data: function() {
		return {
			settings: {
				data: {}
			}
		}
	},
	activate: function(done) {
		var self = this;
		this.$services.swagger.execute("nabu.web.core.rest.environment").then(function(result) {
			if (result) {
				var scheme = result.scheme ? result.scheme : window.location.protocol.replace(":", "");
				var host = result.host ? result.host : window.location.host;
				// hard to make an educated guess from the url...
				var root = result.root ? result.root : "/";
				application.configuration.scheme = {
					http: scheme,
					ws: scheme == "https" ? "wss" : "ws"
				};
				application.configuration.url = scheme + "://" + host;
				application.configuration.host = host;
				application.configuration.root = root;
				application.configuration.cookiePath = result.cookiePath ? result.cookiePath : root;

				if (result.development) {
					application.configuration.development = true;
				}
				if (result.languagePattern) {
					self.applyPattern(result.languagePattern);
				}
				// merge it reactively into settings		
				Object.keys(result).forEach(function(x) {
					if (x != "data") {
						Vue.set(self.settings, x, result[x])
					}
				});
				// use the first (most important) as default
				if (!result.currentLanguage && result.availableLanguages && result.availableLanguages.length) {
					Vue.set(self.settings, "currentLanguage", result.availableLanguages[0]);
				}
				// we need to set this immediately because the watcher is async and too late
				if (self.settings.currentLanguage) {
					self.applyLanguage(self.settings.currentLanguage.name);
				}
				// data as well
				if (result.data) {
					result.data.forEach(function(x) {
						Vue.set(self.settings.data, x.type, x.content);
					});
				}
			}
			done();
		}, function(error) {
			console.log("Could not load environment information", error);
			done();
		});
	},
	watch: {
		'settings.currentLanguage.name': function(newValue) {
			this.applyLanguage(newValue);
		},
		'settings.languagePattern': function(pattern) {
			this.applyPattern(pattern);
		}
	},
	methods: {
		applyLanguage: function(language) {
			application.configuration.applicationLanguage = language;
			this.$services.swagger.language = language;
			
			// attempt to set it in the html root for standards compliancy reasons
			if (Intl && language) {
				try {
					// The Intl.Locale constructor validates the structure based on BCP 47.
					// this is STRUCTURE, not semantics, so it might still be a non existing language but we accept that
					new Intl.Locale(language);
					// if we get here, it is structurally correct, set in html root
					document.documentElement.setAttribute("lang", language);
				}
				// If the tag is malformed, a RangeError is thrown.
				catch (e) {
					// we assume we don't know the language
				}
			}
		},
		get: function(type) {
			return this.settings.data[type];
		},
		applyPattern: function(pattern) {
			var self = this;
			this.$services.router.router.urlRewriter = {
				incoming: function(path) {
					if (!pattern) {
						return path;
					}
					var identifier = pattern.substring(0, 1);
					// we only care about path based stuff, query etc does not need router-level rewriting
					if (identifier == "/") {
						var index = parseInt(pattern.substring(1));
						var parts = path.replace(/^[/]+/, "").split("/");
						if (index < parts.length) {
							parts.splice(index, 1);
						}
						return "/" + parts.join("/");
					}
					return path;
				},
				outgoing: function(path) {
					if (!pattern) {
						return path;
					}
					var index = parseInt(pattern.substring(1));
					var parts = path ? path.replace(/^[/]+/, "").split("/") : [];
					if (index < parts.length) {
						parts.splice(index, 0, self.settings.currentLanguage.name);
					}
					else {
						parts.push(self.settings.currentLanguage.name);
					}
					return "/" + parts.join("/");
				}
			}
		}
	}
});
window.addEventListener("load", function () {
	// make sure we can target the browser using css
	if (!navigator.userAgent.match(/Nabu-Renderer/)) {
		document.documentElement.setAttribute("data-useragent", navigator.userAgent);
	}

    // set load icon while the application is starting up
	var span = document.createElement("span");
	span.setAttribute("class", "n-icon n-icon-spinner");
	span.setAttribute("style", "position: static");
	// we might be using body routing
	var body = document.getElementById("body");
	if (!body) {
		body = document.body;
	}
	body.appendChild(span);

	application.initialize().then(function($services) {
		// route to initial state
		var initial = $services.router.routeInitial();
		// for server-side rendering: throw away all the script tags
		if (initial && initial.then && navigator.userAgent.match(/Nabu-Renderer/)) {
			initial.then(function() {
				// nothing just yet...
			});
		}
	});
});
var clearTemplates = function() {
	// break out of the execution
	setTimeout(function() {
		var scripts = document.head.getElementsByTagName("script");
		for (var i = scripts.length - 1; i >= 0; i--) {
			scripts[i].parentNode.removeChild(scripts[i]);
		}
	}, 1);
}